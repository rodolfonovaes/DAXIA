#INCLUDE "MATXFIS.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "MATXDEF.CH"

// SEMPRE QUE REALIZAR M_ANUTENCAO NAS REFERENCIAS DE IMPOSTOS DA MATXFIS ATUALIZAR A FUNCAO MATXFIS_V COM A DATA ATUAL
/*
MATXFIS - Edson Maricate/Eduardo - 08/12/99
Programa de Calculo de Impostos Fiscais e Financeiros
*/
STATIC aMaster
STATIC aNFCab
STATIC aNFItem
STATIC aItemDec
STATIC aBrwLF
STATIC aStack
STATIC aRefSX3
STATIC aSaveDec
STATIC aAuxOri
STATIC cAliasPROD  := "SB1"
STATIC aInfNat 	   := Array(27)
STATIC aTES[MAX_TS]
STATIC aItemRef
STATIC aCabRef
STATIC aResRef
STATIC aTGITRef
STATIC aTGNFRef
STATIC aLFIS
STATIC aPE
STATIC aSX6
STATIC aDic
STATIC aPos
STATIC aUltPesq   //ALEMES - FUNCAO DE IR
STATIC bFisRefresh
STATIC bLivroRefresh
STATIC cCpoSBZ     := CpyFieldSB(,.T.)  //ALEMES - So utilizada na MaSBCampo
STATIC lLimInss    := .F. //ALEMES - BASICAMENTE PRA SER USADA MAFISDEL
STATIC lNotRemito  := .T. //ALEMES - Localizado por enquanto nao
STATIC cSX6FilAnt  := cFilAnt  //Inicia variavel com filial corrente
STATIC lLoadCache  := Iif((aPE==NIL).Or.(aSX6==NIL).Or.(aPos==NIL).Or.(aDic==NIL),MaLoadCache(),.F.)
STATIC lRastItem   := .T.
STATIC lHistorico  := .F.
STATiC cAlsCab     := ""
STATiC cAlsItem    := ""
STATIC cMunForISS  := ""
STATIC cFornCE1    := ""
STATIC cDescCE1	   := ""
STATIC cLojaCE1    := ""
STATIC dVencCE1    := ""
STATIC cRecIssCE1  := "1"
STATIC lCalculPCC  := .F. //Indica se Calcula (PIS,COFINS,CSLL), independete da TES estar configurada para Gerar Duplicata (F4_DUPLIC)
STATIC lINSSSemDu  := .F. //Indica se Calcula (INSS), independete da TES estar configurada para Gerar Duplicata (F4_DUPLIC)
STATIC lIRRFSemDu  := .F. //Indica se Calcula (IRRF), independete da TES estar configurada para Gerar Duplicata (F4_DUPLIC)
STATIC aAliqSN     := {}
STATIC aRefAlt

/*
MATXFIS_V - Rodrigo Aguilar - 21/11/11
Funcao que retorna a data da ultima manutencao nas referencias de imposto do MATXFIS
O retorno desta funcao eh utilizado na execucao do UPDFIS SEMPRE atualizar com a data de inclusao da referencia
*/
Function MATXFIS_V()
Return CtoD("13/04/16")
/*
MaLoadCache - Alemes/Demetrio Rios  Data 20/09/2012
 Alimenta as variaveis STATIC para cachear as chamadas de
 funcoes de uso generico para evitar processamento recursivo
 aSX6  - Todos os parametros Utilizados na MATXFIS
 aPE - Todos os Pontos de Entradas Utilizados n MATXFIS
 aPos- Todos os FiledPos a serem executados na MATXFIS
 aDic- Todos os AliasinDic executados na MATXFIS
*/
Static Function MaLoadCache()
aPE	:= GPEMxFis()  // Pontos de entrada
aSX6 	:= GParMxFis(@cSX6FilAnt) // Parametros
aDic 	:= GAiMxFis()  // AliasIndic
aPos 	:= GFPMxFis(aSX6)  // FieldPos
Return Nil

/*AS PROXIMAS 26 FUNCOES ABAIXO SAO FUNCOES DE CONTROLE QUE INTERAGEM COM TODOS OS MODULOS DO PROTHEUS OU QUALQUER PROGRAMA COM MATXFIS IMPLEMENTADA*/
/*MaFisFound - Edson Maricate - 08.12.1999
Verifica se o item ja existe na relacao de itens incluidos.
*/
Function MaFisFound(cCampo,nItem)
Local lRetorno  := .T.

If aNfItem <> Nil
	If cCampo == "IT"
		If nItem > Len(aNfItem)
			lRetorno := .F.
		EndIf
	Else
		If Empty(aNfCab)
			lRetorno := .F.
		EndIf
	EndIf
Else
	lRetorno := .F.
EndIf

// Ao utilizar o Protheus com varias Filiais e possivel que em alguns processos como o de inclusao de Notas Fiscais o usuario altere
// a filial atraves da Dialog de seleçao de filiais, com isso se faz necessario que os parametros SX6 sejam novamente carregados para
// a filial corrente refazendo o cache realizado na variavel aSX6, esta nova carga e controlada pela variavel cSX6FilAnt
If cSX6FilAnt <> cFilAnt
	aSX6 := GParMxFis(@cSX6FilAnt)
EndIf

Return lRetorno
/*
MaFisSave - Edson Maricate - 10.12.99
Salva a NF atual em uma area temporaria
*/
Function MaFisSave()

If aMaster == Nil
	aMaster := {}
EndIf

aadd(aMaster,{aClone(aNfCab),;
	aClone(aSaveDec),;
	aClone(aNfItem),;
	aClone(aItemDec),;
	bFisRefresh,;
	bLivroRefresh,;
	aClone(aBrwLF),;
	aClone(aStack),;
	aClone(aAuxOri),;
	cAliasProd,;
	aClone(aRefAlt)})
Return

/*MaFisRestore - Edson Maricate - 10.12.99
Carrega a NF salva em uma area temporaia*/
Function MaFisRestore()

Local nUltimo := Len(aMaster)
aNfCab        := aClone(aMaster[nUltimo][01])
aSaveDec      := aClone(aMaster[nUltimo][02])
aNfItem       := aClone(aMaster[nUltimo][03])
aItemDec      := aClone(aMaster[nUltimo][04])
bFisRefresh   := aMaster[nUltimo][05]
bLivroRefresh := aMaster[nUltimo][06]
aBrwLF        := aClone(aMaster[nUltimo][07])
aStack        := aClone(aMaster[nUltimo][08])
aAuxOri       := aClone(aMaster[nUltimo][09])
cAliasProd    := aMaster[nUltimo][10]
aRefAlt       := aClone(aMaster[nUltimo][11])
aMaster       := aSize(aMaster,nUltimo-1)

If nUltimo == 1
   aMaster := Nil
EndIf

Return .T.

/*MaFisClear - Edson Maricate -09.12.1999
Limpa os itens da NF e zera as variaveis do cabecalho.*/
Function MaFisClear()

If MaFisFound('NF')
	aNfItem := {}
	aRefAlt := {}
	aItemDec:= {}
	If aSaveDec<>Nil
		aFill(aSaveDec,0)
	EndIf
	aAuxOri	:= {}
	MaIt2Cab()
EndIf

Return .T.

/*/MaFisEnd- Edson Maricate -10.01.1999
Finaliza o uso das funcoes Fiscais.
Parametros ExpL1: Indica se deve reinicializar o codeblock da funcao
MaFisRodape ( bFisRefresh )*/
Function MaFisEnd(lRodape)

DEFAULT lRodape := .T.
aNfCab	:= Nil
aNfItem	:= Nil
aRefAlt := NIL
aItemDec:= Nil
aSaveDec:= Nil
aAuxOri	:= Nil
aTes	:= Array(MAX_TS)
bLivroRefresh := Nil
If lRodape
	bFisRefresh := Nil
EndIf
lNotRemito :=.T.
cFornCE1    := ""
cDescCE1	   := ""
cLojaCE1    := ""
dVencCE1    := ""
cRecIssCE1  := "1"

Return .T.

/*/MaFisNfCab - Alexandre Lemes - 01/10/2012
Torna disponivel o array static aNfCab as rotinas externas/*/
Function MaFisNFCab()
Return aClone(aNFCab[NF_IMPOSTOS])

/*/MaFisIni -Eduardo/Edson - 08.12.1999
Inicializa o Calculo das operacoes Fiscais/*/
Function MaFisIni(cCodCliFor,;	// 1-Cod. Cli/For
cLoja,;		  // 02-Lj do Cli/For
cCliFor,;	  // 03-C:Cliente , F:Fornecedor
cTipoNF,;	  // 04-Tp NF( "N","D","B","C","P","I" )
cTpCliFor,;	  // 05-Tp do Cli/For
aRelImp,;	  // 06-Relacao de Impostos que suportados no arquivo
cTpComp,;	  // 07-Tipo de complemento
lInsere,;	  // 08-Permite Incluir Impostos no Rodape .T./.F.
cAliasP,;	  // 09-Alias do Cadastro de Produtos - ("SBI" P/ Front Loja)
cRotina,;	  // 10-Nome da rotina que esta utilizando a funcao
cTipoDoc,;	  // 11-Tipo de documento
cEspecie,;	  // 12-Especie do documento
cCodProsp,;	  // 13-Codigo e Loja do Prospect
cGrpCliFor,;  // 14-Grupo Cliente
cRecolheISS,; // 15-Recolhe ISS
cCliEnt,;	  // 16-Codigo do cliente de entrega na nota fiscal de saida
cLojEnt,;	  // 17-Loja do cliente de entrega na nota fiscal de saida
aTransp,;	  // 18-Informacoes do transportador [01]-UF,[02]-TPTRANS
lEmiteNF,;	  // 19-Se esta emitindo nota fiscal ou cupom fiscal (Sigaloja)
lCalcIPI,;    // 20-Define se calcula IPI (SIGALOJA)
cPedido,;     // 21-Pedido de Venda
cCliFat,;	  // 22-Cliente do faturamento ( cCodCliFor é passado como o cliente de entrega, pois é o considerado na maioria das funções fiscais, exceto ao gravar o clinte nas tabelas do livro)
cLojCFat,;    // 23-Loja do cliente do faturamento
nTotPed,;	  // 24-Total do Pedido
dDtEmiss,;	  // 25-Data de emissão do documento inicialmente só é diferente de dDataBase nas notas de entrada (MATA103 e MATA910)
cTpFrete,;    // 26-Tipo de Frete informado no pedido
lCalcPCC,;    // 27-Indica se Calcula (PIS,COFINS,CSLL), independete da TES estar configurada para Gerar Duplicata (F4_DUPLIC)
lCalcINSS,;   // 28-Indica se Calcula (INSS), independete da TES estar configurada para Gerar Duplicata (F4_DUPLIC)
lCalcIRRF,;   // 29-Indica se Calcula (IRRF), independete da TES estar configurada para Gerar Duplicata (F4_DUPLIC)
cTpCompl,;    // 30-Tipo de Complemento
cCltdest,;	  // 31-Cliente de destino de transporte (Notas de entrada de transporte )
cLjtdest,;    // 32-Loja de destino de transporte (Notas de entrada de transporte )
lCalcTG,;     // 33-Flag para indicar se os tributos genéricos devem ou não ser calculados - deve ser passado como .T. somente após a preparação da rotina para gravação, visualização e exclusão dos tributos genéricos.
nQtdItens)    // 34-Quantidade de itens no documento.

Local aArea    	:= GetArea()
Local aAreaSA1 	:= SA1->(GetArea())
Local aAreaSA2 	:= SA2->(GetArea())
Local cOperNf  	:= ""
Local cUfDest  	:= ""
Local cUfOrig  	:= ""
Local cNatureza	:= ""
Local cCodMuni  := ""
Local cAtividad	:= ""
Local cRecPIS  	:= "N"
Local cRecIRRF  := "2"
Local cRecCOFI 	:= "N"
Local cRecCSLL 	:= "N"
Local cRecISS  	:= "2"
Local cRecINSS 	:= "N"
Local cCalcINP	:= "N"
Local cRecSEST 	:= "2"
Local cCNPJ    	:= ""
Local lInclui 	:= .T.
Local lInscrito	:= .F.
Local lSuframa 	:= .F.
Local cCalcSuf 	:= " "
Local nAliqIRF 	:= 0
Local cSerie   	:= ''
Local nMoeda   	:= 1
Local nTxMoeda 	:= 0
Local cModIRF  	:= ""
Local cOPIrrf  	:= ""
Local cRecFet  	:= "2"
Local cRecFab  	:= "2"
Local cRecFac  	:= "2"
Local cRecFMD	:= "2"
Local cSimpNac 	:= ""
Local nNumDep	:= 0
Local cProvEnt	:= "  "   // Provincia de entrega
Local cIRFProg  := 0
Local nPosNtz   := 0
Local cMvEstado	:= ""
Local cMvDupNat	:= ""
Local cIRMP232  := "2"
Local lA1Contrib:= .F.
Local lA2Contrib:= .F.
Local lA1CalcIRF:= .F.
Local lA2IRPROG := .F.
Local cFRetIss	:=	""
Local cSerSat	:= ""
Local cRegeSim	:= ""   // A1_REGESIM / A2_REGESIM - Regime simplificado MT
Local nPercAtm	:= 0	// A1_PERCATM - Pecentual de Carga Media
Local cPessoa	:= "" 	// A1_PESSOA - Pessoa - Fisica / Juridica
Local cNReduz	:= ""   // A1_NREDUZ / A2_NREDUZ - Nome Fantasia
Local cCRDMA	:= ""	// Credito Estimulo de Manaus
Local cSimpSC	:= "" 	// A1_SIMPLES - Clie. optante SIMPLES/SC
Local cCDRDes	:= ""   // A1_CDRDES - Regiao do Cliente
Local cNatCliFa := ""
Local cTipoFat	:= ""
Local cGrpCliFat:= ""
Local aAreaSA1F	:= {}
Local cIDSA1    := ""
Local cIDSA2    := ""
Local lHist := .F.
Local cHistSA1  := ""
Local cHistSA2  := ""
Local lPOS		:= FindFunction("STFIsPOS") .AND. STFIsPOS()
Local nRecCide	:= ""
Local cUfPreISS := ""
Local cHstA1Dest:=""
Local lHistDest	:=.F.
Local linscDest	:=.F.
Local lA1Cntdest:=.F.
Local cUfCliDest:=""
Local cRecIMAMT	:= "2"
Local cRecFASEMT:= "2"
Local nIndice := 0
Local nIndUpf   := 0
Local cDedBsPC := " "
Local cM0CodMun := IIf(cPaisLoc == "BRA", Iif(Len(Alltrim(SM0->M0_CODMUN))<=5,xFisCodIBGE(SM0->M0_ESTENT),"")+SM0->M0_CODMUN, "")
Local cTipoRur := ""
Local nPerFECP := 0
Local cMesEmi  := ""
Local cAnoEmi  := ""
Local nPosF16 := 0
Local cPerIniSN := ""
Local cPerFimSN := ""
Local cPerEmpty := ""
Local cMesSN  := ""
Local cAnoSN  := ""
Local nPosAlqSN := 0
Local lUsaAlqSN := .F.
Local cGrossIR	:= ""
Local cTPJFor	:= ""
Local lTemF2B   := .F.
Local lPerfPart	:= .F.

DEFAULT aRelImp := {}
DEFAULT cTpComp := ""
DEFAULT lInsere := .F.
DEFAULT cAliasP := "SB1"
DEFAULT cTipoDoc:= ""
DEFAULT cEspecie:= ""
DEFAULT	cCodProsp:= ""	//Codigo e Loja do Prospect
DEFAULT cGrpCliFor:= CriaVar("A1_GRPTRIB",.F.)
DEFAULT cRecolheISS	:=	""
DEFAULT cCliEnt  := Space(TamSx3("F3_CLIEFOR")[1])
DEFAULT cLojEnt  := Space(TamSx3("F2_LOJA")[1])
DEFAULT aTransp  := {"",""}
DEFAULT lEmiteNF:= .T.
DEFAULT cRotina := ""
DEFAULT lCalcIPI:= .T.
DEFAULT cPedido	:= ""
DEFAULT cCliFat		:= ""
DEFAULT cLojCFat	:= ""
DEFAULT nTotPed		:= 0
DEFAULT dDtEmiss	:= dDataBase
DEFAULT cTpFrete	:= ""
DEFAULT lCalcPCC 	:= .F.
DEFAULT lCalcINSS	:= .F.
DEFAULT lCalcIRRF	:= .F.
DEFAULT cTpCompl := ''
DEFAULT cCltdest := ''
DEFAULT cLjtdest := ''
DEFAULT lCalcTG := .F.
DEFAULT nQtdItens := 0

If cRotina $ "LOJA701|FATA701" .AND. !lPOS
	If aSX6[MV_LJINTUF] > 0 .OR. cRotina == "FATA701"
		lEmiteNF :=  LjNFFimVd()// Verifica se emite NF aplica-se apenas quando tipo do cliente for diferente de Consumidor Final e se o mesmo não pertencer a estado configurado no parametro MV_LJDIFAL
	Else
		lEmiteNF :=  IIf(!Empty(cTpCliFor), cTpCliFor, SA1->A1_TIPO) != "F" .And. LjNFFimVd()  // Verifica se emite NF //aplica-se apenas quando tipo do cliente for diferente de Consumidor Final e se o mesmo não pertencer a estado configurado no parametro MV_LJDIFAL
	EndIf
EndIf

cTpCliFor	:= IIf(cTpCliFor==Nil," ",cTpCliFor)
aUltPesq	:= {ctod(""),"","",0,0}
lNotRemito	:= .T.
lCalculPCC	:= lCalcPCC
lINSSSemDu	:= lCalcINSS
lIRRFSemDu	:= lCalcIRRF
cMesEmi     := Month2Str(dDtEmiss)
cAnoEmi     := Year2Str(dDtEmiss)

If MaFisFound("NF")
	lInclui		:= .F.
	cCodCliFor	:= aNfCab[NF_CODCLIFOR]
	cLoja		:= aNfCab[NF_LOJA]
	cCliFor		:= aNfCab[NF_CLIFOR]
	cTipoNF		:= aNfCab[NF_TIPONF]
	cTpCliFor	:= aNfCab[NF_TPCLIFOR]
	aRelImp		:= aNfCab[NF_RELIMP]
	cNatureza	:= aNfCab[NF_NATUREZA]
	cTpComp		:= aNfCab[NF_TPCOMP]
	lInsere		:= aNfCab[NF_INSIMP]
	cRotina		:= aNfCab[NF_ROTINA]
	nAliqIRF	:= aNfCab[NF_ALIQIR]
	cSerie		:= aNfCab[NF_SERIENF]
	cTipoDoc	:= aNfCab[NF_TIPODOC]
	nMoeda		:= aNfCab[NF_MOEDA]
	nTxMoeda	:= aNfCab[NF_TXMOEDA]
	cEspecie	:= aNfCab[NF_ESPECIE]
	cCNPJ		:= aNfCab[NF_CNPJ]
	cCliEnt		:= aNfCab[NF_CLIENT]
	cLojEnt		:= aNfCab[NF_LOJENT]
	cCodMuni	:= aNfCab[NF_CODMUN]
	cAtividad   := aNfCab[NF_TPACTIV]
	cRegeSim	:= aNfCab[NF_REGESIM]
	nPercAtm	:= aNfCab[NF_PERCATM]
	cPessoa		:= aNfCab[NF_PESSOA]
	cNReduz		:= aNfCab[NF_NREDUZ]
	cCRDMA 		:= aNfCab[NF_A1CRDMA]
	cSimpSC		:= aNfCab[NF_SIMPSC]
	cCDRDes		:= aNfCab[NF_CDRDES]
	cCliFat		:= aNfCab[NF_CLIEFAT]
	cLojCFat	:= aNfCab[NF_LOJCFAT]
	dDtEmiss	:= aNfCab[NF_DTEMISS]
	cTpFrete	:= aNfCab[NF_TPFRETE]
	cSerSat		:= aNfCab[NF_SERSAT]
	cTpCompl	:= aNfCab[NF_TPCOMPL]
	cCltdest	:= aNfCab[NF_CLIDEST]
	cLjtdest	:= aNfCab[NF_LOJDEST]
	If cPaisLoc<> "BRA"
		lNotRemito	:=  !(IsRemito(1,"'"+aNFCab[NF_TIPODOC]+"'"))
	EndIf
	If cPaisLoc $ "ARG|EUA"
		cProvEnt  := aNfCab[NF_PROVENT]
	EndIf
	lCalcTG     := aNfCab[NF_CALCTG]
	nQtdItens   := aNfCab[NF_QTDITENS]
EndIf

cMvEstado	:= aSX6[MV_ESTADO]
cMvDupNat	:= aSX6[MV_1DUPNAT]
cIRMP232	:= aSX6[MV_IRMP232]
lA1Contrib	:= aPos[FP_A1_CONTRIB]
lA1CalcIRF	:= aPos[FP_A1_CALCIRF]
lA2IRPROG	:= aPos[FP_A2_IRPROG]
lA2Contrib	:= aPos[FP_A2_CONTRIB]

If lInclui
	aNFCab	:= {}
	aNFItem	:= {}
	aRefAlt := {}
	aItemDec:= {}
	cAliasPROD := cAliasP
EndIf

// Verifica se existe ao menos uma regra na F2B.
If cPaisLoc == "BRA" .And. aDic[AI_F2B]
	dbSelectArea("F2B")
	If F2B->(dbSeek(xFilial("F2B")))
		lTemF2B	:= .T.
	EndIF

	//Verifica se o participante está em algum perfil de participante
	dbSelectArea("F22")
	dbSetOrder(2)
	If F22->(dbSeek(xFilial("F22") + Iif(cCliFor == "C", "2", "1") + cCodCliFor + cLoja)) .Or.  F22->(dbSeek(xFilial("F22") + Iif(cCliFor == "C", "2", "1") + PADR("TODOS",TamSx3("F22_CLIFOR")[1])+PADR("ZZ",TamSx3("F22_LOJA")[1])))
		lPerfPart	:= .T.
	EndIF	
EndIf

// Posiciona os registros necessarios
If ( cCliFor == "C" )
	If Empty(cCodProsp)
		dbSelectArea("SA1")
		dbSetOrder(1)
		MsSeek(xFilial("SA1")+cCodCliFor+cLoja)
		If lHistorico
			//Se for reprocessamento,  e tiver habilitado para buscar os Historico Fiscais,
			//verifico se o ID do historico do Cliente e igual ao que foi gravado na Nota. Se for
			//igual é porque nao teve alterações no cliente após a emissão. Se for diferente,
			//é porque teve alterações no cadastro, e entao os dados são carregados da tabela de
			//Historico(SS2).
			cHistSA1 := IIF(cTipoNF=="D", (cAlsCab)->F1_IDSA1, (cAlsCab)->F2_IDSA1)
			If cPaisLoc == "BRA" .And. Alltrim(SA1->A1_IDHIST)<>Alltrim(cHistSA1)
				dbSelectArea("SS2")
				dbSetOrder(1)
				MsSeek(xFilial("SS2")+cHistSA1+cCodCliFor+cLoja)
				lHist := .T.
			EndIf
		EndIf

		cOperNf   := IIf(cTipoNf$"DB","E","S")
		lInscrito := IIf(lHist, IIf(Empty(SS2->S2_INSCR).Or."ISENT"$SS2->S2_INSCR.Or."RG"$SS2->S2_INSCR.Or.( lA1Contrib .And. SS2->S2_CONTRIB == "2"),.T.,.F.), IIf(Empty(SA1->A1_INSCR).Or."ISENT" $ SA1->A1_INSCR .Or. "RG" $ SA1->A1_INSCR .Or.( lA1Contrib .And. SA1->A1_CONTRIB == "2"),.T.,.F.))

		If SA1->A1_CONTRIB == "1" .and. SA1->A1_TPJ == "3" .and. ( Empty( SA1->A1_INSCR ) .or. "ISENT" $ SA1->A1_INSCR )
			lInscrito := .F.
		EndIf

		//Tratamento para considerar como contribuinte do ICMS Produtor Rural com inscrição Rural
		If IIf(lHist, !Empty(SS2->S2_INSCRUR) .And. "L" $ SS2->S2_TIPO .And. ( lA1Contrib .And. SS2->S2_CONTRIB <> "2"), !Empty(SA1->A1_INSCRUR) .And. "L" $ SA1->A1_TIPO .And. ( lA1Contrib .And. SA1->A1_CONTRIB <> "2"))
			lInscrito := .F.
		EndIf

		cCodMuni  := IIf(lHist, SS2->S2_COD_MUN, SA1->A1_COD_MUN)
		lSuframa  := IIf(lHist, !Empty(SS2->S2_SUFRAMA) .And. SS2->S2_CALCSUF<>'N',  !Empty(SA1->A1_SUFRAMA) .And. SA1->A1_CALCSUF<>'N')
		cCalcSuf  := IIf(lHist, SS2->S2_CALCSUF, SA1->A1_CALCSUF)

		If Empty(cGrpCliFor)
			cGrpCliFor := IIf(lHist, SS2->S2_GRPTRIB, SA1->A1_GRPTRIB)
		EndIf

		If lEmiteNF
			cUfDest   := IIf(lHist, IIf(cTipoNf$"DB",cMvEstado,SS2->S2_EST), IIf(cTipoNf$"DB",cMvEstado,SA1->A1_EST))
			cUfOrig   := IIf(lHist, IIf(cTipoNf$"DB",SS2->S2_EST,cMvEstado), IIf(cTipoNf$"DB",SA1->A1_EST,cMvEstado))
		Else
			cUfDest   := cMvEstado
			cUfOrig   := cMvEstado
			If cPaisLoc == "ARG" // SigaLoja - para argentina inicializa a provincia do cliente
				cProvEnt  := IIf(lHist, SS2->S2_EST, SA1->A1_EST)
			EndIf
		EndIf

		cCNPJ     := IIf(lHist, SS2->S2_CGC, SA1->A1_CGC)

		If lInclui
			cNatureza :=  If(!Empty(cMvDupNat),&(cMvDupNat),"")
			cTpCliFor := IIf(lHist, IIf(Empty(cTpCliFor),SS2->S2_TIPO,cTpCliFor), IIf(Empty(cTpCliFor),SA1->A1_TIPO,cTpCliFor))
		Else
			cTpCliFor := IIf(lHist, SS2->S2_TIPO, SA1->A1_TIPO)
		EndIf

		nAliqIRF  := IIf(lHist, SS2->S2_ALIQIR, SA1->A1_ALIQIR)
		cRecPIS   := IIf(lHist, SS2->S2_RECPIS, SA1->A1_RECPIS)
		cRecCOFI  := IIf(lHist, SS2->S2_RECCOFI, SA1->A1_RECCOFI)
		cRecCSLL  := IIf(lHist, SS2->S2_RECCSLL, SA1->A1_RECCSLL)
		cRecISS   := IIf(lHist, IIf(SS2->S2_RECISS$"N|2| ","2","1"), IIf(SA1->A1_RECISS$"N|2| ","2","1"))

		If !Empty(cRecolheISS)
			cRecISS  := cRecolheISS
		Endif

		cRecINSS := IIf(lHist, SS2->S2_RECINSS, SA1->A1_RECINSS)

		If cPaisLoc == "BRA"
			If aPos[FP_B1_AFETHAB]  .And. aPos[FP_A2_RECFET]  .And. aPos[FP_A1_RECFET] .And. aPos[FP_F4_CALCFET]
				cRecFet  := IIf(lHist, IIf(Empty(SS2->S2_RECFET),"2",SS2->S2_RECFET), IIf(Empty(SA1->A1_RECFET),"2",SA1->A1_RECFET))
			EndIf

			If aPos[FP_B1_AFABOV] .And. aPos[FP_A2_RFABOV] .And. aPos[FP_A1_RFABOV] .And. aPos[FP_F4_CFABOV]
				cRecFab  := IIf(lHist, IIf(Empty(SS2->S2_RFABOV),"2",SS2->S2_RFABOV), IIf(Empty(SA1->A1_RFABOV),"2",SA1->A1_RFABOV))
			EndIf

			If aPos[FP_B1_AFACS] .And. aPos[FP_A2_RFACS] .And. aPos[FP_A1_RFACS]  .And. aPos[FP_F4_CFACS]
				cRecFac  := IIf(lHist, IIf(Empty(SS2->S2_RFACS),"2",SS2->S2_RFACS), IIf(Empty(SA1->A1_RFACS),"2",SA1->A1_RFACS))
			EndIf

			If aPos[FP_AFAMAD] .And. aPos[FP_A2_RECFMD] .And. aPos[FP_A1_RECFMD]  .And. aPos[FP_CFAMAD]
				cRecFMD  := IIf(lHist, IIf(Empty(SS2->S2_RECFMD),"2",SS2->S2_RECFMD), IIf(Empty(SA1->A1_RECFMD),"2",SA1->A1_RECFMD))
			EndIf

			If aPos[FP_B1_AIMAMT] .And. aPos[FP_A2_RIMAMT] .And. aPos[FP_A1_RIMAMT] .And. aPos[FP_F4_CIMAMT]
				cRecIMAMT  := IIf(lHist, IIf(Empty(SS2->S2_RIMAMT),"2",SS2->S2_RIMAMT), IIf(Empty(SA1->A1_RIMAMT),"2",SA1->A1_RIMAMT))
			EndIf

			If aPos[FP_B1_AFASEMT] .And. aPos[FP_A2_RFASEMT] .And. aPos[FP_A1_RFASEMT] .And. aPos[FP_F4_CFASE]
				cRecFASEMT  := IIf(lHist, IIf(Empty(SS2->S2_RFASEMT),"2",SS2->S2_RFASEMT), IIf(Empty(SA1->A1_RFASEMT),"2",SA1->A1_RFASEMT))
			EndIf

			cFRetIss := Iif(lHist, SS2->S2_FRETISS, SA1->A1_FRETISS)

			If aPos[FP_A1_RECIRRF]
				cRecIRRF := IIf(lHist, SS2->S2_RECIRRF, SA1->A1_RECIRRF)
			EndIf			
		EndIf

		cModIRF  := IIf(lHist, IIf( lA1CalcIRF ,SS2->S2_CALCIRF,IIf(cIRMP232=="2","1","2")), IIf( lA1CalcIRF ,SA1->A1_CALCIRF,IIf(cIRMP232=="2","1","2")))
		cOPIrrf  := IIf(lHist, IIf( aPos[FP_A1_TPESSOA], SS2->S2_TPESSOA,""), IIf( aPos[FP_A1_TPESSOA] , SA1->A1_TPESSOA,""))
		nNumDep  := 0	// so verifico os dependentes para os fornecedores
		cIRFProg := IIf(lHist, IIf( lA2IRPROG , SS2->S2_IRPROG , "2" ) , "" )
		cRegeSim := IIf(lHist, IIf(aPos[FP_A1_REGESIM], SS2->S2_REGESIM , "" ), IIf(aPos[FP_A1_REGESIM], SA1->A1_REGESIM , "" ))
		nPercAtm := IIf(lHist, Iif(aPos[FP_A1_PERCATM], SS2->S2_PERCATM , 0   ), Iif(aPos[FP_A1_PERCATM], SA1->A1_PERCATM , 0))
		cPessoa  := IIf(lHist, SS2->S2_PESSOA, SA1->A1_PESSOA )
		cNReduz  := IIf(lHist, SS2->S2_NREDUZ, SA1->A1_NREDUZ)
		cCRDMA   := IIf(lHist, Iif(aPos[FP_A1_CRDMA], SS2->S2_CRDMA , "" ), Iif(aPos[FP_A1_CRDMA]	 , SA1->A1_CRDMA , "" ))
		cSimpSC  := IIf(lHist, Iif(aPos[FP_A1_SIMPLES], SS2->S2_SIMPLES , ""), Iif(aPos[FP_A1_SIMPLES], SA1->A1_SIMPLES , ""))
		cCDRDes  := IIf(lHist, Iif(aPos[FP_A1_CDRDES], SS2->S2_CDRDES , ""), Iif(aPos[FP_A1_CDRDES], SA1->A1_CDRDES , ""))
		cSimpNac := IIf(lHist, Iif(aPos[FP_A1_SIMPNAC],SS2->S2_SIMPNAC,""), Iif(aPos[FP_A1_SIMPNAC],SA1->A1_SIMPNAC,""))
		nPerFECP := IIf(lHist, Iif(aPos[FP_A1_PERFECP],SS2->S2_PERFECP,""), Iif(aPos[FP_A1_PERFECP],SA1->A1_PERFECP,""))

		cIdSA1 := IIf(lHist, IIf(aPos[FP_A1_IDHIST], SS2->S2_IDHIST, ""), IIf(aPos[FP_A1_IDHIST], SA1->A1_IDHIST, ""))

		//Os tratamentos para PIS e COFINS irão utilizar como base o cliente de faturamento e
		//não mais o cliente entrega passado pelo parâmetro cCodCliFor na função MaFisIni e
		//gravado no array aNfCab e utilizado para as regras dos outros tributos.
		If aSX6[MV_PCFATPC] .And. cOperNf == "S"  .And. !Empty(cCliFat)
			aAreaSA1F	:=	SA1->(GetArea())
			If MsSeek(xFilial("SA1")+cCliFat+cLojCFat)
				If lInclui
					cNatCliFa := &(cMvDupNat)
					cTipoFat  := IIf(Empty(cTipoFat),SA1->A1_TIPO,cTipoFat)
				Else
					cTipoFat := SA1->A1_TIPO
				EndIf
				cGrpCliFat:= SA1->A1_GRPTRIB
				cRecPIS  := SA1->A1_RECPIS
				cRecCOFI := SA1->A1_RECCOFI

				If cPaisLoc == "BRA" .And. aPos[FP_A1_RECIRRF]
					cRecIRRF := SA1->A1_RECIRRF
				EndIf
			EndIf
			RestArea(aAreaSA1F)  // Posicionando novamente no cliente principal utilizado na MATXFIS (Parâmetro cCodCliFor do MaFisIni() )
		EndIf

		// Carga das alíquotas da apuração do simples nacional
		If cPaisLoc == "BRA" .And. aDic[AI_F13] .And. aSX6[MV_CODREG] == "1" .And. cOperNf == "S" .And. !cTipoNf $ "DB"

			// Só faço a carga se o array estiver vazio - evitar queries.
			If Empty(aAliqSN)

				#IFDEF TOP

					cPerIniSN := dToS(FirstDay(MonthSub(dDtEmiss, 1)))
					cPerFimSN := dToS(LastDay(MonthSub(dDtEmiss, 1)))
					cMesSN    := Month2Str(MonthSub(dDtEmiss, 1))
					cAnoSN    := Year2Str(MonthSub(dDtEmiss, 1))
					cPerEmpty := Space(TamSX3("F13_FIMVIG")[1])
	
					BeginSql Alias "MaAliqSN"			
						SELECT F12.F12_TPATIV, F13.F13_FATORR, F13.F13_CFOP, F13.F13_CODISS, F16.F16_ICMS, F16.F16_ISS, F16B.F16_ISS AS ALIQFATORR, F16C.F16_ICMS AS ICMSTRCOM, F18.F18_FATORR
						FROM %Table:F13% F13
						INNER JOIN %Table:F12% F12 ON F12.F12_FILIAL = %xFilial:F12% AND F12.F12_CODATV = F13.F13_CODATV AND F12.%NotDel%
						LEFT JOIN %Table:F18% F18 ON F18.F18_FILIAL = %xFilial:F18% AND F18.F18_PER = %Exp:cPerIniSN% AND F18.%NotDel%
						LEFT JOIN %Table:F16% F16 ON F16.F16_FILIAL = %xFilial:F16% AND F16.F16_ANEXO = F13.F13_ANEXO AND F16.F16_MES = %Exp:cMesSN% AND F16.F16_ANO = %Exp:cAnoSN% AND F16.F16_APROV = '1' AND F16.%NotDel%
						LEFT JOIN %Table:F16% F16B ON F16B.F16_FILIAL = %xFilial:F16% AND F16B.F16_ANEXO = F13.F13_ASUB AND F16B.F16_MES = %Exp:cMesSN% AND F16B.F16_ANO = %Exp:cAnoSN% AND F16B.F16_APROV = '1' AND F16B.%NotDel%
						LEFT JOIN %Table:F16% F16C ON F16C.F16_FILIAL = %xFilial:F16% AND F16C.F16_ANEXO = '01' AND F16C.F16_MES = %Exp:cMesSN% AND F16C.F16_ANO = %Exp:cAnoSN% AND F16C.F16_APROV = '1' AND F16C.%NotDel%					
						WHERE
						F13.F13_FILIAL = %xFilial:F13% AND
						F13.F13_INIVIG <= %Exp:cPerIniSN% AND (F13.F13_FIMVIG >= %Exp:cPerFimSN% OR F13.F13_FIMVIG = %Exp:cPerEmpty%) AND
						F13.%NotDel%
					EndSql
	
					dbSelectArea("MaAliqSN")
					MaAliqSN->(dbGoTop())
	
					While !MaAliqSN->(Eof())
	
						aAdd(aAliqSN, {})
						nPosAlqSN := Len(aAliqSN)
	
						If !Empty(MaAliqSN->F13_CFOP)
	
							aAdd(aAliqSN[nPosAlqSN], MaAliqSN->F13_CFOP) // CFOP
							aAdd(aAliqSN[nPosAlqSN], "") // COD ISS
							
							// Se a atividade for de transporte ou comunicação ela será tributada no anexo III
							// mas a alíquota do ICMS será do anexo I. Por isso fiz um JOIN na F16 passando direto
							// o anexo I.
							If MaAliqSN->F12_TPATIV == "1" .And. !Empty(MaAliqSN->ICMSTRCOM)
								aAdd(aAliqSN[nPosAlqSN], MaAliqSN->ICMSTRCOM) // ALIQUOTA
							Else
								aAdd(aAliqSN[nPosAlqSN], MaAliqSN->F16_ICMS) // ALIQUOTA
							EndIf
	
						ElseIf !Empty(MaAliqSN->F13_CODISS)
	
							aAdd(aAliqSN[nPosAlqSN],"") // CFOP
							aAdd(aAliqSN[nPosAlqSN], MaAliqSN->F13_CODISS) // COD ISS
	
							// Se o fator "r" for inferior a 28% a alíquota deve ser a do anexo
							// substituto.
							If MaAliqSN->F13_FATORR == "1" .And. MaAliqSN->F18_FATORR < 0.28
								aAdd(aAliqSN[nPosAlqSN], MaAliqSN->ALIQFATORR) // ALIQUOTA
							Else
								aAdd(aAliqSN[nPosAlqSN], MaAliqSN->F16_ISS) // ALIQUOTA
							EndIf
	
						EndIf
	
						MaAliqSN->(dbSkip())
	
					EndDo
	
					MaAliqSN->(dbCloseArea())

				#ENDIF

			EndIf

			lUsaAlqSN := !Empty(aAliqSN)

		EndIf

	Else
		//Inicializa as variaveis para a entidade prospect
		DbSelectArea("SUS")
		DbSetOrder(1)
		MsSeek(xFilial("SUS")+cCodProsp)
		cOperNf   := IIf(cTipoNf$"DB","E","S")

		If aPos[FP_US_INSCR]
			lInscrito := IIf(Empty(SUS->US_INSCR) .Or. "ISENT" $ SUS->US_INSCR .Or. "RG" $ SUS->US_INSCR .Or. ( aPos[FP_US_CONTRIB] .And. SUS->US_CONTRIB == "2"),.T.,.F.)
		Endif

		If aPos[FP_US_SUFRAMA]  .And. aPos[FP_US_CALCSUF]
			lSuframa  := !Empty(SUS->US_SUFRAMA) .And. SUS->US_CALCSUF<>'N'
			cCalcSuf  := SUS->US_CALCSUF
		Endif

		If aPos[FP_US_GRPTRIB]  .And. Empty(cGrpCliFor)
			cGrpCliFor:= SUS->US_GRPTRIB
		Endif

		cUfDest   := IIf(cTipoNf$"DB",cMvEstado,SUS->US_EST)
		cUfOrig   := IIf(cTipoNf$"DB",SUS->US_EST,cMvEstado)
		cCNPJ     := SUS->US_CGC

		If lInclui
			If aPos[FP_US_NATUREZ]
				cNatureza := SUS->US_NATUREZ
			Endif
			cTpCliFor := IIf(Empty(cTpCliFor),SUS->US_TIPO,cTpCliFor)
		Else
			cTpCliFor := SUS->US_TIPO
		EndIf

		nAliqIRF := IIf(aPos[FP_US_ALIQIR],SUS->US_ALIQIR	,0)
		cRecPIS  := IIf(aPos[FP_US_RECPIS],SUS->US_RECPIS	,"N")
		cRecCOFI := IIf(aPos[FP_US_RECCOFI],SUS->US_RECCOFI	,"N")
		cRecCSLL := IIf(aPos[FP_US_RECCSLL],SUS->US_RECCSLL	,"N")
		cRecISS  := IIf(aPos[FP_US_RECISS],SUS->US_RECISS	,"2")
		cRecINSS := IIf(aPos[FP_US_RECINSS],SUS->US_RECINSS	,"N")
		cModIRF  := IIf( lA1CalcIRF ,SA1->A1_CALCIRF,IIf(cIRMP232=="2","1","2"))
		cOPIrrf  := IIf(aPos[FP_US_TPESSOA],SUS->US_TPESSOA	,"")
		nNumDep	 := 0	// so verifico os dependentes para os fornecedores
		cIRFProg := IIf(lA2IRPROG,SA2->A2_IRPROG,"2")
	EndIf
Else
	lHist := .F.
	dbSelectArea("SA2")
	dbSetOrder(1)
	MsSeek(xFilial("SA2")+cCodCliFor+cLoja)
	If lHistorico
		//Se for reprocessamento,  e tiver habilitado para buscar os Historico Fiscais,
		//verifico se o ID do historico do Fornecedor e igual ao que foi gravado na Nota.
		//Se for igual é porque nao teve alterações no cliente após a emissão. Se for diferen
		//te e porque teve alterações no cadastro, e entao os dados são carregados da tabela
		//de Historico(SS3).
		cHistSA2 := IIF(!cTipoNF$"B|D", (cAlsCab)->F1_IDSA2, (cAlsCab)->F2_IDSA2)
		If cPaisLoc == "BRA" .And. Alltrim(SA2->A2_IDHIST)<>Alltrim(cHistSA2)
			dbSelectArea("SS3")
			dbSetOrder(1)
			MsSeek(xFilial("SS3")+cHistSA2+cCodCliFor+cLoja)
			cAls2 := "SS3"
			lHist := .T.
		EndIf
	EndIf

	cOperNf   := IIf(cTipoNf$"DB","S","E")

	If Empty(cGrpCliFor)
		cGrpCliFor:= IIf(lHist, SS3->S3_GRPTRIB, SA2->A2_GRPTRIB)
	EndIf

	lInscrito := IIf(cOperNf == "S" .And. cTipoNf$"B",IIf(Empty(SA2->A2_INSCR) .Or. "ISENT" $ SA2->A2_INSCR .Or. "RG" $ SA2->A2_INSCR .Or. (lA2Contrib .And. SA2->A2_CONTRIB == "2"),.T.,.F.),IIf(Empty(SM0->M0_INSC).Or."ISENT"$SM0->M0_INSC .Or. aSX6[MV_SM0CONT]=="2",.T.,.F.))
	cCodMuni  := IIf(lHist, SS3->S3_COD_MUN, SA2->A2_COD_MUN)
	cUfDest   := IIf(lHist, IIf(cTipoNf$"DB",SS3->S3_EST,cMvEstado), IIf(cTipoNf$"DB",SA2->A2_EST,cMvEstado))
	cUfOrig   := IIf(lHist, IIf(cTipoNf$"DB",cMvEstado,SS3->S3_EST), IIf(cTipoNf$"DB",cMvEstado,SA2->A2_EST))
	cCNPJ     := IIf(lHist, SS3->S3_CGC, SA2->A2_CGC)

	If cTpComp == "F" .And. cOperNf == "E" .And. (Alltrim(cEspecie)$"CTR/CTE/CTA/CA/CTF" .Or. "NFST"$cEspecie ) //cliente irá alterar o NFOrig pelo MATA116 e manteremos a UF original para gravação no Livro
		cUfCliDest := cUfOrig
	EndIf

	If cPaisLoc == "ARG" //Argentina inicializa a provincia do Fornecedor
		cProvEnt  := IIf(lHist, SS3->S3_EST, SA2->A2_EST)
	EndIf

	If lInclui
		cNatureza := IIf(!Empty(aSX6[MV_2DUPNAT]), &(aSX6[MV_2DUPNAT]),"")
		If Empty( cTpCliFor )
			// Converte os tipos do fornecedor para os tipos validos
			cTpCliFor := IIf(lHist, IIf( SS3->S3_TIPO == "J" .Or. SS3->S3_TIPO == " " , "R" , SS3->S3_TIPO ), IIf( SA2->A2_TIPO == "J" .Or. SA2->A2_TIPO == " " , "R" , SA2->A2_TIPO ))
		EndIf
	Else
		cTpCliFor := IIf(lHist, IIf( SS3->S3_TIPO == "J" .Or. SS3->S3_TIPO == " " , "R" , SS3->S33_TIPO ), IIf( SA2->A2_TIPO == "J" .Or. SA2->A2_TIPO == " " , Iif(Empty(cTpCliFor),"R",cTpCliFor) , SA2->A2_TIPO ))
	EndIf

	If cPaisLoc == "BRA"

		cRecISS  := IIf(lHist, IIf(SS3->S3_RECISS<>"S","2","1"), IIf(SA2->A2_RECISS<>"S","2","1"))
		cRecINSS := IIf(lHist, SS3->S3_RECINSS, SA2->A2_RECINSS)
		cCalcINP := IIf(lHist, IIf(aPos[FP_A2_CALCINP],SS3->S3_CALCINP,"2"), IIf(aPos[FP_A2_CALCINP],SA2->A2_CALCINP,"2"))
		cRecSEST := IIf(lHist, IIf(aPos[FP_A2_RECSEST],SS3->S3_RECSEST,"2"), IIf(aPos[FP_A2_RECSEST],SA2->A2_RECSEST,"2"))
		cRecPIS  := IIf(lHist, IIf(SS3->S3_RECPIS<>"2","N","S"), IIf(SA2->A2_RECPIS<>"2","N","S"))
		cRecCOFI := IIf(lHist, IIf(SS3->S3_RECCOFI<>"2","N","S"), IIf(SA2->A2_RECCOFI<>"2","N","S"))
		cRecCSLL := IIf(lHist, IIf(SS3->S3_RECCSLL<>"2","N","S"), IIf(SA2->A2_RECCSLL<>"2","N","S"))

		If !Empty(cRecolheISS)
			cRecISS  := cRecolheISS
		Endif

		If aPos[FP_B1_AFETHAB]  .And. aPos[FP_A2_RECFET]  .And. aPos[FP_A1_RECFET] .And. aPos[FP_F4_CALCFET]
			cRecFet  := IIf(lHist, IIf(Empty(SS3->S3_RECFET),"2",SS3->S3_RECFET), IIf(Empty(SA2->A2_RECFET),"2",SA2->A2_RECFET))
		Endif

		If aPos[FP_B1_AFABOV] .And. aPos[FP_A2_RFABOV] .And. aPos[FP_A1_RFABOV] .And. aPos[FP_F4_CFABOV]
			cRecFab  := IIf(lHist, IIf(Empty(SS3->S3_RFABOV),"2",SS3->S3_RFABOV), IIf(Empty(SA2->A2_RFABOV),"2",SA2->A2_RFABOV))
		Endif

		If aPos[FP_B1_AFACS] .And. aPos[FP_A2_RFACS] .And. aPos[FP_A1_RFACS]  .And. aPos[FP_F4_CFACS]
			cRecFac  := IIf(lHist, IIf(Empty(SS3->S3_RFACS),"2",SS3->S3_RFACS), IIf(Empty(SA2->A2_RFACS),"2",SA2->A2_RFACS))
		Endif

		If aPos[FP_AFAMAD] .And. aPos[FP_A2_RECFMD] .And. aPos[FP_A1_RECFMD]  .And. aPos[FP_CFAMAD]
			cRecFMD  := IIf(lHist, IIf(Empty(SS3->S3_RECFMD),"2",SS3->S3_RECFMD), IIf(Empty(SA2->A2_RECFMD),"2",SA2->A2_RECFMD))
		Endif

		If aPos[FP_B1_AIMAMT] .And. aPos[FP_A2_RIMAMT] .And. aPos[FP_A1_RIMAMT] .And. aPos[FP_F4_CIMAMT]
			cRecIMAMT  := IIf(lHist, IIf(Empty(SS3->S3_RIMAMT),"2",SS3->S3_RIMAMT), IIf(Empty(SA2->A2_RIMAMT),"2",SA2->A2_RIMAMT))
		Endif

		If aPos[FP_B1_AFASEMT] .And. aPos[FP_A2_RFASEMT] .And. aPos[FP_A1_RFASEMT] .And. aPos[FP_F4_CFASE]
			cRecFASEMT  := IIf(lHist, IIf(Empty(SS3->S3_RFASEMT),"2",SS3->S3_RFASEMT), IIf(Empty(SA2->A2_RFASEMT),"2",SA2->A2_RFASEMT))
		Endif

		cModIRF  := IIf(lHist, IIf(aPos[FP_A2_CALCIRF],SS3->S3_CALCIRF,"1"), IIf(aPos[FP_A2_CALCIRF],SA2->A2_CALCIRF,"1"))
		cOPIrrf  := IIf(lHist, Iif(aPos[FP_A2_TPESSOA],SS3->S3_TPESSOA,""), Iif(aPos[FP_A2_TPESSOA],SA2->A2_TPESSOA,""))
		cSimpNac := IIf(lHist, Iif(aPos[FP_A2_SIMPNAC],SS3->S3_SIMPNAC,""), Iif(aPos[FP_A2_SIMPNAC],SA2->A2_SIMPNAC,""))
		nNumDep  := IIf(lHist, Iif(aPos[FP_A2_NUMDEP],SS3->S3_NUMDEP,0), Iif(aPos[FP_A2_NUMDEP],SA2->A2_NUMDEP,0))  	//so verifico os dependentes para os fornecedores
		cIRFProg := IIf(lHist, IIf(lA2IRPROG,SS3->S3_IRPROG,"2"), IIf(lA2IRPROG,SA2->A2_IRPROG,"2"))
		cRegeSim := IIf(lHist, IIf(aPos[FP_A2_REGESIM], SS3->S3_REGESIM , "" ), IIf(aPos[FP_A2_REGESIM], SA2->A2_REGESIM , "" ))
		cNReduz  := IIf(lHist, SS3->S3_NREDUZ, SA2->A2_NREDUZ)
		cIdSA2   := IIf(lHist, If(aPos[FP_A2_IDHIST], SS3->S3_IDHIST, ""), If(aPos[FP_A2_IDHIST], SA2->A2_IDHIST, ""))
		nRecCide := IIf(lHist, If(aPos[FP_A2_RECCIDE], SS3->S3_RECCIDE, ""), If(aPos[FP_A2_RECCIDE], SA2->A2_RECCIDE, ""))
		cGrossIR := IIf(lHist, If(aPos[FP_A2_GROSSIR], SS3->S3_GROSSIR, ""), If(aPos[FP_A2_GROSSIR], SA2->A2_GROSSIR, ""))

		If cOperNf == "E" .And. !Empty(cCltdest) .And. !Empty(cLjtdest) .And. (AllTrim(cEspecie) $ "CTR/CTE/CTA/CA/CTF" .Or. "NFST"$AllTrim(cEspecie))
			lA1Cntdest	:= aPos[FP_A1_CONTRIB]
			dbSelectArea("SA1")
			dbSetOrder(1)
			If SA1->(MsSeek(xFilial("SA1")+cCltdest+cLjtdest))
				If lHistorico
					cHstA1Dest := (cAlsCab)->F1_IDSA1
					If cPaisLoc == "BRA" .And.  Alltrim(SA1->A1_IDHIST)<>Alltrim(cHstA1Dest)
						dbSelectArea("SS2")
						dbSetOrder(1)
						MsSeek(xFilial("SS2")+cHstA1Dest+cCltdest+cLjtdest)
						lHistDest := .T.
					EndIf
				EndIf

				linscDest := IIf(lHistDest, IIf(Empty(SS2->S2_INSCR).Or."ISENT"$SS2->S2_INSCR.Or."RG"$SS2->S2_INSCR.Or.( lA1Cntdest .And. SS2->S2_CONTRIB == "2"),.T.,.F.), IIf(Empty(SA1->A1_INSCR).Or."ISENT" $ SA1->A1_INSCR .Or. "RG" $ SA1->A1_INSCR .Or.( lA1Cntdest .And. SA1->A1_CONTRIB == "2"),.T.,.F.))
				If SA1->A1_CONTRIB == "1" .And. SA1->A1_TPJ == "3" .And. Empty(SA1->A1_INSCR)
					linscDest := .F.
				Endif
				If IIf(lHistDest, !Empty(SS2->S2_INSCRUR) .And. "L" $ SS2->S2_TIPO .And. ( lA1Cntdest .And. SS2->S2_CONTRIB <> "2"), !Empty(SA1->A1_INSCRUR) .And. "L" $ SA1->A1_TIPO .And. ( lA1Cntdest .And. SA1->A1_CONTRIB <> "2"))
					linscDest := .F.
				EndIf
				cUfCliDest := IIf(lHistDest,SS2->S2_EST,SA1->A1_EST)
				cUfDest := cUfCliDest
			Endif
		Endif

		cDedBsPC := IIf(lHist, If(aPos[FP_A2_DEDBSPC], SS3->S3_DEDBSPC, " "), If(aPos[FP_A2_DEDBSPC], SA2->A2_DEDBSPC, " "))
		cTipoRur := IIf(lHist, If(aPos[FP_A2_TIPORUR], SS3->S3_TIPORUR, ""), If(aPos[FP_A2_TIPORUR], SA2->A2_TIPORUR, ""))
		cTPJFor	 := IIf(lHist, SS3->S3_TPJ, SA2->A2_TPJ)

		nPerFECP := aSX6[MV_PERFECP]
	EndIf
EndIf

IF cOperNF == "E"
	cUfPreISS := cUfOrig
Else
	cUfPreISS := cUfDest
EndIf

cMunForISS := cCodMuni

IF aDic[AI_F0R] .And. aPos[FP_F0RIND]
	If F0R->(MsSeek(xFilial("F0R")+cUfDest+AnoMes(dDtEmiss)))
		nIndice:= F0R->F0R_INDICE
	EndIf
EndIf


//Parametro "MV_INDUPF", utilizado para informar o campo da tabela SM2 (Moedas) que sera utilizado para informar o indexador UPF/MT, com a finalidade de calcular as contribuições FETHAB, FACS, FABOV, FAMAD
IF cPaisLoc == 'BRA'
	If aPos[FP_SM2_IND]
	    SM2->(dbSetOrder(1))
	    If SM2->(MsSeek(dDataBase))
	        nIndUpf := SM2->&(Alltrim(aSX6[MV_INDUPF]))
	    Endif
	Endif
EndIf

dbSelectArea("SED")
SED->(dbSetOrder(1))

If SED->(MsSeek(xFilial("SED")+cNatureza))
	If lHistorico
		If ( cCliFor == "C" .And. !cTipoNf$"D|B") .Or. (cCliFor == "F" .And. cTipoNf$"D|B")
			cHistSED :=	(cAlsCab)->F2_IDSED
		Else
			cHistSED :=	(cAlsCab)->F1_IDSED
		EndIf
		lHistrt := .F.
		If cPaisLoc == "BRA" .And. Alltrim(SED->ED_IDHIST)<>Alltrim(cHistSED)
			dbSelectArea("SS7")
			dbSetOrder(1)
			MsSeek(xFilial("SS7")+cHistSED)
			lHist := .T.
		EndIf
	EndIf

	aInfNat := {IIf(lHist, SS7->S7_CODIGO,  SED->ED_CODIGO),;  //aInfNat->01
				IIf(lHist, SS7->S7_CALCIRF, SED->ED_CALCIRF),; //aInfNat->02
				IIf(lHist, SS7->S7_PERCIRF, SED->ED_PERCIRF),; //aInfNat->03
				IIf(lHist, SS7->S7_BASEIRF, SED->ED_BASEIRF),; //aInfNat->04
				IIf(lHist, SS7->S7_PERCINS, SED->ED_PERCINS),; //aInfNat->05
				IIf(lHist, SS7->S7_BASEINS, SED->ED_BASEINS),; //aInfNat->06
				IIf(lHist, SS7->S7_CALCINS, SED->ED_CALCINS),; //aInfNat->07
				IIf(lHist, SS7->S7_CALCISS, SED->ED_CALCISS),; //aInfNat->08
				IIf(lHist, SS7->S7_CALCPIS, SED->ED_CALCPIS),; //aInfNat->09
				IIf(lHist, SS7->S7_PERCPIS, SED->ED_PERCPIS),; //aInfNat->10
				IIf(lHist, SS7->S7_CALCCOF, SED->ED_CALCCOF),; //aInfNat->11
				IIf(lHist, SS7->S7_PERCCOF, SED->ED_PERCCOF),; //aInfNat->12
				IIf(lHist, SS7->S7_CALCCSL, SED->ED_CALCCSL),; //aInfNat->13
				IIf(lHist, SS7->S7_PERCCSL, SED->ED_PERCCSL),; //aInfNat->14
				IIf(lHist, SS7->S7_BASESES, SED->ED_BASESES),; //aInfNat->15
				IIf(lHist, SS7->S7_PERCSES, SED->ED_PERCSES),; //aInfNat->16
				IIf(lHist, Iif(aPos[FP_ED_IDHIST], SS7->S7_IDHIST,""), Iif(aPos[FP_ED_IDHIST], SED->ED_IDHIST,"")),; // aInfNat -> 17
				IIf(lHist, SS7->S7_DEDINSS, SED->ED_DEDINSS),; // aInfNat -> 18
				IIf(lHist, Iif(aPos[FP_ED_CALCCID], SS7->S7_CALCCID,""), Iif(aPos[FP_ED_CALCCID], SED->ED_CALCCID,"")),; // aInfNat -> 19
				IIf(lHist, Iif(aPos[FP_ED_PERCCID], SS7->S7_PERCCID,0), Iif(aPos[FP_ED_PERCCID], SED->ED_PERCCID,0)),; // aInfNat -> 20
				IIf(lHist, Iif(aPos[FP_ED_BASECID], SS7->S7_BASECID,0), Iif(aPos[FP_ED_BASECID], SED->ED_BASECID,0)),; // aInfNat -> 21
				IIf(lHist, Iif(aPos[FP_ED_IRRFCAR], SS7->S7_IRRFCAR,""), Iif(aPos[FP_ED_IRRFCAR], SED->ED_IRRFCAR,"")),; // aInfNat -> 22
				IIf(lHist, Iif(aPos[FP_ED_BASEIRC], SS7->S7_BASEIRC,0), Iif(aPos[FP_ED_BASEIRC], SED->ED_BASEIRC,0)),; // aInfNat -> 23
				IIf(lHist, "", Iif(aPos[FP_CALCFMP], SED->ED_CALCFMP,"2")),; // aInfNat -> 24
				IIf(lHist, "", Iif(aPos[FP_PERQFMP], SED->ED_PERQFMP,0)),; // aInfNat -> 25
				IIf(lHist, Iif(aPos[FP_ED_CALCINP], SS7->S7_CALCINP,"2"), Iif(aPos[FP_ED_CALCINP], SED->ED_CALCINP,"2")),; // aInfNat -> 26
				IIf(lHist, Iif(aPos[FP_ED_PERCINP], SS7->S7_PERCINP,0), Iif(aPos[FP_ED_PERCINP], SED->ED_PERCINP,0))} // aInfNat -> 27
Else
	aInfNat := {"",;	// aInfNat -> 01 - ED_CODIGO
				"",;	// aInfNat -> 02 - ED_CALCIRF
				0 ,;	// aInfNat -> 03 - ED_PERCIRF
				0 ,;	// aInfNat -> 04 - ED_BASEIRF
				0 ,;	// aInfNat -> 05 - ED_PERCINS
				0 ,;	// aInfNat -> 06 - ED_BASEINS
				"",;	// aInfNat -> 07 - ED_CALCINS
				"",;	// aInfNat -> 08 - ED_CALCISS
				"",;	// aInfNat -> 09 - ED_CALCPIS
				0 ,;	// aInfNat -> 10 - ED_PERCPIS
				"",;	// aInfNat -> 11 - ED_CALCCOF
				0 ,;	// aInfNat -> 12 - ED_PERCCOF
				"",;	// aInfNat -> 13 - ED_CALCCSL
				0 ,;	// aInfNat -> 14 - ED_PERCCSL
				0 ,;	// aInfNat -> 15 - ED_BASESES
				0 ,;	// aInfNat -> 16 - ED_PERCSES
				"",;	// aInfNat -> 17 - ED_IDHIST
				"",;	// aInfNat -> 18 - ED_DEDINSS
				"N",;	// aInfNat -> 19 - ED_CALCCID
				0,;		// aInfNat -> 20 - ED_PERCCID
				0,;     // aInfNat -> 21 - ED_BASECID
				"",;	// aInfNat -> 22 - ED_IRRFCAR
				0,;     // aInfNat -> 23 - ED_BASEIRC
				"2",;	// aInfNat -> 24 - ED_CALCFMP
				0,;		// aInfNat -> 25 - ED_PERQFMP
				"2",;	// aInfNat -> 26 - ED_CALCINP
				0}		// aInfNat -> 27 - ED_PERCINP
EndIf

aNfCab := {cTipoNF,;//1
cOperNF,;//2
cCliFor,;//3
cTpCliFor,;//4
lInscrito,;//5
cGrpCliFor,;//6
cUFdest,;//7
cUfOrig,;//8
0,;//9
0,;//10
0,;//11
0,;//12
0,;//13
0,;//14
{0,0,0,0,0,0,0,0,"1"},;//15
{0,0,0},;//16
0,;//17
0,;//18
0,;//19
cCodCliFor,;//20
cLoja,;//21
{},;//22
{0,0,0},;//23
{0,0},;//24
{0,0},;//25
cNatureza,;//26
0,;//27
{},;//28
{},;//29
IIf(lInclui,{{'...','',0,0,0,'NEW'}},{{"","",0,0,0,""}}),;//30
0,;//31
aRelImp,;//32
IIf(lInclui,{{'...','',0,0,'NEW'}},{{"","",0,0,""}}),;//33
0,;//34
lSuframa,;//35
Array(NMAXIV),;//36
Array(NMAXIV),;//37
cTpComp,;//38
lInsere,;//39
0,;//40
0,;//41
0,;//42
0,;//43
0,;//44
0,;//45
0,;//46
0,;//47
0,;//48
cRotina,;//49
0,;//50
nAliqIRF,;//51
0,;//52
cRecPIS,;//53
cRecCOFI,;//54
cRecCSLL,;//55
cRecISS,;//56
cRecINSS,;//57
nMoeda,;//58
nTxMoeda,;//59
cSerie,;//60
cTipoDoc,;//61
Array(NMAXIV),;//62
0,;//63
0,;//64
cEspecie,;//65
cCNPJ,;//66
0,;//67
0,;//68
0,;//69
cModIRF,;//70
{"","","",""},;//71
cCalcSuf,;//72
0,;//73 - Base de Calculo do AFRMM - NF
0,;//74 - Valor do AFRMM - NF
0,;//75
0,;//76
cOPIrrf,;//77
{0,0},;//78 - Array dos valores do SEST
cRecSEST,;//79 - Recolhe SEST
0,;//80 - Base de calculo do PIS Subst. Tributaria
0,;//81 - Valor do PIS Subst. Tributaria
0,;//82 - Base de calculo da COFINS Subst. Tributaria
0,;//83 - Valor da COFINS Subst. Tributaria
0,;//84 - Valor Total do Frete de Pauta
0,;//85 - Valor FETHAB
cRecFet,;//86 - Recolhe FETHAB
cCliEnt,;//87 - Codigo do cliente de entrega
cLojEnt,;//88 - Loja do cliente de entrega
0,;//89 - Valor do Fundersul - Mato Grosso do Sul
0,;//90 - Valor do Estorno de Credito
cSimpNac,;//91 - Enquadra no Simples Nacional
aTransp,;//92 - Dados do transportador para o calculo do ICMS do frete autonomo embarcador
0,;//93 - Base do ICMS de transporte Substituicao Tributaria
0,;//94 - Base do ICMS de transporte Substituicao Tributaria
0,;//95 - Credito Presumido Simples Nacional - SC
0,;//96 - Valor Antecipacao ICMS
0,;//97 - Despesas nao tributadas - Portugal
0,;//98 - Tara - Portugal
nNumDep,;//99 - Numero de dependentes - cálculo base IRRF pessoa fisica
cProvEnt,;//100 - Provincia de entrega
0,;//101 - Valor do FECP
0,;//102 - Valor do FECP ST
0,;//103 - Valor Crédito Presumido - SC
cIRFProg,;//104 - Calcula IR pela Tabela Progressiva mesmo sendo Pessoa Juridica
0,;//105 - Valor do imposto de Importacao
.T.,;//106 - Flag para recalculo de impostos variaveis
0,;//107 - Valor do credito presumido PE
Array(NMAXIV),;//108 - Valor do ORIGINAL DO iMPOSTO
0,;//109 - Valor FABOV - Mato Grosso
cRecFab,;//110 - Reponsabilidade de recolhimento FABOV - Mato Grosso
0,;//111 - Valor FACS - Mato Grosso
cRecFac,;//112 - Reponsabilidade de recolhimento FACS - Mato Grosso
lCalcIPI,;//113 - Calcula IPI (SIGALOJA)
0,;//114 - Valor do FUMACOP
0,;//115 - Valor do Senar
0,;//116 - Credito Outorgado SP
0,;//117 - Base do ICMS sem desconto - Decreto 43.080/02-MG
0,;//118 - Valor do ICMS sem desconto - Decreto 43.080/02-MG
0,;//119 - Valor do Desconto - Decreto 43.080/02-MG
0,;//120 - Valor do ICMS sem debito de imposto - Decreto 43.080/02-MG
0,;//121 - Base do FUNRURAL
cPedido,;//122 - Pedido de Venda
cCodMuni,;//123 - Codigo do Municipio utilizado na operacao
{0,0},;//124 - Valor TPDP - PB
0,;//125 - Valor incentivo prod.leite RICMS/MG
0,;//126 - Base de calculo do INSS Condições Especiais
0,;//127 - Valor do INSS Condições Especiais
0,;//128 - Valor do FECOP-RN
0,;//129 - Valor do FECOP ST-RN
0,;//130 - Credito Presumido
0,;//131 - Valor do FECP-MG
0,;//132 - Valor do FECP ST-MG
0,;//133 - Valor do Reintegra
0,;//134 - Base de Calculo do Reintegra
0,;//135 - Valor do FECP-MT
0,;//136 - Valor do FECP ST-MT
cRegeSim,;//137 - Regime Simp. MT
nPercAtm,;//138 - Perc. Carga media
cPessoa,;//139 - Pessoa - Fisica/Juridica
cNReduz,;//140 - Nome Fantasia
cCRDMA,;//141 - Credito Estimulo de Manaus
cSimpSC,;//142 - Clie. optante SIMPLES/SC
cCDRDes,;//143 - Regiao do Cliente
{cCliFat,cLojCFat,cTipoFat,cGrpCliFat,cNatCliFa},;//144 - Cliente, Loja, Tipo, Grupo e Natureza do cliente do Faturamento (utilizado para PIS e COFINS)
0,;//145 - Abatimentos de Materiais do ISS
0,;//146 - Abatimentos de Servicos do ISS
0,;//147 - Abatimentos de Materiais do INSS
0,;//148 - Abatimentos de Servicos do INSS
0,;//149 - Adiantamento
nTotPed,;//150 - Total do Pedido
dDtEmiss,;//151 - Emissao do documento
cIDSA1,;//152 - ID Historico Cliente
cIDSA2,;//153 - ID Historico Fornecedor
aInfNat[18],;//154 - ID Historico Natureza
0 ,;//155 - Total do Desconto do Item - USO DO NOVO PDV - LOJA
0 ,;//156 - Total do Acrescimos do Item - USO DO NOVO PDV - LOJA
cTpFrete ,;//157 - Tipo de Frete definido no pedido de Venda
cFRetIss ,;//158 - Forma de Retencao do ISS. 1 - Considera Valor Minimo; 2 - Sempre Retem
cUfPreISS,;//159 - UF da prestacao do servico do ISS onde o servico foi prestado
Array(NMAXUF),;//160 -Array com conteúdo da tabela CFC
0,;//161 - Valor Cide
nRecCide,;//162 - Rec Cide
0,;//163 - Valor do FETAHB retido pelo cliente/fornecedor
" ",;//164 - Modalidade CTE / SF1
0,;//165 - NF_BASNDE
0,;//166 -NF_ICMNDES
0,;//167 - Total de adiantamento
0,;//168-Base de Calculo CIDE
0,;//169-Base do ISS CEPOM
0,;//170-Valor do ISS CEPOM
0,;//171-Valor IPI a ser inserido na base do ICM, venda futura CF
0,;//172- Base Fumipeq
0,;//173- Valor Fumipeq
0,;//174-Valor Famad
cRecFMD,;//175-Responsabilidade de recolhimento FAMAD - Mato Grosso
cSerSat,;//176- Série do CF-e SAT
0,;//177- Base ICMS ST Recolh. Ant.
0,;//178- Valor ICMS ST Recolhido Anteriormente.
cTpCompl,;//179- Tipo de Complemento
0,;//180- Difal
.F.,;//181- Regra para calculo de Difal para consumidor final
0,;//182 - FECP DIFAL
0,;//183 - Base Destino DIFAL
cCltdest,;//184 - Cliente de destino da mercadoria
cLjtdest,;//185 - Loja de destino da mercadoria
cUfCliDest,;//186- UF de destino da mercadoria
linscDest,;//187 - verifica se cliente de destino da mercadoria é contribuinte
0,;//188 - Valor FUNDESA
0,;//189 - Valor IMA-MT
0,;//190 - Valor FASE-MT
0,;//191 - Valor do IMA-MT retido pelo cliente/fornecedor
0,;//192 - Valor do FASE-MT retido pelo cliente/fornecedor
cRecIMAMT,;//193 - Reponsabilidade de recolhimento IMA-MT
cRecFASEMT,;//194 - Reponsabilidade de recolhimento FASE-MT
0,;//195 - Preço Médio Ponderado, para ser utilizado como base de ICMS ST
nIndice,;//196 - Indice tabela F0R
0,;//197 - Valor do Pedágio
cAtividad,;//198 - Actividad economica
cCalcINP,;//199 - Calcula INSS Patronal
0,;//200 - Valor do INSS Patronal
0,;//201 - Valor do AFRMM na Importação
0,;//202 - Valor PROTEGE-GO
nIndUpf,;//203 - Indice Mato Grosso
0,;//204 - Valor FEEF-GO
cDedBsPC,;//205 - Impostos que serão deduzidos da base de PIS/COFINS.
cM0CodMun,;// 206 - Codigo do municipio do SIGAMAT.
cTipoRur,;// 207 - Tipo do Fornecedor para efeito da contribuicao seguridade social.
cRecIRRF,;// 208 - Recolhe IRRF sim ou não.
0,;//209 - Base do FCP recolhido anteriormente.
0,;//210 - Valor do FCP recolhido anteriormente.
nPerFECP,;//211 - Percentual do FECP-ST "por CNAE": Campo A1_PERFECP ou parametro MV_PERFECP.
0,;//212 - Base do FECP - Proprio.
0,;//213 - Base do FECP - ST.
0,;//214 - Base do FECP - Complementar.
lEmiteNF,;//215 - Se esta emitindo nota fiscal ou cupom fiscal (Sigaloja)
aAliqSN,; //216 - Alíquotas de ICMS/ISS calculadas pela apuração do SN
lUsaAlqSN,; // 217 - Define se devem ou não ser utilizadas as alíquotas calculadas pela apuração do SIMPLES NACIONAL.
cGrossIR,;//218 - Opção da base de cálculo do IR, se deverá ou não fazer o Gross Up
cTPJFor,;//219 - Tipo de pessoa jurídica do fornecedor  
"",;//220 - calcular valor Declaratorio
lTemF2B,;   //221 Flag para indicar se existe, ao menos, uma regra na tabela F2B
{},;//222 Totalizador dos tributos genéricos.
lCalcTG,; //223-Flag para indicar se os tributos genéricos devem ou não ser calculados - deve ser passado como .T. somente após a preparação da rotina para gravação, visualização e exclusão dos tributos genéricos.
lPerfPart,; //224 - Indica se o participante está contido em ao menos 1 perfil de participante dos tributos genéricos
nQtdItens} //225 - Quantidade de itens do documento.

//	Carga das referencias vinculadas a tabela UF x UF
//  Foi necessario criar as referencias da tabela CFC no cabecalho e fazer o seek desta tabela na MaFisIni() para que nao
// seja preciso colocar o seek de UF x UF na funcao MaFisIniCpo(), evitando que sejam feitas duas consultas por item. Com
// esta mecanica, sera feito 1 seek no cabecalho com a chave UF x UF e 1 seek por item com a chave UF x UF x Produto.
//  Utilizo o PadR[TamSx3] na posicao 3 do indice (codigo do produto) para garantir que nao seja cacheado no cabecalho o
// conteudo de um registro de item, onde o produto esteja preenchido.

// Carga da tabela CFC.
MaSeekCFC(1)

// Inicializa arrays de impostos variaveis
aNfCab[NF_BASEIMP]:=Afill(aNfCab[NF_BASEIMP],0)
aNfCab[NF_VALIMP]:=Afill(aNfCab[NF_VALIMP],0)
aNfCab[NF_MINIMP]:=Afill(aNfCab[NF_MINIMP],0)
aNfCab[NF_VLRORIG]:=Afill(aNfCab[NF_VLRORIG],0)

// Cria o array de Referencias
If aItemRef == Nil
	MaIniRef()
EndIf

// Cria o array de arredondamentos do item
If aSaveDec == Nil
	aSaveDec := Array(Len(aItemRef))
	aFill(aSaveDec,0)
EndIf

If aAuxOri == Nil
	aAuxOri := {}
EndIf

RestArea(aAreaSA1)
RestArea(aAreaSA2)
RestArea(aArea)

Return(.T.)
/*MaFisIniLo Edson Maricate 09.12.99
Esta rotina tem como objetivo inicializar a variavel aNFItem
Rotina inicializacao do item da funcao Fiscal
Parametros
ExpN1: Item do Array ANFItem que deve ser inicializado
ExpA2: Array de otimizacao de Inicializacao(OPC)
ExpL3: Indica se o item deve ser estornado caso exista
*/
Function MaFisIniLoad(nItem,aLoad,lEstorno,cIdTribGen)

DEFAULT lEstorno := .F.
Default cIdTribGen	:= ""//Id dos tributos genéricos para visualização/exclusão

If !MaFisFound("IT",nItem)

	If aLoad == Nil
		aLoad := Array(14)
		aLoad[01] := IIf( aNfCab[NF_OPERNF] == "S" , Space(Len(SD2->D2_COD)) , Space(Len(SD1->D1_COD)))
		aLoad[02] := "   "
		aLoad[03] :=  If(cPaisLoc == "BRA" ,Space(Len(SD1->D1_CODISS)) , Space(9) )
		aLoad[04] := 0
		aLoad[05] := Space(Len(SD1->D1_NFORI))
		aLoad[06] := Space(Len(SD1->D1_SERIORI))
		aLoad[07] := 0
		aLoad[08] := 0
		aLoad[09] := Nil
		aLoad[10] := ""
		aLoad[11] := ""
		aLoad[12] := Space(Len(aLoad[1])) 	// Codigo do Produto Fiscal
		aLoad[13] := 0 						// Recno do Produto Fiscal
		aLoad[14] := IIf(aPos[FP_D1_OPER], Space(TamSX3("D1_OPER")[1]), "  ") // Tipo de Operação
	EndIf

	aadd(aNfItem,{"",;//1-Grupo de Tributacao
	{},;//2-Array contendo as excessoes Fiscais
	0,;//3-Aliquota de ICMS
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},;//4-Valores de ICMS
	0,;//5-Aliquota de IPI
	{0,0,0,0,0},;//6-Valores de IPI
	aLoad[5],;//7-Numero da NF Original
	aLoad[6],;//8-Serie da NF Original
	aLoad[9],;//9-RecNo da NF original
	0,;//10-Valor do desconto do item
	0,;//11-Valor do Frete
	0,;//12-Valor da despesa
	0,;//13-Valor do seguro
	0,;//14-Valor do frete autonomo
	0,;//15-Valor da Mercadoria
	aLoad[1],;//16-Codigo do produto
	aLoad[2],;//17-Codigo da TES
	0,;//18-Valor Total do item
	"",;//19-Codigo FIscal de Operacao
	0,;//20-Valor do Funrural
	0,;//21-Aliquota para calculo do FunRural
	.F.,;//22-Flag de controle para itens deletados
	MaFisRetLF() ,;//23-Array Contendo o demonstrativo fiscal
	{0,0,0,aLoad[3],"","","",0,0,0,.F.},;//24-Array contendo os valores de ISS
	{0,0,0,0},;//25-Array contendo os valores de IR
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},;//26-Array contendo os valores de INSS
	0 ,;//27-Valor da Embalagem
	Array(NMAXIV),;//28
	Array(NMAXIV),;//29
	Array(NMAXIV),;//30
	0,;//31
	0,;//32
	Array(NMAXIV),;//33
	aLoad[4],;//34
	0,;//35
	0,;//36
	0,;//37
	0,;//38
	0,;//39
	0,;//40
	0,;//41
	0,;//42
	0,;//43
	0,;//44
	0,;//45
	0,;//46
	0,;//47
	0,;//48
	aLoad[7],;//49
	aLoad[8],;//50
	0,;//51
	aNFCAB[NF_TIPONF],;//52
	"",;//53
	0,;//54
	0,;//55
	0,;//56
	0,;//57
	0,;//58
	0,;//59
	0,;//60
	0,;//61
	0,;//62
	0,;//63
	0,;//64
	0,;//65
	0,;//66-AFRMM
	0,;//67
	0,;//68
	0,;//69
	0,;//70
	0,;//71
	"",;//72
	Iif(aNfCab[NF_OPERNF]=="S", "01", "0001"),;//73
	{0,0,0},;//74-Array contendo os valores do SEST
	0,;//75-Base de calculo do PIS Subst. Tributaria
	0,;//76-Aliquota do PIS Subst. Tributaria
	0,;//77-Valor do PIS Subst. Tributaria
	0,;//78-Bae da COFINS Subst. Tributaria
	0,;//79-Aliquota da COFINS Subst. Tributaria
	0,;//80-Valor da COFINS Subst. Tributaria
	0,;//81-Valor do Frete de Pauta
	0,;//82-Base FETHAB
	0,;//83-Aliquota FETHAB
	0,;//84-Valor FETHAB
	0,;//85-Abatimento do Valor do INSS em Valor-Subcontratada
	{"","","","","","",0,0,0,0,0,0,0,"",0},;//86-SPED
	0,;//87-Abatimento da base de calculo do ISS referente ao material utilizado
	"",;//88-Indica se a operacao, mesmo sem calculo de ICMS ST, faz parte do Regime Especial de Substituicao Tributaria
	0,;//89-Percentual de UFERMS para o calculo do Fundersul-Mato Grosso do Sul
	0,;//90-Valor da UFERMS para o calculo do Fundersul-Mato Grosso do Sul
	0,;//91-Valor do Fundersul-Mato Grosso do Sul
	0,;//92-Valor do Estorno de Credito
	"",;//93-Codigo Autorizacao CODIF-Combustiveis
	0,;//94-Base do ICMS de transporte Substituicao Tributaria
	0,;//95-Aliquota do ICMS de transporte Substituicao Tributaria
	0,;//96-Valor do ICMS de transporte Substituicao Tributaria
	0,;//97-Valor do credito presumido simples nacional-SC
	0,;//98-Valor Antecipacao ICMS
	0,;//99-Valor das despesas nao tributadas-Portugal
	0,;//100-Valor da Tara-Portugal
	Iif(cPaisLoc == "ARG" .and. Type("lLocxAuto")<>"U" .And. lLocxAuto,"  " ,aNFCab[NF_PROVENT]),;//101-Provincia de entrega
	0,;//102-Valor do FECP
	0,;//103-Valor do FECP ST
	0,;//104-Aliquota FECP
	0,;//105-Valor Credito Presumido-SC
	0,;//106-Valor do desconto total proporcionalizado
	{{"",0,0,0}},;//107-Array para o calculo do IVA Ajustado
	{0,0},;//108-Array com os valores do Imposto de Importação
	0,;//109-Valor da Pauta do PIS
	0,;//110-Valor da Pauta do Cofins
	0,;//111-Aliquota de Diferencial Simples
	" ",;//112-Classificacao fiscal
	0,;//113-Valor do imposto ISC (Localizado Peru) por unidade"PER"
	0,;//114-Valor do credito presumido PE
	0,;//115-Valor Credito Presumido-MG
	0,;//116-Valor Dependente
	0,;//117-Credito Presumido CE
	0,;//118-Base FABOV-Mato Grosso
	0,;//119-Aliquota FABOV-Mato Grosso
	0,;//120-Valor FABOV-Mato Grosso
	0,;//121-Base FACS-Mato Grosso
	0,;//122-Aliquota FACS-Mato Grosso
	0,;//123-Valor FACS-Mato Grosso
	0,;//124-Valor do FUMACOP
	0,;//125-Aliquota FUMACOP
	Space(5),;//126-Concepto de Retencao(Equador)
	"",;//127-moticms
	0,;//128-Aliquota do Senar
	0,;//129-Valor do Senar
	0,;//130-Base do Senar
	0,;//131-Valor do Credito Outorgado SP
	0,;//132-Abatimento do valor do INSS Subcontratada
	0,;//133-Base de calculo ICMS sem reducao-Decreto 43.080/02-MG
	0,;//134-Valor ICMS sem reducao-Decreto 43.080/02-MG
	0,;//135-Percentual de reducao-Decreto 43.080/02-MG
	0,;//136-Base do FUNRURAL
	0,;//137-Base Veiculo
	{0,0,0},;//138-Valor da Base(01)/Valor(02)/Aliquota(03) do Regime de Operacoes Simplificadas-MT
	0 ,;//139-Valor da Base do FUMACOP
	0, ;//140-Crédito Presumido PR
	{"","","",CToD("")},;//141-Array contendo as informacoes da Natureza da receita.
	{0,0,0},;//142-Array contendo as informacoes da TPDP.
	0,;//143-Valor incentivo prod.leite RICMS/MG
	0,;//144-Percentual incentivo prod.leite RICMS/MG
	{0,0,0},;//145-Array com valores do INSS Condições Especiais
	0,;//146-Valor do FECOP-RN
	0,;//147-Valor do FECOP ST-RN
	0,;//148-Aliquota FECOP-RN
	0,;//149-Valor do FUE-localização Austrália
	"",;//150-Método utilizado cálculo FUE-localização Austrália
	"2",;//151-NF Emitida sob norma específica
	0,;//152-Coeficiente de PIS por Substituição Tributária para fabricantes de cigarros
	0,;//153-Coeficiente de COFINS por Substituição Tributária para fabricantes de cigarros
	0,;//154-Credito Presumido.
	0,;//155-Preco Unitario utilizado para calculo da Substituição tributária para fabrixante de Cigarros
	"2",;//156-Recolhimento Antecipado-Para atender necessidades do SPEDFISCAL de MG
	0,;//157-Valor do FECP-MG
	0,;//158-Valor do FECP ST-MG
	0,;//159-Aliquota FECP-MG
	0,;//160-Valor de Reintegra
	0,;//161-Base de Calculo do Reintegra
	0,;//162-Valor da COFINS de Importacao Majorada
	0,;//163-Aliquota da COFINS de Importacao Majorada
	0,;//164-Valor do FECP-MT
	0,;//165-Valor do FECP ST-MT
	0,;//166-Aliquota FECP-MT
	Iif(Len(aLoad)>=10,{aLoad[10],aLoad[11]},{"",""}),;//167-1- Lote Produto / 2- Sub-Lote Produto
	"2",;//168-DIAT-SC
	"2",;//169-Campo de diferimento na tabela SB1-Conteudo do parametro MV_ALQDFB1
	0,;//170-Indica o % calculo do ICMS-ST, se utiliza pauta ou margem.
	"",;//171-MaSBCampo("RSATIVO")
	"",;//172-MaSBCampo("POSIPI")
	"",;//173-MaSBCampo("UM")
	"",;//174-MaSBCampo("SEGUM")
	0,;//175-MaSBCampo("AFABOV")
	0,;//176-MaSBCampo("AFACS")
	0,;//177-MaSBCampo("AFETHAB")
	"",;//178-MaSBCampo("TFETHAB")
	{},;//179-Array com a exceção fiscal do cliente do faturamento
	0,;//180-Adiantamento
	"",;//181-Codigo da Natureza da Operacao
	Array(NMAXSB) ,;//182-Dados do cadastro de produtos SB1 ou SBi ou SBZ
	{"","",aNfCab[NF_IDSA1],aNfCab[NF_IDSA2],"","","",aNfCab[NF_IDSED],"","",""},;//183-Array ID's Historico
	0,;//184-DescTot-Desconto dado no Total, reteado por item-Uso do novo PDV-LOJA
	0,;//185-AcresciTot-Acrescimo dado no Total, reteado por item-Uso do novo PDV-LOJA
	0,;//186-Valor da PIS de Importacao Majorada
	0,;//187-Aliquota da PIS de Importacao Majorada
	Iif( Len(aLoad)>11 , aLoad[12] , "" ),;//188-Identificação do produto Fiscal- Demetrio
	Iif( Len(aLoad)>12 , aLoad[13] , 0 ),;//189-Recno do Produto Fiscal-Demetrio
	"" ,;//190-NCM Fiscal
	Array(NMAXUFP),;//191-Array com conteudo da tabela CFC
	0,;//192-Valor Cide
	"",;//193-Convênio 139/06
	0,;//194-VAlor do FETHAB retido pelo cliente
	0,;//195-Aliquota do FECP ST
	0,;//196-Aliquota do FECP Outros (Antecipacao/Diferencial de aliquotas)
	0,;//197-NF_BASNDE
	0,;//198 -NF_ICMNDES
	0,;//199-Adiantamento (PERU)
	0,;//200
	0,;//201-Identifica o preço para Consumidor Final
	0,;//202-Base de cálculo cide
	0,;//203-Aliquota Cide
	0,;//204-Base do ISS CEPOM
	0,;//205-Valor do ISS CEPOM
	0,;//206-Aliquota do ISS CEPOM
	0,;//207-Valor IPI a ser inserido na base do ICM, venda futura CF
	0,;//208-Base Fumipeq
	0,;//209-Valor Fumipeq
	0,;//210-Aliquota Fumipeq
	0,;//211-Base FAMAD
	0,;//212-Valor FAMAD
	0,;//213-Alíquota FAMAD
	Array(MAX_TS),;//214-Array com os dados da TES.
	.F.,;//215-Flag p/ indicar calculo de pauta de PIS
	.F.,;//216-Flag p/ indicar calculo de pauta de COFINS
	"",;//217-Enquadramento IPI
	"",;//218-CEST
	0,;//219-Base do CPRB
	0,;//220-Valor do CPRB
	0,;//221-Aliquota do CPRB
	0,;//222-Código atividade CPRB
	0,;//223-Difal
	0,;//224-Perc Difal destino
	0,;//225-Perc Difal origem
	0,;//226-Valor FECP Difal
	0,;//227-Fator de Redução Desc.ICMS
	0,;//228-Valor de Redução Desc.ICMS
	0,;//229-Base FUNDESA
	0,;//230-Aliquota FUNDESA
	0,;//231-Valor FUNDESA
	0,;//232-Base IMA-MT
	0,;//233-Aliquota IMA-MT
	0,;//234-Valor IMA-MT
	0,;//235-Aliquota IMA-MT (SB1)
	0,;//236-Valor IMA-MT retido clie/for
	0,;//237-Base FASE-MT
	0,;//238-Aliquota FASE-MT
	0,;//239-Valor FASE-MT
	0,;//240-Aliquota FASE-MT (SB1)
	0,;//241-Valor FASE-MT retido clie/for
	0,;//242-Preço Médio Ponderado, para ser utilizado como base de ICMS ST
	aNfCab[NF_INDICE],;//243-Indice tabela F0R
	0,;//244-Valor do Pedágio
	0,;//245-Valor Solidario XML
	0,;//246-Pauta CIDE
	" ",;//247-CSOSN
	0,;//248-Base do INSS Patronal
	0,;//249-Percentual do INSS Patronal
	0,;//250-Valor do INSS Patronal
	IIf(aPos[FP_B1_TRIBMUN], Space(TamSX3("B1_TRIBMUN")[1]), ""),;//251-Código de Trib. Municipal
	0,;//252-Valor do AFRMM na Importação
	0,;//253-Valor do Credito Presumido Paraná
	0,;//254 Valor do desconto-Decreto 43.080/2002 RICMS-MG
	0,;//255-Valor do ICMS da Operação-Sem diferimento (Valor como se não tivesse o diferimento)
	0,;//256-Base PROTEGE-GO
	0,;//257-Aliquota PROTEGE-GO
	0,;//258-Valor PROTEGE-GO
	0,;//259-Base FEEF-RJ
	0,;//260-Aliquota FEEF-RJ
	0,;//261-Valor FEEF-RJ
	"",;//262-Código de Atividade
	"",;//263-Coluna onde será escriturada a parcela diferida, na coluna Outros ou Isentod
	0,;//264-Base do FCP recolhido anteriormente.
	0,;//265-Aliquota do FCP recolhido anteriormente.
	0,;//266-Valor do FCP recolhido anteriormente.
	0,;//267-Aliquota ICMS ST Recolh. Ant.
	0,;//268-Base do FECP-Proprio.
	0,;//269-Base do FECP-ST.
	0,;//270-Base do FECP-Complementar.
	0,;//271-Indice auxiliar do FCP.
	0,;//272-Crédito do Prodepe PE
	"",;//273-Conta Contábil de Receita
	0,;//274-Valor do ICMS antes de ser submetido ao arredondamento
	{},;//275-Código declaratorio
	{},;//276-Tributos Genéricos	
	FWUUID("TRBGEN"),;//277-Id do tributo genérico, gerado automaticamente pela MATXFIS nas inclusões de notas
	cIdTribGen,; //278-Id do tributo genérico para visualização e exclusão
	IIf(Len(aLoad) >= 14, aLoad[14], IIf(aPos[FP_D1_OPER], Space(TamSX3("D1_OPER")[1]), "  ") ),;//279 - Tipo de operação.
	0,; // 280 - Valor IPI Origem para Orgãos Publicos
	0,; // 281 - Valor Base ICMS Efetivo
	0,; // 282 - ALQ ICMS Efetivo
	0}) // 283 - Valor ICMS Efetivo

	If Len(aNfitem) > 1 
		aNfitem[Len(aNfitem)][IT_ITEM] := Soma1(aNfitem[Len(aNfitem)-1][IT_ITEM])
	EndIf

	If !Empty( aNfItem[nItem][IT_PRODUTO] ) .And. ( aNfItem[nItem][IT_PRODUTO] <> aNfItem[nItem][IT_PRD][SB_COD] )
		MaFisIniCpo(nItem)
	ElseIf Empty( aNfItem[nItem][IT_PRODUTO] )
		MaFisIniCpo(nItem,.F.)
	EndIf

	If !Empty( aNfItem[nItem][IT_TES] ) .And. ( aNfItem[nItem][IT_TES] <> aNfItem[nItem][IT_TS][TS_CODIGO] )
		MaNewFisTES(aNfItem[nItem][IT_TES],,nItem)
	ElseIf Empty( aNfItem[nItem][IT_TES] )
		MaNewFisTES(,,nItem,.F.)
	EndIf

	// Inicializa arrays de impostos variaveis
	aNfItem[nItem][IT_BASEIMP]:=Afill(aNfItem[nItem][IT_BASEIMP],0)
	aNfItem[nItem][IT_ALIQIMP]:=Afill(aNfItem[nItem][IT_ALIQIMP],0)
	aNfItem[nItem][IT_VALIMP] :=Afill(aNfItem[nItem][IT_VALIMP],0)
	aNfItem[nItem][IT_DESCIV] :=Afill(aNfItem[nItem][IT_DESCIV],{"","",""})

	aadd(aItemDec,{Nil,Nil})
	aItemDec[Len(aItemDec)][1] := Array(Len(aItemRef))
	aItemDec[Len(aItemDec)][2] := Array(Len(aItemRef))
	aFill(aItemDec[Len(aItemDec)][1],0)
	aFill(aItemDec[Len(aItemDec)][2],0)

	// Carga do array aRefAlt - utilizado p/ controle das referências 
	// alteradas por MaFisAlt e MaFisLoad para que as alterações não
	// sejam desfeitas pelos recálculos.
	loadRefAlt(nItem)

	//----------------------------------------------------------------------------
	//Faz carga dos tributos genéricos se o ID do tributo genérico for preenchido.
	//----------------------------------------------------------------------------
	If !Empty(aNfItem[nItem][IT_ID_LOAD_TRBGEN]) .AND. aDic[AI_F2D]
		xFisLoadTG(@aNfItem, nItem)
	EndIF
Else
	If lEstorno
		MaFisSomaIt(nItem,.F.)
	Endif
EndIf

Return .T.

/*
MaFisAdd Edson Maricate 09.12.99
Inicializa o Calculo das operacoes Fiscais por item
*/
Function MaFisAdd(cProduto,;   	// 1-Codigo do Produto ( Obrigatorio )
cTes,;	   	// 2-Codigo do TES ( Opcional )
nQtd,;	   	// 3-Quantidade ( Obrigatorio )
nPrcUnit,;  // 4 -Preco Unitario ( Obrigatorio )
nDesconto,; // 5 -Valor do Desconto ( Opcional )
cNFOri,;	// 6 -Numero da NF Original ( Devolucao/Benef )
cSEROri,;	// 7 -Serie da NF Original ( Devolucao/Benef )
nRecOri,;	// 8 -RecNo da NF Original no arq SD1/SD2
nFrete,;	// 9 -Valor do Frete do Item ( Opcional )
nDespesa,;	// 10-Valor da Despesa do item ( Opcional )
nSeguro,;	// 11-Valor do Seguro do item ( Opcional )
nFretAut,;	// 12-Valor do Frete Autonomo ( Opcional )
nValMerc,;	// 13-Valor da Mercadoria ( Obrigatorio )
nValEmb,;	// 14-Valor da Embalagem ( Opiconal )
nRecSB1,;	// 15-RecNo do SB1
nRecSF4,;	// 16-RecNo do SF4
cNItem,;    // 17-Item
nDesNTrb,;  // 18-Despesas nao tributadas - Portugal
nTara,;		// 19-Tara - Portugal
cCfo,; 		// 20-CFO
aNfOri,;    // 21-Array para o calculo do IVA Ajustado (opcional)
cConcept,;	// 22-Concepto
nBaseVeic,;	// 23-Base Veiculo
nPLote,; 	// 24-Lote Produto
nPSubLot,;	// 25-Sub-Lote Produto
nAbatIss,;	// 26-Valor do Abatimento ISS
cCodISS,; 	// 27-Codigo ISS
cClasFis,;	// 28-Classificação Fiscal
cProdFis,;	// 29-Cod. do Produto Fiscal
nRecPrdF,;	// 30-Recno do Produto Fiscal
cNcmFiscal,;// 31-NCM do produto Fiscal
cIdTribGen,;// 32-Id dos tributos genéricos para visualização/exclusão
cTpOper)    // 33-Tipo de Operação (opcional)

Local aArea	:= GetArea()
Local nItem := 0
DEFAULT nRecSB1  := 0
DEFAULT nRecSF4  := 0
DEFAULT cNItem	 := ""
DEFAULT cCfo	 := ""
DEFAULT nDesNTrb := 0
DEFAULT nTara	 := 0
DEFAULT aNfOri	 := {}
DEFAULT cConcept := Space(5)
DEFAULT nBaseVeic:= 0
DEFAULT nAbatIss := 0
DEFAULT cCodISS	 := ""
DEFAULT cClasFis := ""
DEFAULT cProdFis := Space(Len(cProduto))
DEFAULT nRecPrdF := 0
DEFAULT cNcmFiscal := ""
Default cIdTribGen	:= ""
DEFAULT cTpOper  := IIf(aPos[FP_D1_OPER], Space(TamSX3("D1_OPER")[1]), "  ")

If cPaisLoc == "BRA"
	MaFisTes(@cTes,nRecSF4)
Endif

aadd(aNfItem,{"",; //1 - Grupo de Tributacao
{},;//2 - Array contendo as excessoes Fiscais
0,;//3 - Aliquota de ICMS
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},;//4-Valores de ICMS
0,;//5 - Aliquota de IPI
{0,0,0,0,0},;//6 - Valores de IPI
cNFOri,;//7 - Numero da NF Original
cSEROri,;//8 - Serie da NF Original
nRecOri,;//9 - RecNo da NF original
nDesconto,;//10 - Valor do desconto do item
nFrete,;//11 - Valor do Frete
nDespesa,;//12 - Valor da despesa
nSeguro,;//13 - Valor do seguro
nFretAut,;//14 - Valor do frete autonomo
nValMerc,;//15 - Valor da Mercadoria
cProduto,;//16 - Codigo do produto
cTes,;//17 - Codigo da TES
0,;//18 - Valor Total do item
cCfo,;//19 - Codigo FIscal de Operacao
0,;//20 - Valor do Funrural
0,;//21 - Aliquota para calculo do FunRural
.F.,;//22 - Flag de controle para itens deletados
MaFisRetLF(),;//23 - Array Contendo o demonstrativo fiscal
{0,0,0,cCodISS,"","","",0,0,0,.F.},; //24 - Array contendo os valores de ISS
{0,0,0,0},;//25 - Array contendo os valores de IR
{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},;//26 - Array contendo os valores de INSS
0,;//27 - Valor da Embalagem
Array(NMAXIV),;//28
Array(NMAXIV),;//29
Array(NMAXIV),;//30
0,;//31
0,;//32
Array(NMAXIV),;//33
nQtd,;//34
nPrcUnit,;//35
0,;//36
0,;//37
0,;//38
0,;//39
0,;//40
0,;//41
0,;//42
0,;//43
0,;//44
0,;//45
0,;//46
0,;//47
0,;//48
nRecSB1,;//49
nRecSF4,;//50
0,;//51
aNfCab[NF_TIPONF],;//52
"",;//53
0,;//54
0,;//55
0,;//56
0,;//57
0,;//58
0,;//59
0,;//60
nAbatIss,;//61
0,;//62
0,;//63
0,;//64
0,;//65
0,;//66 - Base AFRMM - Item
0,;//67 - Aliquota AFRMM - Item
0,;//68 - Valor AFRMM - Item
0,;//69
0,;//70
0,;//71
"",;//72
Iif (aNfCab[NF_OPERNF]=='S', "01", "0001"),;//73
{0,0,0},;//74 - Array dos valores do SEST
0,;//75 - Base de calculo do PIS Subst. Tributaria
0,;//76 - Aliquota do PIS Subst. Tributaria
0,;//77 - Valor do PIS Subst. Tributaria
0,;//78 - Bae da COFINS Subst. Tributaria
0,;//79 - Aliquota da COFINS Subst. Tributaria
0,;//80 - Valor da COFINS Subst. Tributaria
0,;//81 - Valor do Frete de Pauta
0,;//82 - Base FETHAB
0,;//83 - Aliquota FETHAB
0,;//84 - Valor FETHAB
0,;//85 - Abatimento do Valor do INSS em Valor - Subcontratada
{"","","","","","",0,0,0,0,0,0,0,"",0},;
0,;//87 - Abatimento do Valor do ISS referente ao material utilizado})
"",;//88 - Indica se a operacao, mesmo sem calculo de ICMS ST, faz parte do Regime Especial de Substituicao Tributaria
0,;//89 - Percentual de UFERMS para o calculo do Fundersul - Mato Grosso do Sul
0,;//90 - Valor da UFERMS para o calculo do Fundersul - Mato Grosso do Sul
0,;//91 - Valor do Fundersul - Mato Grosso do Sul
0,;//92 - Valor do Estorno de Credito
"",;//93 - Codigo Autorizacao CODIF - Combustiveis
0,;//94 - Base do ICMS de transporte Substituicao Tributaria
0,;//95 - Aliquota do ICMS de transporte Substituicao Tributaria
0,;//96 - Valor do ICMS de transporte Substituicao Tributaria
0,;//97 - Valor do credito presumido simples nacional - SC
0,;//98 - Valor Antecipacao ICMS
nDesNTrb,;//99 - Valor das despesas nao tributadas - Portugal
nTara,;//100 - Valor da Tara - Portugal
aNFCab[NF_PROVENT],;//101 - Provincia de entrega
0,;//102 - Valor do FECP
0,;//103 - Valor do FECP ST
0,;//104 - Aliquota FECP
0,;//105 - Valor Crédito Presumido SC
0,;//106 - Valor do desconto total proporcionalizado
{{"",0,0,0}},;//107 - Array para o calculo do IVA Ajustado
{0,0},;//108 - Array com os valores do Imposto de Importação
0,;//109 - Valor da Pauta do PIS
0,;//110 - Valor da Pauta do Cofins
0,;//111 -  Valor da Aliquota Dif para simples
cClasFis,;//112 - IT_CLASFIS
0,;//113 - Valor do imposto ISC (Localizado Peru) por unidade "PER"
0,;//114 - IT_CRPREPE Credito Presumido - Art. 6 Decreto  n28.247
0,;//115 - Valor Crédito Presumido MG
0,;//116 - Valor de desconto de dependente do fornecedor
0,;//117 - Credito Presumido Ceara
0,;//118 - Base FABOV - Mato Grosso
0,;//119 - Aliq FABOV - Mato Grosso
0,;//120 - Valor FABOV - Mato Grosso
0,;//121 - Base FACS - Mato Grosso
0,;//122 - Aliq FACS - Mato Grosso
0,;//123 - Valor FACS - Mato Grosso
0,;//124 - Valor FUMACOP
0,;//125 - Aliq FUMACOP
cConcept,;//126 - Concepto Retencao(Equador)
"",;//127 moticms
0,;//128 - Aliquota Senar
0,;//129 - Valor Senar
0,;//130 - Base Senar
0,;//131 - Credito Outorgado SP
0,;//132- Abatimento do valor do INSS Subcontratada
0,;//133- Base de calculo ICMS sem reducao - Decreto 43.080/02-MG
0,;//134- Valor do ICMS sem reducao - Decreto 43.080/02-MG
0,;//135- Percentual de Reducao Decreto 43.080/02-MG
0,;//136 - Base do FUNRURAL
nBaseVeic,;//137 - Base Veiculo
{0,0,0},;//138 - Valor da Base(01)/Valor(02)/Aliquota(03) do Regime de Operacoes Simplificadas - MT
0,;//139 - Valor da Base do FUMACOP
0,;//140 - Valor do Créd Presumido do Paraná
{"","","",CToD("")},;//141 - Array Dados Natureza da opercao
{0,0,0},;//142 - Array da TPDP.
0,;//143 - Valor incentivo prod.leite RICMS/MG
0,;//144 - Percentual incentivo prod.leite RICMS/MG
{0,0,0},;//145 - Array com valores do INSS Condições Especiais
0,;//146 - Valor do FECOP-RN
0,;//147 - Valor do FECOP ST-RN
0,;//148 - Aliquota FECOP-RN
0,;//149 - Valor do FUE - localização Austrália
"",;//150 - Método utilizado cálculo FUE - localização Austrália
"2",;//151 - NF Emitida sob norma específica
0,;//152 - Coeficiente de PIS por Substituição Tributária para fabricantes de cigarros
0,;//153 - Coeficiente de COFINS por Substituição Tributária para fabricantes de cigarros
0,;//154 - Credito Presumido
0,;//155 - Preco Unitario utilizado para calculo da Substituição tributária para fabrixante de Cigarros
"2",;//156 - Recolhimento Antecipado - Para atender necessidades do SPEDFISCAL de MG
0,;//157 - Valor do FECP-MG
0,;//158 - Valor do FECP ST-MG
0,;//159 - Aliquota FECP-MG
0,;//160 - Valor do Reintegra
0,;//161 - Base de Calculo do Reintegra
0,;//162 - Valor da COFINS de Importacao Majorada
0,;//163 - Aliquota da COFINS de Importacao Majorada
0,;//164 - Valor do FECP-MT
0,;//165 - Valor do FECP ST-MT
0,;//166 - Aliquota FECP-MT
{nPLote,nPSubLot},;//167 - 1- Lote Produto / 2- SubLoteProduto
"2",;//168 - DIAT - SC
"2",;//169 - Campo de diferimento na tabela SB1 - Conteudo do parametro MV_ALQDFB1
0,;//170 - Indica o % calculo do ICMS-ST, se utiliza pauta ou margem.
"",;//171 - MaSBCampo("RSATIVO")
"",;//172 - MaSBCampo("POSIPI")
"",;//173 - MaSBCampo("UM")
"",;//174 - MaSBCampo("SEGUM")
0,;//175 - MaSBCampo("AFABOV")
0,;//176 - MaSBCampo("AFACS")
0,;//177 - MaSBCampo("AFETHAB")
"",;//178 - MaSBCampo("TFETHAB")
{},;//179 - Array com a exceção fiscal do cliente do faturamento
0,;//180 - Adiantamento
"",;//181 - Codigo da Natureza da Operacao
Array(NMAXSB) ,;//182 - Dados do cadastro de produtos SB1 ou SBi ou SBZ
{"","",aNfCab[NF_IDSA1],aNfCab[NF_IDSA2],"","","",aNfCab[NF_IDSED],"","",""},; // 183 - Array ID's Historicos
0,;//184 - DescTot - Desconto dado no Total, reteado por item - Uso do novo PDV - LOJA
0,;//185 - AcresciTot - Acrescimo dado no Total, reteado por item - Uso do novo PDV - LOJA
0,;//186 - Valor da PIS de Importacao Majorada
0,;//187 - Aliquota da PIS de Importacao Majorada
cProdFis,;//188 - Identificação do produto Fiscal  - Demetrio
nRecPrdF,;//189 - Recno do Produto Fiscal - Demetrio
cNcmFiscal,;//190 - NCM Fiscal
Array(NMAXUFP),;// 191 - Array com conteudo da tabela CFC
0,;//192 - Valor Cide
"",;//193 - Convênio 139/06
0,;//194 - VAlor do FETHAB retido pelo cliente
0,;//195 - Aliquota do FECP ST
0,;//196 - Aliquota do FECP Outros (Antecipacao/Diferencial de aliquotas)
0,;//197 - NF_BASNDE
0,;//198 - NF_ICMNDES
0,;//199 - Adiantamento
0,;//200
0,;//201 - Identifica o preço para Consumidor Final
0,;//202 - Base de cálculo cide
0,;//203 - Aliquota Cide
0,;//204 - Base do ISS CEPOM
0,;//205 - Valor do ISS CEPOM
0,;//206 - Aliquota do ISS CEPOM
0,;//207 - Valor IPI a ser inserido na base do ICM, venda futura CF
0,;//208 - Base Fumipeq
0,;//209 - Valor Fumipeq
0,;//210 - Valor Fumipeq
0,;//211 - Base FAMAD
0,;//212 - Valor FAMAD
0,;//213 - Alíquota FAMAD
Array(MAX_TS),;//214 - Array com os dados da TES.
.F.,;//215 - Flag p/ Indicar calculo com pauta de PIS
.F.,;//216 - Flag p/ indicar calculo com pauta de COFINS
"",;//217 - Enquadramento IPI
"",;//218 - CEST
0,;//219 - Base do CPRB
0,;//220 - Valor do CPRB
0,;//221 - Aliquota do CPRB
0,;//222 - Código atividade CPRB
0,;//223 - Difal
0,;//224 - Perc Difal destino
0,;//225 - Perc Difal origem
0,;//226 - Valor FECP Difal
0,;//227 - Fator de Redução Desc.ICMS
0,;//228 - Valor de Redução Desc.ICMS
0,;//229 - Base FUNDESA
0,;//230 - Aliquota FUNDESA
0,;//231 - Valor FUNDESA
0,;//232 - Base IMA-MT
0,;//233 - Aliquota IMA-MT
0,;//234 - Valor IMA-MT
0,;//235 - Aliquota IMA-MT (SB1)
0,;//236 - Valor IMA-MT retido clie/for
0,;//237 - Base FASE-MT
0,;//238 - Aliquota FASE-MT
0,;//239 - Valor FASE-MT
0,;//240 - Aliquota FASE-MT (SB1)
0,;//241 - Valor FASE-MT retido clie/for
0,;	//242 - Preço Médio Ponderado, para ser utilizado como base de ICMS ST
aNfCab[NF_INDICE],; // 243 - Indice tabela F0R
0,;//244 - Valor do Pedágio
0,;//245 - Valor Solidario XML
0,;//246 - Pauta CIDE
"   ",;//247 - CSOSN
0,;//248 - Base do INSS Patronal
0,;//249 - Percentual do INSS Patronal
0,;//250 - Valor do INSS Patronal
IIf(aPos[FP_B1_TRIBMUN], Space(TamSX3("B1_TRIBMUN")[1]), ""),; //251 - Código de Trib. Municipal
0,;//252 - Valor do AFRMM na Importação
0,;//253 - Valor do Credito Presumido Paraná
0,;//254 - Valor do desconto - Decreto 43.080/2002 RICMS-MG
0,;//255 - Valor do ICMS da Operação - Sem diferimento (Valor como se não tivesse o diferimento)
0,;//256 - Base PROTEGE-GO
0,;//257 - Aliquota PROTEGE-GO
0,;//258 - Valor PROTEGE-GO
0,;//259 - Base FEEF-RJ
0,;//260 - Aliquota FEEF-RJ
0,;//261 - Valor FEEF-RJ
"",;//262 - Código de Atividade
"",;//263 - Coluna onde será escriturada a parcela diferida, na coluna Outros ou Isentod
0,;//264 - Base do FCP recolhido anteriormente.
0,;//265 - Aliquota do FCP recolhido anteriormente.
0,;//266 - Valor do FCP recolhido anteriormente.
0,;//267 - Aliquota ICMS ST Recolh. Ant.
0,;//268 - Base do FCP - Proprio.
0,;//269 - Base do FCP - ST.
0,;//270 - Base do FCP - Complementar.
0,;//271 - Indice auxiliar do FCP.
0,;//272 - Crédito Prodepe
"",;//273- Conta Contábil de Receita
0,;//274-Valor do ICMS antes de ser submetido ao arredondamento
{},;//275-Código declaratorio
{},; //276-Tributos Genéricos
FWUUID("TRBGEN"),;//277-Id do tributo genérico, gerado automaticamente pela MATXFIS nas inclusões de notas
cIdTribGen,; //278-Id do tributo genérico para visualização e exclusão
cTpOper,; //279 - Tipo de operação
0,; // 280 - Valor IPI Origem para Orgãos Publicos
0,; // 281 - Valor Base ICMS Efetivo
0,; // 282 - ALQ ICMS Efetivo
0}) // 283 - Valor ICMS Efetivo

If Empty(cNItem)
	If Len(aNfitem) > 1
		aNfitem[Len(aNfitem)][IT_ITEM] := Soma1(aNfitem[Len(aNfitem)-1][IT_ITEM])
	EndIf
Else
	aNfitem[Len(aNfitem)][IT_ITEM] := cNItem
EndIf

aadd(aItemDec,{Nil,Nil})
aItemDec[Len(aItemDec)][1] := Array(Len(aItemRef))
aItemDec[Len(aItemDec)][2] := Array(Len(aItemRef))
aFill(aItemDec[Len(aItemDec)][1],0)
aFill(aItemDec[Len(aItemDec)][2],0)

nItem := Len(aNfItem)

If !Empty( aNfItem[nItem][IT_PRODUTO] ) .And. ( aNfItem[nItem][IT_PRODUTO] <> aNfItem[nItem][IT_PRD][SB_COD] )
	MaFisIniCpo(nItem)
ElseIf Empty( aNfItem[nItem][IT_PRODUTO] )
	MaFisIniCpo( nItem , .F. )
EndIf

If !Empty( aNfItem[nItem][IT_TES] ) .And.  (aNfItem[nItem][IT_TES] <> aNfItem[nItem][IT_TS][TS_CODIGO])
	MaNewFisTES(@cTes, nRecSF4, nItem)
ElseIf Empty( aNfItem[nItem][IT_TES] )
	MaNewFisTES(@cTes, nRecSF4, nItem, .F.)
EndIf

// Inicializa arrays de impostos variaveis
aNfItem[nItem][IT_BASEIMP]:=Afill(aNfItem[nItem][IT_BASEIMP],0)
aNfItem[nItem][IT_ALIQIMP]:=Afill(aNfItem[nItem][IT_ALIQIMP],0)
aNfItem[nItem][IT_VALIMP] :=Afill(aNfItem[nItem][IT_VALIMP],0)
aNfItem[nItem][IT_DESCIV] :=Afill(aNfItem[nItem][IT_DESCIV],{"","",""})

// Carga do array aRefAlt - utilizado p/ controle das referências 
// alteradas por MaFisAlt e MaFisLoad para que as alterações não
// sejam desfeitas pelos recálculos.
loadRefAlt(nItem)

MaFisRecal("",nItem)
//----------------------------------------------------------------------------
//Faz carga dos tributos genéricos se o ID do tributo genérico for preenchido.
//----------------------------------------------------------------------------
If !Empty(aNfItem[nItem][IT_ID_LOAD_TRBGEN]) .AND. aDic[AI_F2D]
	xFisLoadTG(aNfItem, @nItem)
EndIF
MaIt2Cab()

RestArea(aArea)

Return(nItem)

/*MaFisLoad Edson Maricate 09.12.99
Carrega os valores de impostos de bases e item.
*/
Function MaFisLoad(cCampo,nValor,nItem,aTrbGen)

Local cPosCpo  := MaFisScan(cCampo)
Local nPosGen  := 0
DEFAULT aTrbGen := {"",""}

If nValor <> Nil
	// Altera o valor do campo no Array aNfCab ou aNfItem
	If Substr(cCampo,1,2) == "IT"
		//Tratamento para o tributo genérico
		If AllTrim(cCampo) == "IT_TRIBGEN" .And. Len(aTrbGen) >= 2 .And. !Empty(aTrbGen[TG_SIGLA]) .And. !Empty(aTrbGen[TG_REFERENCIA])
			cPosCpo := MaFisScan(aTrbGen[TG_REFERENCIA])
			If (nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| Alltrim(x[TG_IT_SIGLA]) == Alltrim(aTrbGen[TG_SIGLA])})) > 0
				//Se o tributo genérico existir e for referência válida,  então atribuimos o valor a ele.
				aNfItem[nItem][IT_TRIBGEN][nPosGen][cPosCpo] := nValor
			EndIf
		// Tratamento para os itens.
		ElseIf ValType(cPosCpo) == "A"
			aNfItem[nItem][cPosCpo[1]][cPosCpo[2]] := nValor
			aRefAlt[nItem][cPosCpo[1]][cPosCpo[2]] := .T.
		Else
			aNfItem[nItem][Val(cPosCpo)] := nValor
			aRefAlt[nItem][Val(cPosCpo)] := .T.
		EndIf
		If AllTrim(cCampo) == "IT_PRODUTO" .And. !Empty( aNfItem[nItem][IT_PRODUTO] ) .And. ( aNfItem[nItem][IT_PRODUTO] <> aNfItem[nItem][IT_PRD][SB_COD] )
			MaFisIniCpo(nItem)
		EndIf
		If AllTrim(cCampo) == "IT_TES" .And. !Empty( aNfItem[nItem][IT_TES] ) .And. ( aNfItem[nItem][IT_TES] <> aNfItem[nItem][IT_TS][TS_CODIGO] )
			MaNewFisTES(aNfItem[nItem][IT_TES],,nItem)
		EndIf
	ElseIf Substr(cCampo,1,2) == "LF"
		// Tratamento para os itens do livro.
		If ValType(cPosCpo) == "A"
			aNfItem[nItem][IT_LIVRO][cPosCpo[1]][cPosCpo[2]] := nValor
		ElseIf ValType(cPosCpo) == "C"
			aNfItem[nItem][IT_LIVRO][Val(cPosCpo)] := nValor
		ElseIf ValType(cPosCpo) == "N"
			aNfItem[nItem][IT_LIVRO][cPosCpo] := nValor
		EndIf
	Else
		// Tratamento para o cabecalho.
		If AllTrim(cCampo) == "NF_TRIBGEN" .And. Len(aTrbGen) >= 2  .And. !Empty(aTrbGen[TG_SIGLA]) .And. !Empty(aTrbGen[TG_REFERENCIA])
			cPosCpo := MaFisScan(aTrbGen[TG_REFERENCIA])
			If (nPosGen := aScan(aNFCab[NF_TRIBGEN], {|x| AllTrim(x[TG_NF_SIGLA]) == AllTrim(aTrbGen[TG_SIGLA])})) > 0
				aNfcab[NF_TRIBGEN][nPosGen][cPosCpo] := nValor
			EndIf
		ElseIf ValType(cPosCpo) == "A"
			aNfCab[cPosCpo[1]][cPosCpo[2]] := nValor
		Else
			aNfCab[Val(cPosCpo)] := nValor
		EndIf
	EndIf
EndIf


Return .T.

/*MaFisEndLoad Edson Maricate 09.12.99
Finaliza a carga dos itens Fiscais
Parametros
ExpN1 : Item
ExpN2 : Tipo de atualizacao do Item :
1-(default) Executa o recalculo de todos os itens para efetuar a atualizacao do cabecalho
2-Executa a soma do item para atualizacao do cabecalho
3-Nao executa a atualizacao do cabecalho.
*/
Function MaFisEndLoad(nItem,nTipo,lExec)

Local aArea   := GetArea()
DEFAULT nTipo := 1
DEFAULT lExec := .T.

MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
MaFisNameIV(,nItem)
MaFisVTot(nItem)
If lExec
	MaItArred(nItem)
EndIf
MaFisLF(nItem)

Do Case
	Case nTipo == 1
		If lExec
			MaIt2cab()
		EndIf
	Case nTipo == 2
		MaFisSomaIt(nItem)
EndCase

If bFisRefresh <> Nil
	Eval(bFisRefresh)
EndIf

If bLivroRefresh <> Nil
	Eval(bLivroRefresh)
EndIf

RestArea(aArea)

Return .T.

/*MaFisRet Edson Maricate 08.12.99
Retorna os impostos calculados pela MATXFIS.
Retorno   ExpN1: Valor do imposto.
*/
Function MaFisRet(nItem,cCampo,aTrbGen)

Local nRetorno
Local cPosCpo := MaFisScan(cCampo)
Local cSigTrGen := ""
Local cPosRefTG := ""
Local cRefTrGen := ""
Local nPosGen := ""

DEFAULT aTrbGen := {"",""}

Do Case
Case Substr(cCampo,1,2) == "IT"

	If cCampo == "IT_TRIBGEN"

		cSigTrGen := IIf(Len(aTrbGen) >= 1, aTrbGen[TG_SIGLA], "")
		cRefTrGen := IIf(Len(aTrbGen) >= 2, aTrbGen[TG_REFERENCIA], "")

		If !Empty(cRefTrGen)
			cPosRefTG := MaFisScan(cRefTrGen)
		EndIf

		// Se não passou o tributo e a ref. específica retorno a lista completa de tributos
		If Empty(cSigTrGen) .And. Empty(cRefTrGen)
			If nItem == Nil
				nRetorno := aClone(aNfItem[1][Val(cPosCpo)])
			Else
				nRetorno := aClone(aNfItem[nItem][Val(cPosCpo)])
			EndIf
		// Se passou somente a sigla do tributo retorno todas as informações daquele tributo
		ElseIf !Empty(cSigTrGen) .And. Empty(cRefTrGen)
			If (nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_SIGLA]) == AllTrim(cSigTrGen)})) > 0
				nRetorno := aClone(aNFItem[nItem][IT_TRIBGEN][nPosGen])
			Else
				nRetorno := {}
			EndIf
		// Se passou a sigla e a referência desejada retorno somente a referencia
		ElseIf !Empty(cSigTrGen) .And. !Empty(cRefTrGen)
			If (nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_SIGLA]) == AllTrim(cSigTrGen)})) > 0
				nRetorno := aNFItem[nItem][IT_TRIBGEN][nPosGen][cPosRefTG]
			Else
				nRetorno := 0
			EndIf
		EndIf

	Else
		If ValType(cPosCpo) == "A"
			nRetorno := aNfItem[nItem][cPosCpo[1]][cPosCpo[2]]
		Else
			If nItem == Nil
				nRetorno := aNfItem[1][Val(cPosCpo)]
			Else
				nRetorno := aNfItem[nItem][Val(cPosCpo)]
			EndIf
		EndIf
	EndIf
Case Substr(cCampo,1,2) == "LF"
	If nItem == Nil
		nRetorno := aNfItem[nItem][NF_LIVRO][cPosCpo]
	Else
		nRetorno := aNfItem[nItem][IT_LIVRO][cPosCpo]
	EndIf
OtherWise

	If cCampo == "NF_TRIBGEN"

		cSigTrGen := IIf(Len(aTrbGen) >= 1, aTrbGen[TG_SIGLA], "")
		cRefTrGen := IIf(Len(aTrbGen) >= 2, aTrbGen[TG_REFERENCIA], "")

		If !Empty(cRefTrGen)
			cPosRefTG := MaFisScan(cRefTrGen)
		EndIf

		// Se não passou o tributo e a ref. específica retorno a lista completa de tributos
		If Empty(cSigTrGen) .And. Empty(cRefTrGen)
			nRetorno := aClone(aNfCab[Val(cPosCpo)])
		// Se passou somente a sigla do tributo retorno todas as informações daquele tributo
		ElseIf !Empty(cSigTrGen) .And. Empty(cRefTrGen)
			If (nPosGen := aScan(aNFCab[NF_TRIBGEN], {|x| AllTrim(x[TG_NF_SIGLA]) == AllTrim(cSigTrGen)})) > 0
				nRetorno := aClone(aNFCab[NF_TRIBGEN][nPosGen])
			Else
				nRetorno := {}
			EndIf
		// Se passou a sigla e a referência desejada retorno somente a referencia
		ElseIf !Empty(cSigTrGen) .And. !Empty(cRefTrGen)
			If (nPosGen := aScan(aNFCab[NF_TRIBGEN], {|x| AllTrim(x[TG_NF_SIGLA]) == AllTrim(cSigTrGen)})) > 0
				nRetorno := aNFCab[NF_TRIBGEN][nPosGen][cPosRefTG]
			Else
				nRetorno := 0
			EndIf
		EndIf

	Else
		If ValType(cPosCpo) == "A"
			nRetorno := aNfCab[cPosCpo[1]][cPosCpo[2]]
		Else
			nRetorno := aNfCab[Val(cPosCpo)]
		EndIf
	EndIf

EndCase

Return nRetorno

/* MaColsToFi -Edson Maricate  -01.02.1999
Rotina carregamento da funcao fiscal com base no acols e aheader
ParametrosExpA1: Variavel com a estrutura do aHeader
          ExpA2: Variavel com a estrutura do aCols
          ExpN3: Item a ser carregado (OPC)
          ExpC4: Nome do (OPC)
          ExpL5: Indica se o recalculo dos impostos deve ser feito(OPC)
          ExpL6: Indica se o recalculo dos impostos deve ser feito(OPC)
          ExpL7: Indica se o recalculo vai considerar as linhs apagadas
Descrio Esta rotina tem como objetivo inicializar a variavel aNFItem
          com base no aCols
*/
Function MaColsToFis(aHeader,aCols,nItem,cProg,lRecalc,lVisual,lDel,lSoItem)

Local nItemIni := IIf( nItem == Nil, 1 , nItem )
Local nItemAte := IIf( nItem == Nil, Len(aCols) , nItem )
Local nX       := 0
Local nY       := 0
Local cValid   := ""
DEFAULT lRecalc := .F.
DEFAULT lVisual	:= .F.
DEFAULT lDel    := .F.	//Indica que a linha deletada do acols nao sera considerada
DEFAULT lSoItem	:= .F.
If cPaisLoc == "ARG"
	nItemIni := IIf( nItemIni == 0 , 1 , nItemIni )
	nItemAte := IIf( nItemAte == 0 , Len(aCols), nItemAte )
EndIf

If nItem == Nil
	MaFisClear()
EndIf

For nY := nItemIni To nItemAte
	MaFisIniLoad(nY,,.T.)
	For nX	:= 1 To Len(aHeader)
		cValid	 := AllTrim(UPPER(aHeader[nX][6]))
		cRefCols := MaFisGetRf(cValid)[1]
		If !Empty(cRefCols) .And. MaFisFound("IT",nY)
			MaFisLoad(cRefCols,aCols[nY][nX],nY)
		EndIf
	Next nX
	If lRecalc //  .and. Iif(cPaisLoc == "ARG", Type("lLocxAuto") <> "U" .and. lLocxAuto,.T.)
		MaFisRecal("IT_",nY)
		For nX	:= 1 To Len(aHeader)
			cValid	 := AllTrim(UPPER(aHeader[nX][6]))
			cRefCols := MaFisGetRf(cValid)[1]
			If !Empty(cRefCols) .And. MaFisFound("IT",nY)
				aCols[nY][nX]:= MaFisRet(nY,cRefCols)
			EndIf
		Next nX
	EndIf
	MaFisEndLoad(nY,Iif(lVisual,3,If(lSoItem,2,Nil)))
	//Se a execucao da rotina considerar os itens deletados, executa a MAFISDEL
	If lDel .And. aCols[nY][Len(aHeader)+1]
		MaFisDel(nY,.T.)
	Endif
Next nY

Return .T.

/*MaFisToCols - Edson Maricate- 01.02.99
Atualiza os valores do aCols com os valores da Funcao Fiscal
*/
Function MaFisToCols(aHeader,aCols,nItem,cProg)

Local nItemIni := IIf( nItem == Nil , 1 , nItem )
Local nItemAte := IIf( nItem == Nil, Len(aCols) ,nItem )
Local nX       := 0
Local nY       := 0

For nY := nItemIni to nItemAte
	For nX := 1 to Len(aHeader)
		cValid	:= AllTrim(UPPER(aHeader[nX][6]))
		cRefCols:= MaFisGetRF(cValid)[1]
		If !Empty(cRefCols) .And. MaFisFound("IT",nY)
			aCols[nY][nX]:= MaFisRet(nY,cRefCols)
		EndIf
	Next nX
Next nY

Return .T.

/*MaFisSXRef - Eduardo Riera  -08.08.2001
Rotina de avalicao das referencias existentes para um determinada tabela no dicionario de dados
Esta rotina tem como objetivo verificar e retornar as referencias da funcao fiscal com base no dicionario de dados, para recuperar os valores da funcao fiscal
ParametrosExpC1: Tabela do Dicionario de dados
Retorno   ExpA1: Array com as referencias da funcao fiscal
*/
Function MaFisSXRef(cAlias)

Local aArea    := GetArea()
Local aRefer   := {}
Local nX       := 0
DEFAULT aRefSX3 := {}

If aScan(aRefSx3,{|x| x[1] == cAlias}) == 0 // Verifica se o alias solicitado esta no cache de memoria e adiciona as referencia ao cache de memoria
	MaFisRelImp("",{cAlias})
EndIf

For nX := 1 To Len(aRefSX3) // Obtem os dados do cache
	If aRefSX3[nX][1] == cAlias
		aadd(aRefer,{aRefSX3[nX][2],aRefSX3[nX][3]})
	EndIf
Next nX

RestArea(aArea)

Return(aRefer)

/*/
MaFisDel - Edson Maricate -21.12.1999
Marca/Desmarca o item especificado como deletado.
Parametros
ExpN1	: Numero do Item.
ExpL2 : .T. - Deleta o item , .F. - Ativa o item
/*/
Function MaFisDel(nItem,lDelete)

Local nI := 0
Local lCDAIndic	  := aDic[AI_CDA]

If MaFisFound("IT",nItem)
	If lDelete
		If !aNfItem[nItem][IT_DELETED]
			aNfItem[nItem][IT_DELETED]	:= .T.
			If cPaisLoc <> "BRA"
				MaFisRecal(,nItem)
			EndIf
		Endif
	Else
		If aNfItem[nItem][IT_DELETED]
			aNfItem[nItem][IT_DELETED]	:= .F.
			If cPaisLoc <> "BRA"
				MaFisRecal("IT_VALMERC",nItem)
			Endif
		EndIf
	EndIf

	If cPaisLoc == "BRA" .And. ( lLimInss .Or. aSX6[MV_ISSPRG] == "S" )
		For nI := 1 to Len(aNfItem)
			If lLimInss
				MaFisINSS(nI,"VLR")
			Endif
			If aSX6[MV_ISSPRG] == "S"
				MaFisISS(nI)
				MaFisLF(nI)
			EndIf
		Next nI
	EndIf

	MaIt2Cab()

	If cPaisLoc == "BRA" .And. lCDAIndic .And. Type("oLancApICMS") == "O"
		a103AjuICM(nItem)
	EndIf
EndIf

Return

/*/MaFisRef- Edson Maricate - 10.12.99
Executa o calculo dos valores do item da NF.
Parametros
ExpC1 = Referencia
ExpC2 = Identificador do arquivo
ExpC1 = Valor da Referencia
/*/
Function MaFisRef(cReferencia,cProg,xValor)

Local aArea	   := GetArea()
Local lRet 	   := .T.
Local nX       := 0
Local nY       := 0
Local cValid   := ""
Local cRefCols := ""

If MaFisFound("NF")
	If SubStr(cReferencia,1,2) == "NF"
		If lRet := MaFisVldAlt(cReferencia)
			MaFisAlt(cReferencia,xValor)
			For nY := 1 to Len(aCols)
				If MaFisFound("IT",nY)
					For nX	:= 1 to Len(aHeader)
						cValid	:= AllTrim(UPPER(aHeader[nX][6]))
						If "MAFISREF"$cValid
							nPosRef := AT('MAFISREF("',cValid) + 10
							cRefCols:=Substr(cValid,nPosRef,AT('","'+cProg+'",',cValid)-nPosRef )
							aCols[nY][nX]:= MaFisRet(nY,cRefCols)
						EndIf
					Next nX
				EndIf
			Next nY
		EndIf
	Else
		If MaFisFound("IT",N)
			If aNfItem[N][IT_DELETED] .And. IIf(Len(aCols[1])==Len(aHeader)+1,!aCols[N][Len(aHeader)+1],.F.)
				MaFisDel(N,.F.)
			EndIf
			If GdFieldPos("D1_ITEM")>0
				aNfItem[N][IT_ITEM] := aCols[N][GdFieldPos("D1_ITEM")]
			EndIf
		EndIf
		MaFisIniLoad(n)
		If lRet := MaFisVldAlt(cReferencia,n)
			MaFisAlt(cReferencia,xValor,n)
			For nX	:= 1 to Len(aHeader)
				cValid	:= AllTrim(UPPER(aHeader[nX][6]))
				If "MAFISREF"$cValid
					nPosRef := AT('MAFISREF("',cValid) + 10
					cRefCols:=Substr(cValid,nPosRef,AT('","'+cProg+'",',cValid)-nPosRef )
					aCols[n][nX]:= MaFisRet(n,cRefCols)
				EndIf
			Next nX
		EndIf
	EndIf
	Eval(bRefresh)
EndIf

RestArea(aArea)

Return lRet

/*MaFisAlt - Edson Maricate -09.12.1999
Altera os valores de impostos e bases do item
*/
Function MaFisAlt(cCampo,nValor,nItem,lNoCabec,nItemNao,lDupl,cRotina,lRecal,dVencReal,aTrbGen)

Local aArea       := GetArea()
Local aRef        := {}
Local cPosCpo     := ""
Local nPos        := 0
Local nValAnt     := 0
Local nPosItDec   := 0
Local cCpoTxMoeda := IIf( cPaisLoc $ "PER" , "/NF_TXMOEDA" , "" )
Local lCDAIndic	  := aDic[AI_CDA]
Local nPosGen     := 0
Local cRefTrbGen  := ""

DEFAULT lNoCabec := .F.
DEFAULT nItemNao := 0
DEFAULT lDupl    := .F.
DEFAULT cRotina  := ""
DEFAULT lRecal   := .T.
DEFAULT dVencReal := dDataBase
DEFAULT aTrbGen  := {"",""}

If aSX6[MV_RSATIVO]
	lRastItem := .T.
EndIf

// Para alterar _TRIBGEN é OBRIGATÓRIO passar o aTrbGen completo (sigla + referencia).
If ((cCampo == "IT_TRIBGEN" .Or. cCampo == "NF_TRIBGEN") .And. (Len(aTrbGen) < 2 .Or. (Len(aTrbGen) >= 2 .And. (Empty(aTrbGen[TG_SIGLA]) .Or. Empty(aTrbGen[TG_REFERENCIA])))))
	nValor := Nil
EndIf

If nValor <> Nil
	Do Case
		Case Substr(cCampo,1,2) == "IT"
			If MaFisFound("IT",nItem)
				If MaFisRet(nItem,cCampo,aTrbGen) <> nValor
					If !lNocabec
						MaFisSomaIt(nItem,.F.,cCampo)
					EndIf
					
					If cCampo == "IT_TRIBGEN"
						cPosCpo	:= MaFisScan(aTrbGen[TG_REFERENCIA])
						If (nPosGen := aScan(aNFItem[nItem][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_SIGLA]) == AllTrim(aTrbGen[TG_SIGLA])})) > 0
							aNfItem[nItem][IT_TRIBGEN][nPosGen][cPosCpo] := nValor
						EndIf
					Else
						cPosCpo	:= MaFisScan(cCampo)

						// Tratamento para os itens.
						If ValType(cPosCpo) == "A"
							aNfItem[nItem][cPosCpo[1]][cPosCpo[2]] := nValor
							aRefAlt[nItem][cPosCpo[1]][cPosCpo[2]] := .T.
						Else
							aNfItem[nItem][Val(cPosCpo)] := nValor
							aRefAlt[nItem][Val(cPosCpo)] := .T.
						EndIf
					EndIf

					If AllTrim(cCampo) == "IT_PRODUTO" .And. !Empty( aNfItem[nItem][IT_PRODUTO] ) .And. ( aNfItem[nItem][IT_PRODUTO] <> aNfItem[nItem][IT_PRD][SB_COD] )
						MaFisIniCpo(nItem)
					EndIf

					If AllTrim(cCampo) == "IT_TES" .And. !Empty( aNfItem[nItem][IT_TES] ) .And. ( aNfItem[nItem][IT_TES] <> aNfItem[nItem][IT_TS][TS_CODIGO] )
						MaNewFisTES(aNfItem[nItem][IT_TES],,nItem)
					EndIf

					// Tratamento especifico e diferenciado para cada campo.
					If lRecal .and. IIF(cPaisLoc == "ARG" .and. Type("lLocxAuto") <> "U" .and. lLocxAuto, !cCampo $ "IT_" .and. Iif(Type("cUltCpo") <> "U", cCampo == cUltCpo .or. cCampo == "IT_VALMERC" .or. cCampo == "IT_DESCONTO" ,.T.) , .T.)
						MaFisRecal(cCampo,nItem,dVencReal)
					EndIf

					If !lNoCabec
						MaFisSomaIt(nItem)
						If bFisRefresh <> Nil
							Eval(bFisRefresh)
						EndIf
						If bLivroRefresh <> Nil
							Eval(bLivroRefresh)
						EndIf
					EndIf

					If cPaisLoc == "BRA" .And. lCDAIndic .And. Type("oLancApICMS") == "O"
						a103AjuICM(nItem)
					EndIf
				EndIf
			EndIf
		Case Substr(cCampo,1,2) == "NF"
			If MaFisFound("NF")
				If MaFisRet(,cCampo,aTrbGen) <> nValor .Or. lDupl

					If cCampo == "NF_TRIBGEN"
						cPosCpo	:= MaFisScan(aTrbGen[TG_REFERENCIA])
						If (nPosGen := aScan(aNFCab[NF_TRIBGEN], {|x| AllTrim(x[TG_NF_SIGLA]) == AllTrim(aTrbGen[TG_SIGLA])})) > 0
							nValAnt := aNFCab[NF_TRIBGEN][nPosGen][cPosCpo]
							aNFCab[NF_TRIBGEN][nPosGen][cPosCpo] := nValor
						EndIf
					Else
						cPosCpo	:= MaFisScan(cCampo)
						// Tratamento para o cabecalho.
						If ValType(cPosCpo) == "A"
							nValAnt	:= aNfCab[cPosCpo[1]][cPosCpo[2]]
							aNfCab[cPosCpo[1]][cPosCpo[2]] := nValor
						Else
							nValAnt	:= aNfCab[Val(cPosCpo)]
							aNfCab[Val(cPosCpo)] := nValor
						EndIf
					EndIf

					// Tratamento especifico e diferenciado para cada campo.
					Do Case
						Case AllTrim(cCampo)$"NF_CODCLIFOR/NF_LOJA/NF_TIPONF/NF_OPERNF/NF_CLIFOR/NF_NATUREZA/NF_CLIDEST/NF_LOJDEST/NF_TPFRETE"+cCpoTxMoeda
							// Reinicia os valores de arredondamento dos impostos contidos no aSaveDec.
							If AllTrim(cCampo)$"NF_NATUREZA"
								aRef := {"IT_VALISS","IT_VALIRR","IT_VALINS","IT_VALCOF","IT_VALCSL","IT_VALPIS","IT_VALPS2","IT_VALCF2","IT_VALPS3","IT_VALCF3"}
								For nPos := 1 to Len(aItemRef)
									If !Empty(aScan(aRef,aItemRef[nPos,1]))
										aSaveDec[nPos] := 0
									EndIF
								Next nPos
							Else
								aSaveDec := Nil
							EndIf

							MaFisIni( NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, NIL, cRotina, NIL, NIL, NIL, NIL, aNfCab[NF_RECISS],,,,,,,,,,,,,,,aNfCab[NF_CLIDEST],aNfCab[NF_LOJDEST] )

							For nItem := 1 To Len(aNfItem)
								If AllTrim(cCampo)$"NF_CODCLIFOR/NF_LOJA"
									aNfItem[nItem, IT_EXCECAO]	:=	{}
									// Quando estiver alterando o cliente/fornecedor, necessito a chamada da MaFisIniCpo para recarregar as referencias
									// da amarracao UF x UF x Produto (tabela CFC).
									MaFisIniCpo( nItem )
									//Como zero o array aSaveDec acima, preciso zerar o aItemDec tambem, para nao dar diferenca na funcao MaItArred
								ElseIf AllTrim(cCampo)$"NF_NATUREZA"
									For nPos := 1 to Len(aRef)
										nPosItDec	:=	aScan(aItemRef,{|aX| aX[1]==aRef[nPos]})
										If !Empty(nPosItDec)
											If Len(aItemDec[nItem][1])>=nPosItDec
												aItemDec[nItem][1][nPosItDec]	:=	0
											EndIf
											If Len(aItemDec[nItem][2])>=nPosItDec
												aItemDec[nItem][2][nPosItDec]	:=	0
											EndIf
										EndIf
									Next nPos
								EndIf

								MaFisRecal(cCampo,nItem,dVencReal)

								If cPaisLoc == "BRA" .And. lCDAIndic .And. Type("oLancApICMS") == "O"
									a103AjuICM(nItem)
								EndIf
							Next nItem

							If !lNoCabec
								MaIt2Cab()
							EndIf

						Case AllTrim(cCampo)$"NF_UFDEST/NF_UFORIGEM/NF_SUFRAMA/NF_AUXACUM/NF_RECISS"+Iif(cPaisLoc <> "BRA","/NF_SERIENF/NF_PROVENT","")+Iif(cPaisLoc $ "COL|BRA|EUA","/NF_CODMUN/NF_TPACTIV","")+"/NF_PNF_COD/NF_PNF_LOJ/NF_PNF_UF/NF_PNF_TPCLIFOR/NF_DTEMISS/NF_MODAL"
							For nItem := 1 To Len(aNfItem)
								If AllTrim(cCampo)$"NF_UFDEST"
									aNfItem[nItem, IT_EXCECAO]	:=	{}
									If cPaisLoc == "ARG"
										aNFItem[nItem][IT_TS][TS_CODIGO] := "   "
									Endif
								EndIf

								MaFisRecal(cCampo,nItem,dVencReal)

								If !lNoCabec .And. cPaisLoc <> "BRA"
									MaFisSomaIt(nItem)
									If bFisRefresh <> Nil
										Eval(bFisRefresh)
									EndIf
									If bLivroRefresh <> Nil
										Eval(bLivroRefresh)
									EndIf
								EndIf
							Next nItem

							If !lNoCabec
								MaIt2Cab()
							EndIf
							// Atualizacao/recalculo dos valores na alteracao da moeda e taxa
						Case cPaisLoc == "ARG" .And. ((nValAnt <> nValor .Or. lDupl) .And. ValType(nValor) == "N" ) .And. (AllTrim(cCampo)$"NF_MOEDA/NF_TXMOEDA/")
							For nItem := 1 To Len(aNfItem)
								MaFisRecal(Alltrim(cCampo),nItem)
							Next
							If !lNoCabec
								MaIt2Cab()
							Endif
							//	Atualizacao/recalculo dos valores na alteracao dos valores na aba de impostos
						Case cPaisLoc == "ARG" .And. 'NF_VALIV'$AllTrim(cCampo)
							MaFisRatRes("IT"+Substr(cCampo,3,Len(cCampo)-2),nValor,aNfCab[NF_IMPOSTOS][nItem][IMP_ALIQ],'IT_ALIQ'+aNfCab[NF_IMPOSTOS][nItem][IMP_NOME],'IT_BASE'+aNfCab[NF_IMPOSTOS][nItem][IMP_NOME],nItemNao)
							For nItem := 1 to Len(aNfItem)
								MaFisRecal("IT"+Substr(cCampo,3,Len(cCampo)-2),nItem)
							Next nItem
							If !lNoCabec
								MaIt2Cab(nItemNao)
							EndIf
						OtherWise
							If ((nValAnt <> nValor .Or. lDupl) .And. ValType(nValor) == "N" ) .And. !(AllTrim(cCampo)$"NF_MOEDA/NF_TXMOEDA/") .And. !'NF_MINIV'$AllTrim(cCampo) .And.!'NF_MINIMP'$AllTrim(cCampo)
								If AllTrim(cCampo)$"NF_FRETE/NF_SEGURO/NF_DESPESA/NF_DESCONTO/NF_DESCTOT/NF_ACRESCI/NF_VLR_FRT/NF_DESNTRB/NF_TARA/NF_ADIANTTOT/NF_AFRMIMP/NF_VALPEDG"
									For nItem := 1 To Len(aNfItem)
										aFill(aItemDec[nItem][1],0)
										aFill(aItemDec[nItem][2],0)
									Next nItem
									aFill(aSaveDec,0)
								EndIf
								If cCampo == "NF_TRIBGEN"								
									// Necessário fazer este "de-para" entre as referências pois como o MaFisAlt que chamou a 
									// MaRateio foi de NF_TRIBGEN a referência em aTrbGen é "TG_NF_" e no trecho abaixo preciso
									// da referência correspondente em "TG_IT_" para efetuar o rateio entre os itens.
									Do Case
										Case aTrbGen[TG_REFERENCIA] == "TG_NF_BASE"
											cRefTrbGen := "TG_IT_BASE"
										Case aTrbGen[TG_REFERENCIA] == "TG_NF_VALOR"
											cRefTrbGen := "TG_IT_VALOR"
									EndCase
									MaRateio("IT_TRIBGEN",nValAnt,nValor,lDupl,{aTrbGen[1], cRefTrbGen})
									For nItem := 1 To Len(aNfItem)
										MaFisRecal("IT_TRIBGEN",nItem,dVencReal,{aTrbGen[1], cRefTrbGen})
										If cPaisLoc=="BRA" .And. lCDAIndic .And. Type("oLancApICMS")=="O"
											a103AjuICM(nItem)
										EndIf
									Next nItem
									If !lNoCabec
										MaIt2Cab()
									EndIf
								Else
									MaRateio("IT"+Substr(cCampo,3,Len(cCampo)-2),nValAnt,nValor,lDupl)
									For nItem := 1 To Len(aNfItem)
										MaFisRecal("IT"+Substr(cCampo,3,Len(cCampo)-2),nItem,dVencReal)
										If cPaisLoc=="BRA" .And. lCDAIndic .And. Type("oLancApICMS")=="O"
											a103AjuICM(nItem)
										EndIf
									Next nItem
									If !lNoCabec
										MaIt2Cab()
									EndIf
								EndIf									
							EndIf
					EndCase
				EndIf
			EndIf
		Case Substr(cCampo,1,3) == "IMP"
			If cCampo == "IMP_TRIBGEN"
				MaFisRatRes("IT_TRIBGEN",nValor,aNfCab[NF_IMPOSTOS][nItem][IMP_ALIQ],"TG_IT_ALIQUOTA","TG_IT_BASE",nItemNao,aTrbGen)
				For nItem := 1 to Len(aNfItem)
					If nItem <> nItemNao
						MaFisRecal("IT_TRIBGEN",nItem,dVencReal,aTrbGen)
						If cPaisLoc=="BRA" .And. lCDAIndic .And. Type("oLancApICMS")=="O"
							a103AjuICM(nItem)
						EndIf
					Endif
				Next nItem
				If !lNoCabec
					MaIt2Cab(nItemNao)
				EndIf
			Else
				If cCampo == "IMP_VALRUR"
					cCampo := "IMP_FUNRURAL"
					MaFisRatRes("IT_FUNRURAL",nValor,aNfCab[NF_IMPOSTOS][nItem][IMP_ALIQ],"IT_PERFUN","",nItemNao)
				
				ElseIF cCampo $ "IMP_BASEINP/IMP_VALINP"				
					MaFisRatRes("IT"+Substr(cCampo,4,Len(cCampo)-3),nValor,aNfCab[NF_IMPOSTOS][nItem][IMP_ALIQ],"IT_PERCINP","IT_BASEINP",nItemNao)
				Else
					If Alltrim(cCampo) $ "IMP_BASECID | IMP_VALCIDE"
						MaFisRatRes("IT"+Substr(cCampo,4,Len(cCampo)-3),nValor,aNfCab[NF_IMPOSTOS][nItem][IMP_ALIQ],'IT_ALQ'+aNfCab[NF_IMPOSTOS][nItem][IMP_DESC],'IT_BASE'+aNfCab[NF_IMPOSTOS][nItem][IMP_NOME],nItemNao)
					Else
						MaFisRatRes("IT"+Substr(cCampo,4,Len(cCampo)-3),nValor,aNfCab[NF_IMPOSTOS][nItem][IMP_ALIQ],'IT_ALIQ'+aNfCab[NF_IMPOSTOS][nItem][IMP_NOME],'IT_BASE'+aNfCab[NF_IMPOSTOS][nItem][IMP_NOME],nItemNao)
					EndIf
				EndIf
				For nItem := 1 to Len(aNfItem)
					If nItem <> nItemNao
						MaFisRecal("IT"+Substr(cCampo,4,Len(cCampo)-3),nItem,dVencReal)
						If cPaisLoc=="BRA" .And. lCDAIndic .And. Type("oLancApICMS")=="O"
							a103AjuICM(nItem)
						EndIf
					Endif
				Next nItem
				If !lNoCabec
					MaIt2Cab(nItemNao)
				EndIf
			EndIf
	EndCase
EndIF

RestArea(aArea)

Return .T.

/*/
MaFisRecal -  Edson Maricate-20.12.1999
Recalcula os valores de impostos do item.
Parametros
ExpC1: Campo que sofreu alteracao.
ExpN2: Item.
/*/
Function MaFisRecal(cCampo,nItem,dVencReal,aTrbGen)

Local nPosTESM	:= 0
Local nPosAux		:= 0
Local lSort 		:= !(Type("l120Auto") <> "U" .and. l120Auto)
Local lMVRPCBIZF := aSX6[MV_RPCBIZF] .And. aNfCab[NF_UFDEST]$aSX6[MV_RPCBIUF]

DEFAULT cCampo	:=	""
DEFAULT dVencReal := dDataBase
DEFAULT aTrbGen := {"",""}

If AllTrim(cCampo) == "IT_PRODUTO" .And. !Empty( aNfItem[nItem][IT_PRODUTO] ) .And. ( aNfItem[nItem][IT_PRODUTO] <> aNfItem[nItem][IT_PRD][SB_COD] )
	MaFisIniCpo(nItem)
EndIf

If cPaisLoc == "BRA" .And. AllTrim(cCampo) == "IT_TES" .And. !Empty( aNfItem[nItem][IT_TES] ) .And. ( aNfItem[nItem][IT_TES] <> aNfItem[nItem][IT_TS][TS_CODIGO] )
	MaNewFisTES(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
EndIf

If aNfItem[nItem][IT_TES] <> aTes[TS_CODIGO]
	If cPaisLoc == "ARG"
		If Type("aTesMXF") <> "U"
			nPosTESM := Ascan(aTesMXF,{|X| X[1] == nItem})

			If nPosTESM > 0 .and. aTesMXF[nPosTESM][2][1] == aNfItem[nItem][IT_TES]
				aTes := AClone(aTesMXF[nPosTESM][2])
			Else
				nPosAux := ascan(aTesMXF,{|x| AllTrim(x[2][1]) == AllTrim(aNfItem[nItem][IT_TES])})
				If nPosAux > 0 .and. Type("aTesMXF") <> "U" .and. AllTrim(aNfItem[nItem][IT_TES]) <> "" .and. !lSort
					If Type("aTesMXF") <> "U" .and. nPosTESM == 0
						AADD(aTesMXF,{nItem,AClone(aTesMXF[nPosAux][2])})
						aTes := AClone(aTesMXF[Len(aTesMXF)][2])
					ElseIf nPosTESM > 0
						aTesMXF[nPosTESM][2] := AClone(aTesMXF[nPosAux][2])
						aTes := AClone(aTesMXF[nPosTESM][2])
					EndIf
				Else
					MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
					If Type("aTesMXF") <> "U" .and. nPosTESM == 0 .and. !Empty(aTes[TS_CODIGO])
						AADD(aTesMXF,{nItem,AClone(aTes)})
					ElseIf nPosTESM > 0 .and. !Empty(aTes[TS_CODIGO])
						aTesMXF[nPosTESM][2] := AClone(aTes)
					EndIf
				EndIf
			EndIf
		Else
			MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
		EndIf
	Else
		MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
	EndIf
EndIf

Do Case
	Case AllTrim(cCampo) == "IT_CF"
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				// Proteção para não recalcular a alíquota de ICMS caso ela tenha sido intencionalmente
				// alterada por MaFisAlt ou MaFisLoad.
				If aNfCab[NF_USAALIQSN] .And. !aRefAlt[nItem][IT_ALIQICM]
					// Recalculo a alíquota de ICMS.
					MaAliqIcms(nItem)
					// Chamo recursivamente a função MaFisRecal com a referência "IT_ALIQICM" para
					// efetuar todos os recálculos que devem ser feitos na alteração da alíquota.
					MaFisRecal("IT_ALIQICM",nItem,dVencReal)
				EndIf			
				MaFisII(nItem)
				MaFisVTot(nItem)
			EndIf			
			MaCodDecl(nItem)			
		EndIf
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisTPDP(nItem)
		If cPaisLoc $ "ARG|COL"
			MaFisImpIV(nItem,cCampo)
			MaFisNameIV(,nItem)
			MaFisVTot(nItem)
		Endif
	Case AllTrim(cCampo) == "IT_VALMERC"
		aNfItem[nItem][IT_DESCZF] := 0
		If cPaisLoc == "BRA"
			MaAliqSoli(nItem)
			MaExcecao(nItem)
			MaMargem(nItem)
		Endif
		MaFisPreCalc(nItem,cCampo)
		If cPaisLoc == "BRA"
			MaFisIPI(nItem,"BSE|VLR")
			MaFisBSICM(nItem)
			MaALIQCMP(nItem)
			MaFisVICMS(nItem)
			If !( aNFItem[nItem][IT_TS][TS_TPIPI]=="B" .Or. (aSX6[MV_IPIBRUT]=="S" .And. aNFItem[nItem][IT_TS][TS_TPIPI] ==" ") ) .And. ( aNFItem[nItem][IT_TS][TS_AGREG]=="D" .Or. aNFItem[nItem][IT_TS][TS_AGREG]=="R" )
				MaFisIPI(nItem,"BSE|VLR")
			EndIf
			MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
			MaFisVComp(nItem)
			MaFisVDescZF(nItem)
			MaFisBSSol(nItem)
			MaFisVSol(nItem)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisCOFINS(nItem,"CF2")
				MaFisPIS(nItem,"PS2")
				If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
					MaFisIPI(nItem,"BSE|VLR")
					If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVComp(nItem)
					ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVDescZF(nItem)
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
					EndIf
					MaFisBSSol(nItem)
					MaFisVSol(nItem)
				EndIf
			EndIf
			MaFisRURAL(nItem)
			MaFisVSul(nItem)
			MaFisCOFINS(nItem,"CF3")
			MaFisVTot(nItem)
			MaFisPIS(nItem,"PS3")
			If aNFItem[nItem][IT_TS][TS_BCPCST] == "1" //Campo que indica se os valores de PIS/COFINS ST entram na base de ICMS-ST
				MaFisBSSOL(nItem)
				MaFisVSol(nItem)
			EndIf
			MaFisVTot(nItem)
			MaFisSENAR(nItem)
			MaFisAliqIV(,nItem)
			MaFisBSIV(,nItem)
			MaFisVLIV(,nItem)
			MaFisTPDP(nItem)
			MaFisLF(nItem)
			MaFisPROT(nItem)
			MaFisLF(nItem)
		Else
			MaFisImpIV(nItem,cCampo)
		Endif
		MaFisNameIV(,nItem)
		If cPaisLoc == "BRA" .And. !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"CF2")
			MaFisPIS(nItem,"PS2")
			If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
				MaFisIPI(nItem,"BSE|VLR")
				If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					MaFisVComp(nItem)
				ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVDescZF(nItem)
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
				EndIf
				MaFisBSSol(nItem)
				MaFisVSol(nItem)
			EndIf
			MaFisLF(nItem)
			MaFisPROT(nItem)
			MaFisLF(nItem)
		EndIf
		If aNFItem[nItem][IT_TS][TS_OPERSUC]=="1" .And. aNfCab[NF_SIMPSC]<>"1" .And. aNFCab[NF_SIMPNAC]<>"1"
			MaFisBsIcm(nItem)
			MaFisVICMS(nItem)
			MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
		Endif
		MaFisVTot(nItem)
		If cPaisLoc == "BRA"
			MaFisINSS(nItem,"BSE|VLR")
			MaFisIR(nItem,,dVencReal)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisCOFINS(nItem,"COF")
				MaFisPIS(nItem,"PIS")
			EndIF
			MaFisCSLL(nItem)
			MaFisSEST(nItem)
			MaFisCOFINS(nItem,"CF3")
			MaFisISS(nItem)
			MaFisISSBi(nItem)
			MaFisVTot(nItem)
			MaFisPIS(nItem,"PS3")
			MaFisCide(nItem)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem)
			EndIf
			If aNFItem[nItem][IT_TS][TS_BCPCST] == "1" //Campo que indica se os valores de PIS/COFINS ST entram na base de ICMS-ST
				MaFisBSSOL(nItem)
				MaFisVSol(nItem)
			EndIf
			MaFisCPRB(nItem)
			MaFisINSP(nItem)
			// Este bloco deve ser sempre o ultimo (Antes de MaFisVTot, MaItArred e MaFisLF).
			If aNfCab[NF_PPDIFAL] .And. aNfCab[NF_OPERNF] == "S" .And. (((aNFItem[nItem][IT_TS][TS_AGREG] == "I" .Or. aNFItem[nItem][IT_TS][TS_AGREG] == "A") .And. !aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"))
				// Se o valor de ICMS for zero refaco as bases passando o parametro "lAgreg" = .F. para
				// que nao seja feita a divisao: (base = base / 1 - Aliq) para que o arredondamento nao
				// acabe acrescentando valores na base que nao correspondem ao valor efetivo do tributo.
				If aNFItem[nItem][IT_VALICM] == 0
					MaFisBSICM(nItem,,,,,.F.)
					MaFisVICMS(nItem)
					MaFisVComp(nItem)
					MaFisPIS(nItem,"PS2","BSE|VLR",,.F.)
					MaFisCOFINS(nItem,"CF2","BSE|VLR",,.F.)
				EndIf
			EndIf
			MaFisVTot(nItem)
		Endif
		MaFisLF(nItem) //Tratamento realizado para que não seja chamado dentro das funções MaFisPROT e MaFisFEEF e não comprometa a performance
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		If cPaisLoc == "BRA"
			MaFisLF(nItem)
			MaFisAFRMM(nItem)
			MaFisFFF(nItem)
		EndIf
	Case AllTrim(cCampo) == "IT_BASEICM"
		MaAliqSoli(nItem)
		MaExcecao(nItem)
		MaMargem(nItem)
		MaFisVICMS(nItem)
		MaFisTPDP(nItem)
		If !( aNFItem[nItem][IT_TS][TS_TPIPI]=="B" .Or. (aSX6[MV_IPIBRUT]=="S" .And. aNFItem[nItem][IT_TS][TS_TPIPI] ==" ") )	.And. ( aNFItem[nItem][IT_TS][TS_AGREG]=="D" .Or. aNFItem[nItem][IT_TS][TS_AGREG]=="R" )
			MaFisIPI(nItem,"BSE|VLR")
		EndIf
		MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
		MaFisVComp(nItem)
		MaFisBSSol(nItem)
		MaFisVSol(nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			// Quando necessário ajuste de centavos na base de calculo do ICMS, o sistema não pode mudar os valores da base de calculo do PIS e COFINS importação.
			If !(aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_CLIFOR] =="F" .And. aNFCab[NF_TPCLIFOR] =="X" .And. Substr(aNfItem[nItem][IT_CF],1,1)=="3" .And. aNFItem[nItem][IT_TS][TS_INTBSIC]$"123")
				MaFisCOFINS(nItem,"CF2")
				MaFisPIS(nItem,"PS2")
			Endif

			If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
				MaFisIPI(nItem,"BSE|VLR")
				If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					MaFisVComp(nItem)
				ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					MaFisVDescZF(nItem)
					MaFisPIS(nItem,"PS2")
					MaFisCOFINS(nItem,"CF2")
				EndIf
				MaFisBSSol(nItem)
				MaFisVSol(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"COF")
			MaFisPIS(nItem,"PIS")
		EndIf
		MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		MaFisVTot(nItem)
		MaFisINSP(nItem)
		MaFisLF(nItem) //Tratamento realizado para que não seja chamado dentro das funções MaFisPROT e MaFisFEEF e não comprometa a performance
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case AllTrim(cCampo) == "IT_ALIQICM"
		If aNFItem[nItem][IT_TS][TS_AGREG] $ "I,A,D,R,E"
			MaFisBsICM( nItem , , , , cCampo )
		Endif
		MaAliqSoli(nItem)
		If!(IsInCallStack("GFEA065"))// VALIDAÇÃO CRIADA PARA VERIFICAR INTEGRAÇÃO COM O SIGAGFE
			MaFisVICMS(nItem)
		EndIf
		MaFisTPDP(nItem)
		If !( aNFItem[nItem][IT_TS][TS_TPIPI]=="B" .Or. (aSX6[MV_IPIBRUT]=="S" .And. aNFItem[nItem][IT_TS][TS_TPIPI] ==" ") )	.And. ( aNFItem[nItem][IT_TS][TS_AGREG]=="D" .Or. aNFItem[nItem][IT_TS][TS_AGREG]=="R" )
			MaFisIPI(nItem,"BSE|VLR")
		EndIf
		MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
		MaFisVComp(nItem,,cCampo)
		MaFisVSol(nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"CF2")
			MaFisPIS(nItem,"PS2")
			If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
				MaFisIPI(nItem,"BSE|VLR")
				If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
					MaFisBSICM(nItem,,.T.,,cCampo)
					MaFisVICMS(nItem)
					MaFisVComp(nItem,,cCampo)
				ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					MaFisVDescZF(nItem)
					MaFisPIS(nItem,"PS2")
					MaFisCOFINS(nItem,"CF2")
				EndIf
				MaFisBSSol(nItem)
				MaFisVSol(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"COF")
			MaFisPIS(nItem,"PIS")
		EndIf
		MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem, cCampo)
			EndIf
		EndIf
		// Este bloco deve ser sempre o ultimo (Antes de MaFisVTot, MaItArred e MaFisLF).
		If aNfCab[NF_PPDIFAL] .And. aNfCab[NF_OPERNF] == "S" .And. (((aNFItem[nItem][IT_TS][TS_AGREG] == "I" .Or. aNFItem[nItem][IT_TS][TS_AGREG] == "A") .And. !aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"))
			// Se o valor de ICMS for zero refaco as bases passando o parametro "lAgreg" = .F. para
			// que nao seja feita a divisao: (base = base / 1 - Aliq) para que o arredondamento nao
			// acabe acrescentando valores na base que nao correspondem ao valor efetivo do tributo.
			If aNFItem[nItem][IT_VALICM] == 0
				MaFisBSICM(nItem,,,,,.F.)
				MaFisVICMS(nItem)
				MaFisVComp(nItem,,cCampo)
				MaFisPIS(nItem,"PS2","BSE|VLR",,.F.)
				MaFisCOFINS(nItem,"CF2","BSE|VLR",,.F.)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaFisINSP(nItem)
		MaFisLF(nItem)//Tratamento realizado para que não seja chamado dentro das funções MaFisPROT e MaFisFEEF e não comprometa a performance
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case AllTrim(cCampo) == "IT_ALIQIPI"
		MaAliqSoli(nItem)
		MaExcecao(nItem)
		MaMargem(nItem)
		MaFisTPDP(nItem)
		If aNFItem[nItem,IT_BASEIPI] == 0
			MaFisIPI(nItem,"BSE")
		Endif
		MaFisIPI(nItem,"VLR")
		If (aNFItem[nItem][IT_TS][TS_INCIDE]	== "S"  .Or. (aNFItem[nItem][IT_TS][TS_INCIDE] == "F" .And. aNFCab[NF_TPCLIFOR] =="F" .And. aNFCab[NF_CLIFOR] =="C")) .And.;
			aNFItem[nItem][IT_TS][TS_IPI] <> "R"
			MaFisBsICM(nItem)
			MaFisVICMS(nItem)
			MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
		EndIf
		MaFisVComp(nItem)
		MaFisBSSol(nItem)
		MaFisVSol(nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"CF2")
			MaFisPIS(nItem,"PS2")
			If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
				MaFisIPI(nItem,"BSE|VLR")
				If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					MaFisVComp(nItem)
				ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					MaFisVDescZF(nItem)
					MaFisPIS(nItem,"PS2")
					MaFisCOFINS(nItem,"CF2")
				EndIf
				MaFisBSSol(nItem)
				MaFisVSol(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"COF")
			MaFisPIS(nItem,"PIS")
		EndIf
		MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaFisINSP(nItem)
		MaFisLF(nItem) //Tratamento realizado para que não seja chamado dentro das funções MaFisPROT e MaFisFEEF e não comprometa a performance
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case AllTrim(cCampo) == "IT_BASEIPI"
		MaAliqSoli(nItem)
		MaExcecao(nItem)
		MaMargem(nItem)
		MaFisIPI(nItem,"VLR")
		MaFisTPDP(nItem)
		If (aNFItem[nItem][IT_TS][TS_INCIDE]	== "S" .Or. (aNFItem[nItem][IT_TS][TS_INCIDE] == "F" .And. aNFCab[NF_TPCLIFOR] =="F" .And. aNFCab[NF_CLIFOR] =="C")) .And.;
			aNFItem[nItem][IT_TS][TS_IPI] <> "R"
			MaFisBsIcm(nItem)
			MaFisVICMS(nItem)
			MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
			MaFisVComp(nItem)
			MaFisBSSol(nItem)
			MaFisVSol(nitem)
		EndIf
		IF aNFItem[nItem][IT_TS][TS_SOMAIPI] == "1"
			MaFisBSSol(nItem)
			MaFisVSol(nitem)
		EndIf
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"CF2")
			MaFisPIS(nItem,"PS2")
			If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
				MaFisIPI(nItem,"BSE|VLR")
				If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					MaFisVComp(nItem)
				ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					MaFisVDescZF(nItem)
					MaFisPIS(nItem,"PS2")
					MaFisCOFINS(nItem,"CF2")
				EndIf
				MaFisBSSol(nItem)
				MaFisVSol(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"COF")
			MaFisPIS(nItem,"PIS")
		EndIf
		MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		MaFisVTot(nItem)
		MaFisINSP(nItem)
		MaFisLF(nItem) //Tratamento realizado para que não seja chamado dentro das funções MaFisPROT e MaFisFEEF e não comprometa a performance
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case AllTrim(cCampo) == "IT_VALIPI"
		MaAliqSoli(nItem)
		MaExcecao(nItem)
		MaMargem(nItem)
		MaFisTPDP(nItem)
		If (aNFItem[nItem][IT_TS][TS_INCIDE]	== "S"  .Or. (aNFItem[nItem][IT_TS][TS_INCIDE] == "F" .And. aNFCab[NF_TPCLIFOR] =="F" .And. aNFCab[NF_CLIFOR] =="C")) .And.;
			aNFItem[nItem][IT_TS][TS_IPI] <> "R"
			MaFisBsIcm(nItem)
			MaFisVICMS(nItem)
			MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
		EndIf
		MaFisVComp(nItem)
		MaFisBSSol(nItem)
		MaFisVSol(nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"CF2")
			MaFisPIS(nItem,"PS2")
			If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
				MaFisIPI(nItem,"BSE|VLR")
				If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					MaFisVComp(nItem)
				ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					MaFisVDescZF(nItem)
					MaFisPIS(nItem,"PS2")
					MaFisCOFINS(nItem,"CF2")
				EndIf
				MaFisBSSol(nItem)
				MaFisVSol(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"COF")
			MaFisPIS(nItem,"PIS")
		EndIf
		MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaFisINSP(nItem)
		MaFisLF(nItem) //Tratamento realizado para que não seja chamado dentro das funções MaFisPROT e MaFisFEEF e não comprometa a performance
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case Alltrim(cCampo) == "IT_BASESOL"
		MaFisVSol(nItem,cCampo)
		MaFisVTot(nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"CF2")
			MaFisPIS(nItem,"PS2")
		EndIf
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case AllTrim(cCampo) == "IT_ALIQSOL"
		MaFisVSol(nItem)
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		MaFisINSP(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case AllTrim(cCampo) == "IT_VALSOL"
		MaFisVTot(nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"CF2")
			MaFisPIS(nItem,"PS2")
		EndIf
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		MaFisVTot(nItem)
		MaFisINSP(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisTPDP(nItem)
	Case AllTrim(cCampo) == "IT_MARGEM"
		MaFisBsSol(nItem)
		MaFisVSol(nItem)
		MaFisVTot(nItem)
		MaFisCOFINS(nItem,"CF2")
		MaFisPIS(nItem,"PS2")
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		MaFisINSP(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case AllTrim(cCampo) == "IT_ICMFRETE"
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisBSICM(nItem)
				MaFisBSSOL(nItem)
				MaFisVSOL(nItem)
				MaFisLF(nItem)
				MaFisPROT(nItem)
				MaFisFEEF(nItem)
				MaFisLF(nItem)
			Endif
		Endif
	Case AllTrim(cCampo) == "IT_ALIQCMP"
		MaFisVComp(nItem)
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		MaFisINSP(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case AllTrim(cCampo) == "IT_VALCMP"
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		MaFisINSP(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case Alltrim(cCampo) == "IT_VALICM"
		MaFisVComp(nItem)
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"COF")
			MaFisPIS(nItem,"PIS")
		EndIf
		MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		MaFisVTot(nItem)
		MaFisINSP(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case AllTrim(cCampo) == "IT_PERFUN"
		MaFisRURAL(nItem)
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		MaFisINSP(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case AllTrim(cCampo) == "IT_FUNRURAL"
		MaFisRURAL(nItem,"BSE|ALQ")
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		MaFisINSP(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case AllTrim(cCampo) == "IT_VALFDS"
		MaFisVSul(nItem)
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		MaFisINSP(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case AllTrim(cCampo) == "IT_VLSENAR"
		MaFisVSul(nItem)
		MaFisSENAR(nItem)
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		MaFisINSP(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
		MaFisSEST(nItem)
	Case AllTrim(cCampo) == "IT_ESTCRED"
		MaFisLF(nItem)
	Case AllTrim(cCampo) == "IT_FRETE" .Or. AllTrim(cCampo) == "IT_VLR_FRT"
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaAliqSoli(nItem)
			Endif
			MaExcecao(nItem)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaMargem(nItem)
				MaFisIPI(nItem,"BSE|VLR")
				MaFisBSICM(nItem)
				MaFisVICMS(nItem)
				MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
				MaFisVDescZF(nItem)
				MaFisVComp(nItem)
				MaFisBSSOL(nItem)
				MaFisVSOL(nItem)
				If cPaisLoc == "BRA" .And. !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
					MaFisCOFINS(nItem,"CF2")
					MaFisPIS(nItem,"PS2")
					If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
						MaFisIPI(nItem,"BSE|VLR")
						If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
							MaFisBSICM(nItem,,.T.)
							MaFisVICMS(nItem)
							MaFisVComp(nItem)
						ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
							MaFisBSICM(nItem,,.T.)
							MaFisVICMS(nItem)
							MaFisVDescZF(nItem)
							MaFisPIS(nItem,"PS2")
							MaFisCOFINS(nItem,"CF2")
						EndIf
						MaFisBSSol(nItem)
						MaFisVSol(nItem)
					EndIf
				EndIf
			EndIf
			MaFisAliqIV(,nItem)
			MaFisBSIV(,nItem)
			MaFisVLIV(,nItem)
			MaFisRURAL(nItem)
			MaFisTPDP(nItem)
			MaFisLF(nItem)
			MaFisPROT(nItem)
			MaFisFEEF(nItem)
			MaFisLF(nItem)
		Else
			MaFisImpIV(nItem,cCampo)
		Endif
		If cPaisLoc == "BRA" .And. !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"CF2")
			MaFisPIS(nItem,"PS2")
			If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
				MaFisIPI(nItem,"BSE|VLR")
				If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					MaFisVComp(nItem)
				ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					MaFisVDescZF(nItem)
					MaFisPIS(nItem,"PS2")
					MaFisCOFINS(nItem,"CF2")
				EndIf
				MaFisBSSol(nItem)
				MaFisVSol(nItem)
				MaFisLF(nItem)
				MaFisPROT(nItem)
				MaFisFEEF(nItem)
				MaFisLF(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		If cPaisLoc == "BRA"
			MaFisINSS(nItem,"BSE|VLR")
			MaFisSENAR(nItem)
			MaFisIR(nItem,"BSE|VLR",dVencReal)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisCOFINS(nItem,"COF")
				MaFisPIS(nItem,"PIS")
			EndIf
			MaFisCSLL(nItem)
			MaFisSEST(nItem)
			MaFisINSP(nItem)
			MaFisCOFINS(nItem,"CF3")
			MaFisISS(nItem)
			MaFisISSBi(nItem)
			MaFisVTot(nItem)
			MaFisPIS(nItem,"PS3")
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem)
			EndIf
			// Este bloco deve ser sempre o ultimo (Antes de MaFisVTot, MaItArred e MaFisLF).
			If aNfCab[NF_PPDIFAL] .And. aNfCab[NF_OPERNF] == "S" .And. (((aNFItem[nItem][IT_TS][TS_AGREG] == "I" .Or. aNFItem[nItem][IT_TS][TS_AGREG] == "A") .And. !aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"))
				// Se o valor de ICMS for zero refaco as bases passando o parametro "lAgreg" = .F. para
				// que nao seja feita a divisao: (base = base / 1 - Aliq) para que o arredondamento nao
				// acabe acrescentando valores na base que nao correspondem ao valor efetivo do tributo.
				If aNFItem[nItem][IT_VALICM] == 0
					MaFisBSICM(nItem,,,,,.F.)
					MaFisVICMS(nItem)
					MaFisVComp(nItem)
					MaFisPIS(nItem,"PS2","BSE|VLR",,.F.)
					MaFisCOFINS(nItem,"CF2","BSE|VLR",,.F.)
				EndIf
			EndIf
			MaFisVTot(nItem)
		Endif
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		If cPaisLoc == "BRA"
			MaFisLF(nItem)
		EndIf
	Case AllTrim(cCampo) == "IT_DESPESA" .Or. AllTrim(cCampo) == "IT_AFRMIMP"
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaAliqSoli(nItem)
			Endif
			MaExcecao(nItem)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaMargem(nItem)
				If aNFItem[nItem][IT_TS][TS_DESPIPI] <> "N"
					MaFisIPI(nItem,"BSE|VLR")
				EndIf
				MaFisBSICM(nItem)
				MaFisVICMS(nItem)
				MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
				MaFisVDescZF(nItem)
				MaFisVComp(nItem)
				MaFisBSSOL(nItem)
				MaFisVSOL(nItem)
				If cPaisLoc == "BRA" .And. !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
					MaFisCOFINS(nItem,"CF2")
					MaFisPIS(nItem,"PS2")
					If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
						MaFisIPI(nItem,"BSE|VLR")
						If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
							MaFisBSICM(nItem,,.T.)
							MaFisVICMS(nItem)
							MaFisVComp(nItem)
						ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
							MaFisBSICM(nItem,,.T.)
							MaFisVICMS(nItem)
							MaFisVDescZF(nItem)
							MaFisPIS(nItem,"PS2")
							MaFisCOFINS(nItem,"CF2")
						EndIf
						MaFisBSSol(nItem)
						MaFisVSol(nItem)
					EndIf
				EndIf
			EndIf
			MaFisAliqIV(,nItem)
			MaFisBSIV(,nItem)
			MaFisVLIV(,nItem)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisCOFINS(nItem,"CF2")
				MaFisPIS(nItem,"PS2")
				If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
					MaFisIPI(nItem,"BSE|VLR")
					If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVComp(nItem)
					ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVDescZF(nItem)
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
					EndIf
					MaFisBSSol(nItem)
					MaFisVSol(nItem)
				EndIf
			EndIf
			MaFisLF(nItem)
			MaFisPROT(nItem)
			MaFisFEEF(nItem)
			MaFisLF(nItem)
		Else
			MaFisImpIV(nItem,cCampo)
		Endif
		MaFisVTot(nItem)
		If cPaisLoc == "BRA"
			MaFisINSS(nItem,"BSE|VLR")
			MaFisSENAR(nItem)
			MaFisIR(nItem,"BSE|VLR",dVencReal)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisCOFINS(nItem,"COF")
				MaFisPIS(nItem,"PIS")
			EndIf
			MaFisCSLL(nItem)
			MaFisSEST(nItem)
			MaFisINSP(nItem)
			MaFisCOFINS(nItem,"CF3")
			MaFisISS(nItem)
			MaFisVTot(nItem)
			MaFisPIS(nItem,"PS3")
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem)
			EndIf
			// Este bloco deve ser sempre o ultimo (Antes de MaFisVTot, MaItArred e MaFisLF).
			If aNfCab[NF_PPDIFAL] .And. aNfCab[NF_OPERNF] == "S" .And. (((aNFItem[nItem][IT_TS][TS_AGREG] == "I" .Or. aNFItem[nItem][IT_TS][TS_AGREG] == "A") .And. !aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"))
				// Se o valor de ICMS for zero refaco as bases passando o parametro "lAgreg" = .F. para
				// que nao seja feita a divisao: (base = base / 1 - Aliq) para que o arredondamento nao
				// acabe acrescentando valores na base que nao correspondem ao valor efetivo do tributo.
				If aNFItem[nItem][IT_VALICM] == 0
					MaFisBSICM(nItem,,,,,.F.)
					MaFisVICMS(nItem)
					MaFisVComp(nItem)
					MaFisPIS(nItem,"PS2","BSE|VLR",,.F.)
					MaFisCOFINS(nItem,"CF2","BSE|VLR",,.F.)
				EndIf
			EndIf
			MaFisVTot(nItem)
			MaFisRURAL(nItem)
		Endif
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaFisLF(nItem)
		MaItArred(nItem)
		If cPaisLoc == "BRA"
			MaFisLF(nItem)
		EndIf
	Case AllTrim(cCampo) == "IT_SEGURO"
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaAliqSoli(nItem)
			Endif
			MaExcecao(nItem)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaMargem(nItem)
				MaFisIPI(nItem,"BSE|VLR")
				MaFisBSICM(nItem)
				MaFisVICMS(nItem)
				MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
				MaFisVDescZF(nItem)
				MaFisVComp(nItem)
				MaFisBSSOL(nItem)
				MaFisVSOL(nItem)
				If cPaisLoc == "BRA" .And. !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
					MaFisCOFINS(nItem,"CF2")
					MaFisPIS(nItem,"PS2")
					If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
						MaFisIPI(nItem,"BSE|VLR")
						If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
							MaFisBSICM(nItem,,.T.)
							MaFisVICMS(nItem)
							MaFisVComp(nItem)
						ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
							MaFisBSICM(nItem,,.T.)
							MaFisVICMS(nItem)
							MaFisVDescZF(nItem)
							MaFisPIS(nItem,"PS2")
							MaFisCOFINS(nItem,"CF2")
						EndIf
						MaFisBSSol(nItem)
						MaFisVSol(nItem)
					EndIf
				EndIf
			Endif
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisCOFINS(nItem,"CF2")
				MaFisPIS(nItem,"PS2")
				If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
					MaFisIPI(nItem,"BSE|VLR")
					If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVComp(nItem)
					ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVDescZF(nItem)
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
					EndIf
					MaFisBSSol(nItem)
					MaFisVSol(nItem)
				EndIf
			EndIf
			MaFisLF(nItem)
			MaFisPROT(nItem)
			MaFisFEEF(nItem)
			MaFisLF(nItem)
		Else
			MaFisImpIV(nItem,cCampo)
		Endif
		MaFisVTot(nItem)
		If cPaisLoc == "BRA"
			MaFisINSS(nItem,"BSE|VLR")
			MaFisSENAR(nItem)
			MaFisAliqIV(,nItem)
			MaFisBSIV(,nItem)
			MaFisVLIV(,nItem)
			MaFisIR(nItem,"BSE|VLR",dVencReal)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisCOFINS(nItem,"COF")
				MaFisPIS(nItem,"PIS")
			EndIf
			MaFisCSLL(nItem)
			MaFisSEST(nItem)
			MaFisINSP(nItem)
			MaFisCOFINS(nItem,"CF3")
			MaFisISS(nItem)
			MaFisVTot(nItem)
			MaFisPIS(nItem,"PS3")
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem)
			EndIf
			// Este bloco deve ser sempre o ultimo (Antes de MaFisVTot, MaItArred e MaFisLF).
			If aNfCab[NF_PPDIFAL] .And. aNfCab[NF_OPERNF] == "S" .And. (((aNFItem[nItem][IT_TS][TS_AGREG] == "I" .Or. aNFItem[nItem][IT_TS][TS_AGREG] == "A") .And. !aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"))
				// Se o valor de ICMS for zero refaco as bases passando o parametro "lAgreg" = .F. para
				// que nao seja feita a divisao: (base = base / 1 - Aliq) para que o arredondamento nao
				// acabe acrescentando valores na base que nao correspondem ao valor efetivo do tributo.
				If aNFItem[nItem][IT_VALICM] == 0
					MaFisBSICM(nItem,,,,,.F.)
					MaFisVICMS(nItem)
					MaFisVComp(nItem)
					MaFisPIS(nItem,"PS2","BSE|VLR",,.F.)
					MaFisCOFINS(nItem,"CF2","BSE|VLR",,.F.)
				EndIf
			EndIf
			MaFisVTot(nItem)
			MaFisRURAL(nItem)
		Endif
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaFisLF(nItem)
		MaItArred(nItem)
		If cPaisLoc == "BRA"
			MaFisLF(nItem)
		EndIf
	Case AllTrim(cCampo) == "IT_REDIR"
		MaFisIR(nItem,"BSE|VLR",dVencReal)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case Alltrim(cCampo) == "IT_BASEIRR"
		MaFisIR(nItem,"ALQ|VLR",dVencReal)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case AllTrim(cCampo) == "IT_VALIRR"
		MaItArred(nItem)
		MaFisLF(nItem)
	Case AllTrim(cCampo) == "IT_ALIQIRR"
		MaFisIR(nItem,"VLR",dVencReal)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case Alltrim(cCampo) == "IT_BASESES"
		MaFisSEST(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case AllTrim(cCampo) == "IT_VALSES"
		MaItArred(nItem)
		MaFisLF(nItem)
	Case AllTrim(cCampo) == "IT_ALIQSES"
		MaFisSEST(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case AllTrim(cCampo) == "IT_REDINSS"
		MaFisINSS(nItem,"BSE|VLR")
		MaFisINSP(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case Alltrim(cCampo) == "IT_BASEINS"
		MaFisINSS(nItem,"VLR")
		MaFisINSP(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case Alltrim(cCampo) == "IT_ABVLINSS"
		MaFisINSS(nItem,"BSE|VLR")
		MaFisINSP(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case Alltrim(cCampo) == "IT_ABSCINS"
		MaFisINSS(nItem,"BSE|VLR")
		MaFisINSP(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)

	Case cPaisLoc == "BRA" .And. ( Alltrim(cCampo) == "IT_BSCP15" .Or. Alltrim(cCampo) == "IT_BSCP20" .Or. Alltrim(cCampo) == "IT_BSCP25" ) //Valor Base INSS Servico 15, 20 e 25 anos.
		MaFisINSS(nItem,"VLR")
		MaFisINSP(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cPaisLoc == "BRA" .And. ( Alltrim(cCampo) == "IT_SECP15" .Or. Alltrim(cCampo) == "IT_SECP20" .Or. Alltrim(cCampo) == "IT_SECP25" ) //Valor do serviço (usado como base) para contribuição previdenciária (INSS) especial em 15, 20 e 25 anos.
		MaFisINSS(nItem)
		MaFisINSP(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case cPaisLoc == "BRA" .And. ( Alltrim(cCampo) == "IT_ALCP15" .Or. Alltrim(cCampo) == "IT_ALCP20" .Or. Alltrim(cCampo) == "IT_ALCP25" ) //Alíquota para contribuição previdenciária (INSS) especial em 15, 20 e 25 anos.
		MaFisINSS(nItem,"VLR")
		MaFisINSP(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)

	Case cPaisLoc == "BRA" .And. ( Alltrim(cCampo) == "IT_VLCP15" .Or. Alltrim(cCampo) == "IT_VLCP20" .Or. Alltrim(cCampo) == "IT_VLCP25" ) //Valor da contribuição previdenciária (INSS) especial em 15, 20 e 25 anos.
		MaFisLF(nItem)

	Case Alltrim(cCampo) == "IT_ABVLISS"
		MaFisISS(nItem)
		MaFisISSBi(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case Alltrim(cCampo) == "IT_ABMATISS"
		MaFisISS(nItem)
		MaFisISSBi(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case AllTrim(cCampo) == "IT_VALINS"
		MaItArred(nItem)
		MaFisLF(nItem)
	Case AllTrim(cCampo) == "IT_ALIQINS"
		MaFisINSS(nItem,"VLR")
		MaFisINSP(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case Alltrim(cCampo) == "IT_VALISS"
		MaItArred(nItem)
		MaFisLF(nItem)
	Case Alltrim(cCampo) == "IT_REDISS"
		MaFisISS(nItem)
		MaFisISSBi(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case Alltrim(cCampo) == "IT_BASEISS"
		MaFisISS(nItem,"VLR")
		MaFisISSBi(nItem,"VLR")
		MaItArred(nItem)
		MaFisLF(nItem)
	Case Alltrim(cCampo) == "IT_ALIQISS"
		MaFisISS(nItem,"VLR")
		MaItArred(nItem)
		MaFisLF(nItem)
	Case Alltrim(cCampo) == "IT_BASECPM"
		MaFisISSBi(nItem,"VLR")
		MaItArred(nItem)
		MaFisLF(nItem)
	Case Alltrim(cCampo) == "IT_ALQCPM"
		MaFisISSBi(nItem,"VLR")
		MaItArred(nItem)
		MaFisLF(nItem)
	Case AllTrim(cCampo) == "IT_CODISS"
		MaFisISS(nItem,"COD")
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"COF")
			MaFisPIS(nItem,"PIS")
		EndIf
		MaFisCSLL(nItem)
		MaFisIR(nItem,,dVencReal)
		// Se utilizar CE1 (MV_ISSXMUN) ou tiver apuração do simples nacional 
		// recalcular aliq. e valor pois um cod. diferente pode resultar em uma 
		// aliquota diferente conforme a regra enquadrada.
		If aSX6[MV_ISSXMUN] .Or. aNfCab[NF_USAALIQSN]
			MaFisISS(nItem,"ALQ|VLR")
		EndIf
		MaFisISSBi(nItem)
		MaFisINSS(nItem,"BSE|VLR")
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case AllTrim(cCampo) == "IT_BASECID" .OR. AllTrim(cCampo) == "IT_ALQCIDE"
		MafisCide(nItem,"BSE|ALQ")
		MaItArred(nItem)
		MaFisLF(nItem)
	Case AllTrim(cCampo) == "IT_VALCIDE"
		MafisCide(nItem,"VLR")
		MaItArred(nItem)
		MaFisLF(nItem)
	Case AllTrim(cCampo) == "IT_CFPS"
		MaFisLF(nItem)
	Case AllTrim(cCampo) == "IT_RGESPST"
		MaFisLF(nItem)
	Case Alltrim(cCampo) == "IT_BASECOF"
		MaFisCOFINS(nItem,"COF|CF2","ALQ|VLR")
		MaItArred(nItem)
	Case Alltrim(cCampo) == "IT_ALIQCOF"
		MaFisCOFINS(nItem,"COF|CF2","VLR")
		MaItArred(nItem)
	Case Alltrim(cCampo) == "IT_BASEPIS"
		MaFisPIS(nItem,"PIS|PS2","ALQ|VLR")
		MaItArred(nItem)
	Case Alltrim(cCampo) == "IT_ALIQPIS"
		MaFisPIS(nItem,"PIS|PS2","VLR")
		MaItArred(nItem)
		MaFisLF(nItem)
	Case Alltrim(cCampo) == "IT_AVLINSS"
		MaFisINSS(nItem,"BSE|VLR")
		MaFisINSP(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case Alltrim(cCampo) == "IT_BASEPS2"
		MaFisPIS(nItem,"PIS|PS2","ALQ|VLR")
		MaFisVTot(nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"COF")
			MaFisPIS(nItem,"PIS")
		EndIf
		MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisCPRB(nItem)
		MaFisLF(nItem)
	Case Alltrim(cCampo) == "IT_BASECF2"
		MaFisCOFINS(nItem,"COF|CF2","ALQ|VLR")
		MaFisVTot(nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"COF")
			MaFisPIS(nItem,"PIS")
		EndIf
		MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case Alltrim(cCampo) == "IT_ALIQPS2"
		MaFisPIS(nItem,"PIS|PS2","VLR")
		MaFisVTot(nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"COF")
			MaFisPIS(nItem,"PIS")
		EndIf
		MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case Alltrim(cCampo) == "IT_ALIQCF2"
		MaFisCOFINS(nItem,"COF|CF2","VLR")
		MaFisVTot(nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"COF")
			MaFisPIS(nItem,"PIS")
		EndIf
		MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case Alltrim(cCampo) == "IT_VALPS2"
		MaItArred(nItem)
		MaFisVTot(nItem)
	   	MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case Alltrim(cCampo) == "IT_VALCF2"
		MaItArred(nItem)
		MaFisVTot(nItem)
		MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case Alltrim(cCampo) == "IT_BASECSL"
		MaFisCSLL(nItem,"ALQ|VLR")
		MaItArred(nItem)
		MaFisLF(nItem)
	Case Alltrim(cCampo) == "IT_ALIQCSL"
		MaFisCSLL(nItem,"VLR")
		MaItArred(nItem)
		MaFisLF(nItem)
	Case Alltrim(cCampo) == "IT_VALCSL"
		MaItArred(nItem)
		MaFisLF(nItem)
	Case Alltrim(cCampo) == "IT_VALCOF"
		MaItArred(nItem)
		MaFisLF(nItem)
	Case Alltrim(cCampo) == "IT_VALPIS"
		MaItArred(nItem)
		MaFisLF(nItem)
	Case (AllTrim(cCampo) == "IT_DESCONTO")  .OR.  (AllTrim(cCampo) == "IT_DESCTOT")
		If cPaisLoc <> "BRA"
			// Indica se o preco unitario sera arredondado em 0 casas decimais ou nao. Se .T. respeita MV_CENT (Apenas Chile).
			If (aNfCab[NF_OPERNF] =='S' .Or. (aNFitem[nItem][IT_TIPONF ]$"DB" .And. Alltrim(cFunName) $ "MATA465N|MATA462DN|" .And. cPaisLoc $ "MEX|PAR|PER|VEN" .And. cCampo<>"IT_TES")) .And. aSX6[MV_DESCSAI] == "1"
				If cPaisLoc == "CHI" .And. aSX6[MV_PRCDEC]
					aNFitem[nItem][IT_VALMERC] := Round(aNFitem[nItem][IT_VALMERC] - (aNFitem[nItem][IT_DESCONTO]+aNFitem[nItem][IT_DESCTOT]),MsDecimais(aNFCab[NF_MOEDA]))
				Else
					aNFitem[nItem][IT_VALMERC] -= (aNFitem[nItem][IT_DESCONTO]+aNFitem[nItem][IT_DESCTOT])
				Endif
				aNFitem[nItem][IT_PRCUNI]  :=	aNFitem[nItem][IT_VALMERC] / Max( aNFitem[nItem][IT_QUANT] , 1 )
			Endif
			MaFisImpIV(nItem,cCampo)
		Else
			MaAliqSoli(nItem)
			MaExcecao(nItem)
			MaMargem(nItem)
			MaFisIPI(nItem,"BSE|VLR")
			MaFisBSICM(nItem)
			MaFisVICMS(nItem)

			MaFisRURAL(nItem)
			MaFisTPDP(nItem)
			If !( aNFItem[nItem][IT_TS][TS_TPIPI]=="B" .Or. (aSX6[MV_IPIBRUT]=="S" .And. aNFItem[nItem][IT_TS][TS_TPIPI] ==" ") ) .And. ( aNFItem[nItem][IT_TS][TS_AGREG]=="D" .Or. aNFItem[nItem][IT_TS][TS_AGREG]=="R" )
				MaFisIPI(nItem,"BSE|VLR")
			EndIf
			MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
			MaFisVComp(nItem)
			MaFisBSSOL(nItem)
			MaFisVSOL(nItem)
			MaFisAliqIV(,nItem)
			MaFisBSIV(,nItem)
			MaFisVLIV(,nItem)
		Endif
		MaFisNameIV(,nItem)
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisPIS(nItem,"PS2")
				MaFisCOFINS(nItem,"CF2")
				If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
					MaFisIPI(nItem,"BSE|VLR")
					If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVComp(nItem)
					ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVDescZF(nItem)
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
					EndIf
					MaFisBSSol(nItem)
					MaFisVSol(nItem)
				EndIf
			EndIf
		Endif
		MaFisVTot(nItem)
		If cPaisLoc == "BRA"
			MaFisINSS(nItem,"BSE|VLR|RED")
			MaFisIR(nItem,,dVencReal)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisPIS(nItem,"PIS")
				MaFisCOFINS(nItem,"COF")
			EndIf
			MaFisCSLL(nItem)
			MaFisCOFINS(nItem,"CF3")
			MaFisISS(nItem)
			MaFisISSBi(nItem)
			MaFisVTot(nItem)
			MaFisPIS(nItem,"PS3")
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem)
			EndIf
			// Este bloco deve ser sempre o ultimo (Antes de MaFisVTot, MaItArred e MaFisLF).
			If aNfCab[NF_PPDIFAL] .And. aNfCab[NF_OPERNF] == "S" .And. (((aNFItem[nItem][IT_TS][TS_AGREG] == "I" .Or. aNFItem[nItem][IT_TS][TS_AGREG] == "A") .And. !aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"))
				// Se o valor de ICMS for zero refaco as bases passando o parametro "lAgreg" = .F. para
				// que nao seja feita a divisao: (base = base / 1 - Aliq) para que o arredondamento nao
				// acabe acrescentando valores na base que nao correspondem ao valor efetivo do tributo.
				If aNFItem[nItem][IT_VALICM] == 0
					MaFisBSICM(nItem,,,,,.F.)
					MaFisVICMS(nItem)
					MaFisVComp(nItem)
					MaFisPIS(nItem,"PS2","BSE|VLR",,.F.)
					MaFisCOFINS(nItem,"CF2","BSE|VLR",,.F.)
				EndIf
			EndIf
			MaFisVTot(nItem)
			MaFisINSP(nItem)
		Endif
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaFisLF(nItem)
		MaItArred(nItem)
		If cPaisLoc == "BRA"
			MaFisLF(nItem)
		EndIf
	Case  cPaisLoc == "PER" .and. aPos[FP_F1_ADIANT] .and. AllTrim(cCampo) == "IT_ADIANTTOT"
		MaFisImpIV(nItem,cCampo)
		MaFisNameIV(,nItem)
		MaFisVTot(nItem)
		MaItArred(nItem)
	Case Substr(cCampo,1,9) == "IT_BASEIV"
		MaFisVLIV(Ascan(aNFItem[nItem][IT_TS][TS_SFC],{|x| Substr(x[10],10,1) == Substr(cCampo,10,1)}),nItem)
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case Substr(cCampo,1,8) == "IT_VALIV"
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case AllTrim(cCampo) == "IT_AUTONOMO"
		If Empty( aNFItem[nItem,IT_ALIQICM] )
			MaAliqIcms(nItem)
		EndIf
		MaMargem(nItem)
		MaFisBSSOL(nItem)
		MaFisVSol(nItem)
		MaFisICA(nItem)
		MaFisTST(nItem)
		MaFisVTot(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case AllTrim(cCampo) == "IT_BASEICA"
		MaFisICA(nItem)
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case AllTrim(cCampo) == "IT_VALICA"
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case AllTrim(cCampo) == "IT_BASETST"
		MaFisTST(nItem,"ALQ|VLR")
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case AllTrim(cCampo) == "IT_VALTST"
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case AllTrim(cCampo) == "IT_ALIQTST"
		MaFisTST(nItem,"BSE|VLR")
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case AllTrim(cCampo) == "IT_FUNRURAL"
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case AllTrim(cCampo) == "NF_NATUREZA"
		If cPaisLoc == "BRA"
			MaFisISS(nItem,"ALQ")
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisPIS(nItem,"PS2")
				MaFisCOFINS(nItem,"CF2")
				MaFisSEST(nItem)
				If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
					MaFisIPI(nItem,"BSE|VLR")
					If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVComp(nItem)
					ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVDescZF(nItem)
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
					EndIf
					MaFisBSSol(nItem)
					MaFisVSol(nItem)
				EndIf
			EndIf
			MaFisVTot(nItem)
			MaFisINSS(nItem)
			MaFisIR(nItem,,dVencReal)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisCOFINS(nItem,"COF")
				MaFisPIS(nItem,"PIS")
			EndIf
			MaFisCSLL(nItem)
			MaFisCOFINS(nItem,"CF3")
			MaFisISS(nItem)
			MaFisISSBi(nItem)
			MaFisVTot(nItem)
			MaFisINSP(nItem)
			MaFisPIS(nItem,"PS3")
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaFisLF(nItem)
		MaItArred(nItem)
		If cPaisLoc == "BRA"
			MaFisLF(nItem)
		Endif
		MaFisCIDE(nItem)
		MaFisFMPEQ(nItem)
	Case AllTrim(cCampo) == "IT_TES"

		// P/ Brasil a MaFisCFO eh chamada antes da MaExcecao
		// pois pode acontecer das UF's de origem/destino serem
		// alteradas (venda presencial). Entao soh posso enquadrar
		// a excecao depois desta funcao.
		If cPaisLoc == "BRA"
			MaFisCFO(nItem)
			MaExcecao( nItem , cCampo )
			MaFisPreCalc(nItem,cCampo)
		Else
			MaFisPreCalc(nItem,cCampo)
			MaFisCFO(nItem)
		EndIf

		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C" )
				MaFisFECP( nItem , "IT_TES" )
			EndIf
			MaFisTPDP(nItem)
			If (aNFItem[nItem][IT_TS][TS_AGREG]$"B") .And. aSX6[MV_ESTADO] $ aSX6[MV_TIPOB] // FNC 000000193742010 SIGAEIC Protocolo ICMS 99, DE 14 DE DEZEMBRO DE 2007, para que as movimentações geradas pelo EIC, ao utilizar no TES o campo Agrega valor como B que calcule.o ICMS ST.
				MaMargem(nItem)
				MaFisBSSol(nItem)
				MaAliqSoli(nItem)
				MaFisVSol(nItem)
			EndIf
			If ( ( Empty(aNFItem[nItem,IT_ALIQICM] ) .Or. aNFItem[nItem][IT_TS][TS_ICM]=="N") .And. !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C" ) )
				MaAliqIcms(nItem)
			EndIf
			If (Empty( aNFItem[nItem,IT_ALIQIPI] ) .Or. aNFItem[nItem][IT_TS][TS_IPI]=="N") .And. !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C" )
				MaFisIPI(nItem,"ALQ")
			EndIf
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C" ) .Or. ((!Empty(aNFItem[nItem][IT_TS][TS_ISEFECP]) .And. !Empty(aNFItem[nItem][IT_TS][TS_FECPANT]) .And. aNFItem[nItem][IT_TS][TS_ISEFECP]<>aNFItem[nItem][IT_TS][TS_FECPANT]))
				MaALIQCMP(nItem)
				MaAliqSoli(nItem)
			Endif
			MaFisISS(nItem,"ALQ")
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaMargem(nItem)
				MaFisIPI(nItem,"BSE|VLR")
				MaFisBSICM(nItem)
				MaFisVICMS(nItem)
				MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
				MaFisVComp(nItem)
				if aSX6[MV_SOMAICM]
					MaFisBSICM(nItem)
					MaFisVICMS(nItem)
					MaFisIPI(nItem,"BSE|VLR")
				endif
			Else
				MaFisIPI(nItem,"")
			Endif
			MaFisVDescZF(nItem)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C" )
				MaFisBSSOL(nItem)
				MaFisVSOL(nItem)
				MaALIQCMP(nItem)
				MaFisICA(nItem)
				MaFisTST(nItem)
			EndIf
			If cPaisLoc == "BRA" .And. !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisCOFINS(nItem,"CF2","ALQ")
				MaFisPIS(nItem,"PS2")
				MaFisCOFINS(nItem,"CF2")
				If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
					MaFisIPI(nItem,"BSE|VLR")
					If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVComp(nItem)
					ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVDescZF(nItem)
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
					EndIf
					MaFisBSSol(nItem)
					MaFisVSol(nItem)
				Else
					If (aNFItem[nItem][IT_TS][TS_AGRPIS]=="P" .Or. aNFItem[nItem][IT_TS][TS_AGRCOF]=="C") .And. !aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"
						MaFisBSICM(nItem)
						MaFisVICMS(nItem)
						MaFisBSSOL(nItem)
						MaFisVSOL(nItem)
					EndIf
				EndIf
			EndIf
			MaFisRURAL(nItem)
			MaFisVSul(nItem)
			MaFisSENAR(nItem)
			MaFisAliqIV(,nItem)
			MaFisBSIV(,nItem)
			MaFisVLIV(,nItem)
			MaFisFFF(nItem)			
			MaCodDecl(nItem)			
		Else
			MaFisImpIV(nItem,cCampo)
		Endif
		MaFisNameIV(,nItem)
		If cPaisLoc == "BRA" .And. !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"CF2")
			MaFisPIS(nItem,"PS2")
			If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
				MaFisIPI(nItem,"BSE|VLR")
				If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					MaFisVComp(nItem)
				ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVDescZF(nItem)
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
				EndIf
				MaFisBSSol(nItem)
				MaFisVSol(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		If cPaisLoc == "BRA"
			MaFisINSS(nItem)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisIR(nItem,,dVencReal)
				MaFisCOFINS(nItem,"COF")
				MaFisPIS(nItem,"PIS")
			EndIf
			MaFisCSLL(nItem)
			MaFisSEST(nItem)
			MaFisINSP(nItem)
			MaFisCOFINS(nItem,"CF3")
			MaFisISS(nItem)
			MaFisISSBi(nItem)
			MaFisVTot(nItem)
			MaFisPIS(nItem,"PS3")
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem)
			EndIf
			If aNFItem[nItem][IT_TS][TS_BCPCST] == "1" //Campo que indica se os valores de PIS/COFINS ST entram na base de ICMS-ST
				MaFisBSSOL(nItem)
				MaFisVSol(nItem)
			EndIf
			MaFisVTot(nItem)
			If aNFItem[nItem][IT_TS][TS_OPERSUC]=="1" .And. aNfCab[NF_SIMPSC]<>"1" .And. aNFCab[NF_SIMPNAC]<>"1"
				MaFisCOFINS(nItem,"COF|CF2")
				MaFisPIS(nItem,"PIS|PS2")
				MaFisBsIcm(nItem)
				MaFisVICMS(nItem)
				MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
			Endif
			MaFisCPRB(nItem)
			// Este bloco deve ser sempre o ultimo (Antes de MaFisVTot, MaItArred e MaFisLF).
			If aNfCab[NF_PPDIFAL] .And. aNfCab[NF_OPERNF] == "S" .And. (((aNFItem[nItem][IT_TS][TS_AGREG] == "I" .Or. aNFItem[nItem][IT_TS][TS_AGREG] == "A") .And. !aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"))
				// Se o valor de ICMS for zero refaco as bases passando o parametro "lAgreg" = .F. para
				// que nao seja feita a divisao: (base = base / 1 - Aliq) para que o arredondamento nao
				// acabe acrescentando valores na base que nao correspondem ao valor efetivo do tributo.
				If aNFItem[nItem][IT_VALICM] == 0
					MaFisBSICM(nItem,,,,,.F.)
					MaFisVICMS(nItem)
					MaFisVComp(nItem)
					MaFisPIS(nItem,"PS2","BSE|VLR",,.F.)
					MaFisCOFINS(nItem,"CF2","BSE|VLR",,.F.)
					MaFisVTot(nItem)
				EndIf
			EndIf
		Endif
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaFisLF(nItem)
		MaItArred(nItem)
		If cPaisLoc == "BRA"
			MaFisAFRMM(nItem)
			MaFisLF(nItem)
		EndIf
		MafisCide(nItem)
		MaFisFMPEQ(nItem)
	Case AllTrim(cCampo) == "IT_VALEMB"

		// P/ Brasil a MaFisCFO eh chamada antes da MaExcecao
		// pois pode acontecer das UF's de origem/destino serem
		// alteradas (venda presencial). Entao soh posso enquadrar
		// a excecao depois desta funcao.
		If cPaisLoc == "BRA"
			MaFisCFO(nItem)
			MaExcecao(nItem)
			MaFisPreCalc(nItem)
		Else
			MaFisPreCalc(nItem)
			MaFisCFO(nItem)
		Endif

		If cPaisLoc == "BRA"
			If Empty( aNFItem[nItem,IT_ALIQICM] ) .Or. aNFItem[nItem][IT_TS][TS_ICM]=="N"
				MaAliqIcms(nItem)
			EndIf
			If Empty( aNFItem[nItem,IT_ALIQIPI] ) .Or. aNFItem[nItem][IT_TS][TS_IPI]=="N"
				MaFisIPI(nItem,"ALQ")
			EndIf
			MaALIQCMP(nItem)
			MaAliqSoli(nItem)
			MaMargem(nItem)
			MaFisIPI(nItem,"BSE|VLR")
			MaFisBSICM(nItem)
			MaFisVICMS(nItem)
			MaFisTPDP(nItem)
			If !( aNFItem[nItem][IT_TS][TS_TPIPI]=="B" .Or. (aSX6[MV_IPIBRUT]=="S" .And. aNFItem[nItem][IT_TS][TS_TPIPI] ==" ") ) .And. ( aNFItem[nItem][IT_TS][TS_AGREG]=="D" .Or. aNFItem[nItem][IT_TS][TS_AGREG]=="R" )
				MaFisIPI(nItem,"BSE|VLR")
			EndIf
		Endif
		MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
		If cPaisLoc == "BRA"
			MaFisVComp(nItem)
			MaFisVDescZF(nItem)
			MaFisBSSOL(nItem)
			MaFisVSOL(nItem)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisCOFINS(nItem,"CF2")
				MaFisPIS(nItem,"PS2")
				If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
					MaFisIPI(nItem,"BSE|VLR")
					If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVComp(nItem)
					ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVDescZF(nItem)
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
					EndIf
					MaFisBSSol(nItem)
					MaFisVSol(nItem)
				EndIf
			EndIf
			MaFisICA(nItem)
			MaFisTST(nItem)
			MaFisRURAL(nItem)
			MaFisVSul(nItem)
			MaFisSENAR(nItem)
			MaFisAliqIV(,nItem)
			MaFisBSIV(,nItem)
			MaFisVLIV(,nItem)
		Else
			MaFisImpIV(nItem,cCampo)
		Endif
		MaFisNameIV(,nItem)
		If cPaisLoc == "BRA" .And. !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"CF2")
			MaFisPIS(nItem,"PS2")
			If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
				MaFisIPI(nItem,"BSE|VLR")
				If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					MaFisVComp(nItem)
				ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVDescZF(nItem)
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
				EndIf
				MaFisBSSol(nItem)
				MaFisVSol(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		If cPaisLoc == "BRA"
			MaFisINSS(nItem)
			MaFisIR(nItem,,dVencReal)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisCOFINS(nItem,"COF")
				MaFisPIS(nItem,"PIS")
			EndIf
			MaFisCSLL(nItem)
			MaFisCOFINS(nItem,"CF3")
			MaFisISS(nItem)
			MaFisVTot(nItem)
			MaFisPIS(nItem,"PS3")
			MaFisVTot(nItem)
			MaFisINSP(nItem)
		Endif
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaFisLF(nItem)
		MaItArred(nItem)
		If cPaisLoc == "BRA"
			MaFisLF(nItem)
		Endif
	Case Alltrim(cCampo) == "IT_DESCZF"
		MaFisBSSOL(nItem)
		MaFisVSOL(nItem)
		MaFisICA(nItem)
		MaFisTST(nItem)
		MaFisRURAL(nItem)
		MaFisVSul(nItem)
		MaFisSENAR(nItem)
		If cPaisLoc=="BRA"
			MaFisAliqIV(,nItem)
			MaFisBSIV(,nItem)
			MaFisVLIV(,nItem)
		Else
			MaFisImpIV(nItem,cCampo)
		Endif
		MaFisNameIV(,nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisPIS(nItem,"PS2")
			MaFisCOFINS(nItem,"CF2")
			If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
				MaFisIPI(nItem,"BSE|VLR")
				If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					MaFisVComp(nItem)
				ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
					MaFisBSICM(nItem,,.T.)
					MaFisVICMS(nItem)
					MaFisVDescZF(nItem)
					MaFisPIS(nItem,"PS2")
					MaFisCOFINS(nItem,"CF2")
				EndIf
				MaFisBSSol(nItem)
				MaFisVSol(nItem)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaFisINSS(nItem,"BSE|VLR|RED")
		MaFisIR(nItem,,dVencReal)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C")
			MaFisPIS(nItem,"PIS")
			MaFisCOFINS(nItem,"COF")
		EndIf
		MaFisCSLL(nItem)
		MaFisCOFINS(nItem,"CF3")
		MaFisISS(nItem)
		MaFisVTot(nItem)
		MaFisPIS(nItem,"PS3")
		MaFisINSP(nItem)
		MaFisVTot(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case AllTrim(cCampo) == "IT_BASEDUP"
		MaItArred(nItem)
	Case AllTrim(cCampo) == "IT_VALII"
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisBSICM(nItem)
				MaFisVICMS(nItem)
				MaFisII(nItem)
				MaFisIPI(nItem,"BSE|VLR")
				MaFisVTot(nItem)
				MaFisLF(nItem)
				MaFisPROT(nItem)
				MaFisFEEF(nItem)
				MaItArred(nItem)
				MaFisLF(nItem)
			EndIf
		EndIf
	Case AllTrim(cCampo) == "IT_ALIQII"
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisBSICM(nItem)
				MaFisVICMS(nItem)
				MaFisII(nItem)
				MaFisIPI(nItem,"BSE|VLR")
				MaFisVTot(nItem)
				MaFisLF(nItem)
				MaFisPROT(nItem)
				MaFisFEEF(nItem)
				MaItArred(nItem)
				MaFisLF(nItem)
			EndIf
		EndIf
	Case AllTrim(cCampo) == "IT_CONCEPT"
		If cPaisLoc=="EQU" .or. cPaisLoc=="VEN"
			MaFisPreCalc(nItem)
			MaFisCFO(nItem)
			MaFisImpIV(nItem,cCampo)
			MaFisNameIV(,nItem)
			MaFisVTot(nItem)
			MaItArred(nItem)
		Endif
	Case AllTrim(cCampo) == "IT_BASEPS3"
		If cPaisLoc=="BRA"
			MaFisVTot(nItem)
			MaItArred(nItem)
			MaFisLF(nItem)
		Endif
	Case AllTrim(cCampo) == "IT_VALPS3"
		If cPaisLoc=="BRA"
			MaFisVTot(nItem)
			MaItArred(nItem)
			MaFisLF(nItem)
		Endif
	Case AllTrim(cCampo) == "IT_BASECF3"
		If cPaisLoc=="BRA"
			MaFisVTot(nItem)
			MaItArred(nItem)
			MaFisLF(nItem)
		Endif
	Case AllTrim(cCampo) == "IT_VALCF3"
		If cPaisLoc=="BRA"
			MaFisVTot(nItem)
			MaItArred(nItem)
			MaFisLF(nItem)
		Endif
	Case AllTrim(cCampo) == "IT_VALCMAJ"
		If cPaisLoc == "BRA"
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem, "IT_VALCMAJ")
				MaFisVTot(nItem)
				MaItArred(nItem)
				MaFisLF(nItem)
			EndIf
		EndIf
	Case AllTrim(cCampo) == "IT_TRIBMU"
		MaFisLF(nItem)
	Case AllTrim(cCampo) == "IT_PRCMEDP"
		If	cPaisLoc == "BRA"
			MaFisBSSol(nItem)
			MaFisVSol(nItem)
			MaFisVTot(nItem)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisCOFINS(nItem,"CF2")
				MaFisPIS(nItem,"PS2")
			EndIf
			MaFisINSS(nItem,"BSE|VLR")
			MaFisIR(nItem,"BSE|VLR",dVencReal)
			MaFisINSP(nItem)
			MaFisLF(nItem)
			MaFisPROT(nItem)
			MaFisFEEF(nItem)
			MaFisLF(nItem)
			MaItArred(nItem)
			MaFisLF(nItem)
			MaFisSEST(nItem)
		EndIf
	Case (AllTrim(cCampo) == "IT_VALPEDG")
		MaFisBSICM(nItem,,.T.)
		MaFisVICMS(nItem)
		MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
		MaFisVComp(nItem)
		MaFisBSSol(nItem)
		MaFisVSol(nItem)
		// Este bloco deve ser sempre o ultimo (Antes de MaFisVTot, MaItArred e MaFisLF).
		If aNfCab[NF_PPDIFAL] .And. aNfCab[NF_OPERNF] == "S" .And. (((aNFItem[nItem][IT_TS][TS_AGREG] == "I" .Or. aNFItem[nItem][IT_TS][TS_AGREG] == "A") .And. !aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"))
			// Se o valor de ICMS for zero refaco as bases passando o parametro "lAgreg" = .F. para
			// que nao seja feita a divisao: (base = base / 1 - Aliq) para que o arredondamento nao
			// acabe acrescentando valores na base que nao correspondem ao valor efetivo do tributo.
			If aNFItem[nItem][IT_VALICM] == 0
				MaFisBSICM(nItem,,,,,.F.)
				MaFisVICMS(nItem)
				MaFisVComp(nItem)
				MaFisPIS(nItem,"PS2","BSE|VLR",,.F.)
				MaFisCOFINS(nItem,"CF2","BSE|VLR",,.F.)
			EndIf
		EndIf
		MaFisVTot(nItem)
		MaFisLF(nItem)
		MaFisPROT(nItem)
		MaFisFEEF(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case (AllTrim(cCampo) == "IT_GRPCST")
		MaFisIPI(nItem,"CST")
	Case Alltrim(cCampo) == "IT_BASECID"
		MafisCide(nItem,"BSE")
	Case Alltrim(cCampo) == "IT_VALCIDE"
		MafisCide(nItem,"VLR")
	Case (AllTrim(cCampo) == "IT_ALFCCMP"  .Or.;
	      AllTrim(cCampo) == "IT_VFCPDIF"  .Or.;
	      AllTrim(cCampo) == "IT_ALIQFECP" .Or.;
	      AllTrim(cCampo) == "IT_VALFECP"  .Or.;
	      AllTrim(cCampo) == "IT_BASEDES"  .Or.;
	      AllTrim(cCampo) == "IT_DIFAL")
		MaFisVTot(nItem)
		If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
			MaFisCOFINS(nItem,"CF2")
			MaFisPIS(nItem,"PS2")
		EndIf
		MaItArred(nItem)
		MaFisLF(nItem)
	Case AllTrim(cCampo) == "IT_VALINP"
		MaFisINSP(nItem, "BSE|ALQ")
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	Case AllTrim(cCampo) == "IT_BASEINP" 
		MaFisINSP(nItem, "VLR|ALQ")		
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)		
	Case AllTrim(cCampo) == "IT_TRIBGEN"		
		//Obrigatoriamente precisa especificar o tributo e a referência
		IF Len(aTrbGen) >= 2 .AND. !Empty(aTrbGen[TG_SIGLA]) .And. !Empty(aTrbGen[TG_REFERENCIA])
			If aTrbGen[TG_REFERENCIA] $ "TG_IT_BASE/TG_IT_ALIQUOTA" //Se alterou a base ou alíquota recalculará o valor
				xFisTrbGen(@aNfCab, @aNfItem, nItem, "IT_TRIBGEN", "VLR", aTrbGen[TG_SIGLA], aPos, aDic)
			EndIF
		EndIF
	Case AllTrim(cCampo) == "IT_TPOPER"
		MaFisVTot(nItem)
		MaItArred(nItem)
		MaFisLF(nItem)
	OtherWise
		If cPaisLoc == "BRA"
			MaFisCFO(nItem)
			MaExcecao( nItem , cCampo )
			MaFisPreCalc(nItem,cCampo)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	) .And. (Empty( aNFItem[nItem,IT_ALIQICM] ) .Or. aNfCab[NF_TIPONF] $ "DB" .Or. ;
				"NF_" $ Alltrim(cCampo) .Or. "IT_RECORI" == Alltrim(cCampo) .Or.;
				"IT_PRODUTO" == Alltrim(cCampo) .Or. "IT_GRPTRIB" == Alltrim(cCampo) .Or. ;
				"IT_CLASFIS" == Alltrim(cCampo))
				MaAliqIcms(nItem)
			Endif
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	) .And. (Empty( aNFItem[nItem,IT_ALIQIPI] ) .Or. aNfCab[NF_TIPONF] $ "DB" .Or. ;
				"NF_" $ Alltrim(cCampo) .Or. "IT_RECORI" == Alltrim(cCampo) .Or. ;
				"IT_PRODUTO" == Alltrim(cCampo) .Or. "IT_GRPTRIB" == Alltrim(cCampo)) 
				MaFisIPI(nItem,"ALQ")
			Endif
			MaALIQCMP(nItem)
			MaAliqSoli(nItem)
			MaFisISS(nItem,"ALQ")
			MaFisTPDP(nItem)
			MaMargem(nItem)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisIPI(nItem,"BSE|VLR")
				MaFisBSICM(nItem)
				MaFisVICMS(nItem)
			Else
				MaFisIPI(nItem,"")
			Endif
			If !( aNFItem[nItem][IT_TS][TS_TPIPI]=="B" .Or. (aSX6[MV_IPIBRUT]=="S" .And. aNFItem[nItem][IT_TS][TS_TPIPI] ==" ") ) .And. ( aNFItem[nItem][IT_TS][TS_AGREG]=="D" .Or. aNFItem[nItem][IT_TS][TS_AGREG]=="R")
				MaFisIPI(nItem,"BSE|VLR")
			EndIf
			MaItArred(nItem, { "IT_BASEICM","IT_VALICM" } )
			MaFisVComp(nItem)
			MaFisVDescZF(nItem)
			MaFisBSSOL(nItem)
			If aNFItem[nItem][IT_TS][TS_ISEFEMG] == "2" .And. aNfItem[nItem][IT_ALFECMG] > 0
				MaFisVICMS(nItem)
			EndIf
			MaFisVSOL(nItem)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C" )
				If !(aNFItem[nItem][IT_TS][TS_OPERSUC]=="1" .And. aNfCab[NF_SIMPSC]<>"1" .And. aNFCab[NF_SIMPNAC]<>"1" .And. cCampo#"IT_RECORI")
					MaFisCOFINS(nItem,"CF2")
					MaFisPIS(nItem,"PS2")
				EndIf
				If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
					MaFisIPI(nItem,"BSE|VLR")
					If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVComp(nItem)
					ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVDescZF(nItem)
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
					EndIf
					MaFisBSSol(nItem)
					If aNFItem[nItem][IT_TS][TS_ISEFEMG] == "2" .And. aNfItem[nItem][IT_ALFECMG] > 0
						MaFisVICMS(nItem)
					EndIf
					MaFisVSol(nItem)
				ElseIf aNFItem[nItem][IT_TS][TS_OPERSUC]=="1" .And. aNfCab[NF_SIMPSC]<>"1" .And. aNFCab[NF_SIMPNAC]<>"1"
					MaFisBSICM(nItem)
					MaFisVICMS(nItem)
				EndIf
			EndIf
			MaFisICA(nItem)
			MaFisTST(nItem)
			MaFisRURAL(nItem)
			MaFisVSul(nItem)
			MaFisFFF(nItem)
			MaFisAliqIV(,nItem)
			MaFisBSIV(,nItem)
			MaFisVLIV(,nItem)
			MaFisNameIV(,nItem)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C" )
				If !(aNFItem[nItem][IT_TS][TS_OPERSUC]=="1" .And. aNfCab[NF_SIMPSC]<>"1" .And. aNFCab[NF_SIMPNAC]<>"1")
					MaFisCOFINS(nItem,"CF2")
					MaFisPIS(nItem,"PS2")
				EndIf
				If aNfItem[nItem][IT_DESCZFPIS] <> 0 .Or. aNfItem[nItem][IT_DESCZFCOF] <> 0
					MaFisIPI(nItem,"BSE|VLR")
					If aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS]+aNfItem[nItem][IT_DESCZFCOF]) == 0
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVComp(nItem)
					ElseIf	aNfCab[NF_SUFRAMA] .And. lMVRPCBIZF
						MaFisBSICM(nItem,,.T.)
						MaFisVICMS(nItem)
						MaFisVDescZF(nItem)
						MaFisPIS(nItem,"PS2")
						MaFisCOFINS(nItem,"CF2")
					EndIf
					MaFisBSSol(nItem)
					If aNFItem[nItem][IT_TS][TS_ISEFEMG] == "2" .And. aNfItem[nItem][IT_ALFECMG] > 0
						MaFisVICMS(nItem)
					EndIf
					MaFisVSol(nItem)
				Else
					If (aNFItem[nItem][IT_TS][TS_AGRPIS]=="P" .Or. aNFItem[nItem][IT_TS][TS_AGRCOF]=="C") .And. !aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"
						MaFisBSICM(nItem)
						MaFisVICMS(nItem)
					EndIf
				EndIf
			EndIf
			MaFisVTot(nItem)
			MaFisSENAR(nItem)
			MaFisINSS(nItem)
			MaFisIR(nItem,,dVencReal)
			If !(aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C" ) .And. !(aNFItem[nItem][IT_TS][TS_OPERSUC]=="1" .And. aNfCab[NF_SIMPSC]<>"1" .And. aNFCab[NF_SIMPNAC]<>"1")
				MaFisCOFINS(nItem,"COF")
				MaFisPIS(nItem,"PIS")
			EndIf
			MaFisCSLL(nItem)
			MaFisSEST(nItem)
			MaFisINSP(nItem)
			MaFisBSSOL(nItem)
			If aNFItem[nItem][IT_TS][TS_ISEFEMG] == "2" .And. aNfItem[nItem][IT_ALFECMG] > 0
				MaFisVICMS(nItem)
			EndIf
			MaFisVSol(nItem)
			MaFisVTot(nItem)
			MaFisCOFINS(nItem,"CF3")
			MaFisISS(nItem)
			MaFisISSBi(nItem)
			MaFisPIS(nItem,"PS3")
			MaFisVTot(nItem)
			If aNFItem[nItem][IT_TS][TS_BCPCST] == "1" //Campo que indica se os valores de PIS/COFINS ST entram na base de ICMS-ST
				MaFisBSSOL(nItem)
				If aNFItem[nItem][IT_TS][TS_ISEFEMG] == "2" .And. aNfItem[nItem][IT_ALFECMG] > 0
					MaFisVICMS(nItem)
				EndIf
				MaFisVSol(nItem)
			EndIf
			MaFisCPRB(nItem)
			MaCodDecl(nItem)
			// Este bloco deve ser sempre o ultimo (Antes de MaFisVTot, MaItArred e MaFisLF).
			If aNfCab[NF_PPDIFAL] .And. aNfCab[NF_OPERNF] == "S" .And. (((aNFItem[nItem][IT_TS][TS_AGREG] == "I" .Or. aNFItem[nItem][IT_TS][TS_AGREG] == "A") .And. !aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"))
				// Se o valor de ICMS for zero refaco as bases passando o parametro "lAgreg" = .F. para
				// que nao seja feita a divisao: (base = base / 1 - Aliq) para que o arredondamento nao
				// acabe acrescentando valores na base que nao correspondem ao valor efetivo do tributo.
				If aNFItem[nItem][IT_VALICM] == 0
					MaFisBSICM(nItem,,,,,.F.)
					MaFisVICMS(nItem)
					MaFisVComp(nItem)
					MaFisPIS(nItem,"PS2","BSE|VLR",,.F.)
					MaFisCOFINS(nItem,"CF2","BSE|VLR",,.F.)
				EndIf
			EndIf
			MaFisVTot(nItem)
			MaFisLF(nItem)
			MaFisPROT(nItem)
			MaFisFEEF(nItem)
			If AllTrim(cCampo) == "IT_PRODUTO"
				MaFisCide(nItem)				
			EndIf			
			MaItArred(nItem)
			MaFisAFRMM(nItem)
			If !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C"	)
				MaFisII(nItem)
			EndIf
			MaFisLF(nItem)
			MaFisFMPEQ(nItem)			
		Else
			MaFisPreCalc(nItem)
			If cPaisLoc <> "ARG"
				MaFisCFO(nItem)
			Endif
			MaFisImpIV(nItem,cCampo)
			MaFisNameIV(,nItem)
			MaFisVTot(nItem)
			MaItArred(nItem)
		EndIf
EndCase

//Aqui verifica se existe ao menos uma regra cadastrada na tabela F2B, para chamar função de cálculo dos tributos genéricos.
//Se o ID de carga dos tributos genéricos estiver preenchido, a função não será chamada.
//Se o usuário fez alguma alteração via tela, os valores deos tributos genéricos serão recalculados.
If aNfCab[NF_TEMF2B] .And. AllTrim(cCampo) <> "IT_TRIBGEN" .AND. (Empty(aNfItem[nItem][IT_ID_LOAD_TRBGEN]) .Or. (!Empty(aNfItem[nItem][IT_ID_LOAD_TRBGEN]) .AND. IsInCallStack("VALIDGET")))
	xFisTrbGen(aNfCab, @aNfItem, nItem, cCampo,,, aPos, aDic)
EndIF

Return

/*MaFisTes-Alexandre Lemes -03/01/2013´
Inicializa o codigo da TES utilizada no item
*/
Function MaFisTes(cTes,nRecnoSF4,nItemTes)

Local aArea		:= {}
Local aAreaSFC	:= {}
Local aTmp	    := {}
Local cHistSF4  := ""
Local cConverte := ""
Local cDummy	:= "z"
Local cProvAnt	:= ""
Local nX 	    := 0
Local nSeq		:= 0
Local lOk       := .T.
Local lGera		:= .T.
Local lTotal	:= .F.
Local lAchouWN	:= .F.
Local lSS0 := .F.
Local lSort 	:= !(Type("l120Auto") <> "U" .and. l120Auto)
DEFAULT cTes 	   := ""
DEFAULT nRecnoSF4  := 0

If cTes <> aTes[TS_CODIGO] .Or. ( cPaisLoc == "ARG" .And. IIF(lSort,lNotRemito,lSort) )
	aArea	 := GetArea()
	aAreaSFC := SFC->(GetArea())
	dbSelectArea("SF4")
	If nRecnoSF4 == 0
		dbSetOrder(1)
		MsSeek(xFilial("SF4") + cTes)
		If lHistorico .And. !Empty(cAlsItem)
			If( aNfCab[NF_CLIFOR]=="C" .And. aNfCab[NF_TIPONF]<>"D") .Or.( aNfCab[NF_CLIFOR]=="F" .And. aNfCab[NF_TIPONF]$"D|B")
		   		cHistSF4 := (cAlsItem)->D2_IDSF4
			Else
				cHistSF4 := (cAlsItem)->D1_IDSF4
			End
			If  cPaisLoc == "BRA" .And. Alltrim(SF4->F4_IDHIST)<>Alltrim(cHistSF4)
				dbSelectArea("SS0")
				dbSetOrder(1)
				MsSeek(xFilial("SS0")+cHistSF4+cTes)
				lSS0 := .T.
			EndIf
		EndIf
	Else
		MsGoto(nRecnoSF4)
	EndIf

	lOk := !Empty(cTes)
	aTes[TS_SFC]	 := {}
	aTes[TS_LANCFIS] := {}

	aTes[TS_CODIGO]  := IIf(lOk, IIf(!lSS0, SF4->F4_CODIGO  , SS0->S0_CODIGO)  , CriaVar("F4_CODIGO",.F.) )
	aTes[TS_TIPO]	 := IIf(lOk, IIf(!lSS0, SF4->F4_TIPO    , SS0->S0_TIPO)    , aNfCab[NF_OPERNF] )
	aTes[TS_ICM]	 := IIf(lOk .And. cPaisLoc == "BRA"        , IIf(!lSS0, SF4->F4_ICM    , SS0->S0_ICM)     , IIf( cPaisLoc=="BRA",IIf(aSX6[MV_INITES]==.T.,"N","S"),"N")  )
	aTes[TS_IPI]	 := IIf(lOk .And. cPaisLoc == "BRA"        , IIf(!lSS0, SF4->F4_IPI    , SS0->S0_IPI)     , IIf( cPaisLoc=="BRA",IIf(aSX6[MV_INITES]==.T.,"N","S"),"N")  )
	aTes[TS_CREDICM] := IIf(lOk, IIf(!lSS0, SF4->F4_CREDICM, SS0->S0_CREDICM) , "S")
	aTes[TS_CREDIPI] := IIf(lOk, IIf(!lSS0, SF4->F4_CREDIPI,SS0->S0_CREDIPI), "N")
	aTes[TS_DUPLIC]	 := IIf(lOk , IIf(!lSS0, SF4->F4_DUPLIC , SS0->S0_DUPLIC)  , "S")
	aTes[TS_ESTOQUE] := IIf(lOk , IIf(!lSS0, SF4->F4_ESTOQUE, SS0->S0_ESTOQUE) , "S")
	aTes[TS_CF]		 := IIf(lOk, IIf(!lSS0, SF4->F4_CF     , SS0->S0_CF)      , IIf(aNfCab[NF_OPERNF] == "E","111","511") )
	aTes[TS_TEXTO]	 := IIf(lOk  , IIf(!lSS0, SF4->F4_TEXTO  , SS0->S0_TEXTO)   , CriaVar("F4_TEXTO",.F.) )
	aTes[TS_BASEICM] := IIf(lOk , IIf(!lSS0, SF4->F4_BASEICM, SS0->S0_BASEICM) , 0)
	aTes[TS_BASEIPI] := IIf(lOk, IIf(!lSS0, SF4->F4_BASEIPI, SS0->S0_BASEIPI) , 0)
	aTes[TS_PODER3]	 := IIf(lOk , IIf(!lSS0, SF4->F4_PODER3 , SS0->S0_PODER3)  , "N")
	aTes[TS_LFICM]   := IIf(lOk, IIf(!lSS0, SF4->F4_LFICM  , SS0->S0_LFICM )  , IIf(aSX6[MV_INITES]==.T.,"N","T") )
	aTes[TS_LFIPI]	 := IIf(lOk , IIf(!lSS0, SF4->F4_LFIPI  , SS0->S0_LFIPI)   , IIf(aSX6[MV_INITES]==.T.,"N","T") )
	aTes[TS_DESTACA] := IIf(lOk , IIf(!lSS0, SF4->F4_DESTACA, SS0->S0_DESTACA) , "N")
	aTes[TS_INCIDE]	 := IIf(lOk , IIf(!lSS0, SF4->F4_INCIDE , SS0->S0_INCIDE)  , "N")
	aTes[TS_COMPL]	 := IIf(lOk , IIf(!lSS0, SF4->F4_COMPL  , SS0->S0_COMPL)   , "N")
	aTes[TS_IPIFRET] := IIf(lOk, IIf(!lSS0, SF4->F4_IPIFRET, SS0->S0_IPIFRET) , "N")
	aTes[TS_ISS]	 := IIf(lOk, IIf(!lSS0, SF4->F4_ISS    , SS0->S0_ISS)     , " ")
	aTes[TS_LFISS]	 := IIF(lOk .And. aPos[FP_F4_LFISS]   , IIf(!lSS0, SF4->F4_LFISS  , SS0->S0_LFISS)   , " ")
	aTes[TS_NRLIVRO] := IIf(lOk, IIf(!lSS0, SF4->F4_NRLIVRO, SS0->S0_NRLIVRO) , " ")
	aTes[TS_UPRC]	 := IIf(lOk, IIf(!lSS0, SF4->F4_UPRC   , SS0->S0_UPRC)    , " ")
	aTes[TS_CONSUMO] := IIf(lOk, IIf(!lSS0, SF4->F4_CONSUMO, SS0->S0_CONSUMO) , " ")
	aTes[TS_FORMULA] := IIf(lOk, IIf(!lSS0, SF4->F4_FORMULA, SS0->S0_FORMULA) , " ")
	aTes[TS_AGREG]	 := IIf(lOk, IIf(!lSS0, SF4->F4_AGREG  , SS0->S0_AGREG)   , " ")
	aTes[TS_AGRDRED] := IIf(lOk .And. aPos[FP_F4_AGRDRED] .And. !Empty(IIf(!lSS0, SF4->F4_AGRDRED, SS0->S0_AGRDRED)),  IIf(!lSS0, SF4->F4_AGRDRED, SS0->S0_AGRDRED) , "2")
	aTes[TS_INCSOL]	 := IIf(lOk .And. aPos[FP_F4_INCSOL] , IIf(!lSS0, SF4->F4_INCSOL , SS0->S0_INCSOL)   , " ")
	aTes[TS_CIAP]	 := IIf(lOk , IIf(!lSS0, SF4->F4_CIAP   , SS0->S0_CIAP)    , " ")
	aTes[TS_DESPIPI] := IIf(lOk , IIf(!lSS0, SF4->F4_DESPIPI, SS0->S0_DESPIPI) , "N")
	aTes[TS_ATUTEC]	 := IIf(lOk , IIf(!lSS0, SF4->F4_ATUTEC , SS0->S0_ATUTEC)  , " ")
	aTes[TS_ATUATF]	 := IIf(lOk, IIf(!lSS0, SF4->F4_ATUATF , SS0->S0_ATUATF)  , " ")
	aTes[TS_TPIPI]	 := IIf(lOk, IIf(!lSS0, SF4->F4_TPIPI  , SS0->S0_TPIPI)   , "B")
	aTes[TS_LIVRO]	 := IIf(lOk, IIf(!lSS0, SF4->F4_LIVRO  , SS0->S0_LIVRO)   , "")
	aTes[TS_STDESC]	 := IIf(lOk, IIf(!lSS0, SF4->F4_STDESC , SS0->S0_STDESC)  , " ")
	aTes[TS_DESPICM] := IIf(lOk, IIf(!lSS0, SF4->F4_DESPICM, SS0->S0_DESPICM) , "2")
	aTes[TS_DESPPIS] := IIf(lOk .And. aPos[FP_F4_DESPPIS] , IIf(!lSS0, SF4->F4_DESPPIS, SS0->S0_DESPPIS) , "1")
	aTes[TS_DESPCOF] := IIf(lOk .And. aPos[FP_F4_DESPCOF] , IIf(!lSS0, SF4->F4_DESPCOF, SS0->S0_DESPCOF) , "1")
	aTes[TS_BSICMST] := IIf(lOk .And. aPos[FP_F4_BSICMST] , IIf(!lSS0, SF4->F4_BSICMST, SS0->S0_BSICMST) , 0)
	aTes[TS_BASEISS] := IIf(lOk .And. aPos[FP_F4_BASEISS] , IIf(!lSS0, SF4->F4_BASEISS, SS0->S0_BASEISS) , 0)
	aTes[TS_IPILICM] := IIf(lOk , IIf(!lSS0, SF4->F4_IPILICM, SS0->S0_IPILICM) , "2")
	aTes[TS_ICMSDIF] := IIf(lOk, IIf(!lSS0, SF4->F4_ICMSDIF, SS0->S0_ICMSDIF) , "2")
	aTes[TS_QTDZERO] := IIf(lOk , IIf(!lSS0, SF4->F4_QTDZERO, SS0->S0_QTDZERO) , "2")
	aTes[TS_TRFICM]  := IIf(lOk .And. aPos[FP_F4_TRFICM]  , IIf(!lSS0, SF4->F4_TRFICM , SS0->S0_TRFICM)  , "2")
	aTes[TS_OBSICM]  := IIf(lOk .And. aPos[FP_F4_OBSICM]  , IIf(!lSS0, SF4->F4_OBSICM , SS0->S0_OBSICM)  , "2")
	aTes[TS_OBSSOL]  := IIf(lOk .And. aPos[FP_F4_OBSSOL]  , IIf(!lSS0, SF4->F4_OBSSOL , SS0->S0_OBSSOL)  , "2")
	aTES[TS_PICMDIF] := IIf(lOk .And. aPos[FP_F4_PICMDIF] , IIf(!lSS0, SF4->F4_PICMDIF, SS0->S0_PICMDIF) , 0)
	aTES[TS_PISCRED] := IIf(lOk .And. aPos[FP_F4_PISCRED] , IIf(!lSS0, SF4->F4_PISCRED, SS0->S0_PISCRED) , "3")
	aTES[TS_PISCOF]  := IIf(lOk .And. aPos[FP_F4_PISCOF]  , IIf(!lSS0, SF4->F4_PISCOF , SS0->S0_PISCOF)  , "4")
	aTes[TS_CREDST]  := IIf(lOk .And. aPos[FP_F4_CREDST]  , IIf(!lSS0, SF4->F4_CREDST , SS0->S0_CREDST)  , "2")
	aTes[TS_BASEPIS] := IIf(lOk .And. aPos[FP_F4_BASEPIS] , IIf(!lSS0, SF4->F4_BASEPIS, SS0->S0_BASEPIS) , 0)
	aTes[TS_BASECOF] := IIf(lOk .And. aPos[FP_F4_BASECOF] , IIf(!lSS0, SF4->F4_BASECOF, SS0->S0_BASECOF) , 0)
	aTes[TS_ICMSST]  := IIf(lOk .And. aPos[FP_F4_ICMSST]  , IIf(!lSS0, SF4->F4_ICMSST , SS0->S0_ICMSST)  , "1")
	aTes[TS_ISSST]   := IIf(lOk .And. aPos[FP_F4_ISSST]   , IIf(!lSS0, SF4->F4_ISSST  , SS0->S0_ISSST)   , "1")
	aTes[TS_AGRPIS]  := IIf(lOk .And. aPos[FP_F4_AGRPIS]  , IIf(!lSS0, SF4->F4_AGRPIS , SS0->S0_AGRPIS)  , "2")
	aTes[TS_AGRCOF]  := IIf(lOk .And. aPos[FP_F4_AGRCOF]  , IIf(!lSS0, SF4->F4_AGRCOF , SS0->S0_AGRCOF)  , "2")
	aTes[TS_AGRRETC] := IIf(lOk .And. aPos[FP_F4_AGRRETC] , IIf(!lSS0, SF4->F4_AGRRETC, SS0->S0_AGRRETC) , "2")
	aTes[TS_PISBRUT] := IIf(lOk .And. aPos[FP_F4_PISBRUT] , IIf(!lSS0, SF4->F4_PISBRUT, SS0->S0_PISBRUT) , "2")
	aTes[TS_COFBRUT] := IIf(lOk .And. aPos[FP_F4_COFBRUT] , IIf(!lSS0, SF4->F4_COFBRUT, SS0->S0_COFBRUT) , "2")
	aTes[TS_PISDSZF] := IIf(lOk .And. aPos[FP_F4_PISDSZF] , IIf(!lSS0, SF4->F4_PISDSZF, SS0->S0_PISDSZF) , "2")
	aTes[TS_COFDSZF] := IIf(lOk .And. aPos[FP_F4_COFDSZF] , IIf(!lSS0, SF4->F4_COFDSZF, SS0->S0_COFDSZF) , "2")
	aTes[TS_CRDEST]  := IIf(lOk .And. aPos[FP_F4_CRDEST]  , IIf(!lSS0, SF4->F4_CRDEST , SS0->S0_CRDEST)  , "1")
	aTes[TS_CRDPRES] := IIf(lOk .And. aPos[FP_F4_CRDPRES] , IIf(!lSS0, SF4->F4_CRDPRES, SS0->S0_CRDPRES) , 0)
	aTes[TS_AFRMM]	 := IIf(lOk .And. aPos[FP_F4_AFRMM]   , IIf(!lSS0, SF4->F4_AFRMM  , SS0->S0_AFRMM)   , "N")
	aTes[TS_CRDTRAN] := IIf(lOk .And. aPos[FP_F4_CRDTRAN] , IIf(!lSS0, SF4->F4_CRDTRAN, SS0->S0_CRDTRAN) , 0)
	aTes[TS_CALCFET] := IIf(lOk .And. aPos[FP_F4_CALCFET] , IIf(!lSS0, SF4->F4_CALCFET, SS0->S0_CALCFET) , "2")
	aTes[TS_DESCOND] := IIf(lOk .And. aPos[FP_F4_DESCOND] , IIf(!lSS0, SF4->F4_DESCOND, SS0->S0_DESCOND) , "2")
	aTes[TS_CRPREPR] := IIf(lOk .And. aPos[FP_F4_CRPREPR] , IIf(!lSS0, SF4->F4_CRPREPR, SS0->S0_CRPREPR) , 0)
	aTes[TS_INTBSIC] := IIf(lOk .And. aPos[FP_F4_INTBSIC] , IIf(!lSS0, SF4->F4_INTBSIC, SS0->S0_INTBSIC) , "0")
	aTes[TS_OPERSUC] := IIf(lOk .And. aPos[FP_F4_OPERSUC] , IIf(!lSS0, SF4->F4_OPERSUC, SS0->S0_OPERSUC) , "2")
	aTes[TS_CREDACU] := IIf(lOk .And. aPos[FP_F4_CREDACU] , IIf(!lSS0, SF4->F4_CREDACU, SS0->S0_CREDACU) , "3")
	aTes[TS_CRPRERO] := IIf(lOk .And. aPos[FP_F4_CRPRERO] , IIf(!lSS0, SF4->F4_CRPRERO, SS0->S0_CRPRERO) , 0)
	aTes[TS_APLIRED] := IIf(lOk .And. aPos[FP_F4_APLIRED] , IIf(!lSS0, SF4->F4_APLIRED, SS0->S0_APLIRED) , "2")
	aTes[TS_APLIIVA] := IIf(lOk .And. aPos[FP_F4_APLIIVA] , IIf(!lSS0, SF4->F4_APLIIVA, SS0->S0_APLIIVA) , "2")
	aTes[TS_APLREDP] := IIf(lOk .And. aPos[FP_F4_APLREDP] , IIf(!lSS0, SF4->F4_APLREDP, SS0->S0_APLREDP) , "2")
	aTes[TS_CRPREPE] := IIf(lOk .And. aPos[FP_F4_CRPREPE] , IIf(!lSS0, SF4->F4_CRPREPE, SS0->S0_CRPREPE) , 0)
	aTes[TS_CPRESPR] := IIf(lOk .And. aPos[FP_F4_CPRESPR] , IIf(!lSS0, SF4->F4_CPRESPR, SS0->S0_CPRESPR) , 0)
	aTes[TS_CALCFAB] := Iif(lOk .And. aPos[FP_F4_CFABOV]  , IIf(!lSS0, SF4->F4_CFABOV , SS0->S0_CFABOV)  , "2")
	aTes[TS_CALCFAC] := Iif(lOk .And. aPos[FP_F4_CFACS]   , IIf(!lSS0, SF4->F4_CFACS  , SS0->S0_CFACS)   , "2")
	aTes[TS_CRPRESP] := IIf(lOk .And. aPos[FP_F4_CRPRESP] , IIf(!lSS0, SF4->F4_CRPRESP, SS0->S0_CRPRESP) , 0)
	aTes[TS_MOTICMS] := IIf(lOk .And. aPos[FP_F4_MOTICMS] , IIf(!lSS0, SF4->F4_MOTICMS, SS0->S0_MOTICMS) , " ")
	aTes[TS_DUPLIST] := IIf(lOk .And. aPos[FP_F4_DUPLIST] , IIf(!lSS0, SF4->F4_DUPLIST, SS0->S0_DUPLIST) , "2")
	aTes[TS_PR35701] := IIf(lOk .And. aPos[FP_F4_PR35701] , IIf(!lSS0, SF4->F4_PR35701, SS0->S0_PR35701) , 0)
	aTes[TS_CODBCC]  := IIf(lOk .And. aPos[FP_F4_CODBCC]  , IIf(!lSS0, SF4->F4_CODBCC , SS0->S0_CODBCC)  , " ")
	aTes[TS_INDNTFR] := IIf(lOk .And. aPos[FP_F4_INDNTFR] , IIf(!lSS0, SF4->F4_INDNTFR, SS0->S0_INDNTFR) , " ")
	aTes[TS_VENPRES] := IIf(lOk .And. aPos[FP_F4_VENPRES] , IIf(!lSS0, SF4->F4_VENPRES, SS0->S0_VENPRES) , " ")
	aTes[TS_REDBCCE] := IIf(lOk .And. aPos[FP_F4_REDBCCE] , IIf(!lSS0, SF4->F4_REDBCCE, SS0->S0_REDBCCE) , 0)
	aTes[TS_VARATAC] := IIf(lOk .And. aPos[FP_F4_VARATAC] , IIf(!lSS0, SF4->F4_VARATAC, SS0->S0_VARATAC) , "")
	aTes[TS_DUPLIPI] := IIf(lOk .And. aPos[FP_F4_DUPLIPI] , IIf(!lSS0, SF4->F4_DUPLIPI, SS0->S0_DUPLIPI) , "2")
	aTes[TS_AGRPEDG] := IIf(lOk .And. aPos[FP_F4_AGRPEDG] , IIf(!lSS0, SF4->F4_AGRPEDG, SS0->S0_AGRPEDG) , "3")
	aTes[TS_FRETAUT] := IIf(lOk , IIf(!lSS0, SF4->F4_FRETAUT , SS0->S0_FRETAUT) , "1")
	aTes[TS_MKPCMP]  := IIf(lOk , IIf(!lSS0, SF4->F4_MKPCMP  , SS0->S0_MKPCMP)  , "2")
	aTes[TS_CFEXT]   := IIf(lOk , IIf(!lSS0, SF4->F4_CFEXT   , SS0->S0_CFEXT)   , "")
	aTes[TS_MKPSOL]  := IIf(lOk .And. aPos[FP_F4_MKPSOL]  , IIf(!lSS0, SF4->F4_MKPSOL , SS0->S0_MKPSOL)  , "2")
	aTES[TS_LFICMST] := IIf(lOk .And. aPos[FP_F4_LFICMST] , IIf(!lSS0, SF4->F4_LFICMST, SS0->S0_LFICMST) , "N")
	aTES[TS_DESPRDIC]:= IIf(lOk .And. aPos[FP_F4_DSPRDIC] , IIf(!lSS0, SF4->F4_DSPRDIC, SS0->S0_DSPRDIC) , "1")
	aTes[TS_CTIPI]   := IIf(lOk .And. aPos[FP_F4_CTIPI]   , IIf(!lSS0, SF4->F4_CTIPI  , SS0->S0_CTIPI)   , "  ")
	aTes[TS_SITTRIB] := IIf(lOk .And. aPos[FP_F4_SITTRIB] , IIf(!lSS0, SF4->F4_SITTRIB, SS0->S0_SITTRIB) , "  ")
	aTes[TS_CFPS]    := IIf(lOk .And. aPos[FP_F4_CFPS]    , IIf(!lSS0, SF4->F4_CFPS   , SS0->S0_CFPS)    , "")
	aTes[TS_CRPRST]  := IIf(lOk .And. aPos[FP_F4_CRPRST]  , IIf(!lSS0, SF4->F4_CRPRST , SS0->S0_CRPRST)  , 0)
	aTes[TS_IPIOBS]  := IIf(lOk .And. aPos[FP_F4_IPIOBS]  , IIf(!lSS0, SF4->F4_IPIOBS , SS0->S0_IPIOBS)  , "1")
	aTes[TS_IPIPC]   := IIf(lOk .And. aPos[FP_F4_IPIPC]   , IIf(!lSS0, SF4->F4_IPIPC  , SS0->S0_IPIPC)   , "1")
	aTes[TS_PSCFST]	 := IIf(lOk .And. aPos[FP_F4_PSCFST]  , IIf(!lSS0, SF4->F4_PSCFST , SS0->S0_PSCFST)  , "2")
	aTes[TS_CRPRELE] := IIf(lOk .And. aPos[FP_F4_CRPRELE] , IIf(!lSS0, SF4->F4_CRPRELE, SS0->S0_CRPRELE) , 0)
	aTes[TS_CONTSOC] := IIf(lOk .And. aPos[FP_F4_CONTSOC] , IIf(!lSS0, SF4->F4_CONTSOC, SS0->S0_CONTSOC) , "1")
	aTes[TS_COMPRED] := IIf(lOk .And. aPos[FP_F4_COMPRED] .And. !Empty(IIf(!lSS0, SF4->F4_COMPRED, SS0->S0_COMPRED)), IIf(!lSS0, SF4->F4_COMPRED, SS0->S0_COMPRED) , "1")
	aTES[TS_CSTPIS]	 := IIf(lOk .And. aPos[FP_F4_CSTPIS]  , IIf(!lSS0, SF4->F4_CSTPIS , SS0->S0_CSTPIS)  , "")
	aTES[TS_CSTCOF]	 := IIf(lOk .And. aPos[FP_F4_CSTCOF]  , IIf(!lSS0, SF4->F4_CSTCOF , SS0->S0_CSTCOF)  , "")
	aTes[TS_RGESPST] := IIf(lOk .And. aPos[FP_F4_RGESPST] , IIf(!lSS0, SF4->F4_RGESPST, SS0->S0_RGESPST) , "2")
	aTes[TS_CLFDSUL] := IIf(lOk .And. aPos[FP_F4_CLFDSUL] , IIf(!lSS0, SF4->F4_CLFDSUL, SS0->S0_CLFDSUL) , "2")
	aTes[TS_ALSENAR] := IIf(lOk .And. aPos[FP_F4_ALSENAR] , IIf(!lSS0, SF4->F4_ALSENAR, SS0->S0_ALSENAR) , 0)
	aTes[TS_ESTCRED] := IIf(lOk .And. aPos[FP_F4_ESTCRED] , IIf(!lSS0, SF4->F4_ESTCRED, SS0->S0_ESTCRED) , 0)
	aTes[TS_CRPRSIM] := IIf(lOk .And. aPos[FP_F4_CRPRSIM] , IIf(!lSS0, SF4->F4_CRPRSIM, SS0->S0_CRPRSIM) , 0)
	aTes[TS_ANTICMS] := IIf(lOk .And. aPos[FP_F4_ANTICMS] , IIf(!lSS0, SF4->F4_ANTICMS, SS0->S0_ANTICMS) , "2")
	aTes[TS_FECPANT] := IIf(lOk , aTes[TS_ISEFECP], "2")
	aTes[TS_ISEFECP] := IIf(lOk .And. aPos[FP_F4_ISEFECP] , IIf(!lSS0, SF4->F4_ISEFECP, SS0->S0_ISEFECP) , "1")
	aTes[TS_BCPCST]  := IIf(lOk .And. aPos[FP_F4_BCPCST]  , IIf(!lSS0, SF4->F4_BCPCST , SS0->S0_BCPCST)  , "1")
	aTes[TS_REDANT]  := IIf(lOk .And. aPos[FP_F4_REDANT]  , IIf(!lSS0, SF4->F4_REDANT , SS0->S0_REDANT)  , 0)
	aTes[TS_PAUTICM] := IIf(lOk .And. aPos[FP_F4_PAUTICM] , IIf(!lSS0, SF4->F4_PAUTICM, SS0->S0_PAUTICM) , "1")
	aTes[TS_ATACVAR] := IIf(lOk .And. aPos[FP_F4_ATACVAR] , IIf(!lSS0, SF4->F4_ATACVAR, SS0->S0_ATACVAR) , "2")
	aTes[TS_BSRURAL] := IIf(lOk .And. aPos[FP_F4_BSRURAL] , IIf(!lSS0, SF4->F4_BSRURAL, SS0->S0_BSRURAL) , "1")
	aTes[TS_DBSTCSL] := IIf(lOk .And. aPos[FP_F4_DBSTCSL] , IIf(!lSS0, SF4->F4_DBSTCSL, SS0->S0_DBSTCSL) , "2")
	aTes[TS_DBSTIRR] := IIf(lOk .And. aPos[FP_F4_DBSTIRR] , IIf(!lSS0, SF4->F4_DBSTIRR, SS0->S0_DBSTIRR) , "2")
	aTes[TS_CROUTGO] := IIf(lOk .And. aPos[FP_F4_CROUTGO] , IIf(!lSS0, SF4->F4_CROUTGO, SS0->S0_CROUTGO) , 0)
	aTes[TS_STCONF]  := IIf(lOk .And. aPos[FP_F4_STCONF]  , IIf(!lSS0, SF4->F4_STCONF , SS0->S0_STCONF)  , "2")
	aTes[TS_CSTISS]  := IIf(lOk .And. aPos[FP_F4_CSTISS]  , IIf(!lSS0, SF4->F4_CSTISS , SS0->S0_CSTISS)  , "  ")
	aTes[TS_BSRDICM] := IIf(lOk .And. aPos[FP_F4_BSRDICM] , IIf(!lSS0, SF4->F4_BSRDICM, SS0->S0_BSRDICM) , "1")
	aTes[TS_CROUTSP] := IIf(lOk .And. aPos[FP_F4_CROUTSP] , IIf(!lSS0, SF4->F4_CROUTSP, SS0->S0_CROUTSP) , 0)
	aTes[TS_ICMSTMT] := IIf(lOk .And. aPos[FP_F4_ICMSTMT] .And. !Empty(IIf(!lSS0, SF4->F4_ICMSTMT, SS0->S0_ICMSTMT)) , IIf(!lSS0, SF4->F4_ICMSTMT, SS0->S0_ICMSTMT) , "1")
	aTes[TS_CPPRODE] := IIf(lOk .And. aPos[FP_F4_CPPRODE] , IIf(!lSS0, SF4->F4_CPPRODE, SS0->S0_CPPRODE) , 0)
	aTes[TS_TPPRODE] := IIf(lOk .And. aPos[FP_F4_TPPRODE] , IIf(!lSS0, SF4->F4_TPPRODE, SS0->S0_TPPRODE) , " ")
	aTes[TS_VDASOFT] := IIf(lOk .And. aPos[FP_F4_VDASOFT] , IIf(!lSS0, SF4->F4_VDASOFT, SS0->S0_VDASOFT) , "2")
	aTes[TS_ISEFERN] := IIf(lOk .And. aPos[FP_F4_ISEFERN] , IIf(!lSS0, SF4->F4_ISEFERN, SS0->S0_ISEFERN) , "1")
	aTes[TS_NORESPE] := IIf(lOk .And. aPos[FP_F4_NORESP]  , IIf(!lSS0, SF4->F4_NORESP , SS0->S0_NORESP)  , "2")
	aTes[TS_SOMAIPI] := IIf(lOk .And. aPos[FP_F4_SOMAIPI] , IIf(!lSS0, SF4->F4_SOMAIPI, SS0->S0_SOMAIPI) , "1")
	aTes[TS_APSCFST] := IIf(lOk .And. aPos[FP_F4_APSCFST] , IIf(!lSS0, SF4->F4_APSCFST, SS0->S0_APSCFST) , "1")
	aTes[TS_CPRCATR] := IIf(lOk .And. aPos[FP_F4_CPRECTR] , IIf(!lSS0, SF4->F4_CPRECTR, SS0->S0_CPRECTR) , "2")
	aTes[TS_CREDPRE] := IIf(lOk .And. aPos[FP_F4_CREDPRE] , IIf(!lSS0, SF4->F4_CREDPRE, SS0->S0_CREDPRE) , 0)
	aTes[TS_CONSIND] := IIf(lOk .And. aPos[FP_F4_CONSIND] , IIf(!lSS0, SF4->F4_CONSIND, SS0->S0_CONSIND) , "2")
	aTes[TS_ISEFEMG] := IIf(lOk .And. aPos[FP_F4_ISEFEMG] , IIf(!lSS0, SF4->F4_ISEFEMG, SS0->S0_ISEFEMG) , "1")
	aTes[TS_ALQCMAJ] := IIf(lOk .And. aPos[FP_F4_MALQCOF] , IIf(!lSS0, SF4->F4_MALQCOF, SS0->S0_MALQCOF) , 0)
	aTes[TS_ALQPMAJ] := IIf(lOk .And. aPos[FP_F4_MALQPIS] , IIf(!lSS0, SF4->F4_MALQPIS, SS0->S0_MALQPIS) , 0)
	aTes[TS_ISEFEMT] := IIf(lOk .And. aPos[FP_F4_ISEFEMT] , IIf(!lSS0, SF4->F4_ISEFEMT, SS0->S0_ISEFEMT) , "1")
	aTes[TS_IPIANTE] := IIf(lOk .And. aPos[FP_F4_IPIANT]  , IIf(!lSS0, SF4->F4_IPIANT , SS0->S0_IPIANT)  , "2")
	aTes[TS_AGREGCP] := IIf(lOk .And. aPos[FP_F4_AGREGCP] , IIf(!lSS0, SF4->F4_AGREGCP, SS0->S0_AGREGCP) , "1")
	aTes[TS_NATOPER] := Iif(lOk .And. aPos[FP_F4_NATOPER] , IIf(!lSS0, SF4->F4_NATOPER, SS0->S0_NATOPER) , "")
	aTes[TS_TPCPRES] := IIf(lOk .And. aPos[FP_F4_TPCPRES] , IIf(!lSS0, SF4->F4_TPCPRES, SS0->S0_TPCPRES) , "")
	aTes[TS_IDHIST]  := IIf(lOk .And. aPos[FP_F4_IDHIST]  , IIf(!lSS0, SF4->F4_IDHIST , SS0->S0_IDHIST ) , "")
	aTes[TS_DEVPARC] := IIf(lOk .And. aPos[FP_F4_DEVPARC] , IIf(!lSS0, SF4->F4_DEVPARC, SS0->S0_DEVPARC) , "1")
	aTes[TS_PERCATM] := IIf(lOk .And. aPos[FP_F4_PERCATM] , IIf(!lSS0, SF4->F4_PERCATM, SS0->S0_PERCATM) , 0 )
	aTes[TS_DICMFUN] := IIf(lOk .And. aPos[FP_F4_DICMFUN] , IIf(!lSS0, SF4->F4_DICMFUN, SS0->S0_DICMFUN) , "")
	aTes[TS_IMPIND]  := IIf(lOk .And. aPos[FP_F4_IMPIND]  , IIf(!lSS0, SF4->F4_IMPIND , SS0->S0_IMPIND ) , "")
	aTes[TS_OPERGAR] := IIf(lOk .And. aPos[FP_F4_OPERGAR] , IIf(!lSS0, SF4->F4_OPERGAR, SS0->S0_OPERGAR) , "2")
	aTes[TS_FRETISS] := IIf(lOk .And. aPos[FP_F4_FRETISS] , IIf(!lSS0, SF4->F4_FRETISS, SS0->S0_FRETISS) , "1")
	aTes[TS_F4_STLIQ]:= IIf(lOk .And. aPos[FP_F4_STLIQ]   , IIf(!lSS0, SF4->F4_STLIQ  , SS0->S0_STLIQ  ) , "")
	aTes[TS_CV139]   := IIf(lOk .And. aPos[FP_F4_CV139]   , IIf(!lSS0, SF4->F4_CV139  , SS0->S0_CV139  ) , "2")
	aTes[TS_RFETALG] := IIf(lOk .And. aPos[FP_F4_RFETALG] , IIf(!lSS0, SF4->F4_RFETALG, SS0->S0_RFETALG) , "")
	aTes[TS_PARTICM] := IIf(lOk .And. aPos[FP_F4_PARTICM] , IIf(!lSS0, SF4->F4_PARTICM, SS0->S0_PARTICM) , "")
	aTes[TS_BSICMRE] := IIF(lOk .And. aPos[FP_F4_BSICMRE] , IIf(!lSS0, SF4->F4_BSICMRE, SS0->S0_BSICMRE) , "")
	aTes[TS_ALICRST] := IIF(lOk .And. aPos[FP_F4_ALICRST] , IIf(!lSS0, SF4->F4_ALICRST, SS0->S0_ALICRST) , 0)
	aTes[TS_TRANFIL] := IIf(lOk .And. aPos[FP_F4_TRANFIL] , IIf(!lSS0, SF4->F4_TRANFIL, SS0->S0_TRANFIL) , "2")
	aTes[TS_IPIVFCF] := IIf(lOk .And. aPos[FP_IPIVFCF]    , IIf(!lSS0, SF4->F4_IPIVFCF, SS0->S0_IPIVFCF) , "1")
	aTes[TS_RDBSICM] := IIf(lOk .And. aPos[FP_F4_RDBSICM] , IIf(!lSS0, SF4->F4_RDBSICM, SS0->S0_RDBSICM) , "2")
	aTes[TS_CFAMAD]  := IIf(lOk .And. aPos[FP_CFAMAD]     , IIf(!lSS0, SF4->F4_CFAMAD , SS0->S0_CFAMAD ) , "2")
	aTes[TS_DESCISS] := IIf(lOk .And. aPos[FP_F4_DESCISS] , IIf(!lSS0, SF4->F4_DESCISS, SS0->S0_DESCISS) , "1")
	aTes[TS_OUTPERC] := IIf(lOk .And. aPos[FP_F4_OUTPERC] , IIf(!lSS0, SF4->F4_OUTPERC, SS0->S0_OUTPERC) , 0)
	aTes[TS_PISMIN]  := IIf(lOk .And. aPos[FP_F4_PISMIN] , IIf(!lSS0, SF4->F4_PISMIN, SS0->S0_PISMIN) , "2")
	aTes[TS_COFMIN]  := IIf(lOk .And. aPos[FP_F4_COFMIN] , IIf(!lSS0, SF4->F4_COFMIN, SS0->S0_COFMIN) , "2")
	aTes[TS_IPIMIN]  := IIf(lOk .And. aPos[FP_F4_IPIMIN] , IIf(!lSS0, SF4->F4_IPIMIN, SS0->S0_IPIMIN) , "2")
	aTes[TS_CUSENTR] := IIf(lOk .And. aPos[FP_F4_CUSENTR] , IIf(!lSS0, SF4->F4_CUSENTR, SS0->S0_CUSENTR) , "2")
	aTes[TS_GRPCST]  := IIf(lOk .And. aPos[FP_F4_GRPCST] , IIf(!lSS0, SF4->F4_GRPCST, SS0->S0_GRPCST) , "")
	aTes[TS_IPIPECR] := IIf(lOk .And. aPos[FP_F4_IPIPECR] , IIf(!lSS0, SF4->F4_IPIPECR, SS0->S0_IPIPECR) , 0)
	aTes[TS_CALCCPB] := IIf(lOk .And. aPos[FP_F4_CALCCPB] , IIf(!lSS0, SF4->F4_CALCCPB, SS0->S0_CALCCPB) , "2")
	aTes[TS_DIFAL]   := IIf(lOk .And. aPos[FP_F4_DIFAL] , IIf(!lSS0, SF4->F4_DIFAL, SS0->S0_DIFAL) , "")
	aTes[TS_BASCMP]	 := IIf(lOk .And. aPos[FP_F4_BASCMP], IIf(!lSS0, SF4->F4_BASCMP, SS0->S0_BASCMP) , 0)
	aTes[TS_TXAPIPI] := IIf(lOk .And. aPos[FP_F4_TXAPIPI], IIf(!lSS0, SF4->F4_TXAPIPI, SS0->S0_TXAPIPI) , 0)
	aTes[TS_FTRICMS] := IIf(lOk .And. aPos[FP_F4_FTRICMS] , IIf(!lSS0, SF4->F4_FTRICMS, SS0->S0_FTRICMS) , 0)
	aTes[TS_AGRISS]  := IIf(lOk .And. aPos[FP_F4_AGRISS]  , IIf(!lSS0, SF4->F4_AGRISS , SS0->S0_AGRISS)  , "2")
	aTes[TS_CFUNDES] := Iif(lOk .And. aPos[FP_F4_CFUNDES], IIf(!lSS0, SF4->F4_CFUNDES, SS0->S0_CFUNDES), "2")
	aTes[TS_CIMAMT]  := Iif(lOk .And. aPos[FP_F4_CIMAMT], IIf(!lSS0, SF4->F4_CIMAMT, SS0->S0_CIMAMT), "2")
	aTes[TS_CFASE]	 := Iif(lOk .And. aPos[FP_F4_CFASE], IIf(!lSS0, SF4->F4_CFASE, SS0->S0_CFASE), "2")
	aTes[TS_INDVF]   := Iif(lOk .And. aPos[FP_F4_INDVF], IIf(!lSS0, SF4->F4_INDVF, SS0->S0_INDVF), "2")
	aTes[TS_CSOSN]   := IIf(lOk .And. aPos[FP_F4_CSOSN], IIf(!lSS0, SF4->F4_CSOSN, SS0->S0_CSOSN), "   ")
	aTes[TS_ALIQPRO] := IIf(lOk .And. aPos[FP_F4_ALIQPRO], IIf(!lSS0, SF4->F4_ALIQPRO, SS0->S0_ALIQPRO), 0)
	aTes[TS_ALQFEEF] := IIf(lOk .And. aPos[FP_F4_ALQFEEF] , IIf(!lSS0, SF4->F4_ALQFEEF, SS0->S0_ALQFEEF) , 0)
	aTes[TS_DEDDIF]  := IIf(lOk .And. aPos[FP_F4_DEDDIF] , IIf(!lSS0, SF4->F4_DEDDIF, SS0->S0_DEDDIF) , "1")
	aTes[TS_FCALCPR] := IIf(lOk .And. aPos[FP_F4_FCALCPR] , IIf(!lSS0, SF4->F4_FCALCPR, SS0->S0_FCALCPR) , "")
	aTes[TS_DIFALPC] := IIf(lOk .And. aPos[FP_F4_DIFALPC] , IIf(!lSS0, SF4->F4_DIFALPC, SS0->S0_DIFALPC) , "")
	aTes[TS_COLVDIF] := Iif(lOk .AND. aPos[FP_F4_COLVDIF] , Iif(!lSS0, SF4->F4_COLVDIF, SS0->S0_COLVDIF),"" )
	aTes[TS_STREDU] := IIf(lOk .And. aPos[FP_F4_STREDU] , IIf(!lSS0, SF4->F4_STREDU, SS0->S0_STREDU) , "")
	aTes[TS_FEEF] := IIf(lOk .And. aPos[FP_F4_FEEF] , IIf(!lSS0, SF4->F4_FEEF, SS0->S0_FEEF) , "")
	aTes[TS_BICMCMP] := IIf(lOk .And. aPos[FP_F4_BICMCMP] , IIf(!lSS0, SF4->F4_BICMCMP, SS0->S0_F4_BICMCMP) , "")
	aTes[TS_CSENAR]  := IIf(lOk .And. aPos[FP_F4_CSENAR] , IIf(!lSS0, SF4->F4_CSENAR, SS0->S0_CSENAR) , "2")
	aTes[TS_CINSS]   := IIf(lOk .And. aPos[FP_F4_CINSS] , IIf(!lSS0, SF4->F4_CINSS, SS0->S0_CINSS) , "2")
	aTes[TS_APLREPC] := IIf(lOk .And. aPos[FP_F4_APLREPC], IIf(!lSS0, SF4->F4_APLREPC, SS0->S0_APLREPC) , "4")
	aTes[TS_INDISEN] := IIf(lOk .And. aPos[FP_F4_INDISEN], IIf(!lSS0, SF4->F4_INDISEN, SS0->S0_INDISEN) , "2")
	aTes[TS_INFITEM] := IIf(lOk .And. aPos[FP_F4_INFITEM], IIf(!lSS0, SF4->F4_INFITEM, SS0->S0_INFITEM) ,"")
	
	If lOk
		// Inicializa os impostos variaveis
		dbSelectArea("SFC")
		dbSetOrder(1)
		If aSX6[MV_GERIMPV] == "S" .And. !( IsRemito( 1 , "'" + aNFCab[NF_TIPODOC] + "'" ) )
			cTesImp  := SF4->F4_CODIGO
			lAchouWN := .F.
			//Bloco Especifico solicitado pela AVERAGE -FNC 152032 continuação FNC 147106.
			If cPaisLoc <> "BRA"
				If Type("lFacImport") == "L" .And. lFacImport .And. nItemTes <> Nil
					If (SD1->(MsSeek(xFilial("SD1")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA+aNfItem[nItemTes][IT_PRODUTO]+StrZero(nItemTes,TamSX3("D1_ITEM")[1]))))
						If SD1->D1_TIPO_NF $ "5678"
							//Solicitação - Average FNC 152032 continuação FNC 147106
							//Se os campos existirem entro para verificar se estão preenchidos e buscar a referencia da TES na tabela SWN
							If aPos[FP_WN_TES] .And. aPos[FP_WN_ITEMNF]
								SWN->(DbSetOrder(2))
								If SWN->(MsSeek(xFilial("SWN")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA))
									While !SWN->(Eof()) .And.;
										(SWN->WN_FILIAL+SWN->WN_DOC+SWN->WN_SERIE+SWN->WN_FORNECE+SWN->WN_LOJA == xFilial("SWN")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA);
										//Se encontrar a referência do Item e a TES estiver preenchida pego a TES da SWN
										If SWN->WN_PRODUTO+SWN->WN_ITEMNF == SD1->D1_COD+SD1->D1_ITEM .And. !Empty(SWN->WN_TES)
											lAchouWN := .T.
											cTesImp  := SWN->WN_TES
										EndIf
										SWN->(DbSkip())
									EndDo
									//Senão encontrou deixo a referência que existia antes
									If !lAchouWN
										If (SYD->(MsSeek(xFilial("SYD")+SD1->D1_TEC)))
											cTesImp:=SYD->YD_TES
										Endif
									EndIf
								EndIf
							Else
								//Senão os campos não existirem deixo a referência que existia antes
								If (SYD->(MsSeek(xFilial("SYD")+SD1->D1_TEC)))
									cTesImp := SYD->YD_TES
								Endif
							EndIf
						Else
							If aSX6[MV_DESPSD1] == "S" .And. cPaisLoc $ "BRA|ARG|CHI|COL|PER|EQU"
								cTesImp := SD1->D1_TESDES
							Else
								//Solicitação - Average FNC 152032 continuação FNC 147106
								//Se os campos existirem entro para verificar se estão preenchidos e buscar a referencia da TES na tabela SWN
								If aPos[FP_WN_TES] .And. aPos[FP_WN_ITEMNF]
									SWN->(DbSetOrder(2))
									If SWN->(MsSeek(xFilial("SWN")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA))
										While !SWN->(Eof()) .And.;
											(SWN->WN_FILIAL+SWN->WN_DOC+SWN->WN_SERIE+SWN->WN_FORNECE+SWN->WN_LOJA == xFilial("SWN")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA);
											//Se encontrar a referência do Item e a TES estiver preenchida pego a TES da SWN
											If SWN->WN_PRODUTO+SWN->WN_ITEMNF == SD1->D1_COD+SD1->D1_ITEM .And. !Empty(SWN->WN_TES)
												lAchouWN:=.T.
												cTesImp:=SWN->WN_TES
												SFC->(MsSeek(xFilial("SFC")+SWN->WN_TES))
											EndIf
											SWN->(DbSkip())
										End
										//Senão encontrou deixo a referência que existia antes
										If !lAchouWN
											SYD->(MsSeek(xFilial("SYD")+SD1->D1_TEC))
											cTesImp:=SYD->YD_TES
											SFC->(MsSeek(xFilial("SFC")+SYD->YD_TES))
										EndIf
									EndIf
								Else
									//Senão os campos não existirem deixo a referência que existia antes
									SYD->(MsSeek(xFilial("SYD")+SD1->D1_TEC))
									cTesImp:=SYD->YD_TES
									SFC->(MsSeek(xFilial("SFC")+SYD->YD_TES))
								EndIf
							Endif
						Endif
					Endif
				Endif
			Endif

			//Este bloco trata Impostos Variaveis BRASIL e LOCALIZADO - Tabelas SFC e SFB.
			If MsSeek(xFilial("SFC") + cTesImp )
				If nItemTes <> Nil
					cProvAnt := AllTrim(MaFisRet(nItemTes,"IT_PROVENT"))
				Endif

				While !Eof() .And. xFilial("SFC") + cTesImp == SFC->FC_FILIAL + SFC->FC_TES
					If cPaisLoc == "ARG" .And. aPos[FP_FC_PROV] .And. aSX6[MV_TESIB] == .T. .And. Alltrim(Substr(SFC->FC_IMPOSTO,1,2)) == "IB"
						If SFC->FC_PROV == cProvAnt .Or. cProvAnt == "99"
							lGera := .T.
						Else
							lGera := .F.
						Endif
					Else
						lGera := .T.
					Endif

					If lGera
						SFB->(dbSetOrder(1))
						SFB->(MsSeek(xFilial()+SFC->FC_IMPOSTO))
						If Ascan(aTes[TS_SFC],{|x| x[SFC_IMPOSTO]==SFC->FC_IMPOSTO})==0
							Aadd(aTes[TS_SFC],Array(21))
							nSeq := Len(aTes[TS_SFC])
							aTes[TS_SFC][nSeq][SFC_SEQ]			:= SFC->FC_SEQ
							aTes[TS_SFC][nSeq][SFC_IMPOSTO]		:= SFC->FC_IMPOSTO
							aTes[TS_SFC][nSeq][SFC_CALCULO]		:= SFC->FC_CALCULO
							If cPaisLoc == "ARG" .And. aPos[FP_FC_PROV] .And. aSX6[MV_TESIB] == .T.
								aTes[TS_SFC][nSeq][SFC_PROVENT]	:= SFC->FC_PROV
							Endif
							If IsAlpha(SFC->FC_INCDUPL)
								cConverte := SFC->FC_INCDUPL + SFC->FC_INCNOTA + SFC->FC_CREDITA
								aTes[TS_SFC][nSeq][SFC_INCDUPL]	:= IIf(Subs(cConverte,1,2)=="SN".Or.Subs(cConverte,1,2)=="NS","3",;
								IIf(Subs(cConverte,1,2)=="SS","1","2"))
								aTes[TS_SFC][nSeq][SFC_INCNOTA]	:= IIf(Subs(cConverte,2,1)=="S" ,"1",IIf(Subs(cConverte,2,1)=="R" ,"2","3"))
								aTes[TS_SFC][nSeq][SFC_CREDITA]	:= IIf(Subs(cConverte,2,2)=="SN","1",IIf(Subs(cConverte,2,2)=="NS","2","3"))
							Else
								aTes[TS_SFC][nSeq][SFC_INCDUPL]	:= SFC->FC_INCDUPL
								aTes[TS_SFC][nSeq][SFC_INCNOTA]	:= SFC->FC_INCNOTA
								aTes[TS_SFC][nSeq][SFC_CREDITA]	:= SFC->FC_CREDITA
							EndIf
							aTes[TS_SFC][nSeq][SFC_INCIMP]		:= SFC->FC_INCIMP
							aTes[TS_SFC][nSeq][SFC_BASE]		:= SFC->FC_BASE
							aTes[TS_SFC][nSeq][SFB_DESCR]		:= SFB->FB_DESCR
							aTes[TS_SFC][nSeq][SFB_CPOVREI]		:= "D1_VALIMP"+SFB->FB_CPOLVRO
							aTes[TS_SFC][nSeq][SFB_CPOBAEI]		:= "D1_BASIMP"+SFB->FB_CPOLVRO
							aTes[TS_SFC][nSeq][SFB_CPOVREC]		:= "F1_VALIMP"+SFB->FB_CPOLVRO
							aTes[TS_SFC][nSeq][SFB_CPOBAEC]		:= "F1_BASIMP"+SFB->FB_CPOLVRO
							aTes[TS_SFC][nSeq][SFB_CPOVRSI]		:= "D2_VALIMP"+SFB->FB_CPOLVRO
							aTes[TS_SFC][nSeq][SFB_CPOBASI]		:= "D2_BASIMP"+SFB->FB_CPOLVRO
							aTes[TS_SFC][nSeq][SFB_CPOVRSC]		:= "F2_VALIMP"+SFB->FB_CPOLVRO
							aTes[TS_SFC][nSeq][SFB_CPOBASC]		:= "F2_BASIMP"+SFB->FB_CPOLVRO
							aTes[TS_SFC][nSeq][SFB_FORMENT]		:= SFB->FB_FORMENT
							aTes[TS_SFC][nSeq][SFB_FORMSAI]		:= SFB->FB_FORMSAI
							If aPos[FP_FB_DESGR]
								aTes[TS_SFC][nSeq][SFB_DESGR]	:= SFB->FB_DESGR
							EndIf
							Aadd(aTmp,Val(SFB->FB_CPOLVRO))
							If aTes[TS_SFC][nSeq][SFC_CALCULO] == "T"
								lTotal	:=	.T.
							Endif
						Endif
					Endif

					If !(cPaisLoc $ "ARG|MEX|COL") .and. (!empty(aTes[TS_SFC]))
					  aSORT(aTes[TS_SFC],,,{|X,Y| X[SFC_CALCULO]< Y[SFC_CALCULO]})
					ElseIf cPaisLoc == "ARG" .And. (Alltrim(Substr(SFC->FC_IMPOSTO,1,2)) == "IB");
                         .And. (Alltrim(SFC->FC_CALCULO) == "I") .And. (aTes[TS_TIPO] == "E") .and. lSort
                           If !empty(aTes[TS_SFC])
                             aSORT(aTes[TS_SFC],,,{|X,Y| X[SFC_CALCULO]< Y[SFC_CALCULO]})
                           EndIf
                      EndIf
					dbSkip()
				EndDo

				If cPaisLoc == "ARG" .And. lTotal
			//		aSort(aTmp)
					For nX := 1 To Len(aTmp)
						If aTmp[nX] <> nX
							cDummy	:=	Str(nX,1)
							Exit
						Endif
					Next nX

					If cDummy <> "z" .And. Len(aTmp) == 1
						aSize(aTes[TS_SFC],Len(aTes[TS_SFC])+1)
						aIns(aTes[TS_SFC],1)
						aTes[TS_SFC][1]	:=	aClone(aTes[TS_SFC][2])
						aTes[TS_SFC][1][SFC_SEQ]    := "00"
						aTes[TS_SFC][1][SFC_IMPOSTO]:= "DUM"
						aTes[TS_SFC][1][SFC_CALCULO]:= "T"
						aTes[TS_SFC][1][SFB_DESCR]  := "Dummy"
						aTes[TS_SFC][1][SFB_CPOVREI]:= "D1_VALIMP"+cDummy
						aTes[TS_SFC][1][SFB_CPOBAEI]:= "D1_BASIMP"+cDummy
						aTes[TS_SFC][1][SFB_CPOVREC]:= "F1_VALIMP"+cDummy
						aTes[TS_SFC][1][SFB_CPOBAEC]:= "F1_BASIMP"+cDummy
						aTes[TS_SFC][1][SFB_CPOVRSI]:= "D2_VALIMP"+cDummy
						aTes[TS_SFC][1][SFB_CPOBASI]:= "D2_BASIMP"+cDummy
						aTes[TS_SFC][1][SFB_CPOVRSC]:= "F2_VALIMP"+cDummy
						aTes[TS_SFC][1][SFB_CPOBASC]:= "F2_BASIMP"+cDummy
						aTes[TS_SFC][1][SFB_FORMENT]:= "MaFisZero"
						aTes[TS_SFC][1][SFB_FORMSAI]:= "MaFisZero"
						MaFisZero() //Para evitar erro de compilacao
					Endif
				Endif
			Endif
		Else
			aTes[TS_SFC] := {}
		EndIf

		If aDic[AI_CC7] .And. aDic[AI_CC6] .And. TamSx3("CC7_CODLAN")[1] == 10 .And. aPos[FP_CC7_TPREG]
			dbSelectArea("CC7")
			dbSetOrder(1)
			If CC7->(MsSeek(xFilial("CC7")+SF4->F4_CODIGO))
				While !CC7->(Eof()) .And. xFilial("CC7")+CC7->CC7_TES==xFilial("CC7")+SF4->F4_CODIGO
					// Codigos de Ajuste de Documento Fiscal (Tabela CC6)
					If (!(CC7->CC7_TPREG == "NA")) .And. (CC6->(MsSeek(xFilial("CC6")+CC7->CC7_CODLAN)))
						//Somente serao considerados lançamentos da UF do contribuinte
						//Caso o lançamento nao seja de Apuração Propria, o lançamento podera ser de qualquer UF
						If CC6->CC6_STUF == aSX6[MV_ESTADO]  .Or. CC6->CC6_TPAPUR <> "0"
							aAdd( aTes[TS_LANCFIS] ,;
									{	CC7->CC7_CODLAN ,;											// 01 - Codigo de Ajuste
										Iif( aPos[FP_CC7_IFCOMP] , CC7->CC7_IFCOMP , ""  ) ,;	// 02 - Codigo da Informacao Complementar
										Iif( aPos[FP_CC7_CODREF] , CC7->CC7_CODREF , ""  ) ,;	// 03 - Codigo do Reflexo
										Iif( aPos[FP_CC7_CLANC]  , CC7->CC7_CLANC  , ""  ) ,; 	// 04 - Complemento registro 0460
										Iif( aPos[FP_CC7_GUIA]   , CC7->CC7_GUIA	, "2" ) ,;	// 05 - Gera Guia de Recolhimento
										"1"} )	// 06 - Campo com código utilizado na Tes
						EndIf
					// Codigos de Ajuste de Apuracao (Tabela CDO)
					ElseIf Empty( CC7->CC7_CODLAN ) .And. aPos[FP_CC7_CLANAP] .And. !Empty( CC7->CC7_CLANAP )
						aAdd( aTes[TS_LANCFIS] ,;
								{	CC7->CC7_CLANAP ,;
									Iif( aPos[FP_CC7_IFCOMP] , CC7->CC7_IFCOMP , ""  ) ,;
									Iif( aPos[FP_CC7_CODREF] , CC7->CC7_CODREF , ""  ) ,;
									Iif( aPos[FP_CC7_CLANC]  , CC7->CC7_CLANC  , ""  ) ,;
									Iif( aPos[FP_CC7_GUIA]   , CC7->CC7_GUIA	, "2" ),;
									 "2"} )
					ElseIf aPos[FP_CC7_CODIPI] .And. !Empty( CC7->CC7_CODIPI ) .And.  Empty( CC7->CC7_CODLAN ) .And. Empty( CC7->CC7_CLANAP )
						aAdd( aTes[TS_LANCFIS] ,;
								{	CC7->CC7_CODIPI ,;
									Iif( aPos[FP_CC7_IFCOMP] , CC7->CC7_IFCOMP , ""  ) ,;
									Iif( aPos[FP_CC7_CODREF] , CC7->CC7_CODREF , ""  ) ,;
									Iif( aPos[FP_CC7_CLANC]  , CC7->CC7_CLANC  , ""  ) ,;
									Iif( aPos[FP_CC7_GUIA]   , CC7->CC7_GUIA  , "2" ) ,;
									"3"} )
					EndIf
					CC7->(dbSkip())
				EndDo
			EndIf
		EndIf
	EndIf
	RestArea(aAreaSFC)
	RestArea(aArea)

EndIf

cTes := aTes[TS_CODIGO]

If nItemTes <> Nil
	aNfItem[nItemTes][IT_IDSF4] := 	aTes[TS_IDHIST]
EndIf

Return

/*/
MaFisWrite - Edson Maricate -10.01.1999
Verifica arredondamentos para iniciar a gravacao
*/
Function MaFisWrite(nOpc,cArea,nItem,lImpostos,lRemito)

Local aAcDif 	:= Array(Len(aItemRef))
Local aNotasOri := {}
Local nX       	:= 0
Local nY       	:= 0
Local lGravaCpo := .T.
DEFAULT lImpostos:= .F.
DEFAULT lRemito  := .F. //Variavel criada para indicar que impostos nao devem ser gravados (somente despesas)

aFill(aAcDif,0)
Do Case
Case nOpc == 2 // Efetua a gravacao dos campos de impostos.
	dbSelectArea(cArea)
	For nX := 1 to Len(aNfCab[NF_RELIMP])
		If aNfCab[NF_RELIMP][nX][1] == cArea
			Do Case
			Case lImpostos .And. !(Substr(aNfCab[NF_RELIMP][nX][1],4,6) $ "BASIMP*ALQIMP*VALIMP")
				lGravaCpo := .F.
			Case lRemito .And. Substr(aNfCab[NF_RELIMP][nX][1],4,6) $ "BASIMP*ALQIMP*VALIMP"
				lGravaCpo := .F.
			Otherwise
				lGravaCpo := .T.
			EndCase
			If lGravaCpo
				FieldPut(FieldPos(aNfCab[NF_RELIMP][nX][2]),MaFisRet(nItem,aNfCab[NF_RELIMP][nX][3]))
			Endif
		EndIf
	Next nX
OtherWise //Inicia a gravacao e fetua a correcao dos arredondamentos.
	aNfCab[NF_LIVRO] := {}
	For nX := 1 to Len(aNfItem)
		If !aNfItem[nX][IT_DELETED]
			If cPaisLoc=="BRA"
				For nY := 1 to Len(aItemRef)
					If aItemRef[nY][4]
						If ValType(aItemRef[nY][2]) == "A"
							nAcDif := aAcDif[nY]
							nValor := aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]]
							If nValor > 0
								aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] := NoRound(nValor,2,@nAcDif,10)
								aAcDif[nY] := nAcDif
								If NoRound(aAcDif[nY],2) >= 0.01
									aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] += 0.01
									aAcDif[nY] -= 0.01
								EndIf
							EndIf
						Else
							nAcDif := aAcDif[nY]
							nValor := aNfItem[nX][Val(aItemRef[nY][2])]
							If nValor > 0
								aNfItem[nX][Val(aItemRef[nY][2])] := NoRound(nValor,2,@nAcDif,10)
								aAcDif[nY] := nAcDif
								If NoRound(aAcDif[nY],2) >= 0.01
									aNfItem[nX][Val(aItemRef[nY][2])] += 0.01
									aAcDif[nY] -= 0.01
								EndIf
							EndIf
						EndIf
					EndIf
				Next nY
			EndIf
			If cPaisLoc == "BRA" .Or. lNotRemito
				MaFisLFToLivro(nX,@aNotasOri)
			EndIf
		EndIf
	Next nX
	If cPaisLoc == "BRA"
		For nX := 1 To Len(aCabRef)
			If ValType(aCabRef[nX,2]) <> "A"
				nY := Val(aCabRef[nX,2])
				If ValType(aNfCab[nY]) == "N" .And. aCabRef[nX][3]
					aNfCab[nY] := NoRound(aNfCab[nY]+0.00000001,2,,10)
				EndIf
			EndIf
		Next nX
	Endif
EndCase

Return .T.

/*/
MaFisIniNF Rev.   Eduardo Riera  -08.08.2001
Rotina de Inicializacao da funcao fiscal com base nas Notas Fiscais
Esta rotina tem como objetivo atualizar a funcao fiscal com
base em uma nota fiscal de entrada ou saida. A Funcao Fiscal
eh atualizada com base nas referencias do dicionario de dados
Parametros
ExpN1: Tipo de Nota Fiscal
[1] Nota Fiscal de Entrada
[2] Nota Fiscal de Saida
ExpX2: Numero do Registro do Cabecalho da Nota Fiscal, ou o Alias da Tabela a ser considerada
ExpA3: Array para Otimizacao ( Uso Interno deve-se apenas assegurar que seu valor foi amazenado externamente a esta rotina)
ExpC4: Alias da tabela de notas fiscais de entrada (OPC)
ExpL5: Indica se deve ser recalculada a base dos impostos Fiscais (OPC)
/*/
Function MaFisIniNF(nTipoNF,nRecSF,aOtimizacao,cAlias,lReprocess,cFunOrig, lHistFis, cAlsItem2)

Local aArea	   := GetArea()
Local aAreaSD1 := SD1->(GetArea())
Local aAreaSF1 := SF1->(GetArea())
Local aAreaSD2 := SD2->(GetArea())
Local aAreaSF2 := SF2->(GetArea())
Local cAlias2  := ""
Local cCliEnt  := Space(TamSx3("F3_CLIEFOR")[1])
Local cLojEnt  := Space(TamSx3("F3_LOJA")[1])
Local nX	   := 0
Local nY	   := 0
Local nValor   := 0
Local nDesc	   := 0
Local lQuery   := .F.
Local lISS	   := .F.
Local lSoICMS  := .T.
Local lCmpsSN1 := aPos[FP_N1_CSTPIS] .And. aPos[FP_N1_CSTCOFI] .And. aPos[FP_N1_ALIQPIS] .And. aPos[FP_N1_ALIQCOF] .And. aPos[FP_N1_CODBCC]
Local cUfOrig	:= ''
Local cUfDest	:= ''
#IFDEF TOP
	Local aStru := {}
	Local cQuery:= ""
#ENDIF
DEFAULT cFunOrig   := ""
DEFAULT lHistFis   := .F.
DEFAULT lReprocess := .F.
DEFAULT cAlsItem2  := ""

If cFunOrig == "MATA930"
	lHistorico := lHistFis
EndIf

Do Case
	Case nTipoNF == 1
		If Empty(aOtimizacao)
			aOtimizacao := {MaFisSXRef("SF1"),MaFisSxRef("SD1")}
		EndIf

		cAlias2 := "SD1"

		If Empty(cAlias)
			cAlias := "SF1"
			dbSelectArea(cAlias)
			MsGoto(nRecSF)
		EndIf

		If lHistorico
			cAlsCab := cAlias
		EndIf
		MaFisEnd()
		MaFisIni((cAlias)->F1_FORNECE,(cAlias)->F1_LOJA,IIF((cAlias)->F1_TIPO$'DB',"C","F"),(cAlias)->F1_TIPO,,,If((cAlias)->F1_TIPO=="C",AllTrim((cAlias)->F1_ORIGLAN),Nil),,,,,,,,Iif(lReprocess,(cAlias)->F1_RECISS,Nil))

		If (cAlias)->F1_TIPO$"DB" .And. !lReprocess
			MaFisAlt("NF_UFDEST",(cAlias)->F1_EST)
		Else
			MaFisAlt("NF_UFORIGEM",(cAlias)->F1_EST)
		EndIf

		MaFisAlt("NF_ESPECIE",(cAlias)->F1_ESPECIE)

		If lReprocess .And. aNFCab[NF_OPERNF] == "E" .AND. ( AllTrim( aNFCab[NF_ESPECIE] ) $ "CTR/CTE/CTA/CA/CTF" .Or. "NFST" $ AllTrim( aNFCab[NF_ESPECIE] ) )
			//Tratamento do F1_ESTDES
			If (cAlias)->( FieldPos( "F1_ESTDES" ) ) > 0 .And. !Empty( (cAlias)->F1_ESTDES ) 
				MaFisAlt("NF_UFCDEST",(cAlias)->F1_ESTDES)
			Endif			
			
			//Tratamento dos campos F1_UFORITR e F1_UFDESTR
			//Se F1_UFORITR e/ou F1_UFDESTR estiverem preenchidos terão prioridade, se não então considerarei os NF_UFORIGEM e NF_UFDEST já carregados
			cUFOrig	:= Alltrim( Iif( (cAlias)->(FieldPos("F1_UFORITR") ) > 0 .And. !Empty( (cAlias)->F1_UFORITR ) , (cAlias)->F1_UFORITR , aNFCab[NF_UFORIGEM] ) )
			cUfDest	:= Alltrim( Iif( (cAlias)->(FieldPos("F1_UFDESTR") ) > 0 .And. !Empty( (cAlias)->F1_UFDESTR ) , (cAlias)->F1_UFDESTR , aNFCab[NF_UFDEST]   ) )
			
			If !Empty( cUFOrig ) .AND. !Empty( cUfDest ) .AND. aSX6[MV_ESTADO] == cUFOrig .AND.  cUFOrig <> cUfDest
			  	
				If cUFOrig <> Alltrim( aNFCab[NF_UFORIGEM]  )
					MaFisAlt("NF_UFORIGEM"	, cUFOrig	)
				EndIF

				If cUfDest <> Alltrim( aNFCab[NF_UFDEST] )
					MaFisAlt("NF_UFDEST"	, cUfDest  )
				EndIF				

			EndIF

		EndIf	

		dbSelectArea(cAlias2)
		dbSetOrder(1)
		#IFDEF TOP
		If TcSrvType()<>"AS/400"
			aStru   := SD1->(dbStruct())
			lQuery  := .T.
			cAlias2 := "MaFisIniNF"
			cQuery  := "SELECT SD1.*,SD1.R_E_C_N_O_ SD1RECNO FROM "+RetSqlName("SD1")+" SD1 "
			cQuery  += "WHERE "
			cQuery  += "SD1.D1_FILIAL = '"+xFilial("SD1")+"' AND "
			cQuery  += "SD1.D1_DOC = '"+(cAlias)->F1_DOC+"' AND "
			cQuery  += "SD1.D1_SERIE = '"+(cAlias)->F1_SERIE+"' AND "
			cQuery  += "SD1.D1_FORNECE = '"+(cAlias)->F1_FORNECE+"' AND "
			cQuery  += "SD1.D1_LOJA = '"+(cAlias)->F1_LOJA+"' AND "
			cQuery  += "SD1.D1_TIPO= '"+(cAlias)->F1_TIPO+"' AND "
			cQuery  += "SD1.D_E_L_E_T_=' ' "
			cQuery  += "ORDER BY "+SqlOrder(IndexKey())
			cQuery  := ChangeQuery(cQuery)

			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias2,.T.,.T.)
			For nX := 1 To Len(aStru)
				If aStru[nX][2] <> "C"
					TcSetField(cAlias2,aStru[nX][1],aStru[nX][2],aStru[nX][3],aStru[nX][4])
				EndIf
			Next nX
		Else
		#ENDIF
			MsSeek(xFilial("SD1")+(cAlias)->F1_DOC+(cAlias)->F1_SERIE+(cAlias)->F1_FORNECE+(cAlias)->F1_LOJA)
		#IFDEF TOP
		EndIf
		#ENDIF

		dbSelectArea(cAlias2)
		While ( !Eof() .And. (cAlias2)->D1_FILIAL == xFilial("SD1") .And.;
			(cAlias2)->D1_DOC == (cAlias)->F1_DOC .And.;
			(cAlias2)->D1_SERIE == (cAlias)->F1_SERIE .And.;
			(cAlias2)->D1_FORNECE == (cAlias)->F1_FORNECE .And.;
			(cAlias2)->D1_LOJA == (cAlias)->F1_LOJA )

			If (cAlias2)->D1_TIPO == (cAlias)->F1_TIPO
				nY++
				If lHistorico
					cAlsItem  := cAlias2
					cAlsItem2 := cAlias2
				EndIf

				MaFisIniLoad(nY,,,Iif(aPos[FP_D1_IDTRIB],(cAlias2)->D1_IDTRIB,""))

				If lReprocess
					MaFisAlt ("IT_ITEM", (cAlias2)->D1_ITEM, nY)
				EndIf

				(cAliasProd)->(dbSetOrder(1))
				If (cAliasProd)->(MsSeek(xFilial(cAliasProd)+(cAlias2)->D1_COD))
					aNFitem[nY][IT_CODISS]	:=	aNfItem[nY][IT_PRD][SB_CODISS]
				Endif

				For nX := 1 To Len(aOtimizacao[2])
					MaFisLoad(aOtimizacao[2][nX][2],(cAlias2)->(FieldGet(FieldPos(aOtimizacao[2][nX][1]))),nY)
				Next nX

				// Rotina usada apanas para retornar o valor do ICMS ISENTO no Relatorio DUB-ICMS
				If cFunOrig == "FISR001"  .And. (cAlias2)->D1_CLASFIS $(" 40/ 41/040/041/140/141")
					MaFisTes(aNfItem[nY][IT_TES],aNfItem[nY][IT_RECNOSF4],nY)

					aNFItem[nY][IT_TS][TS_ICM] := "S"
					MaAliqIcms(nY)
					MaFisBSICM(nY)
					MaFisVICMS(nY)
					MaItArred(nY,{"IT_VALICM"})
				EndIf

				MaFisEndLoad(nY,2)

				If lReprocess
					If cPaisLoc == "BRA"

						MaFisIPI(nY,"BSE|VLR",.T.) // Calcula a Base de IPI Original
						MaExcecao(nY)
						MaFisPreCalc(nY)
						MaFisBSICM(nY,.T.)	// Calcula a Base de ICMS Original
						MaFisVICMS(nY,.T.) 	// Calcula o Valor do ICMS / Diferido
						MaFisPis(nY,"PS2","BSE|VLR",.T.)
						MaFisCofins(nY,"CF2","BSE|VLR",.T.)
						MaFisCPRB(nY)

						// Não chamar as funcoes do ICMS complementar nas entradas pois
						// os valores ja foram carregados de SD1 e nao precisam ser recalculados.
						/*If (cAlias2)->D1_TIPO $ "NDC"
							MaALIQCMP(nY)
							MaMargem(nY)
							MaFisVComp(nY,.T.)
						EndIf*/

						If aNFItem[nY][IT_TS][TS_ATUATF] == "S" .And. lCmpsSN1//Atualiza Ativo Fixo
							DbSelectArea("SN1")
							DbSetOrder(1)
							If SN1->(MsSeek(xFilial("SN1")+Substr((cAlias2)->D1_CBASEAF,1,10)+Substr((cAlias2)->D1_CBASEAF,11,4)))
								RecLock("SN1",.F.)
								SN1->N1_CSTPIS	:=	aNfItem[nY][IT_LIVRO][LF_CSTPIS]
								SN1->N1_CSTCOFI	:=	aNfItem[nY][IT_LIVRO][LF_CSTCOF]
								SN1->N1_ALIQPIS	:=	aNfItem[nY][IT_ALIQPS2]
								SN1->N1_ALIQCOF	:=	aNfItem[nY][IT_ALIQCF2]
								SN1->N1_CODBCC	:=	aNFItem[nY][IT_TS][TS_CODBCC]
								SN1->(FkCommit())
								MsUnLock()
							Endif
						Endif

						//Grava valor Credito Presumido Substituicao Tributaria retido pelo contratante do servico de transporte - Decreto 44.147/2005 (MG)
						If aNFItem[nY][IT_TS][TS_CRPRST]<>0
							MaAliqSoli(nY)
							MaMargem(nY)
							MaFisVSol(nY)
							MaFisVTot(nY)
						EndIf
					EndIf

					MaItArred(nY,{"IT_VALCMP"})
					MaFisLF(nY)
					MaFisLoad("LF_ITEMORI",(cAlias2)->D1_ITEMORI,nY) //Refaz o Item Original
				EndIf
			EndIf

			If (cAlias2)->D1_ORIGLAN<>(cAlias)->F1_ORIGLAN
				If lQuery
					SD1->(MsGoto((cAlias2)->SD1RECNO))
				EndIf
				RecLock("SD1",.F.)
				SD1->D1_ORIGLAN := (cAlias)->F1_ORIGLAN
				MsUnlock()
			EndIf

			dbSelectArea(cAlias2)
			dbSkip()

		EndDo

		If lQuery .and.(!lReprocess .Or. !lHistorico)
			dbSelectArea(cAlias2)
			dbCloseArea()
			dbSelectArea("SD1")
		EndIf

		If (cAlias)->F1_IMPORT <> "S"
			MaFisAlt("NF_FRETE"  ,(cAlias)->F1_FRETE)
			MaFisAlt("NF_SEGURO" ,(cAlias)->F1_SEGURO)
			MaFisAlt("NF_DESPESA",(cAlias)->F1_DESPESA)
			If aPos[FP_F1_DESNTRB]
				MaFisAlt("NF_DESNTRB",(cAlias)->F1_DESPNTRB)
			Endif
			If aPos[FP_F1_TARA]
				MaFisAlt("NF_TARA"   ,(cAlias)->F1_TARA)
			Endif
		EndIf

		// Fundo Social - Sera recalculado para apresentar nas observacoes do documento
		MaFisAlt("NF_FUNRURAL" ,(cAlias)->F1_CONTSOC,)

		If lReprocess
			MaFisAlt("NF_VALPEDG",(cAlias)->F1_VALPEDG)
		EndIf


	Case nTipoNF == 2 // Processa NF de saida
		If Empty(aOtimizacao) //Verifica se o Array de otimizacao esta disponivel
			aOtimizacao := {MaFisSXRef("SF2"),MaFisSxRef("SD2")}
		EndIf
		cAlias2 := "SD2"
		If Empty(cAlias)
			cAlias := "SF2"
			dbSelectArea(cAlias)
			MsGoto(nRecSF)
		EndIf
		If lHistorico
			cAlsCab := cAlias
		EndIf
		MaFisEnd()
		MaFisIni((cAlias)->F2_CLIENTE,(cAlias)->F2_LOJA,IIF((cAlias)->F2_TIPO$'DB',"F","C"),(cAlias)->F2_TIPO,(cAlias)->F2_TIPOCLI,{},,,,,,,,,Iif( aPos[FP_F2_RECISS] ,(cAlias)->F2_RECISS,""),(cAlias)->F2_CLIENT, (cAlias)->F2_LOJENT,,,,,,,,,IIF(cPaisLoc=="BRA",(cAlias)->F2_TPFRETE,NIL))

		If (cAlias)->F2_TIPO$"DB" .And. !lReprocess
			MaFisAlt("NF_UFORIGEM",(cAlias)->F2_EST)
		Else
			MaFisAlt("NF_UFDEST",(cAlias)->F2_EST)
		EndIf
		MaFisAlt("NF_ESPECIE",(cAlias)->F2_ESPECIE)

		//-- Tratamento para o ambiente Gestao de Transporte (SIGATMS)
		If (AllTrim(aNFCab[NF_ESPECIE]) $ "CTR/CTE" .Or. "NFST" $ AllTrim((cAlias)->F2_ESPECIE))
			MaFisAlt("NF_PNF_COD" ,(cAlias)->F2_CLIENTE,)
			MaFisAlt("NF_PNF_LOJ" ,(cAlias)->F2_LOJA,)
			MaFisAlt("NF_PNF_UF"  ,(cAlias)->F2_EST,)
			// Quando existe um valor de ICMS Retido o Tipo do Cliente deve ser o do Cliente Devedor do Frete
			If (cAlias)->F2_ICMSRET > 0
				MaFisAlt("NF_PNF_TPCLIFOR",Posicione("SA1",1,xFilial("SA1")+(cAlias)->F2_CLIENTE+(cAlias)->F2_LOJA,"A1_TIPO"))
			Else
				MaFisAlt("NF_PNF_TPCLIFOR",(cAlias)->F2_TIPOCLI,)
			EndIf
			If IntTms() .And. lReprocess
				DT6->(dbSetOrder(1))
				If DT6->(MsSeek(IIf(FWModeAccess("DT6",3) == "E" , (cAlias)->F2_FILIAL,xFilial("DT6"))+(cAlias)->F2_FILIAL+(cAlias)->F2_DOC+(cAlias)->F2_SERIE))
					MaFisAlt("NF_UFORIGEM",Posicione("DUY",1,xFilial("DUY")+DT6->DT6_CDRORI,"DUY_EST"))
					MaFisAlt("NF_UFDEST"  ,Posicione("DUY",1,xFilial("DUY")+DT6->DT6_CDRCAL,"DUY_EST"))
					If aSX6[MV_TMSUFPG] //--Com o MV_TMSUFPG True, gravar o Estado do Pagador do Frete
						MaFisAlt("NF_PNF_UF",Posicione("SA1",1,xFilial("SA1")+DT6->DT6_CLIDEV+DT6->DT6_LOJDEV,"A1_EST"),)
					EndIf
				EndIf
			EndIf
		EndIf

		cCliEnt	:=	aNFCab[NF_CLIENT]
		cLojEnt	:=	aNFCab[NF_LOJENT]

		dbSelectArea("SD2")
		dbSetOrder(3)

		#IFDEF TOP
		If TcSrvType()<>"AS/400"
			aStru   := SD2->(dbStruct())
			lQuery  := .T.
			cAlias2 := "MaFisIniNF"
			cQuery  := "SELECT SD2.*,SD2.R_E_C_N_O_ SD2RECNO FROM "+RetSqlName("SD2")+" SD2 "
			cQuery  += "WHERE "
			cQuery  += "SD2.D2_FILIAL = '"+xFilial("SD2")+"' AND "
			cQuery  += "SD2.D2_DOC = '"+(cAlias)->F2_DOC+"' AND "
			cQuery  += "SD2.D2_SERIE = '"+(cAlias)->F2_SERIE+"' AND "
			cQuery  += "SD2.D2_CLIENTE = '"+(cAlias)->F2_CLIENTE+"' AND "
			cQuery  += "SD2.D2_LOJA = '"+(cAlias)->F2_LOJA+"' AND "
			cQuery  += "SD2.D_E_L_E_T_=' ' "
			cQuery  += "ORDER BY "+SqlOrder(SD2->(IndexKey()))
			cQuery := ChangeQuery(cQuery)
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAlias2,.T.,.T.)

			For nX := 1 To Len(aStru)
				If aStru[nX][2]<>"C"
					TcSetField(cAlias2,aStru[nX][1],aStru[nX][2],aStru[nX][3],aStru[nX][4])
				EndIf
			Next nX
		Else
		#ENDIF
			MsSeek(xFilial("SD2")+(cAlias)->F2_DOC+(cAlias)->F2_SERIE+(cAlias)->F2_CLIENTE+(cAlias)->F2_LOJA)
		#IFDEF TOP
		EndIf
		#ENDIF
		dbSelectArea(cAlias)
		While !Eof().And. (cAlias2)->D2_FILIAL == xFilial("SD2") .And.;
			(cAlias2)->D2_DOC == (cAlias)->F2_DOC .And.;
			(cAlias2)->D2_SERIE == (cAlias)->F2_SERIE .And.;
			(cAlias2)->D2_CLIENTE == (cAlias)->F2_CLIENTE .And.;
			(cAlias2)->D2_LOJA == (cAlias)->F2_LOJA
			lISS := .F.
			If Empty(cCliEnt) .And. Empty(cLojEnt)
				SC5->(dbSetOrder(1))
				If SC5->(MsSeek(xFilial("SC5")+(cAlias2)->D2_PEDIDO))

					cCliEnt	:=	SC5->C5_CLIENT
					cLojEnt	:=	SC5->C5_LOJAENT

					MaFisAlt("NF_CLIENT", SC5->C5_CLIENT)
					MaFisAlt("NF_LOJENT", SC5->C5_LOJAENT)

					DbSelectArea("SF2")
					SF2->(DbSetOrder(1))

					If cAlias <> "SF2"
						SF2->(dbSetOrder(1))
						If SF2->(MsSeek(xFilial("SF2")+(cAlias)->F2_DOC+(cAlias)->F2_SERIE+(cAlias)->F2_CLIENTE+(cAlias)->F2_LOJA))
							RecLock("SF2",.F.)
							SF2->F2_CLIENT	:=	aNFCab[NF_CLIENT]
							SF2->F2_LOJENT	:=	aNFCab[NF_LOJENT]
							MsUnLock()
						EndIf
					Else
						SF2->(dbSetOrder(1))
						If SF2->(MsSeek(xFilial("SF2")+(cAlias)->F2_DOC+(cAlias)->F2_SERIE+(cAlias)->F2_CLIENTE+(cAlias)->F2_LOJA))
							RecLock(cAlias,.F.)
							(cAlias)->F2_CLIENT	:=	aNFCab[NF_CLIENT]
							(cAlias)->F2_LOJENT	:=	aNFCab[NF_LOJENT]
							MsUnLock()
						EndIf
					EndIf
				EndIf
			EndIf

			nY++

			If lHistorico
				cAlsItem  := cAlias2
				cAlsItem2 := cAlias2
			EndIf
			
			MaFisIniLoad(nY,,,Iif(aPos[FP_D2_IDTRIB],(cAlias2)->D2_IDTRIB,""))

			If lReprocess
				MaFisAlt ("IT_ITEM", (cAlias2)->D2_ITEM, nY)
			EndIf

			If !Empty((cAlias2)->D2_CODISS) .Or. (cAlias2)->D2_VALISS > 0
				lISS 	:= 	.T.
				lSoICMS	:=	.F.
				If !Empty((cAlias2)->D2_CODISS)
					aNFItem[nY][IT_RATEIOISS] := "S"
				EndIf
			EndIf

			If lReprocess .Or. (cAlias2)->D2_ORIGLAN $ "LO/VD"
				nDesc := LjxPesqDesc(cAlias2)
				MaFisAlt("IT_DESCPRO",nDesc,nY)
				If aNFItem[nY][IT_TS][TS_DESCOND] == "2"  .And. nDesc > 0
					aNfItem[nY][IT_BICMORI] += aNfItem[nY][IT_DESCPRO]
					aNfItem[nY][IT_DESCPRO] := 0
				EndIf
			Else
				nDesc := 0
			EndIf

			For nX := 1 To Len(aOtimizacao[2])
				Do Case
					Case aOtimizacao[2][nX][2] == "IT_VALMERC"
						If cPaisLoc <> "BRA" .And. aSX6[MV_DESCSAI] == "1"
							nValor := (cAlias2)->D2_TOTAL
						Else
							nValor := (cAlias2)->D2_TOTAL + (cAlias2)->D2_DESCON + nDesc
						Endif
					Case aOtimizacao[2][nX][2] == "IT_VALISS"
						nValor := IIF(lISS .And. Empty((cAlias2)->D2_VALISS) ,(cAlias2)->D2_VALICM,(cAlias2)->D2_VALISS)
					Case aOtimizacao[2][nX][2] == "IT_BASEISS"
						nValor := IIF(lISS .And. Empty((cAlias2)->D2_BASEISS),(cAlias2)->D2_BASEICM,(cAlias2)->D2_BASEISS)
					Case aOtimizacao[2][nX][2] == "IT_ALIQISS"
						nValor := IIF(lISS .And. Empty((cAlias2)->D2_ALIQISS),(cAlias2)->D2_PICM,(cAlias2)->D2_ALIQISS)
					OtherWise
						nValor := (cAlias2)->(FieldGet(FieldPos(aOtimizacao[2][nX][1])))
				EndCase
				MaFisLoad(aOtimizacao[2][nX][2],nValor,nY)
			Next nX

			MaFisTes(aNfItem[nY][IT_TES],aNfItem[nY][IT_RECNOSF4],nY)

			If aNFItem[nY][IT_TS][TS_AGREG] == "R"
				MaFisLoad("IT_VALMERC",(cAlias2)->D2_TOTAL + (cAlias2)->D2_DESCICM , nY)
				MaFisLoad("IT_PRCUNI", aNFitem[nY][IT_VALMERC] / aNFitem[nY][IT_QUANT] , nY)
			EndIf

			MaFisLoad("IT_DESCZF",(cAlias2)->D2_DESCZFR,nY)

			If lReprocess .And. (cAlias2)->D2_ORIGLAN $ "LO/VD"
				nDesc := LjxPesqDesc(cAlias2)
				MaFisAlt("IT_DESCPRO",nDesc,nY)
				// Reprocessamento da venda.
				//    No loja nao é gravado o desconto total no d2_descon, por isso busca o nDesc(L2_DESCPRO)
				//    No D2_DESCON é gravado o desconto no item do orçamento e qdo há desconto no total e no item,
				//    tem que somar o dois valores no IT_DESCONTO
				If cFunOrig == "MATA930" .And. ((cAlias2)->D2_DESCON > 0 .Or. nDesc>0)
					MaFisAlt("IT_DESCONTO",nDesc + (cAlias2)->D2_DESCON,nY)
					MaFisAlt("IT_DESCPRO",0,nY)
				EndIf
			EndIf

			// Rotina usada apenas para retornar o valor do ICMS ISENTO no Relatorio DUB-ICMS
			If cFunOrig == "FISR001" .And. (cAlias2)->D2_CLASFIS $(" 40/ 41/040/041/140/141")
				aNFItem[nY][IT_TS][TS_ICM] := "S"
				MaAliqIcms(nY)
				MaFisBSICM(nY)
				MaFisVICMS(nY)
				MaItArred(nY,{"IT_VALICM"})
			EndIf

			MaFisEndLoad(nY,2)

			If lReprocess
				If cPaisLoc=="BRA"
					MaFisIPI(nY,"BSE|VLR",.T.) // Calcula a Base de IPI Original
					MaExcecao(nY)
					MaFisPreCalc(nY)
					MaFisBSICM(nY,.T.)	// Calcula a Base de ICMS Original
					MaFisVICMS(nY,.T.) 	// Calcula o Valor do ICMS / Diferido

					// Não chamar as funcoes do ICMS complementar nas saidas pois
					// os valores ja foram carregados de SD2 e nao precisam ser recalculados.

					MaFisAlt("NF_VALPIS" ,(cAlias)->F2_VALPIS)
					MaFisAlt("NF_VALCOF" ,(cAlias)->F2_VALCOFI)
					MaFisAlt("NF_VALCSL" ,(cAlias)->F2_VALCSLL)

					MaFisCSLL(nY)
					MaFisCofins(nY,"CF2","BSE|VLR",.T.)
					MaFisPis(nY,"PS2","BSE|VLR",.T.)
					MaFisCPRB(nY)

					//Grava valor Credito Presumido Substituicao Tributaria retido pelo contratante do servico de transporte - Decreto 44.147/2005 (MG)
					If aNFItem[nY][IT_TS][TS_CRPRST]<>0
						MaAliqSoli(nY)
						MaMargem(nY)
						MaFisVSol(nY)
						MaFisVTot(nY)
					EndIf
				EndIf
				MaItArred(nY,{"IT_VALCMP"})
 				MaItArred(nY,{"IT_VFECPST"})
 				MaItArred(nY,{"IT_VALFECP"})
				MaFisLF(nY)
				MaFisLoad("LF_ITEMORI",(cAlias2)->D2_ITEMORI,nY) //Refaz o Item Original
			EndIf
			dbSelectArea(cAlias2)
			dbSkip()
		EndDo

		If lQuery .and.(!lReprocess .Or. !lHistorico)
			dbSelectArea(cAlias2)
			dbCloseArea()
			dbSelectArea("SD2")
		EndIf

		MaFisAlt("NF_FRETE",(cAlias)->F2_FRETE)

		If aPos[FP_F2_VLR_FRT]
			MaFisAlt("NF_VLR_FRT",(cAlias)->F2_VLR_FRT)
		EndIf

		MaFisAlt("NF_SEGURO" ,(cAlias)->F2_SEGURO)
		MaFisAlt("NF_DESPESA",(cAlias)->F2_DESPESA)

		If aPos[FP_F2_DESNTRB]
			MaFisAlt("NF_DESNTRB",(cAlias)->F2_DESNTRB)
		Endif

		If aPos[FP_F2_TARA]
			MaFisAlt("NF_TARA",(cAlias)->F2_TARA)
		Endif

		MaFisLoad("NF_AUTONOMO",(cAlias)->F2_FRETAUT)

		If lSoICMS .And. cFunOrig <> "FISR001"	//Nao retirar - So devo processar este bloco se o documento fiscal conter SOMENTE ICMS.
			MaFisAlt("NF_BASEICM",(cAlias)->F2_BASEICM,)
			MaFisAlt("NF_VALICM" ,(cAlias)->F2_VALICM,)
			MaFisAlt("NF_BASEIPI",(cAlias)->F2_BASEIPI,)
			MaFisAlt("NF_VALIPI" ,(cAlias)->F2_VALIPI,)
		EndIf

		MaFisAlt("NF_VALICA"  ,(cAlias)->F2_ICMAUTO,)
		MaFisAlt("NF_FUNRURAL",(cAlias)->F2_CONTSOC,)

		If !lReprocess  .And. cFunOrig <> "FISR001"
			For nX := 1 To Len(aOtimizacao[1])
				If Empty(MaFisRet(,aOtimizacao[1][nX][2]))
					nValor := (cAlias)->(FieldGet(FieldPos(aOtimizacao[1][nX][1])))
					MaFisAlt(aOtimizacao[1][nX][2],nValor)
				ElseIf !lReprocess
					nValor := (cAlias)->(FieldGet(FieldPos(aOtimizacao[1][nX][1])))
					MaFisLoad(aOtimizacao[1][nX][2],nValor)
				EndIf
			Next nX
		EndIf
EndCase

RestArea(aAreaSD2)
RestArea(aAreaSF2)
RestArea(aAreaSD1)
RestArea(aAreaSF1)
RestArea(aArea)

Return .T.

/*FUNCOES DE CONTROLE DOS FOLDERS - LIVRO FISCAL E IMPOSTOS*/

/*
MaFisBrwLF -Edson Maricate  -13.12.1999
Objeto Browse demonstrativo dos livros fiscais
Parametros
ExpO1: Objeto ListBox a ser montado
ExpA2: Array com as coordenadas do Objeto
ExpL3: Flag de edicao livro .F. - Editavel .T. - Nao Editavel
ExpA4: Array contendo os registros do Livro Fiscal
/*/
Function MaFisBrwLivro(oWnd,aPosWnd,lVisual,aRecSF3,lOpcVisual)

Local aFixos	:= xFisAFixos()
Local aArea		:= GetArea()
Local aAreaSX3	:= SX3->(GetArea())
Local aItensLF	:= {}
Local aHeadLF	:= {}
Local aTamHead	:= {}
Local nX        := 0
Local nY        := 0
Local oLivro

DEFAULT lOpcVisual := .F.

// Inicializa os campos fixos do Livro Fiscal
If aBrwLF == Nil
	aBrwLF := {}
	SX3->(DbSetOrder(2))
	For nX := 1 To Len(aFixos)
		If SX3->(MsSeek(aFixos[nX][1]))
			aadd( aBrwLF ,{ aFixos[nX][1] , CriaVar(aFixos[nX][1],.F.) , PesqPict("SF3",aFixos[nX][1]) , X3Titulo() , SX3->X3_TAMANHO } )
		EndIf
	Next nX
EndIf
// Monta o cabecalho com os titulos do SF3.
For nX	:= 1 To Len(aBrwLF)
	aadd(aHeadLF,aBrwLF[nX][4])
	If aBrwLF[nX][5] > Len(aBrwLF[nX][4])
		aadd(aTamHead,aBrwLF[nX][5]*3)
	Else
		aadd(aTamHead,Len(aBrwLF[nX][4])*3)
	EndIf
Next nX
// Monta os itens de visualizacao da ListBox.
Do Case
	Case !Empty(aRecSF3)
		For nX	:= 1 To Len(aRecSF3)
			dbSelectArea("SF3")
			MsGoto(aRecSF3[nX])
			aadd(aItensLF,Array(Len(aBrwLF)))
			For nY := 1 to Len(aBrwLF)
				aItensLF[nX][nY] := &(aBrwLF[nY][1])
			Next nY
		Next nX
	Case !Empty(aNFCab)
		aItensLF := aClone(aNFCab[NF_LIVRO])
		If cPaisLoc<>"BRA"
			If !Empty(aItensLF)
				aItensLF:=Adel(aItensLF,1)
				aItensLF:=aSize(aItensLF,Len(aItensLF)-1)
			Endif
		EndIf
EndCase
If Empty(aItensLF)
	aadd(aItensLF,Array(Len(aBrwLF)))
	For nX	:= 1 To Len(aBrwLF)
		aItensLF[1][nX] := aBrwLF[nX][2]
	Next nX
EndIf

bLivroRefresh   := {|| MaFisLFNew(oLivro)}
oLivro:= TWBrowse():New( aPosWnd[1],aPosWnd[2],aPosWnd[3],aPosWnd[4],,aHeadLF,aTamHead,oWnd,,,,,,,,,,,,.F.,,.T.,,.F.,,,)
oLivro:SetArray(aItensLF)
If Len(aItensLF) > 0
	oLivro:bLine := {||MaFisLFLine(oLivro,aItensLF)}
EndIf
oLivro:lAutoEdit := !lVisual
// O aHeader contido no aHeadLF e montado apartir do aBrwLF criado pela xFisAFixos e diverge do conteudo do aNFCab[NF_LIVRO]
// O Refresh a seguir alinha o aHeadLF com o aItensLF
If bLivroRefresh <> Nil .And. Empty(aRecSF3) .And. !lOpcVisual
	Eval(bLivroRefresh)
EndIf

RestArea(aAreaSX3)
RestArea(aArea)

Return ( oLivro )

/*/
MaFisLFNew -Edson Maricate  -13.12.1999
Esta rotina tem como objetivo atualizar o array com o demonstrativo fiscal.
Browse demonstrativo dos livros fiscais
ParametrosExpO1: Objeto ListBox dos livros fiscais
/*/
Static Function MaFisLFNew(oLivro)

Local aTemp   := {}
Local aFixos  := xFisAFixos()
Local aLinha  := {}
Local nMaxBrw := Len(aBrwLF)
Local nX      := 0
Local nY      := 0
Local nZ      := 0
Local nPosCon := 0
Local nPosTES := 0
Local nMax1   := 0
Local nMax2   := 0
Local laNFCab := !(Empty(aNFCab))

If !laNFCab
	aadd(aLinha,Array(nMaxBrw))
	For nX := 1 To nMaxBrw
		aLinha[1][nX] := aBrwLF[nX][2]
	Next nX
Else
	If Len(aNFCab[NF_LIVRO])>0
		aTemp :=  aClone(aNFCab[NF_LIVRO])
	ELse
		aAdd(aTemp,MaFisRetLF())
	Endif
	If cPaisLoc<>"BRA"
		If !Empty(aTemp)
			aTemp:=Adel(aTemp,1)
			aTemp:=aSize(aTemp,Len(aTemp)-1)
		Endif
	Endif
	nMax1 := Len(aTemp)
	For nX := 1 To nMax1
		nMax2 := Min(Len(aTemp[nX]),Len(aFixos))
		aadd(aLinha,Array(nMaxBrw))
		For nY := 1 To nMax2
			nZ := aScan(aBrwLF,{|x| x[1]==aFixos[nY][1]})
			nPosCon := aScan(aBrwLF,{|x| x[1] == "F3_CONCEPT"})
			nPosTES := aScan(aBrwLF,{|x| x[1] == "F3_TES"})
			If nZ <> 0
				aLinha[nX][nZ]:= aTemp[nX][nY]
			EndIf

			If nPosCon <> 0 .And. cPaisLoc == "EQU" .AND. ALLTRIM( aBrwLF[nZ][1]) == "F3_CONCEPT" .and. FunName() == "MATA101N"
				If aTemp[nX][nPosTES] == MaFisRet(nX,"IT_TES")
					aLinha[nX][nPosCon]:= MaFisRet(nX,"IT_CONCEPT")
				Else
					If aLinha[nX][nPosTES] == MaFisRet(N,"IT_TES")
						aLinha[nX][nPosCon]:= MaFisRet(Nx,"IT_CONCEPT")
					Else
						aLinha[nX][nPosCon]:= MaFisRet(N,"IT_CONCEPT")
					EndIf
				endIf
			EndIf
		Next nY
	Next nX
EndIf

If ValType(oLivro)<>"U"
		oLivro:SetArray(aLinha)
		oLivro:bLine := {|| MaFisLFLine(oLivro,aLinha) }
		oLivro:Refresh()
EndIf

Return(.T.)

/*/
MaFisLFLin - Edson Maricate  -13.12.1999
Esta rotina tem como objetivo preparar a montagem da linha a ser exibida no browse do demonstrativo fiscal
Parametros
ExpO1: Objeto ListBox do Livro Fiscal
ExpA2: Array com os itens do listbox
Retorno
ExpA1: Array com a linha do demonstrativo fiscal
/*/
Static Function MaFisLFLine(oLivro,aItensLF)

Local aLinha := aItensLF[oLivro:nAt]
Local aFixos := xFisAFixos()
Local nX     := 0
Local nY     := 0
Local nMax   := Len(aFixos)

For nX := 1 To nMax
	nY := aScan(aBrwLF,{|x| x[1]==aFixos[nX][1]})
	If nY <> 0 .And. ValType(aLinha[nY]) == "N"
		If cPaisLoc == "BRA"
			If SUBS(aBrwLF[nY][1],1,10) $ "F3_VALANTI"
				aLinha[nY] := Round(aLinha[nY],MsDecimais(1))
			Else
				aLinha[nY]:= TransForm(aLinha[nY],aBrwLF[nY][3])
			EndIf
		Else
			If SUBS(aBrwLF[nY][1],1,6) $ "F3_VAL|F3_BAS|F3_RET|F3_DES"
				aLinha[nY] := Round(aLinha[nY],MsDecimais(1))
			EndIf
			aLinha[nY]:= TransForm(aLinha[nY],aBrwLF[nY][3])
		EndIf
	EndIf
Next nX

Return( aLinha )

/*/
MaFisRodape - Edson Maricate-13.12.1999
Atualiza o Array de Resumos da NF.
/*/
Function MaFisRodape(nTipo,;		// Quebra : 1 Imposto+Aliquota,  2-Imposto
	oJanela,;		// Janela onde sera montado
	aImpostos,;	// Relacao de Impostos que deverao aparecer ( Codigo )
	aPosicao,;			// Array contendo Posicao e Tamanho
	bValidPrg,;	// Validacao executada na Edicao dop Campo
	lVisual,; // So para visualizacao
	cFornIss,; //Fornecedor do ISS
	cLojaIss,; //Loja do Fornecedor do ISS
	aRecSE2,;
	cDirf,;
	cCodRet,;
	oCodRet,;
	nCombo,;
	oCombo,;
	dVencIss,; 	//Vencimento ISS
	aCodR,;
	cRecIss,;	//Informa se recolhe o ISS ou nao
	oRecIss,;
	lEditImp,;//Edicao de impostos dos Docs.Fiscais operacao de Inclusao, MV_EDITIMP ativado, Form.Proprio N e Especie NF/NCP/NDP/NDE/NCE (LOCALIZADO)
	cDescri)

Local oList
Local aTemp
Local aOpcoes := {"Sim","Nao"}
Local oFornIss
Local oLojaIss
Local oVencIss
Local oDescri
Local oBtn081 := Nil
Local oBtn084 := Nil
Local aAreaSE2 := {}
Local aAreaSA2 := {}
Local lFornIss := .F.
Local lVisuimp := .F.
Local nPosDum  := 0
Local aAUTOISS := {}
Local aMaPCCI  := {}
Local nI       := 0
Local nPosCodR := 0
Local aOpcIss  := {"1="+STR0024,"2="+STR0025}
Local nPosImp  := 0
Local nTamForn := (TamSx3("E2_FORNISS")[1]*4)
Local nTamLoja := (TamSx3("E2_LOJAISS")[1]*4)
Local lTamForn := TamSx3("E2_FORNISS")[1]>6
Local lTamLoja := TamSx3("E2_LOJAISS")[1]>2
Local lRotina  := IsInCallStack("MATA103") .Or. FunName()$"MATA119/PMSA300/MATA116" .Or. IsInCallStack("A120TRACK")
Local cVersao := GetVersao(.F.)

DEFAULT oCodRet := Nil
DEFAULT oCombo  := Nil
DEFAULT nCombo  := 2
DEFAULT dVencIss:= CtoD("")
DEFAULT aCodR	:= {}
DEFAULT oRecIss := Nil
DEFAULT cRecIss := "1"
Default lEditImp := .F.

// Ao utilizar o Protheus com varias Filiais e possivel que em alguns processos como o de inclusao de Notas Fiscais o usuario altere
// a filial atraves da Dialog de seleçao de filiais, com isso se faz necessario que os parametros SX6 sejam novamente carregados para
// a filial corrente refazendo o cache realizado na variavel aSX6, esta nova carga e controlada pela variavel cSX6FilAnt
If cSX6FilAnt <> cFilAnt
	aSX6 := GParMxFis(@cSX6FilAnt)
EndIf

aAUTOISS := &(aSX6[MV_AUTOISS])

If nTipo == 1
	If Empty(aNfCab) .Or. Empty(aNfCab[NF_IMPOSTOS])
		aTemp	:= {{"","",0,0,0,""}}
	Else
	    If lVisual
	        For nPosImp := 1 to Len(aNFCab[NF_IMPOSTOS])
                If Alltrim(aNFCab[NF_IMPOSTOS][nPosImp][1]) == "IRR" .And. aNFCab[NF_IMPOSTOS][nPosImp][4] == 0
                    MaFisIR(1,"ALQ",,lVisual)
                    aNFCab[NF_IMPOSTOS][nPosImp][4] := aNfItem[1][IT_ALIQIRR]
                EndIf
	        Next nPosImp
	    EndIf
		aTemp	:= aNFCab[NF_IMPOSTOS]
	EndIf
Else
	If Empty(aNfCab) .Or. Empty(aNfCab[NF_IMPOSTOS2])
		aTemp	:= {{"","",0,0,""}}
	Else
		aTemp	:= aNFCab[NF_IMPOSTOS2]
	EndIf
EndIf

bFisRefresh	:= {|| MaFisRRefresh(oList,nTipo,oFornISS,@cFornISS,oLojaISS,@cLojaISS,oRecISS,@cRecISS,oVencISS,@dVencISS,@cDescri,oDescri)}

If aPos[FP_E2_FORNISS] .And. aPos[FP_E2_LOJAISS]
	If cFornIss <> NIL .And. cLojaIss <> NIL
		lFornIss := .T.
	  	aPosicao[2] := 85
	   	aPosicao[3] -= 80
	   	@ 03,02 TO 58, (Iif (lTamForn, nTamForn+52,84 )+ Iif (lTamLoja,9,0)) LABEL '' OF oJanela PIXEL
		@ 06,10 SAY STR0023 Of oJanela PIXEL SIZE 80,09 //"Dados de Cobrança do ISS"
		@ 19,04 SAY RetTitle("E2_FORNISS") Of oJanela PIXEL SIZE 30,09

		If aPos[FP_E2_VENCISS]
			@ 46,04 SAY RetTitle("E2_VENCISS")Of oJanela PIXEL SIZE 30,09
		EndIf

		If lVisual
		    If Len(aRecSE2) > 0
		    	aAreaSE2 := SE2->(GetArea())
			    aAreaSA2 := SA2->(GetArea())
			    SE2->(dbGoTo(aRecSE2[1]))
			    cFornIss := SE2->E2_FORNISS
		    	cLojaIss := SE2->E2_LOJAISS
			    If SA2->(MsSeek(xFilial("SA2")+cFornIss+cLojaIss))
					cDescri := SA2->A2_NREDUZ
				Endif
				If aPos[FP_E2_VENCISS]
			    	dVencIss := SE2->E2_VENCISS
			 	EndIf

				If cPaisLoc=="BRA"
					If !Empty( SE2->E2_CODRPIS )
						aAdd( aMaPCCI , {"PIS",SE2->E2_CODRPIS} )
					EndIf
					If !Empty( SE2->E2_CODRCOF )
						aAdd( aMaPCCI , {"COF",SE2->E2_CODRCOF} )
					EndIf
					If !Empty( SE2->E2_CODRCSL )
						aAdd( aMaPCCI , {"CSL",SE2->E2_CODRCSL} )
					EndIf
					If !Empty( SE2->E2_CODRET )
						aAdd( aMaPCCI , {"IRR",SE2->E2_CODRET} )
					EndIf
				Endif

			 	For nI := 1 To Len( aTemp )
				 	If (nTipo==1)
						If (nPosCodR := aScan(aMaPCCI, {|aX|aX[1]==aTemp[nI][6]}))>0
							aAdd( aCodR, {nI, aMaPCCI[nPosCodR][2], 1, aTemp[nI][6]} )
						EndIf
					Else
						If (nPosCodR := aScan(aMaPCCI, {|aX|aX[1]==aTemp[nI][5]}))>0
							aAdd( aCodR, {nI, aMaPCCI[nPosCodR][2], 1, aTemp[nI][5]} )
						EndIf
					EndIf
				Next
				RestArea(aAreaSE2)
				RestArea(aAreaSA2)
		    Endif

			@ 18,31 MSGET oFornIss VAR cFornIss PICTURE PesqPict('SE2','E2_FORNISS') OF oJanela PIXEL SIZE IIf(lTamForn, nTamForn,35),09 READONLY
			@ 18,Iif(lTamForn, nTamForn+35,67) MSGET oLojaIss VAR cLojaIss PICTURE PesqPict('SE2','E2_LOJAISS') OF oJanela PIXEL SIZE IIf(lTamLoja, nTamLoja,15),09 READONLY

			If aPos[FP_E2_VENCISS]
				@ 44,38 MSGET oVencIss VAR dVencIss OF oJanela PIXEL READONLY
			EndIf
		Else
			If !Empty(cFornISS) .And. !Empty(cLojaISS)
			    If SA2->(MsSeek(xFilial("SA2")+cFornIss+cLojaIss))
					cDescri := SA2->A2_NREDUZ
				Endif
			Endif
		  	@ 18,31 MSGET oFornIss VAR cFornIss PICTURE PesqPict('SE2','E2_FORNISS') OF oJanela PIXEL SIZE IIf(lTamForn, nTamForn,35),09 F3 CpoRetF3('E2_FORNISS') ;
			VALID MaVldForn(@cFornIss,@cLojaIss,@oDescri,@cDescri,@oLojaISS,@oFornIss,1)
			@ 18,IIf(lTamForn, nTamForn+35,67) MSGET oLojaIss VAR cLojaIss PICTURE PesqPict('SE2','E2_LOJAISS') OF oJanela PIXEL SIZE Iif(lTamLoja, nTamLoja,15),09 F3 CpoRetF3('E2_LOJAISS') ;
			VALID MaVldForn(@cFornIss,@cLojaIss,@oDescri,@cDescri,@oLojaISS,@oFornIss,2)
			If aPos[FP_E2_VENCISS]
		    @ 44,31 MSGET oVencIss VAR dVencIss OF oJanela PIXEL
			EndIf
		EndIf
		@ 31,04 MSGET oDescri VAR cDescri OF oJanela PIXEL SIZE 78,09 WHEN .F.
	Endif
Endif

If aSX6[MV_VISDIRF] == "1"
	If cDirf <> NIL .And. cCodRet <> NIL

	   If lVisual
		   cCodRet 	:= Space(TamSx3("E2_CODRET")[1])
	       cDirf   	:= "2"
	   Else
			cDirf 	:= CriaVar("E2_DIRF",.T.)
			cCodRet := CriaVar("E2_CODRET")
			If aAutoISS<>Nil .And. Len(aAutoISS)==4 .And. !Empty(aAutoISS[03])
				cDirf 	:= aAutoISS[03]
				cCodRet	:= aAutoISS[04]
			EndIf
		Endif

		nCombo	:= aOpcoes[VAL(Iif((cDirf$"1|2"),cDirf,"2"))]
		nTamForn := IIf(lTamForn, nTamForn,0)

	   	If lFornIss

			aPosicao[2] := 170
			aPosicao[3] -= 74

			If cVersao <> "12"
				@ 03,(Iif (lTamForn, nTamForn+53,85) +Iif (lTamLoja,10,0)) TO 42,(Iif (lTamForn, nTamForn+136,169)+Iif (lTamLoja,8,0))  LABEL '' OF oJanela PIXEL
			  	@ 06,(Iif (lTamForn, nTamForn+90,120)+Iif (lTamLoja,10,0)) SAY "DIRF" Of oJanela PIXEL SIZE 80,Iif (lTamForn, nTamForn+09,09) //"Dados de Cobrança do ISS"
			   	@ 16,(Iif (lTamForn, nTamForn+57,89) +Iif (lTamLoja,10,0)) SAY RetTitle("E2_DIRF") Of oJanela PIXEL SIZE 30,Iif (lTamForn, nTamForn+09,09)
			   	@ 16,(Iif (lTamForn, nTamForn+93,125)+Iif (lTamLoja,10,0)) MSCOMBOBOX oCombo VAR nCombo ITEMS aOpcoes ON CHANGE (cDirf := StrZero(oCombo:nAt,1)) VALID MaGrvCdR(@cCodRet,oCombo,oList,@aCodR,@oCodRet,.F.) WHEN !lVisual SIZE 40,50 OF oJanela PIXEL
			   	@ 27,(Iif (lTamForn, nTamForn+57,89) +Iif (lTamLoja,10,0)) SAY RetTitle("E2_CODRET") Of oJanela PIXEL SIZE 50,Iif (lTamForn, nTamForn+09,09)
			   	@ 27,(Iif (lTamForn, nTamForn+93,125)+Iif (lTamLoja,10,0)) MSGET oCodRet VAR cCodRet F3 "37" VALID MaGrvCdR(@cCodRet,oCombo,oList,@aCodR,@oCodRet,.T.) WHEN !lVisual OF oJanela PIXEL SIZE 40,09
			   	@ 42,(Iif (lTamForn, nTamForn+53,85) +Iif (lTamLoja,10,0)) TO 58,(Iif (lTamForn, nTamForn+136,169)+Iif (lTamLoja,8,0))  LABEL '' OF oJanela PIXEL
			   	@ 47,(Iif (lTamForn, nTamForn+57,89) +Iif (lTamLoja,10,0))  SAY RetTitle("A2_RECISS") Of oJanela PIXEL SIZE 50,Iif (lTamForn, nTamForn+09,09)
			   	@ 46,(Iif (lTamForn, nTamForn+93,125)+Iif (lTamLoja,10,0)) MSCOMBOBOX oRecIss VAR cRecIss ITEMS aOpcIss VALID MaFisAlt( "NF_RECISS", cRecIss) WHEN !lVisual SIZE 40,50 OF oJanela PIXEL
			Else
			   @ 03,(Iif (lTamForn, nTamForn+53,85) +Iif (lTamLoja,10,0)) TO 48,(Iif (lTamForn, nTamForn+136,169)+Iif (lTamLoja,8,0))  LABEL '' OF oJanela PIXEL
		  		@ 06,(Iif (lTamForn, nTamForn+90,120)+Iif (lTamLoja,10,0)) SAY "DIRF" Of oJanela PIXEL SIZE 80,Iif (lTamForn, nTamForn+09,09) //"Dados de Cobrança do ISS"
		   		@ 16,(Iif (lTamForn, nTamForn+57,89) +Iif (lTamLoja,10,0)) SAY RetTitle("E2_DIRF") Of oJanela PIXEL SIZE 30,Iif (lTamForn, nTamForn+09,19)
		   		@ 16,(Iif (lTamForn, nTamForn+93,125)+Iif (lTamLoja,10,0)) MSCOMBOBOX oCombo VAR nCombo ITEMS aOpcoes ON CHANGE (cDirf := StrZero(oCombo:nAt,1)) VALID MaGrvCdR(@cCodRet,oCombo,oList,@aCodR,@oCodRet,.F.) WHEN !lVisual SIZE 40,50 OF oJanela PIXEL
		   		@ 35,(Iif (lTamForn, nTamForn+57,89) +Iif (lTamLoja,10,0)) SAY RetTitle("E2_CODRET") Of oJanela PIXEL SIZE 50,Iif (lTamForn, nTamForn+09,09)
		   		@ 34,(Iif (lTamForn, nTamForn+93,125)+Iif (lTamLoja,10,0)) MSGET oCodRet VAR cCodRet F3 "37" VALID MaGrvCdR(@cCodRet,oCombo,oList,@aCodR,@oCodRet,.T.) WHEN !lVisual OF oJanela PIXEL SIZE 40,09
		   		@ 49,(Iif (lTamForn, nTamForn+53,85) +Iif (lTamLoja,10,0)) TO 70,(Iif (lTamForn, nTamForn+136,169)+Iif (lTamLoja,8,0))  LABEL '' OF oJanela PIXEL
		   		@ 55,(Iif (lTamForn, nTamForn+57,89) +Iif (lTamLoja,10,0)) SAY RetTitle("A2_RECISS") Of oJanela PIXEL SIZE 50,Iif (lTamForn, nTamForn+09,09)
		   		@ 52,(Iif (lTamForn, nTamForn+93,125)+Iif (lTamLoja,10,0)) MSCOMBOBOX oRecIss VAR cRecIss ITEMS aOpcIss VALID MaFisAlt( "NF_RECISS", cRecIss) WHEN !lVisual SIZE 40,50 OF oJanela PIXEL
			EndIf

			aPosicao[2] -= 41

		Else

			aPosicao[2] := 129
			aPosicao[3] -= 74

			If cVersao <> "12"
				@ 03,(Iif (lTamForn, nTamForn+53,85) +Iif (lTamLoja,10,0))TO 42,(Iif (lTamForn, nTamForn+136,169)+Iif (lTamLoja,8,0)) LABEL '' OF oJanela PIXEL
				@ 06,(Iif (lTamForn, nTamForn+90,120)+Iif (lTamLoja,10,0)) SAY "DIRF" Of oJanela PIXEL SIZE 80,Iif (lTamForn, nTamForn+09,09) //"Dados de Cobrança do ISS"
				@ 16,(Iif (lTamForn, nTamForn+57,89) +Iif (lTamLoja,10,0))SAY RetTitle("E2_DIRF") Of oJanela PIXEL SIZE 30,Iif (lTamForn, nTamForn+09,09)
				@ 16,(Iif (lTamForn, nTamForn+93,125)+Iif (lTamLoja,10,0)) MSCOMBOBOX oCombo VAR nCombo ITEMS aOpcoes ON CHANGE (cDirf := StrZero(oCombo:nAt,1)) VALID MaGrvCdR(@cCodRet,oCombo,oList,@aCodR,@oCodRet,.F.) WHEN !lVisual SIZE 40,50 OF oJanela PIXEL
				@ 27,(Iif (lTamForn, nTamForn+57,89) +Iif (lTamLoja,10,0))SAY RetTitle("E2_CODRET") Of oJanela PIXEL SIZE 50,Iif (lTamForn, nTamForn+09,09)
				@ 27,(Iif (lTamForn, nTamForn+93,125)+Iif (lTamLoja,10,0))MSGET oCodRet VAR cCodRet F3 "37" VALID MaGrvCdR(@cCodRet,oCombo,oList,@aCodR,@oCodRet,.T.) WHEN !lVisual OF oJanela PIXEL SIZE 40,09
				@ 42,(Iif (lTamForn, nTamForn+53,85) +Iif (lTamLoja,10,0))TO 58,(Iif (lTamForn, nTamForn+136,169)+Iif (lTamLoja,8,0))  LABEL '' OF oJanela PIXEL
				@ 47,(Iif (lTamForn, nTamForn+57,89) +Iif (lTamLoja,10,0))SAY RetTitle("A2_RECISS") Of oJanela PIXEL SIZE 50,Iif (lTamForn, nTamForn+09,09)
				@ 46,(Iif (lTamForn, nTamForn+93,125)+Iif (lTamLoja,10,0))MSCOMBOBOX oRecIss VAR cRecIss ITEMS aOpcIss VALID MaFisAlt( "NF_RECISS", cRecIss) WHEN !lVisual SIZE 40,50 OF oJanela PIXEL
			Else
				@ 03,(Iif (lTamForn, nTamForn+53,85) +Iif (lTamLoja,10,0))TO 48,(Iif (lTamForn, nTamForn+136,169)+Iif (lTamLoja,8,0)) LABEL '' OF oJanela PIXEL
			  	@ 06,(Iif (lTamForn, nTamForn+90,120)+Iif (lTamLoja,10,0)) SAY "DIRF" Of oJanela PIXEL SIZE 80,Iif (lTamForn, nTamForn+09,09) //"Dados de Cobrança do ISS"
				@ 16,(Iif (lTamForn, nTamForn+57,89) +Iif (lTamLoja,10,0))SAY RetTitle("E2_DIRF") Of oJanela PIXEL SIZE 30,Iif (lTamForn, nTamForn+09,09)
			   	@ 16,(Iif (lTamForn, nTamForn+93,125)+Iif (lTamLoja,10,0)) MSCOMBOBOX oCombo VAR nCombo ITEMS aOpcoes ON CHANGE (cDirf := StrZero(oCombo:nAt,1)) VALID MaGrvCdR(@cCodRet,oCombo,oList,@aCodR,@oCodRet,.F.) WHEN !lVisual SIZE 40,50 OF oJanela PIXEL
			   	@ 35,(Iif (lTamForn, nTamForn+57,89) +Iif (lTamLoja,10,0))SAY RetTitle("E2_CODRET") Of oJanela PIXEL SIZE 50,Iif (lTamForn, nTamForn+09,09)
			   	@ 34,(Iif (lTamForn, nTamForn+93,125)+Iif (lTamLoja,10,0))MSGET oCodRet VAR cCodRet F3 "37" VALID MaGrvCdR(@cCodRet,oCombo,oList,@aCodR,@oCodRet,.T.) WHEN !lVisual OF oJanela PIXEL SIZE 40,09
			   	@ 49,(Iif (lTamForn, nTamForn+53,85) +Iif (lTamLoja,10,0))TO 70,(Iif (lTamForn, nTamForn+136,169)+Iif (lTamLoja,8,0))  LABEL '' OF oJanela PIXEL
			  	@ 55,(Iif (lTamForn, nTamForn+57,89) +Iif (lTamLoja,10,0))SAY RetTitle("A2_RECISS") Of oJanela PIXEL SIZE 50,Iif (lTamForn, nTamForn+09,09)
			   	@ 52,(Iif (lTamForn, nTamForn+93,125)+Iif (lTamLoja,10,0))MSCOMBOBOX oRecIss VAR cRecIss ITEMS aOpcIss VALID MaFisAlt( "NF_RECISS", cRecIss) WHEN !lVisual SIZE 40,50 OF oJanela PIXEL
			EndIf

		Endif
	Endif
Endif

If cPaisLoc <> "BRA" .and. lEditImp .and. FindFunction( "FISA081" ) .and. FindFunction( "FISA084" )
	aPosicao[2] := 85
	aPosicao[3] -= 80
	@ 03,02 To 58,( Iif( lTamForn, nTamForn + 52, 84 ) + Iif( lTamLoja, 9, 0 ) ) LABEL STR0042 Of oJanela Pixel //"Editarimposto"
	@ 13,12 Button oBtn081 Prompt STR0043 Action FISA081( oList ) Size 60,10 Of oJanela Pixel //"PorItem"
	@ 38,12 Button oBtn084 Prompt STR0044 Action FISA084( oList ) Size 60,10 Of oJanela Pixel //"PorImposto"
EndIf

If nTipo == 1
	oList := TWBrowse():New( aPosicao[1]-2,Iif(lTamForn .And. lRotina, aPosicao[2]+(nTamForn+nTamLoja),Iif(aSX6[MV_VISDIRF] == "1" .And. lRotina,Iif(lTamLoja,aPosicao[2]+51,aPosicao[2]+41),aPosicao[2])),Iif(lTamForn .And. lRotina, aPosicao[3]+32-(nTamForn+nTamLoja),Iif(aSX6[MV_VISDIRF] == "1" .And. lRotina,aPosicao[3]-10,aPosicao[3])),aPosicao[4]+2,,{STR0003,STR0004,STR0005,STR0006,STR0007},{30,90,50,30,50},oJanela,,,,,,,,,,,,.F.,,.T.,,.F.,,, ) //"Cod."###"Descricao"###"Base Imposto"###"Aliquota"###"Vlr. Imposto"
Else
	oList := TWBrowse():New( aPosicao[1]-2,Iif(lTamForn .And. lRotina, aPosicao[2]+(nTamForn+nTamLoja),Iif(aSX6[MV_VISDIRF] == "1" .And. lRotina,Iif(lTamLoja,aPosicao[2]+51,aPosicao[2]+41),aPosicao[2])),Iif(lTamForn .And. lRotina, aPosicao[3]+32-(nTamForn+nTamLoja),Iif(aSX6[MV_VISDIRF] == "1" .And. lRotina,aPosicao[3]-10,aPosicao[3])),aPosicao[4]+2,,{STR0003,STR0004,STR0005,STR0007},{30,90,50,50},oJanela,,,,,,,,,,,,.F.,,.T.,,.F.,,, ) //"Cod."###"Descricao"###"Base Imposto"###"Vlr. Imposto"
EndIf

If cPaisLoc == "ARG"
	nPosDum	:=	Ascan(aTemp,{|x| x[1] == "DUM"})
	If nPosDum > 0
		aDel(aTemp,nPosDum)
		aSize(aTemp,Len(aTemp)-1)
	Endif
Endif

oList:SetArray(aTemp)

If aPE[PE_VISUIMP]
	lVisuimp := ExecBlock("VISUIMP",.F.,.F.,{lVisuimp})
Endif

If !lVisual .And. !lVisuimp
	oList:bLDblClick 	:= {|| MaFisVRodape(oList,bValidPrg,nTipo,oList:nColPos) .And. MaFisInsereImp(oList,bValidPrg,nTipo)}
EndIf

oList:bChange 		:= {|| MaAtuCdR(@cCodRet,aCodR,oList,oCodRet,oCombo,@nCombo,aOpcoes)}
oList:bLine 		:= {|| MaFisLine(oList,aTemp,nTipo) }
oList:lAutoEdit	:= !lVisual .And. !lVisuimp

Return oList

/*/
MaFisVRoda - Edson Maricate -13.12.1999
Atualiza o Array de Resumos da NF.
/*/
Function MaFisVRodape(oList,bValidPrg,nTipo,nCol)

Local cIniCpo   := ""
Local nPos      := oList:nAT
Local nBaseAnt  := 0
Local nBase     := 0
Local nVal      := 0
Local nLiv	    := 0
Local lEditaVal := .F.
Local lEditaBas	:= .F.
Local nDec		:= IIf( MaFisFound("NF") , MsDecimais(Max(aNFCab[NF_MOEDA],1)) , 2 )
Local cPictGet	:= '@E 999,999,999' + IIf( nDec > 0 , "." + Replicate("9",nDec) , "" )
Local lZerouCMP := .F.
Local cImpuesto := ""
Local lTribGen  := cPaisLoc == "BRA" .And. MaFisFound("NF") .And. IIf(nTipo==1,AllTrim(MaFisRet(,'NF_IMPOSTOS')[nPos][6])=="TG", AllTrim(MaFisRet(,'NF_IMPOSTOS2')[nPos][5])=="TG")

Private nValBck	:= 0
Private nValAnt := 0
Private cImposto:= ""
DEFAULT nCol := 0

If MaFisFound("NF") .And. Len( aNFCab[NF_IMPOSTOS] ) > 0 .And. IIf(nTipo==1,MaFisVldAlt(MaFisRet(,'NF_IMPOSTOS')[nPos][6]),MaFisVldAlt(MaFisRet(,'NF_IMPOSTOS')[nPos][5]))

	nBaseAnt := IIf(nTipo==1,aNFCab[NF_IMPOSTOS][nPos][3],aNFCab[NF_IMPOSTOS2][nPos][3])
	nBase    := nBaseAnt

	lEditaVal:= IIf(aScan(aNfCab[NF_RELIMP],{|x|x[3]==AllTrim('IT_VAL'+IIf(nTipo==1,IIf('IT_VAL'+MaFisRet(,'NF_IMPOSTOS')[nPos][6] == "IT_VALCID",MaFisRet(,'NF_IMPOSTOS')[nPos][2],MaFisRet(,'NF_IMPOSTOS')[nPos][6]),MaFisRet(,'NF_IMPOSTOS2')[nPos][5]))})>0 ;
	.Or.  aScan(aNfCab[NF_RELIMP],{|x|x[3]==AllTrim('NF_VAL'+IIf(nTipo==1,MaFisRet(,'NF_IMPOSTOS')[nPos][6],MaFisRet(,'NF_IMPOSTOS2')[nPos][5]))})>0 ,.T.,.F.) ;
	.Or. MaFisRet(,'NF_IMPOSTOS')[nPos][6]=="RUR";
	.Or. lTribGen

	If cPaisLoc <> "BRA"
		lEditaBas := .F.
	Else
		lEditaBas:= IIf(aScan(aNfCab[NF_RELIMP],{|x|x[3]==AllTrim('IT_BASE'+IIf(nTipo=1,MaFisRet(,'NF_IMPOSTOS')[nPos][6],MaFisRet(,'NF_IMPOSTOS2')[nPos][5]))})>0 ;
		.Or.  aScan(aNfCab[NF_RELIMP],{|x|x[3]==AllTrim('NF_BASE'+IIf(nTipo=1,MaFisRet(,'NF_IMPOSTOS')[nPos][6],MaFisRet(,'NF_IMPOSTOS2')[nPos][5]))})>0 ;
		.Or. lTribGen ,.T.,.F.)
	Endif

	// Monta a Edicao da Base do imposto
	If lEditaBas .And. ( nCol == 0 .Or. nCol == 3)
		MaFisEditCell(@nBase,oList,cPictGet,3,'Positivo()')
		If nBaseAnt <> nBase
			If nTipo == 1
				If lTribGen 
					MaFisAlt("IMP_TRIBGEN",nBase,nPos,,,,,,,{MaFisRet(,'NF_IMPOSTOS')[nPos][1],"TG_IT_BASE"})
					lEditaVal := Len(aNFCab[NF_IMPOSTOS]) >= nPos
				Else
					cIniCpo	:= 'IMP_BASE'
					MaFisAlt('IMP_BASE'+MaFisRet(,'NF_IMPOSTOS')[nPos][6],nBase,nPos)
					If Len(aNFCab[NF_IMPOSTOS]) >= nPos
						If nBase > 0
							aNFCab[NF_IMPOSTOS][nPos][3] := nBase
						EndIf
					Else
						lEditaVal := .F.
					EndIf
				EndIf
			Else
				If lTribGen
					MaFisAlt("NF_TRIBGEN",nBase,nPos,,,,,,,{MaFisRet(,'NF_IMPOSTOS2')[nPos][1],"TG_NF_BASE"})
					lEditaVal := Len(aNFCab[NF_IMPOSTOS2]) >= nPos
				Else
					cIniCpo	:= 'NF_BASE'
					MaFisAlt('NF_BASE'+MaFisRet(,'NF_IMPOSTOS2')[nPos][5],nBase,nPos)
					If Len(aNFCab[NF_IMPOSTOS2]) >= nPos
						aNFCab[NF_IMPOSTOS2][nPos][3] := nBase
					Else
						lEditaVal := .F.
					EndIf
				EndIf
			EndIf
			Eval(bValidPrg)
			MaFisRRefresh(oList,nTipo)
		EndIf
	EndIf

	If lEditaVal
		nLiv:=NumCpoImpVar(Subs(IIf(nTipo==1,aNFCab[NF_IMPOSTOS][nPos][6],aNFCab[NF_IMPOSTOS2][nPos][5]),3,1))
		If nLiv > 0
			nValBck := aNFCab[NF_VLRORIG][nLiv]
		EndIf
		nValAnt	:= IIf(nTipo==1,aNFCab[NF_IMPOSTOS][nPos][5],aNFCab[NF_IMPOSTOS2][nPos][4])
		nVal	:= nValAnt
		If cPaisLoc=="BRA"
			MaFisEditCell(@nVal,oList,cPictGet,IIf(nTipo==1,5,4),'Positivo()')
		Else
			cImposto:= IIf(nTipo==1,aNFCab[NF_IMPOSTOS][nPos][1],aNFCab[NF_IMPOSTOS2][nPos][1])
			MaFisEditCell(@nVal,oList,cPictGet,IIf(nTipo==1,5,4),'LocxValImp(ReadVar(),nValBck,cImposto)')
		Endif
		If nValAnt<>nVal
			If nTipo == 1
				If lTribGen
					MaFisAlt("IMP_TRIBGEN",nVal,nPos,,,,,,,{MaFisRet(,'NF_IMPOSTOS')[nPos][1],"TG_IT_VALOR"})
				Else
					// Verifico se zerou o valor de ICMS Complementar, pois como o mesmo nao tem
					// base de calculo se o valor for zerado o tributo eh eliminado da listagem.
					// Se for o caso nao posso utilizar o "nPos" p/ indexar o NF_IMPOSTOS pois o
					// nro de elementos nao eh mais o mesmo, visto que foi removida uma linha.
					If MaFisRet(,'NF_IMPOSTOS')[nPos][6] == "CMP" .And. nVal == 0
						lZerouCMP := .T.
					EndIf
					MaFisAlt('IMP_VAL'+IIf('IMP_VAL'+MaFisRet(,'NF_IMPOSTOS')[nPos][6] == "IMP_VALCID",MaFisRet(,'NF_IMPOSTOS')[nPos][2],MaFisRet(,'NF_IMPOSTOS')[nPos][6]),nVal,nPos)
					If !lZerouCMP
						If Len(aNFCab[NF_IMPOSTOS]) >= nPos
							aNFCab[NF_IMPOSTOS][nPos][5] := nVal
						Endif
					EndIf
				EndIf
			Else
				If lTribGen
					MaFisAlt("NF_TRIBGEN",nVal,nPos,,,,,,,{MaFisRet(,'NF_IMPOSTOS2')[nPos][1],"TG_NF_VALOR"})	
				Else
					If MaFisRet(,'NF_IMPOSTOS2')[nPos][5] == "CMP" .And. nVal == 0
						lZerouCMP := .T.
					EndIf
					cImpuesto := MaFisRet(,'NF_IMPOSTOS2')[nPos][1]
					MaFisAlt('NF_VAL'+MaFisRet(,'NF_IMPOSTOS2')[nPos][5],nVal,nPos)
					If !lZerouCMP
						If cPaisLoc == "ARG"
							nPos := ASCAN(MaFisRet(,'NF_IMPOSTOS2'),{|X| X[1] == cImpuesto})
						EndIf
						If Len(aNFCab[NF_IMPOSTOS2]) >= nPos
							aNFCab[NF_IMPOSTOS2][nPos][4] := nVal
						Endif
					EndIf
				EndIf
			EndIf
			Eval(bValidPrg)
			MaFisRRefresh(oList,nTipo)
			If nLiv > 0
				aNFCab[NF_VLRORIG][nLiv]:=nValBck
			EndIf
		EndIf
	EndIf
EndIf

Return .T.

/*
MaVldForn      Nereu H. Jr. Microsiga  Data   12/09/03
Desc.      Valida fornecedor no momento da transferencia de fornecedor
           na implantacao do titulo de ISS
*/
Static Function MaVldForn(cFornIss,cLojaIss,oDescri,cDescri,oLojaISS,oFornIss,nTipo)
Local lRet := .F.

If Empty(cFornIss)
	cLojaISS:= Space(Len(cLojaIss))
	lRet    := .T.
	cDescri := ""
	oDescri:Refresh()
Else
	dbSelectArea("SA2")
	dbSetOrder(1)
	If MsSeek(xFilial("SA2")+cFornIss+cLojaIss)
		cDescri:= SA2->A2_NREDUZ
		lRet   := .T.
		oDescri:Refresh()
	Else
		If nTipo == 1
			lRet := .T.
		Else
			lRet := .F.
		Endif
		cDescri := ""
	Endif
EndIf

If nTipo == 2 .And. Empty(cLojaIss) .And. !Empty(cFornIss)
	cFornISS := Space(Len(cFornIss))
	lRet     := .T.
	cDescri  := ""
	oDescri:Refresh()
	oFornIss:Refresh()
Endif

IF lRet .And. !RegistroOk("SA2")
	lRet     := .F.
EndIf

Return(lRet)

/*/
MaFisVldAlt - Edson Maricate-02.02.2000
Verifica a referencia e se a mesma pode ser alterada.
/*/
Function MaFisVldAlt(cReferencia,nItem)
Local lRet := .T.

If cPaisLoc == "BRA"
	Do Case
		Case aNfCab[NF_TIPONF] == "I" .And. Alltrim(cReferencia)$"IT_QUANT"
			Help("   ",1,"COMPICM")
			lRet := .F.
		Case aNfCab[NF_TIPONF] == "P" .And. AllTrim(cReferencia)$"IT_BASEIPI#NF_BASEIPI#IT_VALIPI#NF_VALIPI#IT_QUANT"
			Help("   ",1,"COMPIPI")
			lRet := .F.
		 //Alteração feita em conjunto com materiais e faturamento, para que no complemento de preço
		//	seja possível informar a quantidade.
		Case aNfCab[NF_TIPONF] == "C" .And. AllTrim(cReferencia)$"IT_QUANT"
			If aNfCab[NF_TPCOMPL] == '1' .OR. EmpTy(aNfCab[NF_TPCOMPL])
				Help("   ",1,"COMPPRC")
				lRet := .F.
			ElseIF aNfCab[NF_TPCOMPL] == '3'
				Help("   ",1,"COMPFRT")
				lRet := .F.
			EndIF
		// Campos soh podem ser alterados em NF's de complemento de ICMS/DIFAL
		Case (aNfCab[NF_TIPONF] <> "I" .And. (AllTrim(cReferencia) == "IT_ALFCCMP" .Or.;
											  AllTrim(cReferencia) == "IT_VFCPDIF" .Or.;
											  AllTrim(cReferencia) == "IT_ALIQFECP" .Or.;
											  AllTrim(cReferencia) == "IT_VALFECP" .Or.;
											  AllTrim(cReferencia) == "IT_BASEDES" .Or.;
											  AllTrim(cReferencia) == "IT_DIFAL"))
			MsgInfo(STR0048 + STR0049)
			lRet := .F.
	EndCase
Else
	If nItem <> NIL .And. !Empty(aNfItem[nItem][IT_REMITO]) .And. Alltrim(cReferencia)$"IT_PRODUTO"
		Help("   ",1,"LOCXNF0003")
		lRet := .F.
	Endif
Endif

Return lRet

/*/
MaFisLine - Edson Maricate  -13.12.1999
Retorna a linha de exibicao do ListBox atualizado.
*/
Function MaFisLine(oList,aTemp,nTipo)
Local aRet,nDec
Local cPictAliq	:= IIf(cPaisLoc="BRA", "@E 999.99", PesqPict("SFB","FB_ALIQ"))
Local cPictVal	:= ""
Local nVlrPis	:= IIf(cPaisLoc="BRA" .AND. aPos[FP_B1_VLR_PIS], TamSX3("B1_VLR_PIS")[02], 0)
Local nPPis		:= TamSX3("B1_PPIS")[02]
Local cPictAlDef:=cPictAliq
Local nDecAliq
Local cVlrAliq
Local nPosVg
Local naTemp

If aSX6[MV_DECALIQ]
	cPictAliq	:= IIf(cPaisLoc="BRA",IIF(nVlrPis > nPPis, PesqPict("SB1","B1_VLR_PIS"),PesqPict("SB1","B1_PPIS")),PesqPict("SFB","FB_ALIQ"))
EndIf

If cPaisLoc="BRA" .And. cPictAliq==cPictAlDef
	nPosVg  :=RAt(".",cPictAliq)
	nDecAliq:=Len(Right(cPictAliq,Len(cPictAliq)-nPosVg))
	For naTemp:=1 To Len(aTemp)
		If ValType(aTemp[naTemp][4])=="N"
			cVlrAliq:=Str(aTemp[naTemp][4])
			nPosVg  :=RAt(".",cVlrAliq)
			If nPosVg>0 .And. Len(Right(cVlrAliq,Len(cVlrAliq)-nPosVg))>nDecAliq
				nDecAliq:=Len(Right(cVlrAliq,Len(cVlrAliq)-nPosVg))
			Endif
		EndIf
	Next naTemp
	If nDecAliq=3
		cPictAliq:="@E 999.999"
	ElseIf nDecAliq=4
		cPictAliq:="@E 999.9999"
	ElseIf nDecAliq=5
		cPictAliq:="@E 999.99999"
	ElseIf nDecAliq=6
		cPictAliq:="@E 999.999999"
	EndIf
EndIf

If cPaisLoc<>"BRA"
	If FunName()=="MATA121" .And. Type("nMoedaPed")=="N"
		nDec:=MsDecimais(nMoedaPed)
	ELSEIf FunName()=="MATA123" .And. Type("nMoedaPed")=="N"
		nDec:=MsDecimais(nMoedaPed)
	ElseIf FunName()=="MATA150" .And. Type("nMoedaCot")=="N"
		nDec:=MsDecimais(nMoedaCot)
	ElseIf FunName()=="MATA410"
		nDec:=MsDecimais(M->C5_MOEDA)
	Else
		nDec:=MsDecimais(IIf(Type("nMoedaNF")=="N",nMoedaNF,IIf(Type("nMoedaCor")=="N",nMoedaCor,1)))
	Endif
Else
	nDec:=2
Endif
cPictVal := "@E 999,999,999,999"+IIf(nDec>0,"."+Replicate("9",nDec),"")
If Len(aTemp)>0
	If nTipo == 1
		aRet:= {aTemp[oList:nAt][1],;
		aTemp[oList:nAt][2],;
		IIf(ValType(aTemp[oList:nAt][3])=="N",TransForm(aTemp[oList:nAt][3],cPictVal),aTemp[oList:nAt][3]),;
		TransForm(aTemp[oList:nAt][4],cPictAliq),;
		IIf(valType(aTemp[oList:nAt][5])=="N",TransForm(aTemp[oList:nAt][5],cPictVal),aTemp[oList:nAt][5]) }
	Else
		aRet:= {aTemp[oList:nAt][1],;
		aTemp[oList:nAt][2],;
		IIf(ValType(aTemp[oList:nAt][3])=="N",TransForm(aTemp[oList:nAt][3],cPictVal),aTemp[oList:nAt][3]),;
		IIf(ValType(aTemp[oList:nAt][4])=="N",TransForm(aTemp[oList:nAt][4],cPictVal),aTemp[oList:nAt][4]) }
	EndIf
Else
	aRet:={}
Endif

Return aRet

/*/
MaFisInser - Edson Maricate -13.12.1999
Insere um novo Imposto na NF.
*/
Function MaFisInsereImp(oList,bValidPrg,nTipo)
Local oDlg
Local oCombo
Local lOk		:= .F.
Local nPos		:= oList:nAT
Local lInsere	:= .F.
Local aImpostos	:= {'IRRF Imposto de Renda','ISS Imp. Serviço','I.C.M.S','IPI','ICMS Retido','INSS','PIS - Via Apuração','COFINS - Via Apuração','PIS - Via Retençao','COFINS - Via Retençao','CSLL - Via Retençao','ICMS Complementar','PIS - Subst. Tributaria','COFINS - Subst. Tributaria','SEST/SENAT','FETHAB','FABOV','FACS','CPRB','FUNDESA','IMA-MT','FASE-MT','INSS - Patronal','CIDE'}
Local aImpCod	:= {'IRR','ISS','ICM','IPI','SOL','INS','PS2','CF2','PIS','COF','CSL','CMP','PS3','CF3','SES','FET','FAB','FAC','CPB','FUN','IMA','FAS','INP','CID'}
Local nBase		:= 0
Local nValor	:= 0
Local cImposto	:= aImpostos[1]
Local cVersao	:= GetVersao(.F.)
Local cCodImp	:= ""
Local cCodVal	:= ""
Local lAtuImpMan	:= .T.

lInsere := If( MaFisFound("NF"), AllTrim(IIf(nTipo==1,Len(MaFisRet(,'NF_IMPOSTOS'))>0 .And. MaFisRet(,'NF_IMPOSTOS')[nPos][6],Len(MaFisRet(,'NF_IMPOSTOS2'))>0 .And. MaFisRet(,'NF_IMPOSTOS2')[nPos][5]))=="NEW", .F. )

If lInsere .And. cPaisLoc=="BRA"

	If cVersao <> "12"
		DEFINE MSDIALOG oDlg FROM 119,147 TO 320,580 TITLE "Impostos" Of oMainWnd PIXEL
		@ 22 ,09  SAY "Imposto" Of oDlg PIXEL SIZE 41,09
		@ 21 ,34  MSCOMBOBOX oCombo VAR cImposto ITEMS aImpostos SIZE 106,50 OF oDlg PIXEL
		@ 43 ,09  SAY "Base" Of oDlg PIXEL SIZE 28 ,9
		@ 59 ,09  SAY "Valor" Of oDlg PIXEL SIZE 42 ,9
		@ 42 ,34  MSGET nBase  Picture "@E 999,999,999,999.99" Valid Positivo(nBase)  OF oDlg PIXEL SIZE 75,09
		@ 60 ,34  MSGET nValor Picture "@E 999,999,999,999.99" Valid Positivo(nValor) OF oDlg PIXEL SIZE 75,09
	Else
		DEFINE MSDIALOG oDlg FROM 119,147 TO 320,850 TITLE "Impostos" Of oMainWnd PIXEL
		@ 42 ,09  SAY "Imposto" Of oDlg PIXEL SIZE 41,09
		@ 41 ,34  MSCOMBOBOX oCombo VAR cImposto ITEMS aImpostos SIZE 106,50 OF oDlg PIXEL
		@ 63 ,09  SAY "Base" Of oDlg PIXEL SIZE 28 ,9
		@ 79 ,09  SAY "Valor" Of oDlg PIXEL SIZE 42 ,9
		@ 62 ,34  MSGET nBase  Picture "@E 999,999,999,999.99" Valid Positivo(nBase)  OF oDlg PIXEL SIZE 75,09
		@ 80 ,34  MSGET nValor Picture "@E 999,999,999,999.99" Valid Positivo(nValor) OF oDlg PIXEL SIZE 75,09
	EndIf

	ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{||lOk:=.T.,oDlg:End()},{||oDlg:End()}) CENTERED

EndIf

If lOk
	If aPE[PE_MFISIMP]
		lAtuImpMan := Execblock("MFISIMP",.F.,.F.,{nValor,aImpCod,cImposto,nBase})
		If Valtype(lAtuImpMan) <> 'L'
			lAtuImpMan := .T.
		EndIF
	Endif
	cCodImp := aImpCod[aScan(aImpostos,cImposto)]
	cCodVal := cCodImp
	If cCodImp == "CID"
		cCodVal := "CIDE"
	EndIf
	If lAtuImpMan .And. !Empty(MaFisScan("NF_BASE"+cCodImp,.F.)) .And. (nBase > 0 .Or. cCodImp $ "PIS,COF,CSL,IRR")
		MaFisAlt("NF_BASE"+cCodImp,nBase,)
	EndIf
	If lAtuImpMan .And. !Empty(MaFisScan("NF_VAL"+cCodVal,.F.)) .And. (nValor > 0 .Or. cCodVal $ "PIS,COF,CSL,IRR")
		MaFisAlt("NF_VAL"+cCodVal,nValor,)
	EndIf
	If lAtuImpMan .And. nBase + nValor > 0
		MaFisRRefresh(oList,nTipo)
		Eval(bValidPrg)
	EndIf
EndIf

Return .T.

/*/
MaFisEditCellLine - Edson Maricate  Data 13.12.1999
Cria um Get para edicao do Imposta no ListBox.
/*/
Function MaFisEditCell(nValor,oBrowse,cPict,nCol,cValidCpo)
Local oDlg
Local oRect
Local oGet1
Local oBtn
Local cMacro   := ''
Local nRow     := oBrowse:nAt
Local oOwner   := oBrowse:oWnd
Local lMaVldImp:= aPE[PE_MAVLDIMP]
Local cValid   := IIf( cValidCpo == Nil , '.T.' , cValidCpo ) + ' .And. Eval(bChange)'
Local cCelula  := Iif( nCol == 3 , "BASE" , "VALOR" )

bChange:= { || nValor := &cMacro,oBrowse:aArray[nRow,nCol] := &cMacro }
oRect  := tRect():New(0,0,0,0)    // obtem as coordenadas da celula (lugar onde
oBrowse:GetCellRect(nCol,,oRect)  // a janela de edicao deve ficar)
aDim   := {oRect:nTop,oRect:nLeft,oRect:nBottom,oRect:nRight}

DEFINE MSDIALOG oDlg OF oOwner FROM 0,0 TO 0,0 STYLE nOR( WS_VISIBLE, WS_POPUP ) PIXEL

cMacro := "M->CELL"
&cMacro:= nValor
cPict  := cPict

@ 0,0 MSGET oGet1 VAR &(cMacro) SIZE 0,0 OF oDlg FONT oOwner:oFont PICTURE cPict PIXEL HASBUTTON ;
VALID IIf( lMaVldImp , ExecBlock("MAVLDIMP", .F., .F. , { oBrowse:aArray[nRow,1] , oBrowse:aArray[nRow,3] , oBrowse:aArray[nRow,5] , cCelula , &(cMacro) } ) , .T. ) .And. &cValid

oGet1:Move(-2,-2, (aDim[ 4 ] - aDim[ 2 ]) + 4, aDim[ 3 ] - aDim[ 1 ] + 4 )

@ 0,0 BUTTON oBtn PROMPT "ze" SIZE 0,0 OF oDlg
oBtn:bGotFocus := {|| oDlg:nLastKey := VK_RETURN, oDlg:End(0)}

oGet1:cReadVar  := cMacro

ACTIVATE MSDIALOG oDlg ON INIT oDlg:Move(aDim[1],aDim[2],aDim[4]-aDim[2], aDim[3]-aDim[1])

oBrowse:nAt := nRow
SetFocus(oBrowse:hWnd)
oBrowse:Refresh()

Return Nil

/*/
MaFisRRefresh - Edson Maricate - 13.12.1999
Executa o Refresh no ListBox.
/*/
Function MaFisRRefresh(oList,nTipo,oFornISS,cFornISS,oLojaISS,cLojaISS,oRecISS,cRecISS,oVencISS,dVencISS,cDescri,oDescri)
Local aTemp
Local nPosDum := 0

If nTipo == 1
	aTemp := IIf(!Empty(aNfCab),aNfCab[NF_IMPOSTOS],{{"","",0,0,0}})
Else
	aTemp := IIf(!Empty(aNfCab),aNfCab[NF_IMPOSTOS2],{{"","",0,0}})
EndIf

If cPaisLoc == "ARG"
	nPosDum	:= Ascan(aTemp,{|x| x[1] == "DUM"})
	If nPosDum > 0
		aDel(aTemp,nPosDum)
		aSize(aTemp,Len(aTemp)-1)
	Endif
Endif

If aSX6[MV_ISSXMUN]
	If ValType(oFornISS)<>"U" .And. Empty(cFornISS)
		cFornISS := cFornCE1
		oFornISS:Refresh()
	EndIf

	If ValType(oLojaISS)<>"U" .And. Empty(cLojaISS)
		cLojaISS := cLojaCE1
		oLojaISS:Refresh()
	EndIf

	If ValType(oDescri)<>"U" .And. Empty(cDescri)
		cDescri  := cDescCE1
		oDescri:Refresh()
	EndIf

	If ValType(oVencISS)<>"U" .And. Empty(dVencISS)
		dVencISS := dVencCE1
		oVencISS:Refresh()
	EndIf

	If ValType(oRecISS)<>"U" .And. Empty(cRecISS)
		cRecISS := cRecISSCE1
		oRecISS:Refresh()
	EndIf
EndIf
If ValType(oList)<>"U"
	oList:SetArray(aTemp)
	oList:bLine := {|| MaFisLine(oList,aTemp,nTipo) }
	oList:Refresh()
EndIf

Return .T.

/*
	Funo    MaGrvCdR -Gustavo G. Rueda  Data 15.12.2006
	Descrio Funcao de amarracao do Codigo de receita a devida retencao
	da aba impostos. Somente para PIS/COF/CSL/IRR.
	ParametrosExpC1: Variavel cCodRet que recebe o codigo atualizado.
	ExpO2: Objeto oCombo para refresh.
	ExpO3: Objeto oList para refresh.
	ExpA4: Variavel aCodR que contem todos os codigos d retencoes
	relacionados na nota
	ExpO5: Objeto oCodRet para refresh
	ExpL6: Flag para identificar se a chamada estah sendo d valid
	do campo E2_CODRET
	lRet -> Flag de retorno para o VALID
*/
Static Function MaGrvCdR(cCodRet,oCombo,oList,aCodR,oCodRet,lCodRet)
Local lRet    := .T.
Local nPosCodR:= aScan(aCodR, {|x|x[4]==oList:AARRAY[oList:nAt][1]})
Local lVPos := ValType(oList)=='O' .and. (ValType(oList:AARRAY)=='A' .and. len(oList:AARRAY) > 0 )
DEFAULT lCodRet := .F.
//Quando o combo for 2(Nao) nao deve ter o codigo de receita, por isso atribuo 2 e branco.
If oCombo:nAt==2
	cCodRet := Iif(cPaisLoc=="BRA", Space(TamSx3("E2_CODRET")[1]), Space(4))
	oCodRet:Refresh()
	If nPosCodR!=0
		aCodR[nPosCodR][2]:= cCodRet
		aCodR[nPosCodR][3]:= oCombo:nAt
	Else
		If lVpos
			aAdd( aCodR, {oList:nAt, cCodRet, oCombo:nAt, oList:AARRAY[oList:nAt][1]} )
		Endif
	EndIf
Else
	oCodRet:Refresh()
	If lCodRet .And. !CheckSx3("E2_CODRET", cCodRet)
		lRet := .F.
	Else
		If lCodRet .And. aPE[PE_VLCODRET]
			lRet := ExecBlock( "VLCODRET",.F.,.F.,{ oList:AARRAY[oList:nAt][1] , cCodRet })
			If ValType(lRet) <> "L"
				lRet :=  .T.
			EndIf
		EndIf

		If lRet
			If nPosCodR!=0
				aCodR[nPosCodR][2]:= cCodRet
				aCodR[nPosCodR][3]:= oCombo:nAt
			Else
				If lVPos
					aAdd( aCodR, {oList:nAt, cCodRet, oCombo:nAt, oList:AARRAY[oList:nAt][1]} )
				EndIf
			EndIf
		EndIf
	EndIf
EndIf

Return lRet

/*/
MaAtuCdR -Gustavo G. Rueda-15.12.2006
Rotina de atualizacao do codigo de receita exibido na aba impostos a medida que seleciono a retencao no browse ao lado
Parametros
ExpC1: Variavel cCodRet que recebe o codigo atualizado.
ExpA2: Variavel aCodR que contem todos   codigos de retencoes relacionados na nota.
ExpO3: Objeto oList para refresh.
ExpO4: Objeto oCodRet para refresh.
ExpO5: Objeto oCombo para refresh.
ExpO6: Variavel nCombo que recebe a opcao selecionada.
ExpO7: Variavel aOpcoes que contem as opcoes para selecao.
/*/
Function MaAtuCdR(cCodRet,aCodR,oList,oCodRet,oCombo,nCombo,aOpcoes)
Local nPosCodR := 0
Local nX       := 0

If oList <> Nil
	//Este tratamento se deve para o codigo de receita do IR caso venha preenchido atraves do MV_AUTOISS ou do PE MT103DRF.
	If Len(aCodR) == 1 .And. aCodR[1][1] == 99
		For nX := 1 To Len(oList:aArray)
			If oList:aArray[nX][1]=="IRR"
				aCodR[1][1]	:= nX
			EndIf
		Next nX
	EndIf

	If (nPosCodR:= aScan(aCodR, {|x|x[4] == oList:aArray[oList:nAt][1]})) > 0
		cCodRet	:= aCodR[nPosCodR,2]
		nCombo	:= aOpcoes[aCodR[nPosCodR,3]]
	Else
		cCodRet	:= Iif(cPaisLoc=="BRA", Space(TamSx3("E2_CODRET")[1]), Space(4))
		nCombo	:= aOpcoes[2]
	EndIf
EndIf
If oCodRet <> Nil
	oCodRet:Refresh()
EndIf
If oCombo <> Nil
	oCombo:Refresh()
EndIf


Return .T.

/* FUNCOES SECUNDARIAS AS FUNCOES PRINCIPAIS - FUNCOES DE APOIO */

/*/
MaFisIniCpo -Alexandre Lemes -08/12/2012
/*/
Static Function MaFisIniCpo(nItem,lSeek)
Local lSBI       := cAliasPROD == "SBI"
Local lArqProp   := Iif(cPaisLoc == "BRA",aSX6[MV_ARQPROP], .F.)
Local lSS4  := .F.
Local lSS6  := .F.
Local lSS5  := .F.
Local lSeekCG1	:= .F.
Local cHistSB1   := ""
Local cHistCFC   := ""
Local cHistSBZ   := ""
Local cHistSB5   := ""
Local cCodAtv		:= ""

DEFAULT lSeek    := .T.

If lSeek
	If aNfItem[nItem][IT_RECNOSB1] <> 0 .And. cAliasPROD == "SB1"
		(cAliasPROD)->(MsGoto(aNfItem[nItem][IT_RECNOSB1]))
		//Complemento do produto
		SB5->(dbSetOrder(1))
		SB5->(MsSeek(xFilial("SB5")+aNfItem[nItem][IT_PRODUTO]))
	Else
		If cAliasPROD == "SBI"
			SBI->(dbSetOrder(1))
			SBI->(MsSeek(xFilial("SBI")+aNfItem[nItem][IT_PRODUTO]))
		EndIf
		//Produto
		SB1->(dbSetOrder(1))
		SB1->(MsSeek(xFilial("SB1")+aNfItem[nItem][IT_PRODUTO]))
		//Complemento do produto
		SB5->(dbSetOrder(1))
		SB5->(MsSeek(xFilial("SB5")+aNfItem[nItem][IT_PRODUTO]))
		If lHistorico
			//Se for reprocessamento,  e tiver habilitado para buscar os Historico Fiscais,
			//verifico se o ID do historico do Cliente e igual ao que foi gravado na Nota. Se for
			//igual é porque nao teve alterações no cliente após a emissão. Se for diferente,
			//é porque teve alterações no cadastro, e entao os dados são carregados da tabela de
			//Historico(SS2).
			If( aNfCab[NF_CLIFOR]=="C" .And. aNfCab[NF_TIPONF]<>"D") .Or.( aNfCab[NF_CLIFOR]=="F" .And. aNfCab[NF_TIPONF]$"D|B")
				cHistSB1 := (cAlsItem)->D2_IDSB1
				cHistSB5 := (cAlsItem)->D2_IDSB5
			Else
				cHistSB1 := (cAlsItem)->D1_IDSB1
				cHistSB5 := (cAlsItem)->D1_IDSB5
			End
			If cPaisLoc == "BRA" .And. Alltrim(SB1->B1_IDHIST)<>Alltrim(cHistSB1)
				SS4->(dbSetOrder(1))
				SS4->(MsSeek(xFilial("SS4")+cHistSB1))
				lSS4 := .T.
			EndIf
			If cPaisLoc == "BRA" .And. Alltrim(SB5->B5_IDHIST) <> Alltrim(cHistSB5)
				SS5->(dbSetOrder(1))
				SS5->(MsSeek(xFilial("SS5")+cHistSB5))
				lSS5 := .T.
			EndIf
		EndIf
	EndIf
	If cPaisLoc == "BRA"
		// Carga da CG1
		If !Empty(aSX6[MV_CPRBATV])
			cCodAtv := aSX6[MV_CPRBATV]
		Else
			cCodAtv := IIf(aPos[FP_B5_CODATIV], SB5->B5_CODATIV, "")
		Endif
		If aDic[AI_CG1]
			CG1->(dbSetOrder(1))
			If CG1->(MsSeek(xFilial("CG1")+cCodAtv+DTOS(CTOD("  /  /    "))))
				lSeekCG1 := .T.
			EndIf
		EndIf
	EndIf
EndIf

aNfItem[nItem][IT_PRD][SB_COD]    := IIf( lSBI .And. aPos[FP_BI_COD]    , SBI->BI_COD    , IIf( aPos[FP_B1_COD]    .And. lSeek , IIf(lSS4, SS4->S4_COD    , SB1->B1_COD    ), " " ) )
aNfItem[nItem][IT_PRD][SB_GRTRIB] := IIf( lSBI .And. aPos[FP_BI_GRTRIB] , SBI->BI_GRTRIB , IIf( aPos[FP_B1_GRTRIB] .And. lSeek , IIf(lSS4, SS4->S4_GRTRIB , SB1->B1_GRTRIB ), " " ) )
aNfItem[nItem][IT_PRD][SB_CODIF]  := IIf( lSBI .And. aPos[FP_BI_CODIF]  , SBI->BI_CODIF  , IIf( aPos[FP_B1_CODIF]  .And. lSeek , IIf(lSS4 .And. aPos[FP_S4_CODIF] , SS4->S4_CODIF  , SB1->B1_CODIF  ), " " ) )
aNfItem[nItem][IT_PRD][SB_RSATIVO]:= IIf( lSBI .And. aPos[FP_BI_RSATIVO], SBI->BI_RSATIVO, IIf( aPos[FP_B1_RSATIVO].And. lSeek , IIf(lSS4, SS4->S4_RSATIVO, SB1->B1_RSATIVO), " " ) )
aNfItem[nItem][IT_PRD][SB_POSIPI] := IIf( lSBI .And. aPos[FP_BI_POSIPI] , SBI->BI_POSIPI , IIf( aPos[FP_B1_POSIPI] .And. lSeek , IIf(lSS4, SS4->S4_POSIPI , SB1->B1_POSIPI ), " " ) )
aNfItem[nItem][IT_PRD][SB_UM]     := IIf( lSBI .And. aPos[FP_BI_UM]     , SBI->BI_UM     , IIf( aPos[FP_B1_UM]     .And. lSeek , IIf(lSS4, SS4->S4_UM     , SB1->B1_UM     ), " " ) )
aNfItem[nItem][IT_PRD][SB_SEGUM]  := IIf( lSBI .And. aPos[FP_BI_SEGUM]  , SBI->BI_SEGUM  , IIf( aPos[FP_B1_SEGUM]  .And. lSeek , IIf(lSS4, SS4->S4_SEGUM  , SB1->B1_SEGUM  ), " " ) )
aNfItem[nItem][IT_PRD][SB_AFABOV] := IIf( lSBI .And. aPos[FP_BI_AFABOV] , SBI->BI_AFABOV , IIf( aPos[FP_B1_AFABOV] .And. lSeek , IIf(lSS4, SS4->S4_AFABOV , SB1->B1_AFABOV ), 0   ) )
aNfItem[nItem][IT_PRD][SB_AFACS]  := IIf( lSBI .And. aPos[FP_BI_AFACS]  , SBI->BI_AFACS  , IIf( aPos[FP_B1_AFACS]  .And. lSeek , IIf(lSS4, SS4->S4_AFACS  , SB1->B1_AFACS  ), 0   ) )
aNfItem[nItem][IT_PRD][SB_AFETHAB]:= IIf( lSBI .And. aPos[FP_BI_AFETHAB], SBI->BI_AFETHAB, IIf( aPos[FP_B1_AFETHAB].And. lSeek , IIf(lSS4, SS4->S4_AFETHAB, SB1->B1_AFETHAB), 0   ) )
aNfItem[nItem][IT_PRD][SB_TFETHAB]:= IIf( lSBI .And. aPos[FP_BI_TFETHAB], SBI->BI_TFETHAB, IIf( aPos[FP_B1_TFETHAB].And. lSeek , IIf(lSS4, SS4->S4_TFETHAB, SB1->B1_TFETHAB), " " ) )
aNfItem[nItem][IT_PRD][SB_PICM]   := IIf( lSBI .And. aPos[FP_BI_PICM]   , SBI->BI_PICM   , IIf( aPos[FP_B1_PICM]   .And. lSeek , IIf(lSS4, SS4->S4_PICM   , SB1->B1_PICM   ), 0   ) )
aNfItem[nItem][IT_PRD][SB_FECOP]  := IIf( lSBI .And. aPos[FP_BI_FECOP]  , SBI->BI_FECOP  , IIf( aPos[FP_B1_FECOP]  .And. lSeek , IIf(lSS4, SS4->S4_FECOP  , SB1->B1_FECOP  ), " " ) )
aNfItem[nItem][IT_PRD][SB_ALFECOP]:= IIf( lSBI .And. aPos[FP_BI_ALFECOP], SBI->BI_ALFECOP, IIf( aPos[FP_B1_ALFECOP].And. lSeek , IIf(lSS4, SS4->S4_ALFECOP, SB1->B1_ALFECOP), 0   ) )
aNfItem[nItem][IT_PRD][SB_ALIQISS]:= IIf( lSBI .And. aPos[FP_BI_ALIQISS], SBI->BI_ALIQISS, IIf( aPos[FP_B1_ALIQISS].And. lSeek , IIf(lSS4, SS4->S4_ALIQISS, SB1->B1_ALIQISS), 0   ) )
aNfItem[nItem][IT_PRD][SB_IMPZFRC]:= IIf( lSBI .And. aPos[FP_BI_IMPZFRC], SBI->BI_IMPZFRC, IIf( aPos[FP_B1_IMPZFRC].And. lSeek , IIf(lSS4, SS4->S4_IMPZFRC, SB1->B1_IMPZFRC), " " ) )
aNfItem[nItem][IT_PRD][SB_INT_ICM]:= IIf( lSBI .And. aPos[FP_BI_INT_ICM], SBI->BI_INT_ICM, IIf( aPos[FP_B1_INT_ICM].And. lSeek , IIf(lSS4, SS4->S4_INT_ICM, SB1->B1_INT_ICM), 0   ) )
aNfItem[nItem][IT_PRD][SB_PR43080]:= IIf( lSBI .And. aPos[FP_BI_PR43080], SBI->BI_PR43080, IIf( aPos[FP_B1_PR43080].And. lSeek , IIf(lSS4, SS4->S4_PR43080, SB1->B1_PR43080), 0   ) )
aNfItem[nItem][IT_PRD][SB_PRINCMG]:= IIf( lSBI .And. aPos[FP_BI_PRINCMG], SBI->BI_PRINCMG, IIf( aPos[FP_B1_PRINCMG].And. lSeek , IIf(lSS4, SS4->S4_PRINCMG, SB1->B1_PRINCMG), 0   ) )
aNfItem[nItem][IT_PRD][SB_ALFECST]:= IIf( lSBI .And. aPos[FP_BI_ALFECST], SBI->BI_ALFECST, IIf( aPos[FP_B1_ALFECST].And. lSeek , IIf(lSS4, SS4->S4_ALFECST, SB1->B1_ALFECST), 0   ) )
aNfItem[nItem][IT_PRD][SB_PICMENT]:= IIf( lSBI .And. aPos[FP_BI_PICMENT], SBI->BI_PICMENT, IIf( aPos[FP_B1_PICMENT].And. lSeek , IIf(lSS4, SS4->S4_PICMENT, SB1->B1_PICMENT), 0   ) )
aNfItem[nItem][IT_PRD][SB_PICMRET]:= IIf( lSBI .And. aPos[FP_BI_PICMRET], SBI->BI_PICMRET, IIf( aPos[FP_B1_PICMRET].And. lSeek , IIf(lSS4, SS4->S4_PICMRET, SB1->B1_PICMRET), 0   ) )
aNfItem[nItem][IT_PRD][SB_IVAAJU] := IIf( lSBI .And. aPos[FP_BI_IVAAJU] , SBI->BI_IVAAJU , IIf( aPos[FP_B1_IVAAJU] .And. lSeek , IIf(lSS4, SS4->S4_IVAAJU , SB1->B1_IVAAJU ), " " ) )
aNfItem[nItem][IT_PRD][SB_RASTRO] := IIf( lSBI .And. aPos[FP_BI_RASTRO] , SBI->BI_RASTRO , IIf( aPos[FP_B1_RASTRO] .And. lSeek , IIf(lSS4, SS4->S4_RASTRO , SB1->B1_RASTRO ), " " ) )
aNfItem[nItem][IT_PRD][SB_VLR_ICM]:= IIf( lSBI .And. aPos[FP_BI_VLR_ICM], SBI->BI_VLR_ICM, IIf( aPos[FP_B1_VLR_ICM].And. lSeek , IIf(lSS4, SS4->S4_VLR_ICM, SB1->B1_VLR_ICM), 0   ) )
aNfItem[nItem][IT_PRD][SB_VLR_PIS]:= IIf( lSBI .And. aPos[FP_BI_VLR_PIS], SBI->BI_VLR_PIS, IIf( aPos[FP_B1_VLR_PIS].And. lSeek , IIf(lSS4, SS4->S4_VLR_PIS, SB1->B1_VLR_PIS), 0   ) )
aNfItem[nItem][IT_PRD][SB_VLR_COF]:= IIf( lSBI .And. aPos[FP_BI_VLR_COF], SBI->BI_VLR_COF, IIf( aPos[FP_B1_VLR_COF].And. lSeek , IIf(lSS4, SS4->S4_VLR_COF, SB1->B1_VLR_COF), 0   ) )
aNfItem[nItem][IT_PRD][SB_ORIGEM] := IIf( lSBI .And. aPos[FP_BI_ORIGEM] , SBI->BI_ORIGEM , IIf( aPos[FP_B1_ORIGEM] .And. lSeek , IIf(lSS4, SS4->S4_ORIGEM , SB1->B1_ORIGEM ), " " ) )
aNfItem[nItem][IT_PRD][SB_CRDEST] := IIf( lSBI .And. aPos[FP_BI_CRDEST] , SBI->BI_CRDEST , IIf( aPos[FP_B1_CRDEST] .And. lSeek , IIf(lSS4, SS4->S4_CRDEST , SB1->B1_CRDEST ), 0   ) )
aNfItem[nItem][IT_PRD][SB_CODISS] := IIf( lSBI .And. aPos[FP_BI_CODISS] , SBI->BI_CODISS , IIf( aPos[FP_B1_CODISS] .And. lSeek , IIf(lSS4, SS4->S4_CODISS , SB1->B1_CODISS ), " " ) )
aNfItem[nItem][IT_PRD][SB_TNATREC]:= IIf( lSBI .And. aPos[FP_BI_TNATREC], SBI->BI_TNATREC, IIf( aPos[FP_B1_TNATREC].And. lSeek , IIf(lSS4, SS4->S4_TNATREC, SB1->B1_TNATREC), " " ) )
aNfItem[nItem][IT_PRD][SB_CNATREC]:= IIf( lSBI .And. aPos[FP_BI_CNATREC], SBI->BI_CNATREC, IIf( aPos[FP_B1_CNATREC].And. lSeek , IIf(lSS4, SS4->S4_CNATREC, SB1->B1_CNATREC), " " ) )
aNfItem[nItem][IT_PRD][SB_GRPNATR]:= IIf( lSBI .And. aPos[FP_BI_GRPNATR], SBI->BI_GRPNATR, IIf( aPos[FP_B1_GRPNATR].And. lSeek , IIf(lSS4, SS4->S4_GRPNATR, SB1->B1_GRPNATR), " " ) )
aNfItem[nItem][IT_PRD][SB_DTFIMNT]:= IIf( lSBI .And. aPos[FP_BI_DTFIMNT], SBI->BI_DTFIMNT, IIf( aPos[FP_B1_DTFIMNT].And. lSeek , IIf(lSS4, SS4->S4_DTFIMNT, SB1->B1_DTFIMNT), CtoD("") ) )
aNfItem[nItem][IT_PRD][SB_IPI]    := IIf( lSBI .And. aPos[FP_BI_IPI]    , SBI->BI_IPI    , IIf( aPos[FP_B1_IPI]    .And. lSeek , IIf(lSS4, SS4->S4_IPI    , SB1->B1_IPI    ), 0   ) )
aNfItem[nItem][IT_PRD][SB_VLR_IPI]:= IIf( lSBI .And. aPos[FP_BI_VLR_IPI], SBI->BI_VLR_IPI, IIf( aPos[FP_B1_VLR_IPI].And. lSeek , IIf(lSS4, SS4->S4_VLR_IPI, SB1->B1_VLR_IPI), 0   ) )
aNfItem[nItem][IT_PRD][SB_CNAE]   := IIf( lSBI .And. aPos[FP_BI_CNAE]   , SBI->BI_CNAE   , IIf( aPos[FP_B1_CNAE]   .And. lSeek , IIf(lSS4, SS4->S4_CNAE   , SB1->B1_CNAE   ), " " ) )
aNfItem[nItem][IT_PRD][SB_REGRISS]:= IIf( lSBI .And. aPos[FP_BI_REGRISS], SBI->BI_REGRISS, IIf( aPos[FP_B1_REGRISS].And. lSeek , IIf(lSS4, SS4->S4_REGRISS, SB1->B1_REGRISS), " " ) )
aNfItem[nItem][IT_PRD][SB_REDINSS]:= IIf( lSBI .And. aPos[FP_BI_REDINSS], SBI->BI_REDINSS, IIf( aPos[FP_B1_REDINSS].And. lSeek , IIf(lSS4, SS4->S4_REDINSS, SB1->B1_REDINSS), 0   ) )
aNfItem[nItem][IT_PRD][SB_INSS]   := IIf( lSBI .And. aPos[FP_BI_INSS]   , SBI->BI_INSS   , IIf( aPos[FP_B1_INSS]   .And. lSeek , IIf(lSS4, SS4->S4_INSS   , SB1->B1_INSS   ), " " ) )
aNfItem[nItem][IT_PRD][SB_IRRF]   := IIf( lSBI .And. aPos[FP_BI_IRRF]   , SBI->BI_IRRF   , IIf( aPos[FP_B1_IRRF]   .And. lSeek , IIf(lSS4, SS4->S4_IRRF   , SB1->B1_IRRF   ), " " ) )
aNfItem[nItem][IT_PRD][SB_REDIRRF]:= IIf( lSBI .And. aPos[FP_BI_REDIRRF], SBI->BI_REDIRRF, IIf( aPos[FP_B1_REDIRRF].And. lSeek , IIf(lSS4, SS4->S4_REDIRRF, SB1->B1_REDIRRF), 0   ) )
aNfItem[nItem][IT_PRD][SB_REDPIS] := IIf( lSBI .And. aPos[FP_BI_REDPIS] , SBI->BI_REDPIS , IIf( aPos[FP_B1_REDPIS] .And. lSeek , IIf(lSS4, SS4->S4_REDPIS , SB1->B1_REDPIS ), 0   ) )
aNfItem[nItem][IT_PRD][SB_PPIS]   := IIf( lSBI .And. aPos[FP_BI_PPIS]   , SBI->BI_PPIS   , IIf( aPos[FP_B1_PPIS]   .And. lSeek , IIf(lSS4, SS4->S4_PPIS   , SB1->B1_PPIS   ), 0   ) )
aNfItem[nItem][IT_PRD][SB_PIS]    := IIf( lSBI .And. aPos[FP_BI_PIS]    , SBI->BI_PIS    , IIf( aPos[FP_B1_PIS]    .And. lSeek , IIf(lSS4, SS4->S4_PIS    , SB1->B1_PIS    ), " " ) )
aNfItem[nItem][IT_PRD][SB_CHASSI] := IIf( lSBI .And. aPos[FP_BI_CHASSI] , SBI->BI_CHASSI , IIf( aPos[FP_B1_CHASSI] .And. lSeek , IIf(lSS4  .And. aPos[FP_S4_CHASSI], SS4->S4_CHASSI , SB1->B1_CHASSI ), " " ) )
aNfItem[nItem][IT_PRD][SB_RETOPER]:= IIf( lSBI .And. aPos[FP_BI_RETOPER], SBI->BI_RETOPER, IIf( aPos[FP_B1_RETOPER].And. lSeek , IIf(lSS4, SS4->S4_RETOPER, SB1->B1_RETOPER), " " ) )
aNfItem[nItem][IT_PRD][SB_REDCOF] := IIf( lSBI .And. aPos[FP_BI_REDCOF] , SBI->BI_REDCOF , IIf( aPos[FP_B1_REDCOF] .And. lSeek , IIf(lSS4, SS4->S4_REDCOF , SB1->B1_REDCOF ), 0   ) )
aNfItem[nItem][IT_PRD][SB_PCOFINS]:= IIf( lSBI .And. aPos[FP_BI_PCOFINS], SBI->BI_PCOFINS, IIf( aPos[FP_B1_PCOFINS].And. lSeek , IIf(lSS4, SS4->S4_PCOFINS, SB1->B1_PCOFINS), 0   ) )
aNfItem[nItem][IT_PRD][SB_COFINS] := IIf( lSBI .And. aPos[FP_BI_COFINS] , SBI->BI_COFINS , IIf( aPos[FP_B1_COFINS] .And. lSeek , IIf(lSS4, SS4->S4_COFINS , SB1->B1_COFINS ), " " ) )
aNfItem[nItem][IT_PRD][SB_PCSLL]  := IIf( lSBI .And. aPos[FP_BI_PCSLL]  , SBI->BI_PCSLL  , IIf( aPos[FP_B1_PCSLL]  .And. lSeek , IIf(lSS4, SS4->S4_PCSLL  , SB1->B1_PCSLL  ), 0   ) )
aNfItem[nItem][IT_PRD][SB_CONTSOC]:= IIf( lSBI .And. aPos[FP_BI_CONTSOC], SBI->BI_CONTSOC, IIf( aPos[FP_B1_CONTSOC].And. lSeek , IIf(lSS4, SS4->S4_CONTSOC, SB1->B1_CONTSOC), " " ) )
aNfItem[nItem][IT_PRD][SB_PRFDSUL]:= IIf( lSBI .And. aPos[FP_BI_PRFDSUL], SBI->BI_PRFDSUL, IIf( aPos[FP_B1_PRFDSUL].And. lSeek , IIf(lSS4, SS4->S4_PRFDSUL, SB1->B1_PRFDSUL), 0   ) )
aNfItem[nItem][IT_PRD][SB_FECP]   := IIf( lSBI .And. aPos[FP_BI_FECP]   , SBI->BI_FECP   , IIf( aPos[FP_B1_FECP]   .And. lSeek , IIf(lSS4, SS4->S4_FECP   , SB1->B1_FECP   ), 0   ) )
aNfItem[nItem][IT_PRD][SB_FECPBA] := IIf( lSBI .And. aPos[FP_BI_FECPBA] , SBI->BI_FECPBA , IIf( aPos[FP_B1_FECPBA] .And. lSeek , IIf(lSS4, SS4->S4_FECPBA , SB1->B1_FECPBA ), 0   ) )
aNfItem[nItem][IT_PRD][SB_ALFECRN]:= IIf( lSBI .And. aPos[FP_BI_ALFECRN], SBI->BI_ALFECRN, IIf( aPos[FP_B1_ALFECRN].And. lSeek , IIf(lSS4, SS4->S4_ALFECRN, SB1->B1_ALFECRN), 0   ) )
aNfItem[nItem][IT_PRD][SB_ALFUMAC]:= IIf( lSBI .And. aPos[FP_BI_ALFUMAC], SBI->BI_ALFUMAC, IIf( aPos[FP_B1_ALFUMAC].And. lSeek , IIf(lSS4, SS4->S4_ALFUMAC, SB1->B1_ALFUMAC), 0   ) )
aNfItem[nItem][IT_PRD][SB_PRN944I]:= IIf( lSBI .And. aPos[FP_BI_PRN944I], SBI->BI_PRN944I, IIf( aPos[FP_B1_PRN944I].And. lSeek , IIf(lSS4, SS4->S4_PRN944I, SB1->B1_PRN944I), " " ) )
aNfItem[nItem][IT_PRD][SB_REGESIM]:= IIf( lSBI .And. aPos[FP_BI_REGESIM], SBI->BI_REGESIM, IIf( aPos[FP_B1_REGESIM].And. lSeek , IIf(lSS4, SS4->S4_REGESIM, SB1->B1_REGESIM), " " ) )
aNfItem[nItem][IT_PRD][SB_VLRISC] := IIf( lSBI .And. aPos[FP_BI_VLRISC] , SBI->BI_VLRISC , IIf( aPos[FP_B1_VLRISC] .And. lSeek , IIf(lSS4 .And. aPos[FP_S4_VLRISC], SS4->S4_VLRISC , SB1->B1_VLRISC ), 0   ) )
aNfItem[nItem][IT_PRD][SB_CRDPRES]:= IIf( lSBI .And. aPos[FP_BI_CRDPRES], SBI->BI_CRDPRES, IIf( aPos[FP_B1_CRDPRES].And. lSeek , IIf(lSS4, SS4->S4_CRDPRES, SB1->B1_CRDPRES), 0   ) )
aNfItem[nItem][IT_PRD][SB_VMINDET]:= IIf( lSBI .And. aPos[FP_BI_VMINDET], SBI->BI_VMINDET, IIf( aPos[FP_B1_VMINDET].And. lSeek , IIf(lSS4 .And. aPos[FP_S4_VMINDET], SS4->S4_VMINDET, SB1->B1_VMINDET), 0   ) )
aNfItem[nItem][IT_PRD][SB_IMPORT] := IIf( lSBI .And. aPos[FP_BI_IMPORT] , SBI->BI_IMPORT , IIf( aPos[FP_B1_IMPORT] .And. lSeek , IIf(lSS4, SS4->S4_IMPORT , SB1->B1_IMPORT ), " " ) )
aNfItem[nItem][IT_PRD][SB_TPDP]   := IIf( lSBI .And. aPos[FP_BI_TPDP]   , SBI->BI_TPDP   , IIf( aPos[FP_B1_TPDP]   .And. lSeek , IIf(lSS4, SS4->S4_TPDP   , SB1->B1_TPDP   ), " " ) )
aNfItem[nItem][IT_PRD][SB_CSLL]   := IIf( lSBI .And. aPos[FP_BI_CSLL]   , SBI->BI_CSLL   , IIf( aPos[FP_B1_CSLL]   .And. lSeek , IIf(lSS4, SS4->S4_CSLL   , SB1->B1_CSLL   ), " " ) )
aNfItem[nItem][IT_PRD][SB_IDHIST] := IIf( lSBI                                , ""             , IIf( aPos[FP_B1_IDHIST] .And. lSeek , IIf(lSS4, SS4->S4_IDHIST , SB1->B1_IDHIST ), " " ) )
aNfItem[nItem][IT_PRD][SB_MEPLES] := IIf( lSBI .And. aPos[FP_BI_MEPLES] , SBI->BI_MEPLES , IIf( aPos[FP_B1_MEPLES] .And. lSeek , IIf(lSS4, SS4->S4_MEPLES , SB1->B1_MEPLES ), " " ) )
aNfItem[nItem][IT_PRD][SB_UVLRC] := IIf( lSBI  								, "" 			  , IIf( aPos[FP_B1_UPRC] .And. lSeek , IIf(lSS4, SS4->S4_UVLRC , SB1->B1_UPRC ), " " ) )
aNfItem[nItem][IT_PRD][SB_ALQDFB1]:= IIf( lSBI .And. aPos[FP_BI_ALQDFB1], SBI->&("BI_"+Substr(aSX6[MV_ALQDFB1],4)), IIf( aPos[FP_B1_ALQDFB1], SB1->&("B1_"+Substr(aSX6[MV_ALQDFB1],4)) , "2" ) )
aNfItem[nItem][IT_PRD][SB_B1PTST] := IIf( lSBI .And. aPos[FP_BI_B1PTST] , SBI->&("BI_"+Substr(aSX6[MV_B1PTST] ,4)), IIf( aPos[FP_B1_B1PTST] , SB1->&("B1_"+Substr(aSX6[MV_B1PTST] ,4)) , 0   ) )
aNfItem[nItem][IT_PRD][SB_PRDDIAT]:= IIf( lSBI .And. aPos[FP_BI_PRDDIAT], SBI->&("BI_"+Substr(aSX6[MV_PRDDIAT],4)), IIf( aPos[FP_B1_PRDDIAT], SB1->&("B1_"+Substr(aSX6[MV_PRDDIAT],4)) , " " ) )
aNfItem[nItem][IT_PRD][SB_B1CALTR]:= IIf( lSBI .And. aPos[FP_BI_B1CALTR], SBI->&("BI_"+Substr(aSX6[MV_B1CALTR],4)), IIf( aPos[FP_B1_B1CALTR], SB1->&("B1_"+Substr(aSX6[MV_B1CALTR],4)) , " " ) )
aNfItem[nItem][IT_PRD][SB_B1CATRI]:= IIf( lSBI .And. aPos[FP_BI_B1CATRI], SBI->&("BI_"+Substr(aSX6[MV_B1CATRI],4)), IIf( aPos[FP_B1_B1CATRI], SB1->&("B1_"+Substr(aSX6[MV_B1CATRI],4)) , 0   ) )
aNfItem[nItem][IT_PRD][SB_ICMPFAT]:= IIf( lSBI .And. aPos[FP_BI_ICMPFAT], SBI->&("BI_"+Substr(aSX6[MV_ICMPFAT],4)), IIf( aPos[FP_B1_ICMPFAT], SB1->&("B1_"+Substr(aSX6[MV_ICMPFAT],4)) , 0   ) )
aNfItem[nItem][IT_PRD][SB_IPIPFAT]:= IIf( lSBI .And. aPos[FP_BI_IPIPFAT], SBI->&("BI_"+Substr(aSX6[MV_IPIPFAT],4)), IIf( aPos[FP_B1_IPIPFAT], SB1->&("B1_"+Substr(aSX6[MV_IPIPFAT],4)) , 0   ) )
aNfItem[nItem][IT_PRD][SB_PUPCCST]:= IIf( lSBI .And. aPos[FP_BI_PUPCCST], SBI->&("BI_"+Substr(aSX6[MV_PUPCCST],4)), IIf( aPos[FP_B1_PUPCCST], SB1->&("B1_"+Substr(aSX6[MV_PUPCCST],4)) , 0   ) )
aNfItem[nItem][IT_PRD][SB_B1CPSST]:= IIf( lSBI .And. aPos[FP_BI_B1CPSST], SBI->&("BI_"+Substr(aSX6[MV_B1CPSST],4)), IIf( aPos[FP_B1_B1CPSST], SB1->&("B1_"+Substr(aSX6[MV_B1CPSST],4)) , 0   ) )
aNfItem[nItem][IT_PRD][SB_B1CCFST]:= IIf( lSBI .And. aPos[FP_BI_B1CCFST], SBI->&("BI_"+Substr(aSX6[MV_B1CCFST],4)), IIf( aPos[FP_B1_B1CCFST], SB1->&("B1_"+Substr(aSX6[MV_B1CCFST],4)) , 0   ) )
aNfItem[nItem][IT_PRD][SB_FECPMT] := IIf( lSBI .And. aPos[FP_BI_FECPMT] , SBI->&("BI_"+Substr(aSX6[MV_FECPMT] ,4)), IIf( aPos[FP_B1_FECPMT] , SB1->&("B1_"+Substr(aSX6[MV_FECPMT] ,4)) , 0   ) )
aNfItem[nItem][IT_PRD][SB_ADIFECP]:= IIf( lSBI .And. aPos[FP_BI_ADIFECP], SBI->&("BI_"+Substr(aSX6[MV_ADIFECP],4)), IIf( aPos[FP_B1_ADIFECP], SB1->&("B1_"+Substr(aSX6[MV_ADIFECP],4)) , 0   ) )
aNfItem[nItem][IT_PRD][SB_ALFECMG]:= IIf( lSBI .And. aPos[FP_BI_ALFECMG], SBI->&("BI_"+Substr(aSX6[MV_ALFECMG],4)), IIf( aPos[FP_B1_ALFECMG], SB1->&("B1_"+Substr(aSX6[MV_ALFECMG],4)) , 0   ) )
aNfItem[nItem][IT_PRD][SB_MVAFRP] := IIf( lSBI .And. aPos[FP_MV_MVAFBI],  &(aSX6[MV_MVAFRP]),	IIf( aPos[FP_MV_MVAFRP], &(aSX6[MV_MVAFRP]) , 0   ) )
aNfItem[nItem][IT_PRD][SB_MVAFRC] := IIf( lSBI .And. aPos[FP_MV_MVAFBC],  &(aSX6[MV_MVAFRC]),	IIf( aPos[FP_MV_MVAFRC], &(aSX6[MV_MVAFRC]) , 0   ) )
aNfItem[nItem][IT_PRD][SB_AFAMAD] := IIf( aPos[FP_AFAMAD] .And. lSeek , SB1->B1_AFAMAD,0)
aNfItem[nItem][IT_PRD][SB_CONV]   := IIf( aPos[FP_B1_CONV] .And. lSeek , SB1->B1_CONV,0)
aNfItem[nItem][IT_PRD][SB_GRPCST]   := IIf( aPos[FP_B1_GRPCST] .And. lSeek , SB1->B1_GRPCST,"")
aNfItem[nItem][IT_PRD][SB_CEST]   := IIf( lSBI .And. aPos[FP_BI_CEST]  , SBI->BI_CEST, IIf( aPos[FP_B1_CEST] .And. lSeek ,  SB1->B1_CEST , " " ) )
//-- Pauta ICMS informada no parametro MV_PAUTFOB
aNfItem[nItem][IT_PRD][SB_MV_PAUTFOB]:= IIf( aPos[FP_MV_PAUTFOB], SB1->&(aSX6[MV_PAUTFOB]), 0 )
aNfItem[nItem][IT_PRD][SB_CODATIV]  := IIf(aPos[FP_B5_CODATIV] .And. lSeek, IIf(lSS5, SS5->S5_CODATIV, cCodAtv), " ")
aNfItem[nItem][IT_PRD][SB_AFUNDES] := IIf(aPos[FP_B1_AFUNDES] .And. lSeek, IIf(lSS4, SS4->S4_AFUNDES, SB1->B1_AFUNDES), 0)
aNfItem[nItem][IT_PRD][SB_AIMAMT]	:= IIf(aPos[FP_B1_AIMAMT] .And. lSeek, IIf(lSS4, SS4->S4_AIMAMT, SB1->B1_AIMAMT), 0)
aNfItem[nItem][IT_PRD][SB_AFASEMT]	:= IIf(aPos[FP_B1_AFASEMT] .And. lSeek, IIf(lSS4, SS4->S4_AFASEMT, SB1->B1_AFASEMT), 0)
aNfItem[nItem][IT_PRD][SB_VLRCID]	:= IIf(aPos[FP_B5_VLRCID] .And. lSeek, IIf(lSS5, SS5->S5_VLRCID, SB5->B5_VLRCID), 0)
aNfItem[nItem][IT_PRD][SB_CG1_ALIQ] := IIf(aPos[FP_CG1_ALIQ] .And. lSeek .And. lSeekCG1, CG1->CG1_ALIQ, 0)
aNfItem[nItem][IT_PRD][SB_TRIBMU] := IIf( lSBI .And. aPos[FP_BI_TRIBMUN], SBI->BI_TRIBMUN , IIf( aPos[FP_B1_TRIBMUN] .And. lSeek , IIf(lSS4 .And. aPos[FP_S4_TRIBMUN], SS4->S4_TRIBMUN, SB1->B1_TRIBMUN   ), " " ) )
aNfItem[nItem][IT_PRD][SB_B1PISST]	:= IIf(aPos[FP_B1_B1PISST] .And. lSeek, SB1->&("B1_"+Substr(aSX6[MV_B1PISST] ,4)), 0)
aNfItem[nItem][IT_PRD][SB_B1COFST]	:= IIf(aPos[FP_B1_B1COFST] .And. lSeek, SB1->&("B1_"+Substr(aSX6[MV_B1COFST] ,4)), 0)

// ID da SB1 - Carga separada pois nao faz parte do array "SB".
aNfItem[nItem][IT_IDSB1] := IIf(aPos[FP_B1_IDHIST] .And. lSeek, IIf(lSS4, SS4->S4_IDHIST, SB1->B1_IDHIST), "")

SBZ->(dbSetOrder(1))
If lSeek .And. cAliasPROD == "SB1" .And. aSX6[MV_ARQPROD] == "SBZ" .And. SBZ->( MsSeek( xFilial("SBZ") + SB1->B1_COD ) )

	If lHistorico
	//Se for reprocessamento,  e tiver habilitado para buscar os Historico Fiscais,
	//verifico se o ID do historico do Ind.Prod.e igual aoque foi gravado na Nota. Se for
	//igual é porque nao teve alterações no Ind.Prod.   na emissão. Se for diferente,
	//é porque teve alterações no cadastro, e entao os dados são carregados da tabela de
	//Historico(SS2).
		If( aNfCab[NF_CLIFOR]=="C" .And. aNfCab[NF_TIPONF]<>"D") .Or.( aNfCab[NF_CLIFOR]=="F" .And. aNfCab[NF_TIPONF]$"D|B")
				cHistSBZ :=  (cAlsItem)->D2_IDSBZ
		Else
				cHistSBZ := (cAlsItem)->D1_IDSBZ
		End
		If cPaisLoc == "BRA" .And. Alltrim(SBZ->BZ_IDHIST) <> Alltrim(cHistSBZ)
			SS6->(dbSetOrder(1))
			SS6->(MsSeek(xFilial("SS6")+cHistSBZ))
			lSS6 := .T.
		EndIf
	EndIf

  If "PICM"    $ cCpoSBZ .And. aPos[FP_BZ_PICM]    .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_PICM   ), !Empty(SBZ->BZ_PICM    )), .T. ) ; aNfItem[nItem][IT_PRD][SB_PICM]   := IIf(lSS6, SS6->S6_PICM    , SBZ->BZ_PICM    );EndIf
  If "VLR_ICM" $ cCpoSBZ .And. aPos[FP_BZ_VLR_ICM] .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_VLR_ICM), !Empty(SBZ->BZ_VLR_ICM )), .T. ) ; aNfItem[nItem][IT_PRD][SB_VLR_ICM]:= IIf(lSS6, SS6->S6_VLR_ICM , SBZ->BZ_VLR_ICM );EndIf
  If "INT_ICM" $ cCpoSBZ .And. aPos[FP_BZ_INT_ICM] .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_INT_ICM), !Empty(SBZ->BZ_INT_ICM )), .T. ) ; aNfItem[nItem][IT_PRD][SB_INT_ICM]:= IIf(lSS6, SS6->S6_INT_ICM , SBZ->BZ_INT_ICM );EndIf
  If "PICMRET" $ cCpoSBZ .And. aPos[FP_BZ_PICMRET] .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_PICMRET), !Empty(SBZ->BZ_PICMRET )), .T. ) ; aNfItem[nItem][IT_PRD][SB_PICMRET]:= IIf(lSS6, SS6->S6_PICMRET , SBZ->BZ_PICMRET );EndIf
  If "PICMENT" $ cCpoSBZ .And. aPos[FP_BZ_PICMENT] .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_PICMENT), !Empty(SBZ->BZ_PICMENT )), .T. ) ; aNfItem[nItem][IT_PRD][SB_PICMENT]:= IIf(lSS6, SS6->S6_PICMENT , SBZ->BZ_PICMENT );EndIf
  If "IPI"     $ cCpoSBZ .And. aPos[FP_BZ_IPI]     .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_IPI    ), !Empty(SBZ->BZ_IPI     )), .T. ) ; aNfItem[nItem][IT_PRD][SB_IPI]    := IIf(lSS6, SS6->S6_IPI     , SBZ->BZ_IPI     );EndIf
  If "VLR_IPI" $ cCpoSBZ .And. aPos[FP_BZ_VLR_IPI] .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_VLR_IPI), !Empty(SBZ->BZ_VLR_IPI )), .T. ) ; aNfItem[nItem][IT_PRD][SB_VLR_IPI]:= IIf(lSS6, SS6->S6_VLR_IPI , SBZ->BZ_VLR_IPI );EndIf
  If "REDPIS"  $ cCpoSBZ .And. aPos[FP_BZ_REDPIS]  .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_REDPIS ), !Empty(SBZ->BZ_REDPIS  )), .T. ) ; aNfItem[nItem][IT_PRD][SB_REDPIS] := IIf(lSS6, SS6->S6_REDPIS  , SBZ->BZ_REDPIS  );EndIf
  If "REDCOF"  $ cCpoSBZ .And. aPos[FP_BZ_REDCOF]  .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_REDCOF ), !Empty(SBZ->BZ_REDCOF  )), .T. ) ; aNfItem[nItem][IT_PRD][SB_REDCOF] := IIf(lSS6, SS6->S6_REDCOF  , SBZ->BZ_REDCOF  );EndIf
  If "IRRF"    $ cCpoSBZ .And. aPos[FP_BZ_IRRF]    .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_IRRF   ), !Empty(SBZ->BZ_IRRF    )), .T. ) ; aNfItem[nItem][IT_PRD][SB_IRRF]   := IIf(lSS6, SS6->S6_IRRF    , SBZ->BZ_IRRF    );EndIf
  If "ORIGEM"  $ cCpoSBZ .And. aPos[FP_BZ_ORIGEM]  .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_ORIGEM ), !Empty(SBZ->BZ_ORIGEM  )), .T. ) ; aNfItem[nItem][IT_PRD][SB_ORIGEM] := IIf(lSS6, SS6->S6_ORIGEM  , SBZ->BZ_ORIGEM  );EndIf
  If "GRTRIB"  $ cCpoSBZ .And. aPos[FP_BZ_GRTRIB]  .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_GRTRIB ), !Empty(SBZ->BZ_GRTRIB  )), .T. ) ; aNfItem[nItem][IT_PRD][SB_GRTRIB] := IIf(lSS6, SS6->S6_GRTRIB  , SBZ->BZ_GRTRIB  );EndIf
  If "CODISS"  $ cCpoSBZ .And. aPos[FP_BZ_CODISS]  .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_CODISS ), !Empty(SBZ->BZ_CODISS  )), .T. ) ; aNfItem[nItem][IT_PRD][SB_CODISS] := IIf(lSS6, SS6->S6_CODISS  , SBZ->BZ_CODISS  );EndIf
  If "FECP"    $ cCpoSBZ .And. aPos[FP_BZ_FECP]    .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_FECP   ), !Empty(SBZ->BZ_FECP    )), .T. ) ; aNfItem[nItem][IT_PRD][SB_FECP]   := IIf(lSS6, SS6->S6_FECP    , SBZ->BZ_FECP    );EndIf
  If "ALIQISS" $ cCpoSBZ .And. aPos[FP_BZ_ALIQISS] .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_ALIQISS), !Empty(SBZ->BZ_ALIQISS )), .T. ) ; aNfItem[nItem][IT_PRD][SB_ALIQISS]:= IIf(lSS6, SS6->S6_ALIQISS , SBZ->BZ_ALIQISS );EndIf
  If "PIS"     $ cCpoSBZ .And. aPos[FP_BZ_PIS]     .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_PIS    ), !Empty(SBZ->BZ_PIS     )), .T. ) ; aNfItem[nItem][IT_PRD][SB_PIS]    := IIf(lSS6, SS6->S6_PIS     , SBZ->BZ_PIS     );EndIf
  If "COFINS"  $ cCpoSBZ .And. aPos[FP_BZ_COFINS]  .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_COFINS ), !Empty(SBZ->BZ_COFINS  )), .T. ) ; aNfItem[nItem][IT_PRD][SB_COFINS] := IIf(lSS6, SS6->S6_COFINS  , SBZ->BZ_COFINS  );EndIf
  If "PCSLL"   $ cCpoSBZ .And. aPos[FP_BZ_PCSLL]   .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_PCSLL  ), !Empty(SBZ->BZ_PCSLL   )), .T. ) ; aNfItem[nItem][IT_PRD][SB_PCSLL]  := IIf(lSS6, SS6->S6_PCSLL   , SBZ->BZ_PCSLL   );EndIf
  If "ALFUMAC" $ cCpoSBZ .And. aPos[FP_BZ_ALFUMAC] .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_ALFUMAC), !Empty(SBZ->BZ_ALFUMAC )), .T. ) ; aNfItem[nItem][IT_PRD][SB_ALFUMAC]:= IIf(lSS6, SS6->S6_ALFUMAC , SBZ->BZ_ALFUMAC );EndIf
  If "FECPBA"  $ cCpoSBZ .And. aPos[FP_BZ_FECPBA]  .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_FECPBA ), !Empty(SBZ->BZ_FECPBA  )), .T. ) ; aNfItem[nItem][IT_PRD][SB_FECPBA] := IIf(lSS6, SS6->S6_FECPBA  , SBZ->BZ_FECPBA  );EndIf
  If "ALFECRN" $ cCpoSBZ .And. aPos[FP_BZ_ALFECRN] .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_ALFECRN), !Empty(SBZ->BZ_ALFECRN )), .T. ) ; aNfItem[nItem][IT_PRD][SB_ALFECRN]:= IIf(lSS6, SS6->S6_ALFECRN , SBZ->BZ_ALFECRN );EndIf
  If "CNAE"    $ cCpoSBZ .And. aPos[FP_BZ_CNAE]    .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_CNAE   ), !Empty(SBZ->BZ_CNAE    )), .T. ) ; aNfItem[nItem][IT_PRD][SB_CNAE]   := IIf(lSS6, SS6->S6_CNAE    , SBZ->BZ_CNAE    );EndIf
  If "CSLL"    $ cCpoSBZ .And. aPos[FP_BZ_CSLL]    .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_CSLL   ), !Empty(SBZ->BZ_CSLL    )), .T. ) ; aNfItem[nItem][IT_PRD][SB_CSLL]   := IIf(lSS6, SS6->S6_CSLL    , SBZ->BZ_CSLL    );EndIf
  If "PPIS"    $ cCpoSBZ .And. aPos[FP_BZ_PPIS]    .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_PPIS   ), !Empty(SBZ->BZ_PPIS   )), .T. ) ; aNfItem[nItem][IT_PRD][SB_PPIS]   := IIf(lSS6, SS6->S6_PPIS    , SBZ->BZ_PPIS    );EndIf
  If "PCOFINS" $ cCpoSBZ .And. aPos[FP_BZ_PCOFINS] .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_PCOFINS), !Empty(SBZ->BZ_PCOFINS )), .T. ) ; aNfItem[nItem][IT_PRD][SB_PCOFINS]:= IIf(lSS6, SS6->S6_PCOFINS , SBZ->BZ_PCOFINS );EndIf
  If "AFUNDES" $ cCpoSBZ .And. aPos[FP_BZ_AFUNDES] .And. IIf( lArqProp , IIf(lSS6, !Empty(SS6->S6_AFUNDES), !Empty(SBZ->BZ_AFUNDES )), .T. ) ; aNfItem[nItem][IT_PRD][SB_AFUNDES]:= IIf(lSS6, SS6->S6_AFUNDES , SBZ->BZ_AFUNDES );EndIf
  If "TRIBMUN" $ cCpoSBZ .And. aPos[FP_BZ_TRIBMUN] .And. IIf( lArqProp , IIf(lSS6 .And. aPos[FP_S6_TRIBMUN], !Empty(SS6->S6_TRIBMUN), !Empty(SBZ->BZ_TRIBMUN )), .T. ) ; aNfItem[nItem][IT_PRD][SB_TRIBMU]:= IIf(lSS6 .And. aPos[FP_S6_TRIBMUN], SS6->S6_TRIBMUN , SBZ->BZ_TRIBMUN );EndIf 

  /*O tratamento do referência SB_MV_PAUTFOB é diferente das demais, pois o campo não existe no dicionário padrão na SB1, é criado pelo usuário e informado no parâmetro MV_PAUTFOB, e pode acontecer do campo existir somente na SBZ.
  Por este motivo não irei utilizar a função CpyFieldSB, irei atribuir diretamente aqui quando enquadrar SBZ.
  O campo não existe no histórico de cadastro, por este motivo não irei fazer tratamento com tabela SS6.
  */
  aNfItem[nItem][IT_PRD][SB_MV_PAUTFOB]:= IIf( aPos[FP_BZ_PAUTFOB], SBZ->&(aSX6[MV_PAUTFOB]), aNfItem[nItem][IT_PRD][SB_MV_PAUTFOB] )

If !lSBI
	aNfItem[nItem][IT_IDSBZ] := IIf( aPos[FP_BZ_IDHIST] .And. lSeek , IIf(lSS6, SS6->S6_IDHIST, SBZ->BZ_IDHIST), "" )
Else
	aNfItem[nItem][IT_IDSBZ] := ""
EndIf

EndIf

aNfItem[nItem][IT_GRPTRIB] := aNfItem[nItem][IT_PRD][SB_GRTRIB]
aNfItem[nItem][IT_RSATIVO] := aNfItem[nItem][IT_PRD][SB_RSATIVO]
aNfItem[nItem][IT_POSIPI]  := aNfItem[nItem][IT_PRD][SB_POSIPI]
aNfItem[nItem][IT_CEST]		:= aNfItem[nItem][IT_PRD][SB_CEST]
aNfItem[nItem][IT_B1UM]    := aNfItem[nItem][IT_PRD][SB_UM]
aNfItem[nItem][IT_B1SEGUM] := aNfItem[nItem][IT_PRD][SB_SEGUM]
aNfItem[nItem][IT_AFABOV]  := aNfItem[nItem][IT_PRD][SB_AFABOV]
aNfItem[nItem][IT_AFACS]   := aNfItem[nItem][IT_PRD][SB_AFACS]
aNfItem[nItem][IT_AFETHAB] := aNfItem[nItem][IT_PRD][SB_AFETHAB]
aNfItem[nItem][IT_TFETHAB] := aNfItem[nItem][IT_PRD][SB_TFETHAB]
aNfItem[nItem][IT_CPDIFST] := aNfItem[nItem][IT_PRD][SB_ALQDFB1]
aNfItem[nItem][IT_CPPERST] := aNfItem[nItem][IT_PRD][SB_B1PTST]
aNfItem[nItem][IT_CODIF]   := aNfItem[nItem][IT_PRD][SB_CODIF]
aNfItem[nItem][IT_IDSB1]   := aNfItem[nItem][IT_PRD][SB_IDHIST]
aNfItem[nItem][IT_ALQFMD]  := aNfItem[nItem][IT_PRD][SB_AFAMAD]
aNfItem[nItem][IT_AIMAMT]	:= aNfItem[nItem][IT_PRD][SB_AIMAMT]
aNfItem[nItem][IT_AFASEMT]	:= aNfItem[nItem][IT_PRD][SB_AFASEMT]
aNfItem[nItem][IT_VLRCID]	:= aNfItem[nItem][IT_PRD][SB_VLRCID]

//Carga das referencias vinculadas a tabela UF x UF
//Alimento a referência com os dados do cabecalho primeiramente, caso não encontre na CFC ou SS9
//já estará preenchida com informação do cabecalho
aNfItem[nItem][IT_UFXPROD][UFP_ALIQFECP]	:=	aNfCab[NF_UFXUF][UF_ALIQFECP]
aNfItem[nItem][IT_UFXPROD][UFP_MARGSTLIQ]	:=	aNfCab[NF_UFXUF][UF_MARGSTLIQ]
aNfItem[nItem][IT_UFXPROD][UFP_ALIQSTLIQ]	:=	aNfCab[NF_UFXUF][UF_ALIQSTLIQ]
aNfItem[nItem][IT_UFXPROD][UFP_MARGEM]		:=	aNfCab[NF_UFXUF][UF_MARGEM]
aNfItem[nItem][IT_UFXPROD][UFP_ALQFCPO]		:=	aNfCab[NF_UFXUF][UF_ALQFCPO]
aNfItem[nItem][IT_UFXPROD][UFP_FECPAUX]		:=	aNfCab[NF_UFXUF][UF_FECPAUX]
aNfItem[nItem][IT_UFXPROD][UFP_FECPDIF]		:=	aNfCab[NF_UFXUF][UF_FECPDIF]
aNfItem[nItem][IT_UFXPROD][UFP_FECPINT]		:=	aNfCab[NF_UFXUF][UF_FECPINT]
aNfItem[nItem][IT_UFXPROD][UFP_RDCTIMP]		:=  aNfCab[NF_UFXUF][UF_RDCTIMP]
aNfItem[nItem][IT_UFXPROD][UFP_MVAFRU]		:=  aNfCab[NF_UFXUF][UF_MVAFRU]
aNfItem[nItem][IT_UFXPROD][UFP_MVAES]		:=  aNfCab[NF_UFXUF][UF_MVAES]
aNfItem[nItem][IT_UFXPROD][UFP_ADICST]   := aNfCab[NF_UFXUF][UF_ADICST]
aNfItem[nItem][IT_UFXPROD][UFP_PICM]   := aNfCab[NF_UFXUF][UF_PICM]
aNfItem[nItem][IT_UFXPROD][UFP_VLICMP]   := aNfCab[NF_UFXUF][UF_VLICMP]
aNfItem[nItem][IT_UFXPROD][UFP_VL_ICM]   := aNfCab[NF_UFXUF][UF_VL_ICM]
aNfItem[nItem][IT_UFXPROD][UFP_VL_ANT]   := aNfCab[NF_UFXUF][UF_VL_ANT]
aNfItem[nItem][IT_UFXPROD][UFP_BS_FCPPR]   := aNfCab[NF_UFXUF][UF_BS_FCPPR]
aNfItem[nItem][IT_UFXPROD][UFP_BS_FCPST]   := aNfCab[NF_UFXUF][UF_BS_FCPST]
aNfItem[nItem][IT_UFXPROD][UFP_BS_FCPCM]   := aNfCab[NF_UFXUF][UF_BS_FCPCM]
aNfItem[nItem][IT_UFXPROD][UFP_AFCPST]     := aNfCab[NF_UFXUF][UF_AFCPST]
aNfItem[nItem][IT_UFXPROD][UFP_ALFEEF]     := aNfCab[NF_UFXUF][UF_ALFEEF]
aNfItem[nItem][IT_UFXPROD][UFP_PAUTFOB]     := aNfCab[NF_UFXUF][UF_PAUTFOB]

//Faz busca na CFC considerando a uf origem, uf destino e código do produto.
MaSeekCFC(3,nItem)

//Trecho para caso de reprocessamento, irá buscar na tabela espelho SS9 considerando id gravado na D1/D2.
If lHistorico .AND. !Empty(cAlsItem) .AND. aDic[AI_CFC]
	If( aNfCab[NF_CLIFOR]=="C" .And. aNfCab[NF_TIPONF]<>"D") .Or.( aNfCab[NF_CLIFOR]=="F" .And. aNfCab[NF_TIPONF]$"D|B")
		cHistCFC :=  Iif( aPos[FP_D2_IDCFC], (cAlsItem)->D2_IDCFC, "" )
	Else
		cHistCFC :=  Iif( aPos[FP_D1_IDCFC], (cAlsItem)->D1_IDCFC,"" )
	EndiF
	If !Empty(cHistCFC) .AND.  Alltrim(CFC->CFC_IDHIST)<>Alltrim(cHistCFC)
		SS9->(dbSetOrder(1))
		SS9->(MsSeek(xFilial("SS9")+cHistCFC))
		aNfItem[nItem][IT_UFXPROD][UFP_ALIQFECP]	:=	SS9->S9_ALQFCP
		aNfItem[nItem][IT_UFXPROD][UFP_MARGSTLIQ]	:=	Iif( aPos[FP_S9_MGLQST] , SS9->S9_MGLQST , 0	)
		aNfItem[nItem][IT_UFXPROD][UFP_ALIQSTLIQ]	:=	Iif( aPos[FP_S9_ALQSTL] , SS9->S9_ALQSTL , 0	)
		aNfItem[nItem][IT_UFXPROD][UFP_MARGEM]		:=	Iif( aPos[FP_S9_MARGEM] , SS9->S9_MARGEM , 0	)
		aNfItem[nItem][IT_UFXPROD][UFP_ALQFCPO]		:=	Iif( aPos[FP_S9_ALFCPO] , SS9->S9_ALFCPO , 0	)
		aNfItem[nItem][IT_UFXPROD][UFP_FECPAUX]		:=	Iif( aPos[FP_S9_FCPAUX] , SS9->S9_FCPAUX , 0	)
		aNfItem[nItem][IT_UFXPROD][UFP_FECPDIF]		:=	Iif( aPos[FP_S9_FCPXDA] , SS9->S9_FCPXDA , '1'	)
		aNfItem[nItem][IT_UFXPROD][UFP_FECPINT]		:=	Iif( aPos[FP_S9_FCPINT] , SS9->S9_FCPINT , '1'	)
		aNfItem[nItem][IT_UFXPROD][UFP_RDCTIMP]	        :=	Iif( aPos[FP_S9_RDCTIM] , SS9->S9_RDCTIM , 1	)
		aNfItem[nItem][IT_IDCFC]			:= 	SS9->S9_IDHIST
		aNfItem[nItem][IT_UFXPROD][UFP_MVAFRU]		:=	Iif( aPos[FP_MV_MVAFRU] , &(aSX6[MV_MVAFRU]) , 0   )
		aNfItem[nItem][IT_UFXPROD][UFP_MVAES]		:=	Iif( aPos[FP_S9_MVAES]  , SS9->S9_MVAES ,  '1'	)
		aNfItem[nItem][IT_UFXPROD][UFP_ADICST]   :=  Iif( aPos[FP_SS9_ADICST]  , SS9->SS9_ADICST ,  0  )
		aNfItem[nItem][IT_UFXPROD][UFP_PICM]   :=  Iif( aPos[FP_S9_PICM]  , SS9->S9_PICM ,  0  )
		aNfItem[nItem][IT_UFXPROD][UFP_VLICMP]   := Iif( aPos[FP_S9_VLICMP]  , SS9->S9_VLICMP  , 0 )
		aNfItem[nItem][IT_UFXPROD][UFP_VL_ICM]   := Iif( aPos[FP_S9_VL_ICM]  , SS9->S9_VL_ICM  , 0 )
		aNfItem[nItem][IT_UFXPROD][UFP_VL_ANT]   := Iif( aPos[FP_S9_VL_ANT]  , SS9->S9_VL_ANT  , 0 )
		aNfItem[nItem][IT_UFXPROD][UFP_PAUTFOB]   := Iif( aPos[FP_S9_PAUTFOB]  , SS9->S9_PAUTFOB  , 0 )
	EndIf
EndIf

Return

/*/
MaFisRetLF - Edson Maricate -03.01.2000
Retorna um array com a estrutura inicial do aLivro
/*/
Function MaFisRetLF()
       //1  2  3  4  5   6  7  8  9  10 11 12 13 14  15  16  17 18  19  20  21 22  23  24  25 26 27 28 29 30  31  32  33  34          35  36 37 38 39 40 41  42 43  44  45  46  47  48  49 50  51  52  53 54  55 56 57 58 59 60 61 62  63 64 65 66 67 68 69  70  71 72 73 74  75 76 77 78 79 80  81 82  83 84 85 86 87  88 89 90 91 92   93   94  95 96  97 98 99    100  101 102 103 104 105 106 107 108 109  110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157
Return {"",0, 0, 0, 0, 0, 0,  0, 0, 0,  0,"", 0, 0, "", "",  0, "", 0, "", 0, 0,  "", "",  0, 0, 0, 0, 0, 0, "", "", "", 0, {0,0,0,0,0}, "", 0, 0, 0, 0, 0, "","", "", "", "", "", "",  0, 0, "", "", 0,  0,  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, "",  0, 0, 0, 0 ,"","", 0, 0, 0, 0 ,"", 0,  0, 0, 0, 0, 0, "", 0, 0, 0, 0 ,  0 , "", "","", "","","",CtoD(""), 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,  0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  "", 0 , 0, "", "", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}

/*/
MaFisScan-Eduardo/Edson   -02.04.2002
Func de procura da posicao da referencia nos arrays internos
/*/
Function MaFisScan(cCampo,lErro)

Local cPosCpo := 0
Local nScan   := 0
Local lRefVld := .F.

DEFAULT lErro := .T.

If aItemRef == Nil
	MaIniRef()
EndIf

If Substr(cCampo,1,2) == "IT"
	nScan	:= aScan(aItemRef,{|x|x[1]==cCampo})
	If nScan > 0
		cPosCpo	:= aItemRef[nScan][2]
	Else
		If lErro
			If IsBlind() //Utilizado IsBlind() + UserException() em detrimento de Final() para interromper a aplicacao quando utilizado em EAI Mensagem Unica/ WS / Rotinas Automaticas.
				UserException( STR0001 + cCampo ) //"ERRO MATXFIS - Referencia de imposto invalida "
			Else
				MsgAlert(STR0001 + cCampo ) //"ERRO MATXFIS - Referencia de imposto invalida : "
				MsgAlert(STR0029+STR0030+CHR(13)+CHR(10)+CHR(13)+CHR(10)+ STR0031)
				Final(STR0002) //"ERRO MATXFIS - Referencia de imposto invalida "
			EndIf
		EndIf
	EndIf
ElseIf Substr(cCampo,1,2) == "NF"
	nScan	:= aScan(aCabRef,{|x|x[1]==cCampo})
	If nScan > 0
		cPosCpo	:= aCabRef[nScan][2]
	Else
		If lErro
			If IsBlind()
				UserException( STR0001 + cCampo ) //"ERRO MATXFIS - Referencia de imposto invalida "
			Else
				MsgAlert(STR0001 + cCampo ) //"ERRO MATXFIS - Referencia de imposto invalida : "
				MsgAlert(STR0029+STR0030+CHR(13)+CHR(10)+CHR(13)+CHR(10)+ STR0031)
				Final(STR0002) //"ERRO MATXFIS - Referencia de imposto invalida "
			EndIf
		EndIf
	EndIf
ElseIf Substr(cCampo,1,2) == "LF"
	nScan	:= aScan(aLFis,{|x|x[1]==cCampo})
	If nScan > 0
		cPosCpo	:= aLFis[nScan][2]
	Else
		If lErro
			If IsBlind()
				UserException( STR0001 + cCampo ) //"ERRO MATXFIS - Referencia de imposto invalida "
			Else
				MsgAlert(STR0001 + cCampo ) //"ERRO MATXFIS - Referencia de imposto invalida : "
				MsgAlert(STR0029+STR0030+CHR(13)+CHR(10)+CHR(13)+CHR(10)+ STR0031)
				Final(STR0002) //"ERRO MATXFIS - Referencia de imposto invalida "
			EndIf
		EndIf
	EndIf
ElseIf Substr(cCampo,1,3) == "IMP"
	nScan 	:= aScan(aResRef,{|x|x[1]==cCampo})
	If nScan > 0
		cPosCpo	:= aResRef[nScan][2]
	Else
		If lErro
			If IsBlind()
				UserException( STR0001 + cCampo ) //"ERRO MATXFIS - Referencia de imposto invalida "
			Else
				MsgAlert(STR0001 + cCampo ) //"ERRO MATXFIS - Referencia de imposto invalida : "
				MsgAlert(STR0029+STR0030+CHR(13)+CHR(10)+CHR(13)+CHR(10)+ STR0031)
				Final(STR0002) //"ERRO MATXFIS - Referencia de imposto invalida "
			EndIf
		EndIf
	EndIf
ElseIf Substr(cCampo,1,2) == "TG"

	If Substr(cCampo,1,5) == "TG_IT"
		If (nScan := aScan(aTGITRef,{|x|x[1]==cCampo})) > 0
			cPosCpo	:= aTGITRef[nScan][2]
			lRefVld := .T.
		EndIf
	ElseIf Substr(cCampo,1,5) == "TG_NF"
		If (nScan 	:= aScan(aTGNFRef,{|x|x[1]==cCampo})) > 0
			cPosCpo	:= aTGNFRef[nScan][2]
			lRefVld := .T.
		EndIF
	EndIf

	If !lRefVld
		If lErro
			If IsBlind()
				UserException( STR0001 + cCampo ) //"ERRO MATXFIS - Referencia de imposto invalida "
			Else
				MsgAlert(STR0001 + cCampo ) //"ERRO MATXFIS - Referencia de imposto invalida : "
				MsgAlert(STR0029+STR0030+CHR(13)+CHR(10)+CHR(13)+CHR(10)+ STR0031)
				Final(STR0002) //"ERRO MATXFIS - Referencia de imposto invalida "
			EndIf
		EndIf
	EndIf

EndIf

Return(cPosCpo)

/*/
MaItArred - Edson Maricate  -12.04.2001
 Executa a correcao dos arredondamentos do item
           Utiliza o Array aSaveDec para armazenar os centesimos
           que foram truncados. ( aSaveDec deve estar inicializado
           obrigatoriamente pela MaFisIni() )
/*/
Function MaItArred(nX,aRefs)
Local nY        := 0
Local nZ        := 0
Local nDifItDel := 0
Local nAbatISS	:= 0
Local nDif      := 0
Local nValor 	:= 0
Local nDifItem	:= 0
Local nDec      := 2
Local nRndPrec  := IIf( aSX6[MV_RNDPREC] < 3 , 10 , aSX6[MV_RNDPREC] ) // Precisao para o arredondamento
Local lSobra    := aSX6[MV_RNDSOBR] // Parametro para considerar, ou nao, as sobras quando o parametro de arredondamento estiver como .F., ou seja, para truncar.
Local lRndrne   := aSX6[MV_RNDRNE]
Local lIBGE886  := aSX6[MV_IBGE886]
Local nValISS := 0
Local nBasIss   := 0
Local nIteISS   := 0
Local nDifISS := 0
Local nISSABNT  := 0
Local lArdISS   := .F.
Local lVisReproc := IsInCallStack("MAFISININF")

If aItemRef == Nil
	MaIniRef()
EndIf

// Executa a correcao nos arredondamentos.
For nY := 1 to Len(aItemRef)
	If aRefs == Nil .Or. aScan( aRefs, aItemRef[nY][1] ) <> 0
		If aItemRef[nY][4]
			nDifItem	:= 0
			nDifItDel   := 0
			If cPaisLoc<>"BRA"
				If FunName()=="MATA121" .And. Type("nMoedaPed")=="N"
					nDec:=MsDecimais(nMoedaPed)
				ElseIf FunName()=="MATA123" .And. Type("nMoedaPed")=="N"
					nDec:=MsDecimais(nMoedaPed)
				ElseIf FunName()=="MATA150" .And. Type("nMoedaCot")=="N"
					nDec:=MsDecimais(nMoedaCot)
				ElseIf FunName()=="MATA160" .And. Type("nMoedaAval")=="N"
					nDec:=MsDecimais(nMoedaAval)
				ElseIf Type("nMoedaNF")=="N"
					nDec:=MsDecimais(nMoedaNF)
				ElseIf Type("nMoedaCor")=="N"
					nDec:=MsDecimais(nMoedaCor)
				ElseIf Type("M->F1_MOEDA")=="N"
					nDec:=MsDecimais(M->F1_MOEDA)
				ElseIf Type("M->F2_MOEDA")=="N"
					nDec:=MsDecimais(M->F2_MOEDA)
				ElseIf Type("M->C5_MOEDA")=="N"
					nDec:=MsDecimais(M->C5_MOEDA)
				ElseIf FunName()=="MATA143" .And. Type("nMoedaDes")=="N"
					nDec:=MsDecimais(nMoedaDes)
				Else
					nDec:=MsDecimais(1)
				Endif
				nDif:=10**(-nDec)
			Endif

			For nZ := 1 To Len(aNfItem) // For para desconsiderar os itens deletados nos arrays de acumulos da sobras qdo o parametro MV_RNDSOBR = .T.
				If aNfItem[nZ][IT_DELETED] .And. lSobra
					If aItemDec[nZ][1][nY] > 0
						nDifItDel += aItemDec[nZ][1][nY]
						nDifItDel -= (1/10**nDec)
					Else
						nDifItDel += aItemDec[nZ][2][nY]
					EndIf
				EndIf
			Next nZ

			If ValType(aItemRef[nY][2]) == "A"
				nValor := aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]]
				If nValor <> 0
					While Int(nValor) <> Int(NoRound(NoRound(nValor,nRndPrec),nDec,nDifItem,10)) .And. nRndPrec > 2
						nRndPrec -= 1
					Enddo
					aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] := NoRound(NoRound(nValor,nRndPrec),nDec,@nDifItem,10)
					If nDifItem <> 0
						aSaveDec[nY] += aItemDec[nX][1][nY]
						aItemDec[nX][1][nY] := 0
						If !aItemRef[nY][5]
							aSaveDec[nY] -= aItemDec[nX][2][nY]
							aItemDec[nX][2][nY]	:= nDifItem
							aSaveDec[nY] += nDifItem
							If lSobra
								//TRATAMENTO SAO PAULO COM ITENS QUE TENHAM ABATIMENTO.
								If lRndrne .And. aItemRef[nY][1] == "IT_VALISS" .And. aNfItem[nX,IT_ABVLISS] > 0
									If ( (NoRound(aSaveDec[nY],nDec) - nDifItDel ) >= 1/10**nDec)
										aItemDec[nX][1][nY]	:= (1/10**nDec) - nDifItem
										aItemDec[nX][2][nY]	:= 0
										aSaveDec[nY] -= (1/10**nDec)
										aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] += (1/10**nDec)
										nAbatISS += aNfItem[nX,IT_ABVLISS]
									EndIf
									//TRATAMENTO SAO PAULO COM ITENS QUE NAO TENHAM ABATIMENTO ANTERIORES.
								ElseIf lRndrne .And. aItemRef[nY][1] == "IT_VALISS" .And. nAbatISS == 0
									If ( (NoRound(aSaveDec[nY],nDec) - nDifItDel ) >= 1/10**nDec)
										aItemDec[nX][1][nY]	:= (1/10**nDec) - nDifItem
										aItemDec[nX][2][nY]	:= 0
										aSaveDec[nY] -= (1/10**nDec)
										aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] += (1/10**nDec)
									EndIf
								Else
									If ( aSaveDec[nY] - nDifItDel )  >= (50/(10**(nDec + 2)))
										aItemDec[nX][1][nY]	:= (1/10**nDec) - nDifItem
										aItemDec[nX][2][nY]	:= 0
										aSaveDec[nY] -= (1/10**nDec)
										aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] += (1/10**nDec)
									EndIf
								EndIf
							EndIf
						ElseIf nDifItem > 0 .And. aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] > 0
							aSaveDec[nY] -= aItemDec[nX][2][nY]
							aItemDec[nX][2][nY]	:= nDifItem
							aSaveDec[nY] += nDifItem							
							If ( aSaveDec[nY] - nDifItDel ) >= (50/(10**(nDec + 2)))
								If lSobra
									aItemDec[nX][1][nY]	:= (1/10**nDec) - nDifItem
									aItemDec[nX][2][nY]	:= 0
									aSaveDec[nY] -= (1/10**nDec)
								EndIf							
								aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] += (1/10**nDec)
							EndIf
						EndIf
						If !lSobra
							aItemDec[nX][1][nY]	:= 0
							aItemDec[nX][2][nY]	:= 0
							aSaveDec[nY] := 0
						Endif
					EndIf

					// Tratamento p/ arredondamento ABNT/IBGE - ISS - MV_IBGE886
					// Não executa quando MAFISININF estiver na pilha pois esta função é p/ visualização e reprocessamento
					// do documento, então não posso alterar nenhum valor.
					If cPaisLoc == "BRA" .And. lIBGE886 .And. aItemRef[nY][1] == "IT_VALISS" .And. aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] > 0 .And. !lVisReproc

						// Se o documento tem mais de um item só vou fazer o tratamento no último item p/ acertar o valor total, que é 
						// o que é validado na transmissão da NFS.
						// Atenção: Este tratamento p/ o último item só funciona para o faturamento (Planilha / MATA461) pois para as demais
						// interfaces de digitação não é possível saber a quantidade de itens que o documento terá. Assim, para estas demais rotinas,
						// o tratamento continuará sendo feito item a item assim como era feito anteriormente.
						If aNFCab[NF_QTDITENS] > 0
							If nX == aNFCab[NF_QTDITENS]								
								lArdISS := .T.
								aEval(aNFItem,{|x| nBasIss += x[IT_BASEISS]})
								aEval(aNFItem,{|x| nValISS += x[IT_VALISS]})
							EndIf
						Else
							lArdISS := .T.
							nBasIss := aNfItem[nX][IT_BASEISS]
							nValISS := aNfItem[nX][IT_VALISS]
						EndIf
						
						If lArdISS
							// Calculo o valor total de ISS da forma mais "pura" possível, ou seja,
							// sem nenhum tratamento de arredondamento.
							nISSABNT := (nBasIss * (aNfItem[nX][IT_ALIQISS] / 100))

							// Arredondo o valor para 2 casas e guardo a sobra, ou seja, o valor da 3 casa em diante na variavel nDifISS.
							nISSABNT := NoRound(NoRound(nISSABNT, 10), 2, @nDifISS, 10)
						
							// Caso 1: Terceiro dígito é 5 seguido de zeros, então igualo exatamente a 0.005 pois 0.005 = 0.005000...
							If nDifISS == 0.005 
									// Verifico se o segundo algarismo após a vírgula é ímpar.
									// Se for, somo 0.01 p/ arredondar. Caso contrário não faço
									// nada pois o número deve ser truncado. 
								If Mod(Val(Right(cValToChar(nISSABNT * 100), 1)), 2) <> 0
									nISSABNT += 0.01
								EndIf
							// Caso 2: Terceiro digito maior do que 5, ou 5 seguido de qualquer número diferente de zero, ou seja, qlqr valor acima de 0.005...
							ElseIf nDifISS > 0.005 
								nISSABNT += 0.01
							EndIf

							// Por fim, verifico se o valor total dos itens já corresponde ao valor que seria esperado
							// no padrão ABNT. Se não corresponder, faço o ajuste no último item para que os valores batam.
							If nValISS <> nISSABNT
								aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] += (nISSABNT - nValISS)
							EndIf
								
							// Se o controle de sobras estiver ativo limpo os arrays.
							If lSobra
								aItemDec[nX][1][nY]	:= 0
								aItemDec[nX][2][nY]	:= 0
								aSaveDec[nY] := 0
							EndIf
						EndIf
					
					EndIf

				EndIf
			Else
				nValor := aNfItem[nX][Val(aItemRef[nY][2])]
				If nValor <> 0
					While Int(nValor) <> Int(NoRound(NoRound(nValor,nRndPrec),nDec,nDifItem,10)) .And. nRndPrec > 2
						nRndPrec -= 1
					Enddo
					aNfItem[nX][Val(aItemRef[nY][2])] := NoRound(NoRound(nValor,nRndPrec),nDec,@nDifItem,10)
					If nDifItem <> 0
						aSaveDec[nY] += aItemDec[nX][1][nY]
						aItemDec[nX][1][nY] := 0
						If !aItemRef[nY][5]
							aSaveDec[nY] -= aItemDec[nX][2][nY]
							aItemDec[nX][2][nY]	:= nDifItem
							aSaveDec[nY] += nDifItem

							//TRATAMENTO SAO PAULO COM ITENS QUE TENHAM ABATIMENTO.
							If  lRndRne .And. aItemRef[nY][1] == "IT_VALISS" .And. aNfItem[nX,IT_ABVLISS] > 0
								If ( NoRound(aSaveDec[nY],nDec) - nDifItDel ) >= 1/10**nDec
									aItemDec[nX][1][nY]	:= (1/10**nDec) - nDifItem
									aItemDec[nX][2][nY]	:= 0
									aSaveDec[nY] -= (1/10**nDec)
									aNfItem[nX][Val(aItemRef[nY][2])] += (1/10**nDec)
									nAbatISS += aNfItem[nX,IT_ABVLISS]
								EndIf
								//TRATAMENTO SAO PAULO COM ITENS QUE NAO TENHAM ABATIMENTO ANTERIORES.
							ElseIf lRndRne .And. aItemRef[nY][1] == "IT_VALISS" .And. nAbatISS == 0
								If ( NoRound(aSaveDec[nY],nDec) - nDifItDel ) >= 1/10**nDec
									aItemDec[nX][1][nY]	:= (1/10**nDec) - nDifItem
									aItemDec[nX][2][nY]	:= 0
									aSaveDec[nY] -= (1/10**nDec)
									aNfItem[nX][Val(aItemRef[nY][2])] += (1/10**nDec)
								EndIf
							Else
								If lSobra .And. ( aSaveDec[nY] - nDifItDel ) >= (50/(10**(nDec + 2)))
									aItemDec[nX][1][nY]	:= (1/10**nDec) - nDifItem
									aItemDec[nX][2][nY]	:= 0
									aSaveDec[nY] -= (1/10**nDec)
									aNfItem[nX][Val(aItemRef[nY][2])] += (1/10**nDec)
								EndIf
							EndIf

						ElseIf nDifItem > 0 .And. aNfItem[nX][Val(aItemRef[nY][2])] > 0
							aSaveDec[nY] -= aItemDec[nX][2][nY]
							aItemDec[nX][2][nY] := nDifItem
							aSaveDec[nY] += nDifItem
							If ( aSaveDec[nY] - nDifItDel ) >= (50/(10**(nDec + 2)))
								aItemDec[nX][1][nY] := (1/10**nDec) - nDifItem
								aItemDec[nX][2][nY] := 0
								aSaveDec[nY] -= (1/10**nDec)
								aNfItem[nX][Val(aItemRef[nY][2])] += (1/10**nDec)
							EndIf
						EndIf
						If !lSobra
							aItemDec[nX][1][nY]	:= 0
							aItemDec[nX][2][nY]	:= 0
							aSaveDec[nY] 		:= 0
						Endif
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
Next nY

Return

/*/
 MaIt2Cab- Edson Maricate -13.12.1999
 Atualiza os valores totais do cabecalho da NF
/*/
Static Function MaIt2Cab(nItemNao)
Local nX := 0
Local nY := 0
DEFAULT nItemNao := 0

aAuxOri := {}
aNfCab[NF_DESCONTO]	:= 0
aNfCab[NF_DESCTOT]	:= 0
aNfCab[NF_ACRESCI]	:= 0
aNfCab[NF_FRETE]	:= 0
aNfCab[NF_DESPESA]	:= 0
aNfCab[NF_SEGURO]	:= 0
aNfCab[NF_VALEMB]	:= 0
aNfCab[NF_AUTONOMO]	:= 0
aNfCab[NF_ICMS]		:= {0,0,0,0,0,0,0,0,"1"}
aNfCab[NF_IPI]		:= {0,0,0}
aNfCab[NF_TOTAL]	:= 0
aNfCab[NF_VALMERC]	:= 0
aNfCab[NF_VNAGREG]  := 0
aNfCab[NF_FUNRURAL]	:= 0
aNfCab[NF_LIVRO]	:= {}
aNfCab[NF_BASEIRR]	:= 0
aNfCab[NF_VALIRR]	:= 0
aNfCab[NF_BASEINS]  := 0
aNfCab[NF_VALINS]	:= 0
aNfCab[NF_BASEISS] 	:= 0
aNfCab[NF_VALISS]	:= 0
aNfCab[NF_DESCISS]  := 0
aNfCab[NF_IMPOSTOS]	:= {}
aNfCab[NF_IMPOSTOS2]:= {}
aNfCab[NF_BASEDUP]	:= 0
aNfCab[NF_DESCZF]	:= 0
aNfCab[NF_BASEIMP]	:= Array(NMAXIV)
aNfCab[NF_BASEIMP]	:= Afill(aNfCab[NF_BASEIMP],0)
aNfCab[NF_VALIMP]	:= Array(NMAXIV)
aNfCab[NF_VALIMP]	:= Afill(aNfCab[NF_VALIMP],0)
aNfCab[NF_PESO]		:= 0
aNfCab[NF_ICMFRETE]	:= 0
aNfCab[NF_BSFRETE]	:= 0
aNfCab[NF_BASEICA]	:= 0
aNfCab[NF_VALICA]	:= 0
aNfCab[NF_BASECOF]	:= 0
aNfCab[NF_VALCOF]	:= 0
aNfCab[NF_BASECSL]	:= 0
aNfCab[NF_VALCSL]	:= 0
aNfCab[NF_BASEPIS]	:= 0
aNfCab[NF_VALPIS]	:= 0
aNfCab[NF_BASEPS2]	:= 0
aNfCab[NF_VALPS2]	:= 0
aNfCab[NF_BASECF2]	:= 0
aNfCab[NF_VALCF2]	:= 0
aNfCab[NF_MINIMP]	:=Array(NMAXIV)
aNfCab[NF_MINIMP]	:=Afill(aNfCab[NF_MINIMP],0)
aNfCab[NF_BASEAFRMM]:= 0
aNfCab[NF_PIS252]   := 0
aNfCab[NF_COF252]   := 0
aNfCab[NF_BASESES]  := 0
aNfCab[NF_VALSES]	:= 0
aNfCab[NF_BASEPS3]  := 0
aNfCab[NF_VALPS3]   := 0
aNfCab[NF_BASECF3]  := 0
aNfCab[NF_VALCF3]   := 0
aNfCab[NF_VLR_FRT]  := 0
aNfCab[NF_VALFET]   := 0
aNfCab[NF_VALFETR]  := 0
aNfCab[NF_VALFDS]   := 0
aNfCab[NF_VLSENAR]  := 0
aNfCab[NF_ESTCRED]  := 0
aNfCab[NF_BASETST]  := 0
aNfCab[NF_VALTST]   := 0
aNfCab[NF_CRPRSIM]  := 0
aNfCab[NF_VALANTI]  := 0
aNfCab[NF_DESNTRB]  := 0
aNfCab[NF_TARA]   	:= 0
aNfCab[NF_CRDPRES]	:= 0
aNfCab[NF_CRPREPE]	:= 0
aNfCab[NF_VALFAC]	:= 0
aNfCab[NF_VALFET]	:= 0
aNfCab[NF_VALFETR]	:= 0
aNfCab[NF_VALFAB]	:= 0
aNfCab[NF_CROUTSP]  := 0
aNfCab[NF_BSSEMDS]  := 0
aNfCab[NF_ICSEMDS]  := 0
aNfCab[NF_DS43080]  := 0
aNfCab[NF_VL43080]  := 0
aNfCab[NF_VLRORIG]	:= Array(NMAXIV)
aNfCab[NF_VLRORIG]	:= Afill(aNfCab[NF_VLRORIG],0)
aNfCab[NF_ICMSDIF]  := 0
aNfCab[NF_BASEFUN]  := 0
aNfCab[NF_VALII]    := 0
aNfCab[NF_VLINCMG]  := 0
aNfCab[NF_BASEINA]	:= 0
aNFCab[NF_VALINA]	:= 0
aNfCab[NF_VFECPRN]  := 0
aNfCab[NF_VFESTRN]  := 0
aNfCab[NF_CREDPRE]	:= 0
aNfCab[NF_VFECPMG]  := 0
aNfCab[NF_VFESTMG]  := 0
aNfCab[NF_VREINT]   := 0
aNfCab[NF_BSREIN]   := 0
aNfCab[NF_VFECPMT]  := 0
aNfCab[NF_VFESTMT]  := 0
aNfCab[NF_ISSABMT]  := 0
aNfCab[NF_ISSABSR]  := 0
aNfCab[NF_INSABMT]  := 0
aNfCab[NF_INSABSR]  := 0
aNfCab[NF_ADIANT]   := 0
aNfCab[NF_VALTPDP]  := 0
aNfCab[NF_BASTPDP]  := 0
aNfCab[NF_VALAFRMM] := 0
aNfCab[NF_VALFECP]  := 0
aNfCab[NF_VFECPST]  := 0
aNfCab[NF_VALFUM]   := 0
aNfCab[NF_VALCIDE]  := 0
aNfCab[NF_AFRMIMP]	:= 0
aNfCab[NF_VALINP]  := 0
aNfCab[NF_VALPRO]  := 0
aNfCab[NF_TRIBGEN] := {}

IF cPaisLoc == "PER" .and. aPos[FP_F1_ADIANT]
	aNfCab[NF_ADIANTTOT] := 0
EndIf

For nX := 1 to Len(aNfItem)
	If nItemNao <> nX
		MaFisSomaIt(nX)
	Endif
Next nX

If cPaisLoc == "BRA" // Executa a correcao nos arredondamentos no Cabecalho e Livros Fiscais
	For nX := 1 To Len(aCabRef)
		If ValType(aCabRef[nX,2]) <> "A"
			nY := Val(aCabRef[nX,2])
			If ValType(aNfCab[nY]) == "N" .And. aCabRef[nX][3]
				aNfCab[nY] := NoRound(aNfCab[nY],2,,10)
			EndIf
		EndIf
	Next nX
Endif

If bFisRefresh <> Nil
	Eval(bFisRefresh)
EndIf

If bLivroRefresh <> Nil
	Eval(bLivroRefresh)
EndIf

Return .T.

/*
MaFisSomaIt -Edson Maricate -13.12.1999
Esta rotina tem como objetivo atualizar a variavel aNfCab com base nos itens da funcao fiscal
Rotina atualizacao dos dados do Cabecalho da funcao fiscal
aNfCab com base em um item da funcao fiscal aNfItem
Parametros
ExpN1: Item do Array ANFItem que deve ser inicializado
ExpL2: Indica se eh inclusao (.T.)ou estorno(.F.) (OPC)
ExpC3: Campo a ser atualizado (OPC)
*/
Static Function MaFisSomaIt(nX,lSoma,cCampo)
Local nY := 0
Local nG := 0
Local nPosDesc := 0
Local cUFFCP := ""
Local nTrbGen		:= 0
Local cSiglaGen		:= ""
Local cDescriGen    := ""
Local nBaseGen	    := 0
Local nAlqGen		:= 0
Local nValGen		:= 0
Local nPosGen       := 0

DEFAULT lSoma := .T.

If !aNfItem[nX][IT_DELETED]
	If lSoma
		// Atualiza os campos totalizadores.
		aNfCab[NF_DESCONTO]+= aNfItem[nX][IT_DESCONTO]
		aNfCab[NF_FRETE]   += aNfItem[nX][IT_FRETE]
		aNfCab[NF_DESPESA] += aNfItem[nX][IT_DESPESA]
		aNfCab[NF_SEGURO]  += aNfItem[nX][IT_SEGURO]
		aNfCab[NF_VALEMB]  += aNfItem[nX][IT_VALEMB]
		aNfCab[NF_AUTONOMO]+= aNfItem[nX][IT_AUTONOMO]
		aNfCab[NF_BASEICM] += aNfItem[nX][IT_BASEICM]
		aNfCab[NF_VALICM]  += aNfItem[nX][IT_VALICM]
		aNfCab[NF_BASESOL] += aNfItem[nX][IT_BASESOL]
		aNfCab[NF_VALSOL]  += aNfItem[nX][IT_VALSOL]
		aNfCab[NF_BICMORI] += aNfItem[nX][IT_BICMORI]
		aNfCab[NF_VALCMP]  += aNfItem[nX][IT_VALCMP]
		aNfCab[NF_DIFAL]   += aNfItem[nX][IT_DIFAL]
		aNfCab[NF_BASEIPI] += aNfItem[nX][IT_BASEIPI]
		aNfCab[NF_BIPIORI] += aNfitem[nX][IT_BIPIORI]
		aNfCab[NF_VALIPI]  += aNfItem[nX][IT_VALIPI]
		aNfCab[NF_TOTAL]   += aNfItem[nX][IT_TOTAL]
		aNfCab[NF_VALMERC] += aNfItem[nX][IT_VALMERC]-aNfItem[nX][IT_VNAGREG]
		aNfCab[NF_VNAGREG] += aNfItem[nX][IT_VNAGREG]
		aNfCab[NF_FUNRURAL]+= aNfItem[nX][IT_FUNRURAL]
		aNfCab[NF_BASEIRR] += aNfItem[nX][IT_BASEIRR]
		aNfCab[NF_VALIRR]  += aNfItem[nX][IT_VALIRR]
		aNfCab[NF_BASEINS] += aNfItem[nX][IT_BASEINS]
		aNfCab[NF_VALINS]  += aNfItem[nX][IT_VALINS]
		aNfCab[NF_BASEISS] += aNfItem[nX][IT_BASEISS]
		aNfCab[NF_VALISS]  += aNfItem[nX][IT_VALISS]
		aNfCab[NF_BASEDUP] += aNfItem[nX][IT_BASEDUP]
		aNfCab[NF_DESCZF]  += aNfItem[nX][IT_DESCZF]
		aNfCab[NF_PESO]	   += aNfItem[nX][IT_PESO]
		aNfCab[NF_ICMFRETE]+= aNfItem[nX][IT_ICMFRETE]
		aNfCab[NF_BSFRETE] += aNfItem[nX][IT_BSFRETE]
		aNfCab[NF_BASEICA] += aNfItem[nX][IT_BASEICA]
		aNfCab[NF_VALICA]  += aNfItem[nX][IT_VALICA]
		aNfCab[NF_BASECOF] += aNfItem[nX][IT_BASECOF]
		aNfCab[NF_VALCOF]  += aNfItem[nX][IT_VALCOF]
		aNfCab[NF_BASEPIS] += aNfItem[nX][IT_BASEPIS]
		aNfCab[NF_VALPIS]  += aNfItem[nX][IT_VALPIS]
		aNfCab[NF_BASEPS2] += aNfItem[nX][IT_BASEPS2]
		aNfCab[NF_VALPS2]  += aNfItem[nX][IT_VALPS2]
		aNfCab[NF_BASECF2] += aNfItem[nX][IT_BASECF2]
		aNfCab[NF_VALCF2]  += aNfItem[nX][IT_VALCF2]
		aNfCab[NF_BASECSL] += aNfItem[nX][IT_BASECSL]
		aNfCab[NF_VALCSL]  += aNfItem[nX][IT_VALCSL]
		aNfCab[NF_BASEFUN] += aNfItem[nX][IT_BASEFUN]
		aNfCab[NF_ADIANT]  += aNfItem[nX][IT_ADIANT]

		If cPaisLoc == "PER" .and. aPos[FP_F1_ADIANT]
			aNfCab[NF_ADIANTTOT]+= aNfItem[nX][IT_ADIANTTOT]
		EndIf

		aNfCab[NF_DESCTOT] += aNfItem[nX][IT_DESCTOT]
		aNfCab[NF_ACRESCI] += aNfItem[nX][IT_ACRESCI]
		aNfCab[NF_VALCIDE] += aNfItem[nX][IT_VALCIDE]
		aNfCab[NF_BASECID] += aNfItem[nX][IT_BASECID]
		aNfCab[NF_BASECPM] += aNfItem[nX][IT_BASECPM]
		aNfCab[NF_VALCPM]  += aNfItem[nX][IT_VALCPM]
		aNfCab[NF_IPIVFCF]  += aNfItem[nX][IT_IPIVFCF]
		aNfCab[NF_BASEFMP] += aNfItem[nX][IT_BASEFMP]
		aNfCab[NF_VALFMP]  += aNfItem[nX][IT_VALFMP]
		aNfCab[NF_VALFMD]  += aNfItem[nX][IT_VALFMD]
		aNfCab[NF_BASNDES] += aNfItem[nX][IT_BASNDES]
		aNfCab[NF_ICMNDES] += aNfItem[nX][IT_ICMNDES]

		If cPaisLoc == "BRA" .Or. lNotRemito
			For nG := 1 To NMAXIV
				aNfCab[NF_BASEIMP][nG]+= IIf(ValType(aNfItem[nX][IT_BASEIMP][nG])<>"N",0,aNfItem[nX][IT_BASEIMP][nG])
				aNfCab[NF_VALIMP][nG] += aNfItem[nX][IT_VALIMP][nG]
				aNfCab[NF_VLRORIG][nG]+= aNfItem[nX][IT_VALIMP][nG]
			Next nG
			aNfCab[NF_ICMSDIF]	+= aNfItem[nX][IT_ICMSDIF]
			aNfCab[NF_BASEAFRMM]+= aNfItem[nX][IT_BASEAFRMM]
			aNfCab[NF_VALAFRMM] += aNfItem[nX][IT_VALAFRMM]
			aNfCab[NF_PIS252]	+= aNfItem[nX][IT_PIS252]
			aNfCab[NF_COF252]	+= aNfItem[nX][IT_COF252]
			aNfCab[NF_BASESES]	+= aNfItem[nX][IT_BASESES]
			aNfCab[NF_VALSES]	+= aNfItem[nX][IT_VALSES]
			aNfCab[NF_BASEPS3]	+= aNfItem[nX][IT_BASEPS3]
			aNfCab[NF_VALPS3]	+= aNfItem[nX][IT_VALPS3]
			aNfCab[NF_BASECF3]	+= aNfItem[nX][IT_BASECF3]
			aNfCab[NF_VALCF3]	+= aNfItem[nX][IT_VALCF3]
			aNfCab[NF_VLR_FRT]	+= aNfItem[nX][IT_VLR_FRT]
			aNfCab[NF_VALFET]	+= aNfItem[nX][IT_VALFET]
			aNfCab[NF_VALFETR]	+= aNfItem[nX][IT_VALFETR]
			aNfCab[NF_VALFDS]	+= aNfItem[nX][IT_VALFDS]
			aNfCab[NF_ESTCRED]	+= aNfItem[nX][IT_ESTCRED]
			aNfCab[NF_BASETST]	+= aNfItem[nX][IT_BASETST]
			aNfCab[NF_VALTST]	+= aNfItem[nX][IT_VALTST]
			aNfCab[NF_CRPRSIM]	+= aNfItem[nX][IT_CRPRSIM]
			aNfCab[NF_VALANTI]	+= aNfItem[nX][IT_VALANTI]
			aNfCab[NF_DESNTRB]	+= aNfItem[nX][IT_DESNTRB]
			aNfCab[NF_TARA]		+= aNfItem[nX][IT_TARA]
			aNfCab[NF_VALFECP]	+= aNfItem[nX][IT_VALFECP]
			aNfCab[NF_VFCPDIF]	+= aNfItem[nX][IT_VFCPDIF]
			aNfCab[NF_BASEDES]	+= aNfItem[nX][IT_BASEDES]
			aNfCab[NF_VFECPST]	+= aNfItem[nX][IT_VFECPST]
			aNfCab[NF_CRDPRES]	+= aNfItem[nX][IT_CRPRESC]
			aNfCab[NF_CRDPRES]	+= aNfItem[nX][IT_CRPREMG]
			aNfCab[NF_CRDPRES]	+= aNfItem[nX][IT_CRPRECE]
			aNfCab[NF_VALII]	+= aNfItem[nX][IT_VALII]
			aNfCab[NF_CRPREPE]	+= aNfItem[nX][IT_CRPREPE]
			aNfCab[NF_VALFAB]	+= aNfItem[nX][IT_VALFAB]
			aNfCab[NF_VALFAC]	+= aNfItem[nX][IT_VALFAC]
			aNfCab[NF_VALFUM]	+= aNfItem[nX][IT_VALFUM]
			aNfCab[NF_VLSENAR]	+= aNfItem[nX][IT_VLSENAR]
			aNfCab[NF_CROUTSP]	+= aNfItem[nX][IT_CROUTSP]
			aNfCab[NF_BSSEMDS]	+= aNfItem[nX][IT_BSSEMDS]
			aNfCab[NF_ICSEMDS]	+= aNfItem[nX][IT_ICSEMDS]
			aNfCab[NF_VLINCMG]	+= aNfItem[nX][IT_VLINCMG]
			aNfCab[NF_TOTAL]	+= aNfItem[nX][IT_VLINCMG]
			aNfCab[NF_BASEINA]	+= aNfItem[nX][IT_BASEINA]
			aNFCab[NF_VALINA]	+= aNfItem[nX][IT_VALINA]
			aNfCab[NF_VFECPRN]	+= aNfItem[nX][IT_VFECPRN]
			aNfCab[NF_VFESTRN]	+= aNfItem[nX][IT_VFESTRN]
			aNfCab[NF_CREDPRE]	+= aNfItem[nX][IT_CREDPRE]
			aNfCab[NF_VFECPMG]	+= aNfItem[nX][IT_VFECPMG]
			aNfCab[NF_VFESTMG]	+= aNfItem[nX][IT_VFESTMG]
			aNfCab[NF_VREINT]	+= aNfItem[nX][IT_VREINT]
			aNfCab[NF_BSREIN]	+= aNfItem[nX][IT_BSREIN]
			aNfCab[NF_VFECPMT]	+= aNfItem[nX][IT_VFECPMT]
			aNfCab[NF_VFESTMT]	+= aNfItem[nX][IT_VFESTMT]
			aNfCab[NF_ISSABMT] 	+= aNfItem[nX][IT_ABMATISS]
			aNfCab[NF_ISSABSR]	+= aNfItem[nX][IT_ABVLISS]
			aNfCab[NF_INSABMT]	+= aNfItem[nX][IT_AVLINSS]
			aNfCab[NF_INSABSR]	+= aNfItem[nX][IT_ABVLINSS]
			aNfCab[NF_VALTPDP]  += aNfItem[nX][IT_VALTPDP]
			aNfCab[NF_BASTPDP]  += aNfItem[nX][IT_BASTPDP]
			aNfCab[NF_VALFUND]	+= aNfItem[nX][IT_VALFUND]
			aNfCab[NF_VALIMA]	+= aNfItem[nX][IT_VALIMA]
			aNfCab[NF_VALFASE]	+= aNfItem[nX][IT_VALFASE]
			aNfCab[NF_VLIMAR]	+= aNfItem[nX][IT_VLIMAR]
			aNfCab[NF_VLFASER]	+= aNfItem[nX][IT_VLFASER]
			aNfCab[NF_VALINP]   += aNfItem[nX][IT_VALINP]
			aNfCab[NF_AFRMIMP]	+= aNfItem[nX][IT_AFRMIMP]
			aNfCab[NF_VALPRO]   += aNfItem[nX][IT_VALPRO]
			aNfCab[NF_BFCPANT]  += aNfItem[nX][IT_BFCPANT]
			aNfCab[NF_VFCPANT]  += aNfItem[nX][IT_VFCPANT]
			aNfCab[NF_BASFECP]  += aNfItem[nX][IT_BASFECP]
			aNfCab[NF_BSFCPST]  += aNfItem[nX][IT_BSFCPST]
			aNfCab[NF_BSFCCMP]  += aNfItem[nX][IT_BSFCCMP]

			If cPaisLoc == "BRA"
				For nTrbGen:= 1 to Len(aNfItem[nx][IT_TRIBGEN])

					If (nPosGen := aScan(aNfCab[NF_TRIBGEN], {|x| AllTrim(x[TG_NF_SIGLA]) == AllTrim(aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_SIGLA])})) == 0
						aAdd(aNfCab[NF_TRIBGEN], Array(NMAX_NF_TG))
						nPosGen := Len(aNfCab[NF_TRIBGEN])
						aNfCab[NF_TRIBGEN][nPosGen][TG_NF_SIGLA] 		:= aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_SIGLA]
						aNfCab[NF_TRIBGEN][nPosGen][TG_NF_BASE]  		:= aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_BASE]
						aNfCab[NF_TRIBGEN][nPosGen][TG_NF_VALOR] 		:= aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_VALOR]
						aNfCab[NF_TRIBGEN][nPosGen][TG_NF_REGRA_FIN] 	:= aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_REGRA_FIN]
						aNfCab[NF_TRIBGEN][nPosGen][TG_NF_ID_REGRA] 	:= aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_ID_REGRA]						
						aNfCab[NF_TRIBGEN][nPosGen][TG_NF_ALQ_CODURF] 	:= aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_REGRA_ALQ][TG_ALQ_CODURF]
						aNfCab[NF_TRIBGEN][nPosGen][TG_NF_ALQ_PERURF] 	:= aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_REGRA_ALQ][TG_ALQ_PERURF]									

					Else					
						aNfCab[NF_TRIBGEN][nPosGen][TG_NF_BASE]  += aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_BASE]
						aNfCab[NF_TRIBGEN][nPosGen][TG_NF_VALOR] += aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_VALOR]
					EndIf

				Next nTrbGen
			EndIf

		EndIf
	Else
		// Atualiza os campos totalizadores.
		aNfCab[NF_DESCONTO]	-= aNfItem[nX][IT_DESCONTO]
		aNfCab[NF_FRETE]	-= aNfItem[nX][IT_FRETE]
		aNfCab[NF_DESPESA]	-= aNfItem[nX][IT_DESPESA]
		aNfCab[NF_SEGURO]	-= aNfItem[nX][IT_SEGURO]
		aNfCab[NF_VALEMB]	-= aNfItem[nX][IT_VALEMB]
		aNfCab[NF_AUTONOMO]	-= aNfItem[nX][IT_AUTONOMO]
		aNfCab[NF_BASEICM]	-= aNfItem[nX][IT_BASEICM]
		aNfCab[NF_VALICM]	-= aNfItem[nX][IT_VALICM]
		aNfCab[NF_BASESOL]	-= aNfItem[nX][IT_BASESOL]
		aNfCab[NF_VALSOL]	-= aNfItem[nX][IT_VALSOL]
		aNfCab[NF_BICMORI]	-= aNfItem[nX][IT_BICMORI]
		aNfCab[NF_VALCMP]	-= aNfItem[nX][IT_VALCMP]
		aNfCab[NF_DIFAL]    -= aNfItem[nX][IT_DIFAL]
		aNfCab[NF_BASEIPI]	-= aNfItem[nX][IT_BASEIPI]
		aNfCab[NF_BIPIORI]	-= aNfitem[nX][IT_BIPIORI]
		aNfCab[NF_VALIPI]	-= aNfItem[nX][IT_VALIPI]
		aNfCab[NF_TOTAL]	-= aNfItem[nX][IT_TOTAL]
		aNfCab[NF_VALMERC]	-= aNfItem[nX][IT_VALMERC]-aNfItem[nX][IT_VNAGREG]
		aNfCab[NF_VNAGREG] 	-= aNfItem[nX][IT_VNAGREG]
		aNfCab[NF_FUNRURAL]	-= aNfItem[nX][IT_FUNRURAL]
		aNfCab[NF_BASEIRR]	-= aNfItem[nX][IT_BASEIRR]
		aNfCab[NF_VALIRR]	-= aNfItem[nX][IT_VALIRR]
		aNfCab[NF_BASEINS]	-= aNfItem[nX][IT_BASEINS]
		aNfCab[NF_VALINS]	-= aNfItem[nX][IT_VALINS]
		aNfCab[NF_BASEISS]	-= aNfItem[nX][IT_BASEISS]
		aNfCab[NF_VALISS]	-= aNfItem[nX][IT_VALISS]
		aNfCab[NF_BASEDUP]	-= aNfItem[nX][IT_BASEDUP]
		aNfCab[NF_DESCZF]	-= aNfItem[nX][IT_DESCZF]
		aNfCab[NF_PESO]		-= aNfItem[nX][IT_PESO]
		aNfCab[NF_ICMFRETE]	-= aNfItem[nX][IT_ICMFRETE]
		aNfCab[NF_BSFRETE]	-= aNfItem[nX][IT_BSFRETE]
		aNfCab[NF_BASEICA]	-= aNfItem[nX][IT_BASEICA]
		aNfCab[NF_VALICA]	-= aNfItem[nX][IT_VALICA]
		aNfCab[NF_BASECOF]	-= aNfItem[nX][IT_BASECOF]
		aNfCab[NF_VALCOF]	-= aNfItem[nX][IT_VALCOF]
		aNfCab[NF_BASEPIS]	-= aNfItem[nX][IT_BASEPIS]
		aNfCab[NF_VALPIS]	-= aNfItem[nX][IT_VALPIS]
		aNfCab[NF_BASEPS2]  -= aNfItem[nX][IT_BASEPS2]
		aNfCab[NF_VALPS2]   -= aNfItem[nX][IT_VALPS2]
		aNfCab[NF_BASECF2]  -= aNfItem[nX][IT_BASECF2]
		aNfCab[NF_VALCF2]   -= aNfItem[nX][IT_VALCF2]
		aNfCab[NF_BASECSL]	-= aNfItem[nX][IT_BASECSL]
		aNfCab[NF_VALCSL]	-= aNfItem[nX][IT_VALCSL]
		aNfCab[NF_BASEINA]	-= aNfItem[nX][IT_BASEINA]
		aNFCab[NF_VALINA]	-= aNfItem[nX][IT_VALINA]
		aNFCab[NF_ADIANT]	-= aNfItem[nX][IT_ADIANT]
		aNfCab[NF_DESCTOT]  -= aNfItem[nX][IT_DESCTOT]
		aNfCab[NF_ACRESCI]	-= aNfItem[nX][IT_ACRESCI]
		aNfCab[NF_VALCIDE] -= aNfItem[nX][IT_VALCIDE]
		aNfCab[NF_BASECID] -= aNfItem[nX][IT_BASECID]
		aNfCab[NF_BASECPM] -= aNfItem[nX][IT_BASECPM]
		aNfCab[NF_VALCPM] -= aNfItem[nX][IT_VALCPM]
		aNfCab[NF_IPIVFCF]  -= aNfItem[nX][IT_IPIVFCF]
		aNfCab[NF_BASEFMP] -= aNfItem[nX][IT_BASEFMP]
		aNfCab[NF_VALFMP]  -= aNfItem[nX][IT_VALFMP]
		aNfCab[NF_VALFMD]  -= aNfItem[nX][IT_VALFMD]
		aNfCab[NF_BASNDES] 	-= aNfItem[nX][IT_BASNDES]
		aNfCab[NF_ICMNDES]  	-= aNfItem[nX][IT_ICMNDES]
		If cPaisLoc == "PER" .and. aPos[FP_F1_ADIANT]
			aNfCab[NF_ADIANTTOT]-= aNfItem[nX][IT_ADIANTTOT]
		EndIf

		If cPaisLoc == "BRA" .Or. lNotRemito
			For nG := 1 To NMAXIV
				aNfCab[NF_BASEIMP][nG] -= aNfItem[nX][IT_BASEIMP][nG]
				aNfCab[NF_VALIMP][nG]  -= aNfItem[nX][IT_VALIMP][nG]
				aNfCab[NF_VLRORIG][nG] -= aNfItem[nX][IT_VALIMP][nG]
			Next nG
		EndIf
		If cPaisLoc <> "BRA" .And. (cCampo=="IT_DESCONTO" .OR. cCampo=="IT_DESCTOT") .And. (aNfCab[NF_OPERNF] =='S' .Or. (aNFitem[nX][IT_TIPONF ]$"DB" .And. Alltrim(cFunName) $ "MATA465N|MATA462DN" .And. cPaisLoc $ "MEX|PAR|PER|VEN" .And. cCampo<>"IT_TES")) .And. aSX6[MV_DESCSAI]=='1'
			aNFitem[nX][IT_VALMERC] += (aNFitem[nX][IT_DESCONTO]+aNFitem[nX][IT_DESCTOT])
			aNFitem[nX][IT_PRCUNI]  := aNFitem[nX][IT_VALMERC] / Max(aNFitem[nX][IT_QUANT],1)
		ElseIf cPaisLoc == "ARG" .And. (cCampo == "IT_QUANT" .Or. cCampo == "IT_PRCUNI") .And. Alltrim(FunName()) $ "MATA467N|MATA465N"
			If aNFitem[nX][IT_DESCONTO]+aNFitem[nX][IT_DESCTOT] <> 0
				If (cCampo == "IT_QUANT") .And. aNfCab[NF_OPERNF] =='S' .And. aSX6[MV_DESCSAI]=='1'
					aNFitem[nX][IT_PRCUNI] += ((aNFitem[nX][IT_DESCONTO]+aNFitem[nX][IT_DESCTOT])/aNFitem[nX][IT_QUANT])
				EndIf
			EndIf
		EndIf
		aNfCab[NF_ICMSDIF]	-= aNfItem[nX][IT_ICMSDIF]
		aNfCab[NF_BASEAFRMM]-= aNfItem[nX][IT_BASEAFRMM]
		aNfCab[NF_VALAFRMM] -= aNfItem[nX][IT_VALAFRMM]
		aNfCab[NF_PIS252]	-= aNfItem[nX][IT_PIS252]
		aNfCab[NF_COF252]	-= aNfItem[nX][IT_COF252]
		aNfCab[NF_BASESES]	-= aNfItem[nX][IT_BASESES]
		aNfCab[NF_VALSES]	-= aNfItem[nX][IT_VALSES]
		aNfCab[NF_BASEPS3]	-= aNfItem[nX][IT_BASEPS3]
		aNfCab[NF_VALPS3]	-= aNfItem[nX][IT_VALPS3]
		aNfCab[NF_BASECF3]	-= aNfItem[nX][IT_BASECF3]
		aNfCab[NF_VALCF3]	-= aNfItem[nX][IT_VALCF3]
		aNfCab[NF_VLR_FRT]	-= aNfItem[nX][IT_VLR_FRT]
		aNfCab[NF_VALFET]	-= aNfItem[nX][IT_VALFET]
		aNfCab[NF_VALFETR]	-= aNfItem[nX][IT_VALFETR]
		aNfCab[NF_VALFDS]	-= aNfItem[nX][IT_VALFDS]
		aNfCab[NF_ESTCRED]	-= aNfItem[nX][IT_ESTCRED]
		aNfCab[NF_BASETST]	-= aNfItem[nX][IT_BASETST]
		aNfCab[NF_VALTST]	-= aNfItem[nX][IT_VALTST]
		aNfCab[NF_CRPRSIM]	-= aNfItem[nX][IT_CRPRSIM]
		aNfCab[NF_VALANTI]	-= aNfItem[nX][IT_VALANTI]
		aNfCab[NF_DESNTRB]	-= aNfItem[nX][IT_DESNTRB]
		aNfCab[NF_TARA]		-= aNfItem[nX][IT_TARA]
		aNfCab[NF_VALFECP]	-= aNfItem[nX][IT_VALFECP]
		aNfCab[NF_VFCPDIF]	-= aNfItem[nX][IT_VFCPDIF]
		aNfCab[NF_BASEDES]	-= aNfItem[nX][IT_BASEDES]
		aNfCab[NF_VFECPST]	-= aNfItem[nX][IT_VFECPST]
		aNfCab[NF_CRDPRES]	-= aNfItem[nX][IT_CRPRESC]
		aNfCab[NF_CRDPRES]	-= aNfItem[nX][IT_CRPREMG]
		aNfCab[NF_CRDPRES]	-= aNfItem[nX][IT_CRPRECE]
		aNfCab[NF_VALII]	-= aNfItem[nX][IT_VALII]
		aNfCab[NF_CRPREPE]	-= aNfItem[nX][IT_CRPREPE]
		aNfCab[NF_VALFAB] 	-= aNfItem[nX][IT_VALFAB]
		aNfCab[NF_VALFAC] 	-= aNfItem[nX][IT_VALFAC]
		aNfCab[NF_VALFUM]	-= aNfItem[nX][IT_VALFUM]
		aNfCab[NF_VLSENAR]	-= aNfItem[nX][IT_VLSENAR]
		aNfCab[NF_CROUTSP]	-= aNfItem[nX][IT_CROUTSP]
		aNfCab[NF_BSSEMDS]	-= aNfItem[nX][IT_BSSEMDS]
		aNfCab[NF_ICSEMDS]	-= aNfItem[nX][IT_ICSEMDS]
		aNfCab[NF_BASEFUN]	-= aNfItem[nX][IT_BASEFUN]
		aNfCab[NF_VLINCMG]	-= aNfItem[nX][IT_VLINCMG]
		aNfCab[NF_TOTAL]	-= aNfItem[nX][IT_VLINCMG]
		aNfCab[NF_VFECPRN]	-= aNfItem[nX][IT_VFECPRN]
		aNfCab[NF_VFESTRN]	-= aNfItem[nX][IT_VFESTRN]
		aNfCab[NF_CREDPRE]	-= aNfItem[nX][IT_CREDPRE]
		aNfCab[NF_VFECPMG]	-= aNfItem[nX][IT_VFECPMG]
		aNfCab[NF_VFESTMG]	-= aNfItem[nX][IT_VFESTMG]
		aNfCab[NF_VREINT]	-= aNfItem[nX][IT_VREINT]
		aNfCab[NF_BSREIN]	-= aNfItem[nX][IT_BSREIN]
		aNfCab[NF_VFECPMT]	-= aNfItem[nX][IT_VFECPMT]
		aNfCab[NF_VFESTMT]	-= aNfItem[nX][IT_VFESTMT]
		aNfCab[NF_ISSABMT] 	-= aNfItem[nX][IT_ABMATISS]
		aNfCab[NF_ISSABSR]	-= aNfItem[nX][IT_ABVLISS]
		aNfCab[NF_INSABMT]	-= aNfItem[nX][IT_AVLINSS]
		aNfCab[NF_INSABSR]	-= aNfItem[nX][IT_ABVLINSS]
		aNfCab[NF_VALTPDP]  -= aNfItem[nX][IT_VALTPDP]
		aNfCab[NF_BASTPDP]  -= aNfItem[nX][IT_BASTPDP]
		aNfCab[NF_VALFUND]	-= aNfItem[nX][IT_VALFUND]
		aNfCab[NF_VALIMA]	-= aNfItem[nX][IT_VALIMA]
		aNfCab[NF_VALFASE]	-= aNfItem[nX][IT_VALFASE]
		aNfCab[NF_VLIMAR]	-= aNfItem[nX][IT_VLIMAR]
		aNfCab[NF_VLFASER]	-= aNfItem[nX][IT_VLFASER]
		aNfCab[NF_VALINP]   -= aNfItem[nX][IT_VALINP]
		aNfCab[NF_AFRMIMP]	-= aNfItem[nX][IT_AFRMIMP]
		aNfCab[NF_VALPRO]   -= aNfItem[nX][IT_VALPRO]
		aNfCab[NF_BFCPANT]  -= aNfItem[nX][IT_BFCPANT]
		aNfCab[NF_VFCPANT]  -= aNfItem[nX][IT_VFCPANT]
		aNfCab[NF_BASFECP]  -= aNfItem[nX][IT_BASFECP]
		aNfCab[NF_BSFCPST]  -= aNfItem[nX][IT_BSFCPST]
		aNfCab[NF_BSFCCMP]  -= aNfItem[nX][IT_BSFCCMP]
		
		If cPaisLoc == "BRA"
			For nTrbGen:= 1 to Len(aNfItem[nx][IT_TRIBGEN])	

				If (nPosGen := aScan(aNfCab[NF_TRIBGEN], {|x| AllTrim(x[TG_NF_SIGLA]) == AllTrim(aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_SIGLA])})) > 0
					aNfCab[NF_TRIBGEN][nPosGen][TG_NF_BASE]  -= aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_BASE]
					aNfCab[NF_TRIBGEN][nPosGen][TG_NF_VALOR] -= aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_VALOR]			

					// Quando a base e o valor forem zerados, excluo a posição do totalizador. Isso evita que o cabeçalho
					// contenha referências zeradas de tributos que podem, eventualmente, não ser calculados no item. Por
					// exemplo na hipótese de alteração de alguma referência "chave" de forma que antes eram calculados 
					// 3 tributos e depois de alterar são calculados só 2 devido ao re-enquadramento das regras.
					If aNfCab[NF_TRIBGEN][nPosGen][TG_NF_BASE] == 0 .And. aNfCab[NF_TRIBGEN][nPosGen][TG_NF_VALOR] == 0
						aDel(aNfCab[NF_TRIBGEN], nPosGen)
						aSize(aNfCab[NF_TRIBGEN], Len(aNfCab[NF_TRIBGEN])-1)
					EndIf
				EndIf

			Next nTrbGen
		EndIf

	EndIf

	//Inclui a linha para inclusao de Impostos.
	If aNfCab[NF_INSIMP]
		If aScan(aNfCab[NF_IMPOSTOS],{|x| x[6] == "NEW"  }) == 0
			aadd(aNfCab[NF_IMPOSTOS],{'...','  ',0,0,0,'NEW'})
		EndIf
		If aScan(aNfCab[NF_IMPOSTOS2],{|x| x[5] == "NEW"  }) == 0
			aadd(aNfCab[NF_IMPOSTOS2],{'...','  ',0,0,'NEW'})
		EndIf
	EndIf

	// Montagem do array NF_IMPOSTOS contando o rodape e todos os impostos calculados
	// ICMS,IPI,INSS,ICMS RETIDO,ICMS COMP,ISS,IR    Impostos Argentina,Chile,Etc
	If cPaisLoc == "BRA"

		MaFisTes(aNfItem[nX][IT_TES],aNfItem[nX][IT_RECNOSF4],nX)

		If (aNfItem[nX][IT_BASEICM]<>0 .Or. aNfItem[nX][IT_VALICM]<>0) .And. aNfItem[nX][IT_VALISS] == 0;
			.And. !((aNFCab[NF_SIMPNAC] =="1" .And. aNFItem[nX][IT_TS][TS_COMPL] == "S" .And. aNFItem[nX][IT_TS][TS_CIAP] == "S"))
			MaFisResumo(aNfItem[nX][IT_BASEICM],aNfItem[nX][IT_ALIQICM],aNfItem[nX][IT_VALICM],'ICM','ICMS','ICM',,,lSoma)
		EndIf
		IF aNfItem[nX][IT_VALCIDE] > 0
			MaFisResumo(aNfItem[nX][IT_BASECID],aNfItem[nX][IT_ALQCIDE],aNfItem[nX][IT_VALCIDE],'CID','CIDE','CID',,,lSoma)
		EndIf
		//ISSCPM
		IF aNfItem[nX][IT_VALCPM] > 0
			MaFisResumo(aNfItem[nX][IT_BASECPM],aNfItem[nX][IT_ALQCPM],aNfItem[nX][IT_VALCPM],'CPM','ISS BiTributado','CPM',,,lSoma)
		EndIf
		//FUMIPEQ
		IF aNfItem[nX][IT_VALFMP] > 0
			MaFisResumo(aNfItem[nX][IT_BASEFMP],aNfItem[nX][IT_ALQFMP],aNfItem[nX][IT_VALFMP],'FMP','FUMIPEQ','FMP',,,lSoma)
		EndIf
		If (aNfItem[nX][IT_BASEIPI]<>0 .Or. aNfItem[nX][IT_VALIPI]<>0)
			MaFisResumo(aNfItem[nX][IT_BASEIPI],aNfItem[nX][IT_ALIQIPI],aNfItem[nX][IT_VALIPI],'IPI','IPI ','IPI',,,lSoma)
		EndIf
		If aNfItem[nX][IT_BASEICA]<>0 .Or. aNfItem[nX][IT_VALICA]<>0
			MaFisResumo(aNfItem[nX][IT_BASEICA],aNfItem[nX][IT_ALIQICM],aNfItem[nX][IT_VALICA],'ICA','ICMS ref. Frete Autonomo','ICA',,,lSoma)
		EndIf
		If aNfItem[nX][IT_BASETST]<>0 .Or. aNfItem[nX][IT_VALTST]<>0
			MaFisResumo(aNfItem[nX][IT_BASETST],aNfItem[nX][IT_ALIQTST],aNfItem[nX][IT_VALTST],'TST','ICMS ref. Frete Autonomo - ST','TST',,,lSoma)
		EndIf
		If aNfItem[nX][IT_BASESOL]<>0 .Or. aNfItem[nX][IT_VALSOL]<>0
			MaFisResumo(aNfItem[nX][IT_BASESOL],aNfItem[nX][IT_ALIQSOL],aNfItem[nX][IT_VALSOL],'ICR','ICMS Retido ','SOL',,,lSoma)
		EndIf
		If aNfItem[nX][IT_VALCMP]<>0 .And. aNfItem[nX][IT_DIFAL]==0 .And. aNfItem[nX][IT_PDDES] == 0
			MaFisResumo(0,aNfItem[nX][IT_ALIQCMP],aNfItem[nX][IT_VALCMP],'ICC','ICMS Complementar ','CMP',,,lSoma)
		EndIf
		If ((aNfItem[nX][IT_BASEDES]<>0 .Or. aNfItem[nX][IT_DIFAL]<>0) .And. aNfItem[nX][IT_PDDES] > 0)
			If aNfItem[nX][IT_DIFAL]==0 .And. aNfItem[nX][IT_VFCPDIF]>0
				MaFisResumo(aNfItem[nX][IT_BASEDES],aNfItem[nX][IT_ALIQCMP],Iif(aNfCab[NF_TIPONF]=="D",aNfItem[nX][IT_DIFAL],aNfItem[nX][IT_VALCMP]),'ICC','ICMS Complementar ','CMP',.T.,.T.,lSoma)
				MaFisResumo(aNfItem[nX][IT_BASEDES],aNfItem[nX][IT_ALFCCMP],aNfItem[nX][IT_VFCPDIF],'DIF','FECP','CMP',.T.,.T.,lSoma)
			Else
				If aNfCab[NF_OPERNF]=="S"
					MaFisResumo(aNfItem[nX][IT_BASEDES],aNfItem[nX][IT_ALIQCMP],Iif(aNfCab[NF_TIPONF]=="D",aNfItem[nX][IT_DIFAL],aNfItem[nX][IT_VALCMP]),'ICC','ICMS Complementar ','CMP',.T.,.T.,lSoma)
					MaFisResumo(aNfItem[nX][IT_BASEDES],aNfItem[nX][IT_ALIQCMP]+(Iif(aNfItem[nX][IT_VFCPDIF]>0,aNfItem[nX][IT_ALFCCMP],0)),Iif(aNfCab[NF_TIPONF]=="D",aNfItem[nX][IT_VALCMP],aNfItem[nX][IT_DIFAL])+aNfItem[nX][IT_VFCPDIF],'DIF','ICMS Complementar Dest.'+(Iif(aNfItem[nX][IT_VFCPDIF]>0,' + ' + xFisNameFCP(aNFCab[NF_UFDEST], .F., .F.),'')),'CMP',.T.,.T.,lSoma)
				Else
					MaFisResumo(aNfItem[nX][IT_BASEDES],aNfItem[nX][IT_ALIQCMP],Iif(aNfCab[NF_TIPONF]=="D" .Or. (aNfCab[NF_TIPONF]=="B" .And. Iif(Type("cFormul")=="C",cFormul == "S", .F.)),aNfItem[nX][IT_VALCMP],aNfItem[nX][IT_DIFAL]),'ICC','ICMS Complementar ','CMP',.T.,.T.,lSoma)
					MaFisResumo(aNfItem[nX][IT_BASEDES],aNfItem[nX][IT_ALIQCMP]+(Iif(aNfItem[nX][IT_VFCPDIF]>0,aNfItem[nX][IT_ALFCCMP],0)),Iif(aNfCab[NF_TIPONF]=="D" .Or. (aNfCab[NF_TIPONF]=="B" .And. Iif(Type("cFormul")=="C",cFormul == "S", .F.)),aNfItem[nX][IT_DIFAL],aNfItem[nX][IT_VALCMP])+aNfItem[nX][IT_VFCPDIF],'DIF','ICMS Complementar Dest.'+(Iif(aNfItem[nX][IT_VFCPDIF]>0,' + ' + xFisNameFCP(aNFCab[NF_UFDEST], .F., .F.),'')),'CMP',.T.,.T.,lSoma)
				Endif
			EndIf
		EndIf
		If aNfItem[nX][IT_BASEISS]<>0 .Or. aNfItem[nX][IT_VALISS]<>0
			MaFisResumo(aNfItem[nX][IT_BASEISS],aNfItem[nX][IT_ALIQISS],aNfItem[nX][IT_VALISS],'ISS','ISS Imposto sobre servico ','ISS',,,lSoma)
		EndIf
		If aNfItem[nX][IT_BASEIRR]<>0 .Or. aNfItem[nX][IT_VALIRR]<>0
			MaFisResumo(aNfItem[nX][IT_BASEIRR],aNfItem[nX][IT_ALIQIRR],aNfItem[nX][IT_VALIRR],'IRR','IRRF Imposto de renda ','IRR',,,lSoma)
		EndIf
				
		If aNfItem[nX][IT_BASEINS]<>0 .Or. aNfItem[nX][IT_VALINS]<>0
			MaFisResumo(aNfItem[nX][IT_BASEINS],aNfItem[nX][IT_ALIQINS],aNfItem[nX][IT_VALINS],'INS','INSS ','INS',,,lSoma)
		EndIf		
		
		If aNfItem[nX][IT_BASEPIS]<>0 .Or. aNfItem[nX][IT_VALPIS]<>0
			MaFisResumo(aNfItem[nX][IT_BASEPIS],aNfItem[nX][IT_ALIQPIS],aNfItem[nX][IT_VALPIS],'PIS','PIS - Via Retençao','PIS',.T.,.T.,lSoma)
		EndIf
		If aNfItem[nX][IT_BASECOF]<>0 .Or. aNfItem[nX][IT_VALCOF]<>0
			MaFisResumo(aNfItem[nX][IT_BASECOF],aNfItem[nX][IT_ALIQCOF],aNfItem[nX][IT_VALCOF],'COF','COFINS - Via Retenção','COF',.T.,.T.,lSoma)
		EndIf
		If aNfItem[nX][IT_BASECSL]<>0 .Or. aNfItem[nX][IT_VALCSL]<>0
			MaFisResumo(aNfItem[nX][IT_BASECSL],aNfItem[nX][IT_ALIQCSL],aNfItem[nX][IT_VALCSL],'CSL','CSLL - Via Retenção','CSL',.T.,.T.,lSoma)
		EndIf
		If aNfItem[nX][IT_BASEFUN]<>0 .Or. aNfItem[nX][IT_FUNRURAL]<>0
			MaFisResumo(aNfItem[nX][IT_BASEFUN],aNfItem[nX][IT_PERFUN],aNfItem[nX][IT_FUNRURAL],'FRU','GILRAT ','RUR',.T.,.T.,lSoma)
		EndIf
		If (aNfItem[nX,IT_BASEPS2]<>0 .Or. aNfItem[nX,IT_VALPS2]<>0) .And. (aNFCab[NF_CLIFOR] =="F" .And. aNFCab[NF_TPCLIFOR] =="X" .And. Substr(aNfItem[nX,IT_CF],1,1)=="3" .And. aNFItem[nX][IT_TS][TS_INTBSIC]$"123")
			MaFisResumo(aNfItem[nX,IT_BASEPS2],aNfItem[nX,IT_ALIQPS2],aNfItem[nX,IT_VALPS2],'PS2',Iif(aNFItem[nX][IT_TS][TS_ALQPMAJ]>0,'PIS - Importacao + Majorada','PIS - Importacao'),'PS2',,,lSoma)
		ElseIf (aNfItem[nX,IT_BASEPS2]<>0 .Or. aNfItem[nX,IT_VALPS2]<>0) .And.;
			((aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_CLIFOR] =="F" .And. aNFCab[NF_TPCLIFOR] =="X" .And. Substr(aNfItem[nX,IT_CF],1,1)=="3" .And. aNFItem[nX][IT_TS][TS_INTBSIC]$"123") .Or.;
			(aNFCab[NF_OPERNF] == "S" .And. aNFCab[NF_CLIFOR] =="F" .And. aNFCab[NF_TPCLIFOR] =="X" .And. Substr(aNfItem[nX,IT_CF],1,1)=="7" .And. aNFItem[nX][IT_TS][TS_INTBSIC]$"123"))
			MaFisResumo(aNfItem[nX,IT_BASEPS2],aNfItem[nX,IT_ALIQPS2],aNfItem[nX,IT_VALPS2],'PS2','PIS/Pasep - Importacao','PS2',,,lSoma)
		ElseIf aNfItem[nX,IT_BASEPS2]<>0 .Or. aNfItem[nX,IT_VALPS2]<>0
			MaFisResumo(aNfItem[nX,IT_BASEPS2],aNfItem[nX,IT_ALIQPS2],aNfItem[nX,IT_VALPS2],'PS2','PIS/Pasep - Via apuracao','PS2',,,lSoma)
		EndIf
		If (aNfItem[nX,IT_BASECF2]<>0 .Or. aNfItem[nX,IT_VALCF2]<>0) .And. (aNFCab[NF_CLIFOR] =="F" .And. aNFCab[NF_TPCLIFOR] =="X" .And. Substr(aNfItem[nX,IT_CF],1,1)=="3" .And. aNFItem[nX][IT_TS][TS_INTBSIC]$"123")
			MaFisResumo(aNfItem[nX,IT_BASECF2],aNfItem[nX,IT_ALIQCF2],aNfItem[nX,IT_VALCF2],'CF2',Iif(aNFItem[nX][IT_TS][TS_ALQCMAJ]>0,'COFINS - Importacao + Majorada','COFINS - Importacao'),'CF2',,,lSoma)
		ElseIf (aNfItem[nX,IT_BASECF2]<>0 .Or. aNfItem[nX,IT_VALCF2]<>0) .And.;
			((aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_CLIFOR] =="F" .And. aNFCab[NF_TPCLIFOR] =="X" .And. Substr(aNfItem[nX,IT_CF],1,1)=="3" .And. aNFItem[nX][IT_TS][TS_INTBSIC]$"123") .Or.;
			(aNFCab[NF_OPERNF] == "S" .And. aNFCab[NF_CLIFOR] =="F" .And. aNFCab[NF_TPCLIFOR] =="X" .And. Substr(aNfItem[nX,IT_CF],1,1)=="7" .And. aNFItem[nX][IT_TS][TS_INTBSIC]$"123"))
			MaFisResumo(aNfItem[nX,IT_BASECF2],aNfItem[nX,IT_ALIQCF2],aNfItem[nX,IT_VALCF2],'CF2','COFINS - Importacao','CF2',,,lSoma)
		ElseIf aNfItem[nX,IT_BASECF2]<>0 .Or. aNfItem[nX,IT_VALCF2]<>0
			MaFisResumo(aNfItem[nX,IT_BASECF2],aNfItem[nX,IT_ALIQCF2],aNfItem[nX,IT_VALCF2],'CF2','COFINS - Via apuracao','CF2',,,lSoma)
		EndIf
		If aNfItem[nx][IT_BASEAFRMM]<>0 .Or. aNfItem[nx][IT_VALAFRMM]<>0
			MaFisResumo(aNfItem[nx][IT_BASEAFRMM],aNfItem[nx][IT_ALIQAFRMM],aNfItem[nx][IT_VALAFRMM],'AFRMM','AFRMM','AFRMM',,,lSoma)
		EndIf
		If aNfItem[nX][IT_BASESES]<>0 .Or. aNfItem[nX][IT_VALSES]<>0
			MaFisResumo(aNfItem[nX][IT_BASESES],aNfItem[nX][IT_ALIQSES],aNfItem[nX][IT_VALSES],'SES','SEST/SENAT','SES',,,lSoma)
		EndIf
		If aNfItem[nx][IT_BASEPS3]<>0 .Or. aNfItem[nx][IT_VALPS3]<>0
			MaFisResumo(aNfItem[nx][IT_BASEPS3],aNfItem[nx][IT_ALIQPS3],aNfItem[nx][IT_VALPS3],'PS3','PIS/Pasep - Subst. Tributaria','PS3',,,lSoma)
		EndIf
		If aNfItem[nx][IT_BASECF3]<>0 .Or. aNfItem[nx][IT_VALCF3]<>0
			MaFisResumo(aNfItem[nx][IT_BASECF3],aNfItem[nx][IT_ALIQCF3],aNfItem[nx][IT_VALCF3],'CF3','COFINS - Subst. Tributaria','CF3',,,lSoma)
		EndIf
		If aPos[FP_B1_AFETHAB] .And. aPos[FP_A2_RECFET] .And. aPos[FP_A1_RECFET] .And. aPos[FP_F4_CALCFET]
			If aNfItem[nx][IT_BASEFET]<>0 .Or. aNfItem[nx][IT_VALFET]<>0
				MaFisResumo(aNfItem[nx][IT_BASEFET],aNfItem[nx][IT_ALIQFET],aNfItem[nx][IT_VALFET],'FET','FETHAB','FET',.T.,.T.,lSoma)
			Endif
		EndIf
		If aPos[FP_B1_AFABOV] .And. aPos[FP_A2_RFABOV] .And. aPos[FP_A1_RFABOV] .And. aPos[FP_F4_CFABOV]
			If aNfItem[nx][IT_BASEFAB]<>0 .Or. aNfItem[nx][IT_VALFAB]<>0
				MaFisResumo(aNfItem[nx][IT_BASEFAB],aNfItem[nx][IT_ALIQFAB],aNfItem[nx][IT_VALFAB],'FAB','FABOV','FAB',.T.,.T.,lSoma)
			Endif
		EndIf
		If aPos[FP_B1_ALFUMAC]
			If aNfItem[nx][IT_BASEFUM]<>0 .And. aNfItem[nx][IT_VALFUM]<>0
				MaFisResumo(aNfItem[nx][IT_BASEFUM],aNfItem[nx][IT_ALIQFUM],aNfItem[nx][IT_VALFUM],'FUM','FUMACOP','FUM',.T.,.T.,lSoma)
			Endif
		EndIf
		If aPos[FP_B1_AFACS] .And. aPos[FP_A2_RFACS] .And. aPos[FP_A1_RFACS] .And. aPos[FP_F4_CFACS]
			If aNfItem[nx][IT_BASEFAC]<>0 .Or. aNfItem[nx][IT_VALFAC]<>0
				MaFisResumo(aNfItem[nx][IT_BASEFAC],aNfItem[nx][IT_ALIQFAC],aNfItem[nx][IT_VALFAC],'FAC','FACS','FAC',.T.,.T.,lSoma)
			Endif
		EndIf
		IF aNfItem[nX][IT_VALFMD] > 0
			MaFisResumo(aNfItem[nX][IT_BASEFMD],aNfItem[nX][IT_ALQFMD],aNfItem[nX][IT_VALFMD],'FMD','FAMAD','FMD',,,lSoma)
		EndIf
		If aNfItem[nX][IT_VALFDS] > 0
			MaFisResumo(0,0,aNfItem[nX][IT_VALFDS],'FDS','FUNDERSUL','FDS',.T.,.T.,lSoma)
		EndIf
		If aNfItem[nX][IT_BSSENAR]<>0 .Or. aNfItem[nX][IT_VLSENAR]<>0
			MaFisResumo(aNfItem[nX][IT_BSSENAR],aNfItem[nX][IT_ALSENAR],aNfItem[nX][IT_VLSENAR],'SENAR','SENAR','SENAR',.T.,.T.,lSoma)
		Endif
		If aSX6[MV_ALITPDP] > 0 .And. aNfCab[NF_BASTPDP] >= 100
			If aNfItem[nX][IT_BASTPDP] <> 0 .And. aNfItem[nX][IT_VALTPDP] <> 0 .And. nX == Len(aNfItem)
				MaFisResumo(aNfCab[NF_BASTPDP],aNfItem[nX][IT_ALITPDP],aNfCab[NF_VALTPDP],'TPD','TPDP-PB','TPDP',.T.,.T.,lSoma)
			Endif
		EndIf
		IF aNfItem[nX][IT_VALCPB] > 0
			MaFisResumo(aNfItem[nX][IT_BASECPB],aNfItem[nX][IT_ALIQCPB],aNfItem[nX][IT_VALCPB],'CPB','CPRB','CPB',.T.,.T.,lSoma)
		EndIf
		If aPos[FP_B1_AFUNDES] .And. aPos[FP_F4_CFUNDES]
			If aNfItem[nx][IT_BASFUND]<>0 .Or. aNfItem[nx][IT_VALFUND]<>0
				MaFisResumo(aNfItem[nx][IT_BASFUND],aNfItem[nx][IT_ALIFUND],aNfItem[nx][IT_VALFUND],'FUN','FUNDESA','FUN',.T.,.T.,lSoma)
			Endif
		EndIf
		If aPos[FP_B1_AIMAMT] .And. aPos[FP_A2_RIMAMT] .And. aPos[FP_A1_RIMAMT] .And. aPos[FP_F4_CIMAMT]
			If aNfItem[nx][IT_BASIMA]<>0 .Or. aNfItem[nx][IT_VALIMA]<>0
				MaFisResumo(aNfItem[nx][IT_BASIMA],aNfItem[nx][IT_ALIIMA],aNfItem[nx][IT_VALIMA],'IMA','IMA-MT','IMA',.T.,.T.,lSoma)
			Endif
		EndIf
		If aPos[FP_B1_AFASEMT] .And. aPos[FP_A2_RFASEMT] .And. aPos[FP_A1_RFASEMT] .And. aPos[FP_F4_CFASE]
			If aNfItem[nx][IT_BASFASE]<>0 .Or. aNfItem[nx][IT_VALFASE]<>0
				MaFisResumo(aNfItem[nx][IT_BASFASE],aNfItem[nx][IT_ALIFASE],aNfItem[nx][IT_VALFASE],'FAS','FASE-MT','FAS',.T.,.T.,lSoma)
			Endif
		EndIf
		IF aNfItem[nX][IT_VALINP] > 0
			MaFisResumo(aNfItem[nX][IT_BASEINP],aNfItem[nX][IT_PERCINP],aNfItem[nX][IT_VALINP],'INP','INSS-Patronal','INP',.T.,.T.,lSoma)
		EndIf
		IF aNfItem[nX][IT_VALPRO] > 0
			MaFisResumo(aNfItem[nX][IT_BASEPRO],aNfItem[nX][IT_ALIQPRO],aNfItem[nX][IT_VALPRO],'PTG','PROTEGE-GO','PTG',.T.,.T.,lSoma)
		EndIf
		// Exibe os valores de ICMS,PIS e COFINS descontados do documento nas operacoes com ZFM/ALC.
		// Atencao: NUNCA habilitar estes campos p/ edicao no folder "Impostos".
		If aNfCab[NF_SUFRAMA] .And. aSX6[MV_DESCZF]
			If (aNfItem[nX][IT_DESCZF] - (aNfItem[nX][IT_DESCZFPIS] + aNfItem[nX][IT_DESCZFCOF])) > 0
				MaFisResumo(0,0,aNfItem[nX][IT_DESCZF] - (aNfItem[nX][IT_DESCZFPIS] + aNfItem[nX][IT_DESCZFCOF]),'ZFI','ICMS Desonerado - ZFM','ZFI',.T.,.T.,lSoma)
			EndIf
			If aNfItem[nX][IT_DESCZFPIS] > 0
				MaFisResumo(0,0,aNfItem[nX][IT_DESCZFPIS],'ZFP','PIS Desonerado - ZFM','ZFP',.T.,.T.,lSoma)
			EndIf
			If aNfItem[nX][IT_DESCZFCOF] > 0
				MaFisResumo(0,0,aNfItem[nX][IT_DESCZFCOF],'ZFC','COFINS Desonerado - ZFM','ZFC',.T.,.T.,lSoma)
			EndIf
		EndIf
		//Valido a existencia dos novos campos de base de calculo para que nao sejam exibidos
		//os valores 'segregados' de FCP de NF's emitidas anteriormente à criacao destes campos. A ideia
		//eh manter o sistema exatamente como ele trabalhava antes da NF-e 4.0 e soh demonstrar os valores
		//separadamente em NF's emitidas apos a implementacao da NF-e / atualizacao do dicionario.

		If aPos[FP_FT_BASFECP] .And. aPos[FP_FT_BSFCPST] .And. aPos[FP_FT_BSFCCMP]

			// Nas devoluções considerar o FCP da UF de origem do documento.
			cUFFCP := IIf(aNFCab[NF_TIPONF] $ "DB", aNfCab[NF_UFORIGEM], aNFCab[NF_UFDEST])

			// FCP Proprio.
			If aNfItem[nX][IT_BASFECP] > 0 .And. (aNfItem[nX][IT_ALIQFECP] > 0 .Or. aNfItem[nX][IT_FCPAUX] > 0) .And. aNfItem[nX][IT_VALFECP] > 0
				MaFisResumo(aNfItem[nX][IT_BASFECP],IIf(aNfItem[nX][IT_FCPAUX] > 0, aNfItem[nX][IT_FCPAUX], aNfItem[nX][IT_ALIQFECP]),aNfItem[nX][IT_VALFECP],'FCP',xFisNameFCP(cUFFCP, .F., .F.),'FCP',.T.,.T.,lSoma)
			EndIf

			// FCP Complementar (Diferencial de Aliquotas - Entrada)
			If aNfItem[nX][IT_BSFCCMP] > 0 .And. (aNfItem[nX][IT_ALFCCMP] > 0 .Or. aNfItem[nX][IT_FCPAUX] > 0) .And. aNfItem[nX][IT_VALFECP] > 0
				MaFisResumo(aNfItem[nX][IT_BSFCCMP],IIf(aNfItem[nX][IT_FCPAUX] > 0, aNfItem[nX][IT_FCPAUX], aNfItem[nX][IT_ALFCCMP]),aNfItem[nX][IT_VALFECP],'FCM',xFisNameFCP(cUFFCP, .F., .T.),'FCM',.T.,.T.,lSoma)
			EndIf

			// FCP ST
			If aNfItem[nX][IT_BSFCPST] > 0 .And. (aNfItem[nX][IT_ALFCST] > 0 .Or. aNfItem[nX][IT_FCPAUX] > 0) .And. aNfItem[nX][IT_VFECPST] > 0
				MaFisResumo(aNfItem[nX][IT_BSFCPST],IIf(aNfItem[nX][IT_FCPAUX] > 0, aNfItem[nX][IT_FCPAUX], aNfItem[nX][IT_ALFCST]),aNfItem[nX][IT_VFECPST],'FST',xFisNameFCP(cUFFCP, .T., .F.),'FST',.T.,.T.,lSoma)
			EndIf

			// FCP Complementar (Diferencial de Aliquotas - Saida)
			If aNfItem[nX][IT_BSFCCMP] > 0 .And. (aNfItem[nX][IT_ALFCCMP] > 0 .Or. aNfItem[nX][IT_FCPAUX] > 0) .And. aNfItem[nX][IT_VFCPDIF] > 0
				MaFisResumo(aNfItem[nX][IT_BSFCCMP],IIf(aNfItem[nX][IT_FCPAUX] > 0, aNfItem[nX][IT_FCPAUX], aNfItem[nX][IT_ALFCCMP]),aNfItem[nX][IT_VFCPDIF],'FCM',xFisNameFCP(cUFFCP, .F., .T.),'FCM',.T.,.T.,lSoma)
			EndIf

		EndIf
		//FEEF -RJ
		If aNfItem[nX][IT_BASFEEF] > 0 .and. aNfItem[nX][IT_VALFEEF] > 0			
			MaFisResumo(aNfItem[nX][IT_BASFEEF],aNfItem[nX][IT_ALQFEEF],aNfItem[nX][IT_VALFEEF],'FEEF','FEEF - Fundo Est. Equilíbrio Fiscal','FEEF',.T.,.T.,lSoma)
		Endif 

		//Aqui faço laço nos tributos genéricos, para chamar a MaFisResumo		
		If cPaisLoc == "BRA"
			For nTrbGen:= 1 to Len(aNfItem[nx][IT_TRIBGEN])
				
				cSiglaGen	:= aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_SIGLA]
				cDescriGen  := aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_DESCRICAO]
				nBaseGen	:= aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_BASE]
				nAlqGen		:= aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_ALIQUOTA]
				nValGen		:= aNfItem[nX][IT_TRIBGEN][nTrbGen][TG_IT_VALOR]

				//Se o tributo genérico possuir base ou valor chamarei a Resumo
				If nBaseGen > 0 .And. nValGen > 0				
					MaFisResumo(nBaseGen,nAlqGen,nValGen,cSiglaGen,cDescriGen,'TG',.T.,.T.,lSoma)
				EndIF

			Next nTrbGen
		EndIf
	Endif

	If cPaisLoc == "BRA" .Or. lNotRemito
		For nG := 1 To NMAXIV
			If aNfItem[nX][IT_BASEIMP][nG]<>0 .Or. aNfItem[nX][IT_VALIMP][nG]<>0
				MaFisResumo(aNfItem[nX][IT_BASEIMP][nG],aNfItem[nX][IT_ALIQIMP][nG],aNfItem[nX][IT_VALIMP][nG],aNfItem[nX][IT_DESCIV][nG][1],aNfItem[nX][IT_DESCIV][nG][2],"IV"+NumCpoImpVar(nG),,,lSoma)
			EndIf
		Next nG

		MaFisLFToLivro(nX,@aAuxOri,lSoma)

	EndIf

	If !lSoma // Executa a correcao nos arredondamentos.
		For nY := 1 to Len(aItemRef)
			If aItemRef[nY][4]
				If !aItemRef[nY][5]
					If ValType(aItemRef[nY][2]) == "A"
						aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] += aItemDec[nX][2][nY]
						aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] -= aItemDec[nX][1][nY]
					Else
						aNfItem[nX][Val(aItemRef[nY][2])] += aItemDec[nX][2][nY]
						aNfItem[nX][Val(aItemRef[nY][2])] -= aItemDec[nX][1][nY]
					EndIf
					aSaveDec[nY] += aItemDec[nX][1][nY]
					aSaveDec[nY] -= aItemDec[nX][2][nY]
				Else
					If ValType(aItemRef[nY][2]) == "A"
						aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] -= aItemDec[nX][2][nY]
						aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] += aItemDec[nX][1][nY]
					Else
						aNfItem[nX][Val(aItemRef[nY][2])] -= aItemDec[nX][2][nY]
						aNfItem[nX][Val(aItemRef[nY][2])] += aItemDec[nX][1][nY]
					EndIf
					If !(!Empty(cCampo) .And. cCampo == aItemRef[nY][1])
						aSaveDec[nY] += aItemDec[nX][1][nY]
						aSaveDec[nY] -= aItemDec[nX][2][nY]
					EndIf
				EndIf
				aItemDec[nX][1][nY]:= 0
				aItemDec[nX][2][nY]:= 0
			EndIf
		Next nY
	EndIf

	If aPE[PE_MXTOTIT]
		// PE para manipulação dos valores das referencias (em uso na importação TSF)
		// nesse ponto passa 0 para aplicar regra somente para o cabecalho
		ExecBlock("MXTOTIT",.F.,.F.,{0})
	EndIf

EndIf

Return

/*/
MaFisResum - Edson Maricate -13.12.1999
Atualiza o Array de Resumos da NF.
/*/
Static Function MaFisResumo(nValBase,nAliquota,nValor,cCodImp,cDescImp,cNomeRef,lForceVlr,lForceBs,lSoma)
Local nRS  := 0
Local nRS2 := 0

DEFAULT lForceVlr := .F.
DEFAULT lForceBs  := .F.
DEFAULT lSoma	  := .T.

If Empty(cCodImp)
	Return	.F.
Endif

If !Empty(aNfCab[NF_IMPOSTOS]) .And. aNfCab[NF_IMPOSTOS][1][1] == ""
	aNfCab[NF_IMPOSTOS] := {}
	aNfCab[NF_IMPOSTOS2]:= {}
Else
	nRS	:= aScan(aNfCab[NF_IMPOSTOS] ,{|x| x[IMP_COD] == cCodImp .And. x[IMP_ALIQ] == nAliquota })
	nRS2:= aScan(aNfCab[NF_IMPOSTOS2],{|x| x[IMP_COD] == cCodImp })
EndIf

If aNfCab[NF_RELIMP] <> Nil .And. !Empty(aNfCab[NF_RELIMP])
	nValBase := IIf( aScan(aNfCab[NF_RELIMP] , {|x|"BASE" + cNomeRef $ x[3] } ) > 0 .Or. lForceBs  , nValBase , 0 )
	nValor	 := IIf( aScan(aNfCab[NF_RELIMP] , {|x|"VAL"  + cNomeRef $ x[3] } ) > 0 .Or. lForceVlr , nValor   , 0 )
EndIf

If cPaisLoc == "CHI" .And. aSX6[MV_PRCDEC]
	aNfCab[NF_TOTAL]   := Round(aNfCab[NF_TOTAL]   , MsDecimais(aNFCab[NF_MOEDA]))
	aNfCab[NF_VALMERC] := Round(aNfCab[NF_VALMERC] , MsDecimais(aNFCab[NF_MOEDA]))
	aNfCab[NF_BASEDUP] := Round(aNfCab[NF_BASEDUP] , MsDecimais(aNFCab[NF_MOEDA]))
	nValor   		   := Round(nValor             , MsDecimais(aNFCab[NF_MOEDA]))
ElseIf cPaisLoc == "ANG" .And. aSX6[MV_RNDANG] //Arredondamento do valor total da nota de acordo com MV_RNDANG para localizado Angola
	aNfCab[NF_TOTAL]   := int(aNfCab[NF_TOTAL]  ) + IIf( aNfCab[NF_TOTAL]   - int(aNfCab[NF_TOTAL]  )  >= 0.01 , 1.0 , 0.0 )
	aNfCab[NF_BASEDUP] := int(aNfCab[NF_BASEDUP]) + IIf( aNfCab[NF_BASEDUP] - int(aNfCab[NF_BASEDUP])  >= 0.01 , 1.0 , 0.0 )
EndIf

If lSoma

	If nRS > 0
		aNfCab[NF_IMPOSTOS][nRS][IMP_BASE] 	+= nValBase
		aNfCab[NF_IMPOSTOS][nRS][IMP_VAL]  	+= nValor
	Else
		aadd(aNfCab[NF_IMPOSTOS],{cCodImp,cDescImp,nValBase,nAliquota,nValor,cNomeRef})
	EndIf

	If nRS2 > 0
		If cPaisLoc $ "CHI" .And. aSX6[MV_PRCDEC]
			aNfCab[NF_IMPOSTOS2][nRS2][3] 	+= Round(nValBase,MsDecimais(aNFCab[NF_MOEDA]))
			aNfCab[NF_IMPOSTOS2][nRS2][4] 	+= Round(nValor,MsDecimais(aNFCab[NF_MOEDA]))
		Else
			aNfCab[NF_IMPOSTOS2][nRS2][3] 	+= nValBase
			aNfCab[NF_IMPOSTOS2][nRS2][4] 	+= nValor
		EndIf
	Else
		If cPaisLoc == "CHI" .And. aSX6[MV_PRCDEC]
			aadd(aNfCab[NF_IMPOSTOS2],{cCodImp,cDescImp,Round(nValBase,MsDecimais(aNFCab[NF_MOEDA])),Round(nValor,MsDecimais(aNFCab[NF_MOEDA])),cNomeRef})
		Else
			aadd(aNfCab[NF_IMPOSTOS2],{cCodImp,cDescImp,nValBase,nValor,cNomeRef})
		EndIf
	EndIf

Else

	If nRS > 0
		aNfCab[NF_IMPOSTOS][nRS][IMP_BASE] 	-= nValBase
		aNfCab[NF_IMPOSTOS][nRS][IMP_VAL]  	-= nValor
		If  aNfCab[NF_IMPOSTOS][nRS][IMP_BASE] <= 0 .And. aNfCab[NF_IMPOSTOS][nRS][IMP_VAL] <= 0
			aDel(aNfCab[NF_IMPOSTOS],nRS)
			aSize(aNfCab[NF_IMPOSTOS],Len(aNfCab[NF_IMPOSTOS])-1)
		EndIf
	EndIf

	If nRS2 > 0
		aNfCab[NF_IMPOSTOS2][nRS2][3] 	-= nValBase
		aNfCab[NF_IMPOSTOS2][nRS2][4] 	-= nValor
		If  aNfCab[NF_IMPOSTOS2][nRS2][3] <= 0 .And. aNfCab[NF_IMPOSTOS2][nRS2][4] <= 0
			aDel(aNfCab[NF_IMPOSTOS2],nRS2)
			aSize(aNfCab[NF_IMPOSTOS2],Len(aNfCab[NF_IMPOSTOS2])-1)
		EndIf
	EndIf

EndIf

Return .T.

/*
MaFisLFToLivro - Edson Maricate - 07.03.2000
Adiciona o item nos livros fiscais
*/
Static Function MaFisLFToLivro(nItem,aNotasOri,lSoma)
Local alAreaX  := {}
Local aGetBook := {}
Local aSFB     := {}
Local aSFC     := {}
Local aSF4     := {}

Local cAux     := ""
Local cIdent   := ""
Local cNFOri   := ""
Local cObs     := ""

Local nLF      := 0
Local nY       := 0
Local nX       := 0
Local nS	   := 0

Local dDataEmi := dDataBase

Local lImport  := Type("lFacImport") == "L" .And. lFacImport
Local lFildPSWN:= aPos[FP_WN_TES] .And. aPos[FP_WN_ITEMNF]
Local lAchouWN := .F.
Local nPosTESM	:= 0

DEFAULT lSoma  := .T.

If aNfItem[nItem][IT_TES] <> aTes[TS_CODIGO]
	If cPaisLoc == "ARG"
		If Type("aTesMXF") <> "U"
			nPosTESM := Ascan(aTesMXF,{|X| X[1] == nItem})
		EndIf
		If nPosTESM > 0
			aTes := aClone(aTesMXF[nPosTESM][2])
		Else
			MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
			If Type("aTesMXF") <> "U" .and. nPosTESM == 0
				AADD(aTesMXF,{nItem,aClone(aTes)})
			EndIf
		EndIf
	Else
		MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
	EndIf
EndIf

//Montagem dos Livros Fiscals ( aLivro )
If cPaisLoc == "BRA"
	If 	aNfItem[nItem][IT_LIVRO][3] +;
		aNfItem[nItem][IT_LIVRO][4] +;
		aNfItem[nItem][IT_LIVRO][5] +;
		aNfItem[nItem][IT_LIVRO][6] +;
		aNfItem[nItem][IT_LIVRO][7] +;
		aNfItem[nItem][IT_LIVRO][9] +;
		aNfItem[nItem][IT_LIVRO][10]+;
		aNfItem[nItem][IT_LIVRO][11]+;
		aNfItem[nItem][IT_LIVRO][27]+;
		aNfItem[nItem][IT_LIVRO][131] <> 0 .Or. !Empty(aNfItem[nItem][IT_LIVRO][24])

		If aNfItem[nItem][IT_CALCISS] == "S"
			nLF	:= aScan(aNfCab[NF_LIVRO],{|x|x[LF_CFO] == aNfItem[nItem][IT_LIVRO][LF_CFO] .And. ;
			x[LF_CODISS]  == aNfItem[nItem][IT_LIVRO][LF_CODISS]  .And. ;
			x[LF_ALIQICMS]== aNfItem[nItem][IT_LIVRO][LF_ALIQICMS].And. ;
			x[LF_NFLIVRO] == aNfItem[nItem][IT_LIVRO][LF_NFLIVRO] .And. ;
			x[LF_FORMULA] == aNfItem[nItem][IT_LIVRO][LF_FORMULA] .And. ;
			x[LF_ANTICMS] == aNfItem[nItem][IT_LIVRO][LF_ANTICMS] .And. ;
			x[LF_CFPS]    == aNfItem[nItem][IT_LIVRO][LF_CFPS]})
		Else
			nLF	:= aScan(aNfCab[NF_LIVRO],{|x|x[LF_CFO] == aNfItem[nItem][IT_LIVRO][LF_CFO] .And. ;
			x[LF_CFOEXT]  == aNfItem[nItem][IT_LIVRO][LF_CFOEXT]  .And. ;
			x[LF_ALIQICMS]== aNfItem[nItem][IT_LIVRO][LF_ALIQICMS].And. ;
			x[LF_NFLIVRO] == aNfItem[nItem][IT_LIVRO][LF_NFLIVRO] .And. ;
			x[LF_FORMULA] == aNfItem[nItem][IT_LIVRO][LF_FORMULA] .And. ;
			x[LF_CODISS]  == aNfItem[nItem][IT_LIVRO][LF_CODISS]  .And. ;
			x[LF_ANTICMS] == aNfItem[nItem][IT_LIVRO][LF_ANTICMS] .And. ;
			x[LF_CREDACU] == aNfItem[nItem][IT_LIVRO][LF_CREDACU] .And. ;
			x[LF_CFPS]    == aNfItem[nItem][IT_LIVRO][LF_CFPS]})
		EndIf

		cIdent := StrZero(nLF,6)

		If nLF == 0

			aNotasOri := {}
			aadd( aNfCab[NF_LIVRO] , MaFisRetLF() )
			nLF	:= Len(aNfCab[NF_LIVRO])

			aNfCab[NF_LIVRO][nLF][LF_CFO]     := aNfItem[nItem][IT_LIVRO][LF_CFO]
			aNfCab[NF_LIVRO][nLF][LF_CFOEXT]  := aNfItem[nItem][IT_LIVRO][LF_CFOEXT]
			aNfCab[NF_LIVRO][nLF][LF_ALIQICMS]:= aNfItem[nItem][IT_LIVRO][LF_ALIQICMS]
			aNfCab[NF_LIVRO][nLF][LF_NFLIVRO] := aNfItem[nItem][IT_LIVRO][LF_NFLIVRO]
			aNfCab[NF_LIVRO][nLF][LF_FORMULA] := aNfItem[nItem][IT_LIVRO][LF_FORMULA]
			aNfCab[NF_LIVRO][nLF][LF_TIPO]    := aNfItem[nItem][IT_LIVRO][LF_TIPO]
			aNfCab[NF_LIVRO][nLF][LF_CODISS]  := aNfItem[nItem][IT_LIVRO][LF_CODISS]
			aNfCab[NF_LIVRO][nLF][LF_FORMUL]  := aNfItem[nItem][IT_LIVRO][LF_FORMUL]
			aNfCab[NF_LIVRO][nLF][LF_ISSST]   := aNfItem[nItem][IT_LIVRO][LF_ISSST]
			aNfCab[NF_LIVRO][nLF][LF_RECISS]  := aNfItem[nItem][IT_LIVRO][LF_RECISS]
			aNfcab[NF_LIVRO][nLF][LF_CREDST]  := aNfItem[nItem][IT_LIVRO][LF_CREDST]
			aNfcab[NF_LIVRO][nLF][LF_CNAE]    := aNfItem[nItem][IT_LIVRO][LF_CNAE]
			aNfcab[NF_LIVRO][nLF][LF_TRIBMU]  := aNfItem[nItem][IT_LIVRO][LF_TRIBMU]

			//  Inconsistencia descoberta no SIGALOJA quanto utiliza-se
			//  MAFISALT depois de carregar todos os itens do cupom, onde necessita-se
			//  alterar centavos para manter o calculo da impressora igual ao do sistema.
			//  Esta condicao determina que o codigo indentificador de relacionamento ??_IDENT
			//  seja reutilizado do IT_ para o NF_ depois de ter passado pelo aDEL abaixo, onde
			//  exclui o indice do array que possui os valores zerados, porem nao exluir do aNFITEM
			//  O retorno do codigo identificador foi implementado pelo For/Next de nX abaixo
			If IsInCallStack("LJXCONFICM") .And. aScan(aNfcab[NF_LIVRO] , {|x| Alltrim(x[LF_IDENT]) == StrZero(nLF,6)}) > 0 //SIGALOJA
				For nX := 1 To Len(aNfcab[NF_LIVRO]) + 1
					If aScan(aNfcab[NF_LIVRO], {|x| x[LF_IDENT] == StrZero(nX,6)}) == 0
						Exit
					EndIf
				Next nX
				aNfcab[NF_LIVRO][nLF][LF_IDENT]:= StrZero(nX,6)
			Else
				aNfcab[NF_LIVRO][nLF][LF_IDENT]:= StrZero(nLF,6)
			EndIf

			cIdent := aNfcab[NF_LIVRO][nLF][LF_IDENT]

			aNfCab[NF_LIVRO][nLF][LF_CFPS]   := aNfItem[nItem][IT_LIVRO][LF_CFPS]
			aNfCab[NF_LIVRO][nLF][LF_ALIQIPI]:= aNfItem[nItem][IT_LIVRO][LF_ALIQIPI]
			aNfCab[NF_LIVRO][nLF][LF_ALIQCF3]:= aNfItem[nItem][IT_LIVRO][LF_ALIQCF3]
			aNfCab[NF_LIVRO][nLF][LF_ALIQPS3]:= aNfItem[nItem][IT_LIVRO][LF_ALIQPS3]
			aNfCab[NF_LIVRO][nLF][LF_ANTICMS]:= aNfItem[nItem][IT_LIVRO][LF_ANTICMS]
			aNfCab[NF_LIVRO][nLF][LF_CREDACU]:= aNfItem[nItem][IT_LIVRO][LF_CREDACU]
			aNfCab[NF_LIVRO][nLF][LF_CSTISS] := aNfItem[nItem][IT_LIVRO][LF_CSTISS]
			aNfCab[NF_LIVRO][nLF][LF_MOTICMS]:= aNfItem[nItem][IT_LIVRO][LF_MOTICMS]
			aNfCab[NF_LIVRO][nLF][LF_TPPRODE]:= aNfItem[nItem][IT_LIVRO][LF_TPPRODE]
			aNfCab[NF_LIVRO][nLF][LF_ALIQCPB]:= aNfItem[nItem][IT_LIVRO][LF_ALIQCPB]

			// REMOVIDO TRATAMENTO DE CAMPOS DO FECOP RN NO CHAMADO THIBOA, NAO DEVE SER COLOCADO AQUI POIS O TRATAMENTO EH DINAMICO.

			aNfCab[NF_LIVRO][nLF][LF_CLIDEST] := aNfItem[nItem][IT_LIVRO][LF_CLIDEST]
			aNfCab[NF_LIVRO][nLF][LF_LOJDEST] := aNfItem[nItem][IT_LIVRO][LF_LOJDEST]
			aNfCab[NF_LIVRO][nLF][LF_ALQCMAJ] := aNfItem[nItem][IT_LIVRO][LF_ALQCMAJ]

		EndIf

		For nY	:= 1 to Len(aNfCab[NF_LIVRO][nLf])
			If !AllTrim(StrZero(nY,3))$"001#002#012#015#016#018#020#023#024#031#032#033#036#042#043#044#045#046#047#048#051#052#053#058#061#070#075#076#077#081#088#094#095#096#097#098#099#100#112#116#128#142#145#146#148#150#151#155"
				If lSoma
					If Valtype(aNfItem[nItem][IT_LIVRO][nY])<>"A"
						aNfCab[NF_LIVRO][nLF][nY] += aNfItem[nItem][IT_LIVRO][nY]
					Else
						For nS := 1 To Len(aNfCab[NF_LIVRO][nLF][nY])
							aNfCab[NF_LIVRO][nLF][nY][nS] += aNfItem[nItem][IT_LIVRO][nY][nS]
						Next nS
					EndIf
				Else
					If Valtype(aNfItem[nItem][IT_LIVRO][nY])<>"A"
						aNfCab[NF_LIVRO][nLF][nY] -= aNfItem[nItem][IT_LIVRO][nY]
					Else
						For nS := 1 To Len(aNfCab[NF_LIVRO][nLF][nY])
							aNfCab[NF_LIVRO][nLF][nY][nS] += aNfItem[nItem][IT_LIVRO][nY][nS]
						Next nS
					EndIf
				EndIf
			EndIf
		Next nY

		//Preenche a Observacao dos livros Fiscais
		cNFOri := IIf(!Empty(aNfItem[nItem][IT_NFORI]),aNfItem[nItem][IT_NFORI]+"/"+Substr(aNfItem[nItem][IT_SERORI],1,3),"")
		If !Empty(cNFOri) .And. aScan(aNotasOri,cNFOri) == 0
			aadd(aNotasOri,cNFOri)
		EndIf

		cNFOri := IIf(Len(aNotasOri)>1,STR0009,cNFOri) //"DIVERSAS"

		//Ponto de entrada para alteracao da mensagem quanto a devolucao
		If !Empty( aNotasOri )
			If aPE[PE_MAFISOBS]
				cNFOri := ExecBlock( "MAFISOBS", .F., .F., { cNfOri, AClone( aNotasOri ) } )
			EndIf
		EndIf

		Do Case
			Case aNfCab[NF_TIPONF]=="D"
				cObs := IIf( !Empty(cNFOri) , STR0011 + cNFOri , "" )      // "DEVOLUCAO N.F.:"
			Case aNfCab[NF_TIPONF]=="C" .And. aNfCab[NF_TPCOMP] == "F"
				cObs := STR0012                                             // "CONHEC. FRETE"
			Case aNfCab[NF_TIPONF]=="C" .And. aNfCab[NF_TPCOMP] == "D"
				cObs := STR0013                                             // "NF DESPESA"
			Case aNfCab[NF_TIPONF]=="C"
				If !Empty(aNfCab[NF_ESPECIE])
					cObs := STR0014 + "(" + aNfCab[NF_ESPECIE] + ")"+cNFOri // "COMPL.N.F.: "
				Else
					cObs := STR0014 + cNFOri                                 // "COMPL.N.F.: "
				EndIf
			Case aNfCab[NF_TIPONF] == "B".And. aNFItem[nItem][IT_TS][TS_PODER3] <> "R"
				cObs := IIf( !Empty(cNFOri) , STR0015 + cNFOri , "" )       // "N.F.ORIG.: "
			Case aNfCab[NF_TIPONF] == "P"
				If	aNfCab[NF_VALICM] > 0
					cObs := STR0047 + cNFOri                    					 // "COMPL.IPI + ICMS N.F.: "
				Else
					cObs := STR0016 + cNFOri                                     // "COMPL.IPI N.F.: "
				EndIf
			Case aNfCab[NF_TIPONF] == "I"
				If "CIAP" $ Upper(cNFORi)
					cObs := ""
				Else
					cObs := IIf( aNFItem[nItem][IT_TS][TS_ISS]<>"N",STR0022,STR0017)+cNFOri  // "COMPL.ICMS N.F.: " OU "COMPL.ISS N.F.: "
				EndIf
			Case aNfCab[NF_TPCLIFOR] == "X" .And. aNfCab[NF_OPERNF] == "S"
				cObs := ""
				If !Empty(cNFOri) .And. !AllTrim(aNfItem[nItem][IT_CF]) $ "5663/5664/5665/5666/6663/6664/6665/6666"
					cObs := STR0018 + cNFOri                                // "EXPORTACAO-GE No.: "
				Endif
			Case aNFItem[nItem][IT_TS][TS_IPI]=="R" .And. Empty(aNFItem[nItem][IT_TS][TS_TXAPIPI])
				cObs := STR0019                                             // "AQUIS.COMERC.NAO-CONTRIB.IPI"
			Case aNfCab[NF_TIPONF] == "N" .And. aNFItem[nItem][IT_TS][TS_PODER3] == "D" .And. aNFItem[nItem][IT_TS][TS_CONSIND] <> "1"
				cObs := Iif( !Empty(cNfOri) , (STR0020+cNFOri) , "" )      // "Dev. Benef. N.F.ORIG.: "
			Case aNfCab[NF_FUNRURAL] > 0 .And. aNfCab[NF_VLSENAR] > 0 .And. aNfCab[NF_VALINS] > 0
				If aSX6[MV_IMPCSS] == "S"                               // Imprime Contribuicao Seguridade Social
					cObs := STR0021 + Alltrim(Transform(aNfCab[NF_FUNRURAL]+aNfCab[NF_VLSENAR]+aNfCab[NF_VALINS],"@E 999,999,999.99")) //"CONT.SEG.SOCIAL: "				Endif
				EndIf
			Case aNFItem[nItem][IT_TS][TS_OBSSOL] == "3"
				cObs := " ICMS GARANTIDO "
			Case aNFItem[nItem][IT_TS][TS_OBSSOL] == "4"
				cObs := " ICMS GARANTIDO INTEGRAL "
			Case aNfCab[NF_CREDPRE] > 0
				cObs := " CREDITO PRESUMIDO R$ " + Alltrim(Transform(aNfCab[NF_CREDPRE],"@E 999,999,999.99"))
			Case aNfCab[NF_TIPONF] == "N" .And. aNFItem[nItem][IT_TS][TS_PODER3] == "D" .And. aNFItem[nItem][IT_TS][TS_CONSIND] == "1"
				If !Empty(cNfOri)
					cObs := "CONSIG INDUS,NF " + cNFOri + "DE " + DtoC(SD2->D2_EMISSAO)
				EndIf
			Case aNfCab[NF_VALFUND] > 0
				cObs := "CONT.FUNDESA LEI 12.380/05 R$ " + Alltrim(Transform(aNfCab[NF_VALFUND],"@E 999,999,999.99"))
		EndCase

		aNfCab[NF_LIVRO][nLF][LF_OBSERV]   := cObs
		aNfItem[nItem][IT_LIVRO][LF_OBSERV]:= cObs

		//Zera a coluna outras caso esteja menor que zero
		aNfCab[NF_LIVRO,nLF,LF_OUTRICM] := Max(aNfCab[NF_LIVRO,nLF,LF_OUTRICM],0)
		aNfCab[NF_LIVRO,nLF,LF_OUTRIPI] := Max(aNfCab[NF_LIVRO,nLF,LF_OUTRIPI],0)

		//Vinculo do item do livro com o cabecalho
		aNfcab[NF_LIVRO][nLF][LF_IDENT]   := cIdent
		aNfItem[nItem][IT_LIVRO][LF_IDENT]:= cIdent

		//Exclusao dos itens sem valor
		If 	aNfCab[NF_LIVRO][nLF][3]+;
			aNfCab[NF_LIVRO][nLF][4]+;
			aNfCab[NF_LIVRO][nLF][5]+;
			aNfCab[NF_LIVRO][nLF][6]+;
			aNfCab[NF_LIVRO][nLF][7]+;
			aNfCab[NF_LIVRO][nLF][9]+;
			aNfCab[NF_LIVRO][nLF][10]+;
			aNfCab[NF_LIVRO][nLF][11]+;
			aNfCab[NF_LIVRO][nLF][27]+;
			aNfCab[NF_LIVRO][nLF][131] == 0 .And. Empty(aNfCab[NF_LIVRO][nLF][LF_FORMULA])
			aDel(aNfCab[NF_LIVRO],nLF)
			aSize(aNfCab[NF_LIVRO],Len(aNfCab[NF_LIVRO])-1)
		EndIf
	EndIf
Else
	aSF4:=SF4->(GetArea())
	aSFB:=SFB->(GetArea())
	aSFC:=SFC->(GetArea())
	SFC->(DbSetOrder(2))
	SFB->(DbSetOrder(1))
	SF4->(DbSetOrder(1))
	SF4->(MsSeek(xFilial("SF4")+aNfItem[nItem][IT_TES]))
	If cPaisLoc $ "COL|URU|EQU"
		aImpVar:=Array(10)
	Else
		aImpVar:=Array(8)
	EndIf
	aImpVar[1] := aNfItem[nItem][IT_QUANT]
	If aNFCab[NF_OPERNF] == 'E' .Or. aSX6[MV_DESCSAI]=='2'
		If cPaisLoc $ "ARG" .And. aNFCab[NF_OPERNF] == 'S' .And. Alltrim(FunName()) <> "MATA410" .And. (( Type("INCLUI" )=="L" .And. !INCLUI) .Or. ( Type("lVisualiza" )=="L" .And. lVisualiza ))
			aImpVar[2] := aNfItem[nItem][IT_VALMERC] /Max(aNfItem[nItem][IT_QUANT],1)
			aImpVar[3] := aNfItem[nItem][IT_VALMERC]
		Else
			If cPaisLoc == "ARG" .And. aNfCab[NF_CLIFOR]=="C" .And. aSX6[MV_DESCSAI]=='1'
				aImpVar[2] := aNfItem[nItem][IT_PRCUNI]
				aImpVar[3] := aNfItem[nItem][IT_VALMERC]
			ElseIf cPaisLoc == "MEX" .And. Alltrim(FunName()) $ "MATA466N" .And. ( Type("lVisualiza" )=="L" .And. lVisualiza ) .AND. aSX6[MV_DESCSAI]=='2'
				aImpVar[2] := aNfItem[nItem][IT_VALMERC] /Max(aNfItem[nItem][IT_QUANT],1)
				aImpVar[3] := aNfItem[nItem][IT_VALMERC]
			Else
				aImpVar[2] := (aNfItem[nItem][IT_VALMERC]-(aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT]) )/Max(aNfItem[nItem][IT_QUANT],1)
				aImpVar[3] := aNfItem[nItem][IT_VALMERC]-(aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT])
			EndIf
		EndIF
	Else
		aImpVar[2] := aNfItem[nItem][IT_PRCUNI]
		aImpVar[3] := aNfItem[nItem][IT_VALMERC]
	Endif
	If cPaisLoc == "MEX"
		aImpVar[3] -= aNfItem[nItem][IT_ADIANT]
	EndIf
	aImpVar[4] := aNfItem[nItem][IT_FRETE]
	aImpVar[5] := aNfItem[nItem][IT_DESPESA] + aNfItem[nItem][IT_SEGURO] + Iif(cPaisLoc=="PTG",aNfItem[nItem][IT_DESNTRB]+aNfItem[nItem][IT_TARA],0)
	aImpVar[6] := {}
	aImpVar[7] := ""
	If cPaisLoc $ "COL"
		aImpVar[9] := aNfItem[nItem][IT_SEGURO]
	EndIf
	If cPaisLoc $ "URU|EQU|COL"
		aImpVar[8] := nItem
	Endif

	If cPaisLoc $ "BOL | ARG"
		aImpVar[8] := aNfItem[nItem][IT_CF]
	EndIf
	If cPaisLoc $ "COL"
		aImpVar[10] := aNfItem[nItem][IT_CF]
	EndIf

	If aNfItem[nItem][IT_TES] <> aTes[TS_CODIGO]
		MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
	EndIf

	For nY := 1 to Len(aTes[TS_SFC])
		If (cPaisLoc <> "ARG".Or. aTes[TS_SFC][nY][SFC_IMPOSTO]<> "DUM") //Ignmorar o DUMMY
			lAchouWN:=.F.
			nImp:=NumCpoImpVar(RIGHT(Alltrim(aTes[TS_SFC][nY][SFB_CPOVREI]),1))
			aadd(aImpVar[6],Array(18))
			nX:=Len(aImpVar[6])
			// No caso abaixo o código do imposto (ISC,IGV,PIV,DIG) é gravado
			// na primeira posição do array aImpVar[6][nX], pois o mesmo é
			// utilizado nas funções de formação dos livros fiscais GetBook,
			// M460LIVR  e M100LIVR.
			// OBS. No caso do não localizado o valor do código do produto é
			// é passado como parâmetro, porém não é utilizado.

			If cPaisLoc $ "PER" .Or. cPaisLoc $ "COL"
				aImpVar[6][nX][1] := aTes[TS_SFC][nY][SFC_IMPOSTO]
			Else
				aImpVar[6][nX][1] :=aNfItem[nItem][IT_PRODUTO]
			EndIf
			aImpVar[6][nX][2] :=aNfItem[nItem][IT_ALIQIMP][nImp]
			aImpVar[6][nX][3] :=aNfItem[nItem][IT_BASEIMP][nImp]
			aImpVar[6][nX][4] :=aNfItem[nItem][IT_VALIMP][nImp]
			If (lImport)
				SD1->(MsSeek(xFilial("SD1")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA+aNfItem[nItem][IT_PRODUTO]))
				If SF1->F1_TIPO_NF$"5678"
					//Solicitação - Average FNC 152032 continuação FNC 147106
					//Se os campos existirem entro para verificar se estão preenchidos e buscar a referencia da TES na tabela SWN
					If lFildPSWN
						SWN->(DbSetOrder(2))
						If SWN->(MsSeek(xFilial("SWN")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA))
							While !SWN->(Eof()) .And.;
								(SWN->WN_FILIAL+SWN->WN_DOC+SWN->WN_SERIE+SWN->WN_FORNECE+SWN->WN_LOJA == xFilial("SWN")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA);
								//Se encontrar a referência do Item e a TES estiver preenchida pego a TES da SWN
								If SWN->WN_PRODUTO+SWN->WN_ITEMNF == SD1->D1_COD+SD1->D1_ITEM .And. !Empty(SWN->WN_TES)
									lAchouWN:=.T.
									SFC->(MsSeek(xFilial("SFC")+SWN->WN_TES+aTes[TS_SFC][nY][SFC_IMPOSTO]))
								EndIf
								SWN->(DbSkip())
							End
							//Senão encontrou deixo a referência que existia antes
							If !lAchouWN
								SYD->(MsSeek(xFilial("SYD")+SD1->D1_TEC))
								SFC->(MsSeek(xFilial("SFC")+SYD->YD_TES+aTes[TS_SFC][nY][SFC_IMPOSTO]))
							EndIf
						EndIf
					Else
						//Senão os campos não existirem deixo a referência que existia antes
						SYD->(MsSeek(xFilial("SYD")+SD1->D1_TEC))
						SFC->(MsSeek(xFilial("SFC")+SYD->YD_TES+aTes[TS_SFC][nY][SFC_IMPOSTO]))
					EndIf
				Else
					If aSX6[MV_DESPSD1]=="S" .And. cPaisLoc == "BRA"
						SFC->(MsSeek(xFilial("SFC")+SD1->D1_TESDES+aTes[TS_SFC][nY][SFC_IMPOSTO]))
					Else
						//Solicitação - Average FNC 152032 continuação FNC 147106
						//Se os campos existirem entro para verificar se estão preenchidos e buscar a referencia da TES na tabela SWN
						If lFildPSWN
							SWN->(DbSetOrder(2))
							If SWN->(MsSeek(xFilial("SWN")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA))
								While !SWN->(Eof()) .And.;
									(SWN->WN_FILIAL+SWN->WN_DOC+SWN->WN_SERIE+SWN->WN_FORNECE+SWN->WN_LOJA == xFilial("SWN")+SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA);
									//Se encontrar a referência do Item e a TES estiver preenchida pego a TES da SWN
									If SWN->WN_PRODUTO+SWN->WN_ITEMNF == SD1->D1_COD+SD1->D1_ITEM .And. !Empty(SWN->WN_TES)
										lAchouWN:=.T.
										SFC->(MsSeek(xFilial("SFC")+SWN->WN_TES+aTes[TS_SFC][nY][SFC_IMPOSTO]))
									EndIf
									SWN->(DbSkip())
								End
								//Senão encontrou deixo a referência que existia antes
								If !lAchouWN
									SYD->(MsSeek(xFilial("SYD")+SD1->D1_TEC))
									SFC->(MsSeek(xFilial("SFC")+SYD->YD_TES+aTes[TS_SFC][nY][SFC_IMPOSTO]))
								EndIf
							EndIf
						Else
							//Senão os campos não existirem deixo a referência que existia antes
							SYD->(MsSeek(xFilial("SYD")+SD1->D1_TEC))
							SFC->(MsSeek(xFilial("SFC")+SYD->YD_TES+aTes[TS_SFC][nY][SFC_IMPOSTO]))
						EndIf
					Endif
				Endif
				SFB->(MsSeek(xFilial("SFB")+aTes[TS_SFC][nY][SFC_IMPOSTO]))
				cAux:=SFC->FC_INCDUPL+SFC->FC_INCNOTA+SFC->FC_CREDITA
				If IsAlpha(SFC->FC_INCDUPL)
					aImpVar[6][nX][5]:=IIf(Subs(cAux,1,2)=="SN".Or.Subs(cAux,1,2)=="NS","3",;
					IIf(Subs(cAux,1,2)=="SS","1","2"))
					aImpVar[6][nX][5]+=IIf(Subs(cAux,2,1)=="S" ,"1",IIf(Subs(cAux,2,1)=="R" ,"2","3"))
					aImpVar[6][nX][5]+=IIf(Subs(cAux,2,2)=="SN","1",IIf(Subs(cAux,2,2)=="NS","2","3"))
				Else
					aImpVar[6][nX][5]:=cAux
				EndIf
				aImpVar[6][nX][17]:=SFB->FB_CPOLVRO
			Else
				aImpVar[6][nX][5]:=	aTes[TS_SFC][nY][SFC_INCDUPL]+	aTes[TS_SFC][nY][SFC_INCNOTA]+	aTes[TS_SFC][nY][SFC_CREDITA]
				aImpVar[6][nX][17]:=Right(aTes[TS_SFC][nY][SFB_CPOVREI],1)
				aImpVar[6][nX][18]:= aTes[TS_SFC][nY][SFB_DESGR]
			Endif
		Endif
	Next nY
	If Type('dDEmissao') == "D" .And. !Empty(dDEmissao)
		dDataEmi	:=	dDEmissao
	Endif
	//          TRATAMENTO EXPECIFICO PARA LOCALIZADO PERU
	// Quando o TES for referente ao imposto do IGV, o valor do IPM, o
	// qual é uma porcentagem do IGV,o valor da base, aliquota e valor do
	// imposto é gravado nos campos _BASIMP3, _ALQIMP3 e VALIMP3.
	// O valor da base é a mesma utilizada para o cálculo do IGV.
	// O valor da alíqutoa é proveniente de um paramêtro chamado
	// MV_ALQIPM.
	// O valor do imposto é a multiplicação da base pelo valor da aliquota
	// NO CASO ABAIXO FOI INCLUIDA UMA CONDIçãO PARA O FLUXO POSSIBILITAR
	// QUE O VALOR DOS CAMPOS _BASIMP3, _ALQIMP3 E _VALIMP3 SEJAM PREENCHI-
	// DOS.

	If cPaisLoc == "PER" .And. ValType(aNfItem[nItem][IT_ALIQIMP][3]) == "N"
		alAreaX := GetArea()

		nImp:=3
		aadd(aImpVar[6],Array(17))
		nX:=Len(aImpVar[6])
		aImpVar[6][nX][1] := "IGV"
		aImpVar[6][nX][2] :=aNfItem[nItem][IT_ALIQIMP][nImp]
		aImpVar[6][nX][3] :=aNfItem[nItem][IT_BASEIMP][nImp]
		aImpVar[6][nX][4] :=aNfItem[nItem][IT_VALIMP][nImp]

		aImpVar[6][nX][5] := "333"
		aImpVar[6][nX][17]:= "3"

		RestArea(alAreaX)
	EndIf
	aNfCab[NF_LIVRO]:=GetBook(@aGetBook,aImpVar,If(aNfCab[NF_CLIFOR]=="C","V","C"),If(Type("nTaxa")=="N",nTaxa,If(Type("nTXMoeda")=="N",nTXMoeda,1)),aNfCab[NF_LIVRO],aNfCab[NF_OPERNF],lSoma,,,,,,dDataEmi)
	RestArea(aSF4)
	RestArea(aSFB)
	RestArea(aSFC)
EndIf

Return .T.

/*/
MaFisLF -  Edson Maricate - 20.12.1999
Atualiza os livros fiscais para o item.
/*/
Function MaFisLF(nItem,lRecPreSt)

If FindFunction("xFisLF")
	xFisLF(nItem, lRecPreSt, @aNFItem, @aNfCab, aSX6, aPos, aPE, cAliasPROD)
Else
	If IsBlind()
		UserException(STR0045)
	Else
		MsgAlert(STR0045)
		Final(STR0045)
	EndIf
EndIf

Return

/*/
MaRateio -Edson Maricate  -20.12.2000
Esta rotina tem como objetivo efetuar o rateio das despesas
acessorias sobre todos os itens da nota fiscal, exceto os
que possuirem a referencia ISS.
Parametros
ExpC1: Nome da Referencia da despesas acessoria
ExpN2: Valor atual da despesa acessoria
ExpN3: Novo valor da despesa acessoria
/*/
Static Function MaRateio(cReferencia,nAnterior,nAtual,lDupl,aTrbGen)

Local aRateio    := {}
Local nX		 := 0
Local nDiferenca := 0
Local nY		 := 0
Local nSoma 	 := 0
Local nValMISS   := 0
Local nValDISS   := 0
Local nPesoMISS  := 0
Local nDec       := 2
Local nItValMerc := 0
Local nBseRateio := 0
Local aPosCpo	 := MaFisScan(cReferencia)
Local cMvRatDesp := aSX6[MV_RATDESP]
Local cTpRatDesp := Substr(cMvRatDesp,AT("DESP=",cMvRatDesp)+5,1)
Local cTpRatFrete:= Substr(cMvRatDesp,AT("FR=",cMvRatDesp)+3,1)
Local cTpRatSeg	 := Substr(cMvRatDesp,AT("SEG=",cMvRatDesp)+4,1)
Local cTpRatNTr	 := Substr(cMvRatDesp,AT("NTRB=",cMvRatDesp)+5,1)
Local cTpRatTara := Substr(cMvRatDesp,AT("TARA=",cMvRatDesp)+5,1)
Local lRatDesc	 :=	( (cReferencia == "IT_DESCONTO" .OR. cReferencia == "IT_DESCTOT" ) .And. cPaisLoc <> "BRA" .And. aNfCab[NF_OPERNF] == "S" .And. aSX6[MV_DESCSAI] == "1" )
Local lRateiaIt  := .T.
Local lRatECF    := aNfCab[NF_ROTINA] == 'LOJA701' .AND. (cReferencia $ "IT_DESCTOT|IT_ACRESCI") .AND. FindFunction("STFIsPOS") .AND. STFIsPOS() .AND. FindFunction("STBTaxGrupTrib") .AND. FindFunction("STBTaxRateio")
Local lTribGen   := cPaisLoc == "BRA" .And. AllTrim(cReferencia) == "IT_TRIBGEN"
Local nPosRefGen := 0
Local nPosGen    := 0

DEFAULT lDupl := .F.
DEFAULT aTrbGen := {"",""}

If cPaisLoc<>"BRA"
	If FunName()=="MATA121" .And. Type("nMoedaPed")=="N"
		nDec:=MsDecimais(nMoedaPed)
	ElseIf FunName()=="MATA123" .And. Type("nMoedaPed")=="N"
		nDec:=MsDecimais(nMoedaPed)
	ElseIf FunName()=="MATA150" .And. Type("nMoedaCot")=="N"
		nDec:=MsDecimais(nMoedaCot)
	ElseIf FunName()=="MATA160" .And. Type("nMoedaAval")=="N"
		nDec:=MsDecimais(nMoedaAval)
	ElseIf Type("nMoedaNF")=="N"
		nDec:=MsDecimais(nMoedaNF)
	ElseIf Type("nMoedaCor")=="N"
		nDec:=MsDecimais(nMoedaCor)
	ElseIf Type("M->F1_MOEDA")=="N"
		nDec:=MsDecimais(M->F1_MOEDA)
	ElseIf Type("M->F2_MOEDA")=="N"
		nDec:=MsDecimais(M->F2_MOEDA)
	ElseIf FunName()=="MATA143" .And. Type("nMoedaDes")=="N"
		nDec:=MsDecimais(nMoedaDes)
	Else
		nDec:=MsDecimais(1)
	Endif
Endif

If aPE[PE_MARATEIO]
	aRateio := ExecBlock("MARATEIO",.F.,.F.,{cTpRatDesp,cTpRatFrete,cTpRatSeg,cTpRatNTr,cTpRatTara})
	cTpRatDesp  := aRateio[1]
	cTpRatFrete := aRateio[2]
	cTpRatSeg   := aRateio[3]
	cTpRatNTr	:= Iif(Len(aRateio) > 3 , aRateio[4] , "" )
	cTpRatTara	:= Iif(Len(aRateio) > 4 , aRateio[5] , "" )
EndIf

If ( "FRETE"$cReferencia .Or. "SEGURO"$cReferencia .Or. "DESPESA"$cReferencia .Or. "VLR_FRT"$cReferencia .Or. "DESNTRB"$cReferencia .Or."TARA"$cReferencia)
	If aNfCab[NF_PESO] <> 0 .And. ((cReferencia == "IT_FRETE" .And. cTpRatFrete == "2" ) .Or. ;
			(cReferencia == "IT_DESPESA" .And. cTpRatDesp == "2" ).Or.;
			(cReferencia == "IT_SEGURO"  .And. cTpRatSeg  == "2" ).Or.;
			(cReferencia == "IT_VLR_FRT" .And. cTpRatFrete== "2" ).Or.;
			(cReferencia == "IT_DESNTRB" .And. cTpRatNTr  == "2" ).Or.;
			(cReferencia == "IT_TARA"    .And. cTpRatTara == "2" ))
		aEval(aNfItem,{|x| nPesoMISS+= If(!x[IT_DELETED] .And. x[IT_RATEIOISS]=="S" .And. (!lDupl .Or. x[IT_BASEDUP]>0),x[IT_PESO],0)})
	Else
		aEval(aNfItem,{|x| nValMISS += If(!x[IT_DELETED] .And. x[IT_RATEIOISS]=="S" .And. (!lDupl .Or. x[IT_BASEDUP]>0),(x[IT_VALMERC]+x[IT_VNAGREG]),0)})
		aEval(aNfItem,{|x| nValDISS += If(!x[IT_DELETED] .And. x[IT_RATEIOISS]=="S" .And. (!lDupl .Or. x[IT_BASEDUP]>0),((x[IT_VALMERC]-(x[IT_DESCONTO]+x[IT_DESCTOT]))+x[IT_VNAGREG]),0)})
	EndIf
EndIf

// O MV_VALDESP = T impede que as despesas sejam rateadas no item com F4_ICMS = N para que o valor total das despesas sejam rateadas entre os itens F4_ICMS=S para que o frete integral faca parte da base do ICMS
// O MV_RATAGRE = T impede que as despesas sejam rateadas no item com F4_AGREG = N para que o valor total das despesas sejam rateadas entre os itens F4_AGREG=S.
// OBSERVACAO - INFORMACOES DA TES PODERIA ESTAR NO ITEM
If ((aSX6[MV_VALDESP] .Or. aSX6[MV_RATAGRE]) .And. !lTribGen)
	For nX	:= 1 to Len(aNfItem)
		SF4->(dbSetOrder(1))
		SF4->(MsSeek(xFilial("SF4")+aNfItem[nX][IT_TES] ))
		If aSX6[MV_VALDESP] .And. SF4->F4_ICM == "N" .And. !aNfItem[nX][IT_DELETED]
			nItValMerc += aNfItem[nX][IT_VALMERC]
		ElseIf aSX6[MV_RATAGRE] .And. SF4->F4_AGREG == "N" .And. !aNfItem[nX][IT_DELETED]
			nItValMerc += aNfItem[nX][IT_VALMERC]
		EndIf
	Next nX
EndIf

If nAnterior > 0

	nDiferenca := (nAtual-nAnterior) / nAnterior

	If AllTrim(cReferencia) == "IT_TRIBGEN"

		nPosRefGen := MaFisScan(aTrbGen[TG_REFERENCIA])

		For nX := 1 to Len(aNfItem)

			// Verifica se o item não está deletado e se o tributo em questão foi calculado
			lRateiaIt := !aNfItem[nX][IT_DELETED] .And. ((nPosGen := aScan(aNFItem[nX][IT_TRIBGEN], {|x| Alltrim(x[TG_IT_SIGLA]) == Alltrim(aTrbGen[TG_SIGLA])})) > 0)

			If lRateiaIt 
				aNfItem[nX][IT_TRIBGEN][nPosGen][nPosRefGen] := NoRound((1+nDiferenca)*aNfItem[nX][IT_TRIBGEN][nPosGen][nPosRefGen],nDec)
				nSoma += aNfItem[nX][IT_TRIBGEN][nPosGen][nPosRefGen]
				nY := nX
			EndIf

		Next nX

		// Efetua a correcao da dizima no ultimo item.
		If nY <> 0 .And. nPosGen > 0
			aNfItem[nY][IT_TRIBGEN][nPosGen][nPosRefGen] += nAtual - nSoma
		EndIf

	Else

		For nX	:= 1 to Len(aNfItem)

			lRateiaIt := .T.
			SF4->(dbSetOrder(1))
			SF4->(MsSeek(xFilial("SF4")+aNfItem[nX][IT_TES] ))
			If aSX6[MV_VALDESP] .And. SF4->F4_ICM == "N"
				If ValType(aPosCpo) == "A"
					aNfItem[nX][aPosCpo[1]][aPosCpo[2]] := 0
				Else
					aNfItem[nX][Val(aPosCpo)] := 0
				EndIf
				lRateiaIt := .F. //Impede que o item participe do rateio das depesas
			EndIf
			If aSX6[MV_RATAGRE] .And. SF4->F4_AGREG == "N"
				If ValType(aPosCpo) == "A"
					aNfItem[nX][aPosCpo[1]][aPosCpo[2]] := 0
				Else
					aNfItem[nX][Val(aPosCpo)] := 0
				EndIf
				lRateiaIt := .F. //Impede que o item participe do rateio do desconto
			EndIf
			If lRateiaIt .And. !aNfItem[nX][IT_DELETED] .And.;
				!( aNfItem[nX][IT_RATEIOISS]=="S" .And. ("FRETE"$cReferencia .Or. "SEGURO"$cReferencia .Or. "DESPESA"$cReferencia .Or. "VLR_FRT"$cReferencia .Or. "DESNTRB"$cReferencia .Or."TARA"$cReferencia) ) .And.;
				(!lDupl .Or. aNfItem[nX][IT_BASEDUP]>0)

				If ValType(aPosCpo) == "A"
					aNfItem[nX][aPosCpo[1]][aPosCpo[2]] := NoRound((1+nDiferenca)*aNfItem[nX][aPosCpo[1]][aPosCpo[2]],nDec)
					IF cPaisLoc=="COL" .And. (NoRound((1+nDiferenca)*aNfItem[nX][aPosCpo[1]][aPosCpo[2]],nDec) == 0) .and. (nAnterior==0)
						Loop
					Else
						nY := nX
					EndIf
					nSoma += aNfItem[nX][aPosCpo[1]][aPosCpo[2]]
				Else
				IF cPaisLoc=="COL" .And. (NoRound((1+nDiferenca)*aNfItem[nX][Val(aPosCpo)],nDec) == 0) .and. (nAnterior==0)
						Loop
					Else
						nY := nX
					EndIf
					If lRatDesc
						aNFitem[nX][IT_VALMERC]   += aNfItem[nX][Val(aPosCpo)]
						aNfItem[nX][Val(aPosCpo)] := NoRound((1+nDiferenca)*aNfItem[nX][Val(aPosCpo)],nDec)
						nSoma += aNfItem[nX][Val(aPosCpo)]
					Else
						aNfItem[nX][Val(aPosCpo)] := NoRound((1+nDiferenca)*aNfItem[nX][Val(aPosCpo)],nDec)
						nSoma += aNfItem[nX][Val(aPosCpo)]
					Endif
				EndIf
			EndIf

		Next nX

		// Efetua a correcao da dizima no primeiro item.
		If nY <> 0
			If ValType(aPosCpo) == "A"
				aNfItem[nY][aPosCpo[1]][aPosCpo[2]] += nAtual - nSoma
			Else
				aNfItem[nY][Val(aPosCpo)] += nAtual - nSoma
			EndIf
		EndIf

	EndIf

Else
	For nX	:= 1 to Len(aNfItem)

        lRateiaIt := .T.
		SF4->(dbSetOrder(1))
		SF4->(MsSeek(xFilial("SF4") + aNfItem[nX][IT_TES] ))
		If aSX6[MV_VALDESP] .And. SF4->F4_ICM == "N"
			If ValType(aPosCpo) == "A"
				aNfItem[nX][aPosCpo[1]][aPosCpo[2]] := 0
            Else
				aNfItem[nX][Val(aPosCpo)] := 0
            EndIf
           lRateiaIt := .F. //Impede que o item participe do rateio das depesas
        EndIf
		If aSX6[MV_RATAGRE] .And. SF4->F4_AGREG == "N"
			If ValType(aPosCpo) == "A"
				aNfItem[nX][aPosCpo[1]][aPosCpo[2]] := 0
            Else
				aNfItem[nX][Val(aPosCpo)] := 0
            EndIf
           lRateiaIt := .F. //Impede que o item participe do rateio do desconto
        EndIf
		If lRateiaIt .And. !aNfItem[nX][IT_DELETED] .And.;
			!( aNfItem[nX][IT_RATEIOISS]=="S" .And. ("FRETE"$cReferencia .Or. "SEGURO"$cReferencia .Or. "DESPESA"$cReferencia .Or. "VLR_FRT"$cReferencia .Or. "DESNTRB"$cReferencia .Or."TARA"$cReferencia) ).And.;
			(!lDupl .Or. aNfItem[nX][IT_BASEDUP]>0)
			nY := nX
			// Efetua o rateio do valor informado nos itens da NF
			// O rateio das despesas ( frete/seguro/despesas ) podera
			// ser efetuado por valor ou peso, de acordo com a config.
			// do parametro MV_RATDESP.
			If aNfCab[NF_PESO] <> 0 .And. (( cReferencia == "IT_FRETE" .And. cTpRatFrete == "2" ) .Or. ;
					(cReferencia=="IT_DESPESA" .And. cTpRatDesp == "2") .Or. ;
					(cReferencia=="IT_SEGURO"  .And. cTpRatSeg  == "2") .Or. ;
					(cReferencia=="IT_VLR_FRT" .And. cTpRatFrete== "2") .Or. ;
					(cReferencia=="IT_DESNTRB" .And. cTpRatNTr  == "2") .Or. ;
					(cReferencia=="IT_TARA"    .And. cTpRatTara == "2"))
				// Rateio por Peso.
				If ValType(aPosCpo) == "A"
					aNfItem[nX][aPosCpo[1]][aPosCpo[2]] += NoRound((nAtual-nAnterior)*(aNfItem[nX][IT_PESO]/(aNfCab[NF_PESO]-nPesoMISS)),nDec)
					nSoma += aNfItem[nX][aPosCpo[1]][aPosCpo[2]]
				Else
					aNfItem[nX][Val(aPosCpo)] += NoRound((nAtual-nAnterior)*(aNfItem[nX][IT_PESO]/(aNfCab[NF_PESO]-nPesoMISS)),nDec)
					nSoma += aNfItem[nX][Val(aPosCpo)]
				EndIf
			Else
				// Rateio por Valor.
				If ValType(aPosCpo) == "A"
					aNfItem[nX][aPosCpo[1]][aPosCpo[2]] += NoRound((nAtual-nAnterior)*(aNfItem[nX][IT_VALMERC]/((aNfCab[NF_VALMERC]+aNfCab[NF_VNAGREG] - nItValMerc )-nValMISS)),nDec)
					nSoma += aNfItem[nX][aPosCpo[1]][aPosCpo[2]]
				Else
					If lRatDesc
						aNFitem[nX][IT_VALMERC]  += NoRound(aNfItem[nX][Val(aPosCpo)],nDec)
						aNfItem[nX][Val(aPosCpo)]+= NoRound((nAtual-nAnterior)*(aNfItem[nX][IT_VALMERC]/((aNfCab[NF_VALMERC]+aNfCab[NF_VNAGREG]- nItValMerc )-nValMISS)),nDec)
						nSoma += aNfItem[nX][Val(aPosCpo)]
					Else
						If aNfCab[NF_ROTINA] == "MATA461"
							nBseRateio := Iif(("FRETE"$cReferencia .Or. "SEGURO"$cReferencia .Or. "DESPESA"$cReferencia) .And. (aNfCab[NF_DESCONTO] + aNfCab[NF_DESCTOT]) > 0 , aNfCab[NF_VALMERC] - (aNfCab[NF_DESCONTO]+ aNfCab[NF_DESCTOT]), aNfCab[NF_VALMERC] )

							//Realizada correcao para que o rateio por valor seja realizado corretamente quando existir abatimento C5_DESCONT no pedido de venda.
							aNfItem[nX][Val(aPosCpo)]+= Round((nAtual-nAnterior)*((aNfItem[nX][IT_VALMERC] - (aNfItem[nX][IT_DESCONTO] + aNfItem[nX][IT_DESCTOT]))/((( nBseRateio - nItValMerc)+aNfCab[NF_VNAGREG])-nValDISS)),MsDecimais(aNfCab[NF_MOEDA]))
						ElseIf lRatECF
							STBTaxGrupTrib(aNfCab,aNfItem,nX,cReferencia)
						Else
							aNfItem[nX][Val(aPosCpo)]+= Round((nAtual-nAnterior)*(aNfItem[nX][IT_VALMERC]/((aNfCab[NF_VALMERC] - nItValMerc +aNfCab[NF_VNAGREG])-nValMISS)),MsDecimais(aNfCab[NF_MOEDA]))
						EndIf
						nSoma += aNfItem[nX][Val(aPosCpo)]
					Endif
				EndIf
			EndIf
		EndIf
	Next nX

	If lRatECF
		STBTaxRateio(aNfCab,@aNfItem,aPosCpo,cReferencia,nDec)
    Else
		//Efetua a correcao da dizima no primeiro item
		If nY <> 0
			If ValType(aPosCpo) == "A"
				If aNfItem[nY][aPosCpo[1]][aPosCpo[2]] + ( nAtual-nSoma ) >= 0
					aNfItem[nY][aPosCpo[1]][aPosCpo[2]] += nAtual-nSoma
	            Else
	                For nY :=1 to Len(aNfItem)
						If aNfItem[nY][aPosCpo[1]][aPosCpo[2]] + ( nAtual-nSoma ) >= 0
	 						aNfItem[nY][aPosCpo[1]][aPosCpo[2]] += nAtual-nSoma
	                        Exit
	                    EndIf
	                Next nY
	            EndIf
			Else
	            If aNfItem[nY][Val(aPosCpo)] + ( nAtual-nSoma ) >= 0
					aNfItem[nY][Val(aPosCpo)] += nAtual-nSoma

	            Else
	                For nY :=1 to Len(aNfItem)
	                	If aNfItem[nY][Val(aPosCpo)] + ( nAtual-nSoma ) >= 0
							aNfItem[nY][Val(aPosCpo)] += nAtual-nSoma
	                        Exit
	                    EndIf
	                Next nY
	            EndIf
			EndIf
		EndIf
	EndIf
EndIf

Return

/*/
MaFisRatRe -Edson Maricate  -20.12.1999
Esta rotina tem como objetivo distribuir o valor da referencia alterada, entre os itens de mesma referencia.
Rateio do resumo de impostos
Parametros
ExpC1: Nome da Referencia do imposto
ExpN2: Valor atual da referencia
ExpN3: Aliquota da referencia alterada
ExpN4: Nome da Referencia Aliquota para este imposto
/*/
Static Function MaFisRatRes(cReferencia,nAtual,nAliquota,cCpoAliq,cCpoBase,nItemNao,aTrbGen)

Local aPosCpo 	:= MaFisScan(cReferencia)
Local nCpoAliq	:= MaFisScan(cCpoAliq)
Local nCpoBase	:= MaFisScan(cCpoBase,.F.)
Local nX        := 0
Local nTotAcum	:= 0
Local nAuxItem	:= 0
Local nAliqItem	:= 0
Local nBaseTot	:= 0
Local nVlrTot   := 0
Local nFator    := 0
Local nPosItRef := 0
Local nDecimais	:= 0
Local lAuxItem	:= .T.
Local lsomadif	:=	.F.
Local nPosGen   := 0
Local nPosRefGen := 0

DEFAULT aTrbGen := {"",""}

nAtual := Round(nAtual,MsDecimais( aNFCab[NF_MOEDA] ))

DEFAULT nItemNao	:=	0

If cReferencia=="IT_VALSOL"
	nCpoBase := 0
EndIf

If cReferencia == "IT_TRIBGEN"

	nPosRefGen := MaFisScan(aTrbGen[TG_REFERENCIA])

	For nX := 1 To Len(aNFItem)
		//Soh somar as bases da mesma aliquota, porque o rateio eh soh para os itens da mesma aliquota
		If (MaFisRet(nX,cReferencia,{aTrbGen[TG_SIGLA],cCpoAliq}) == nAliquota)
			nBaseTot += IIf(!aNfItem[nX][IT_DELETED],MaFisRet(nX,cReferencia,{aTrbGen[TG_SIGLA],cCpoBase}),0)
		EndIf
	Next nX

	For nX := 1 to Len(aNfItem)
		If !aNfItem[nX][IT_DELETED]

			If nAtual <> 0 .And. nAtual == nTotAcum .And. cPaisLoc == "BRA"
				Exit
			Endif
			
			nFator := MaFisRet(nX,cReferencia,{aTrbGen[TG_SIGLA],cCpoBase}) / nBaseTot
			nAliqItem := MaFisRet(nX,cReferencia,{aTrbGen[TG_SIGLA],cCpoAliq})

			If nAliqItem == nAliquota

				If nX <> nItemNao
					MaFisSomaIt(nX,.F.)
				Endif

				If lAuxItem
					nAuxItem := nX
					lAuxItem := .F.
				EndIf

				If (nPosGen := aScan(aNFItem[nX][IT_TRIBGEN], {|x| Alltrim(x[TG_IT_SIGLA]) == Alltrim(aTrbGen[TG_SIGLA])})) > 0

					nPosItRef := Ascan(aTGITRef,{|x| x[1] == aTrbGen[TG_REFERENCIA]})

					If aTGITRef[nPosItRef][4] .And. aTGITRef[nPosItRef][5]
						nTotAcum += aNfItem[nX][IT_TRIBGEN][nPosGen][nPosRefGen] := NoRound(nFator * nAtual, 2)
					Else
						nTotAcum += aNfItem[nX][IT_TRIBGEN][nPosGen][nPosRefGen] := nFator * nAtual
					EndIf

				EndIf
				
			EndIf
		EndIf
	Next nX

	If !lAuxItem .And. nAtual <> nTotAcum
		If (nPosGen := aScan(aNFItem[nAuxItem][IT_TRIBGEN], {|x| Alltrim(x[TG_IT_SIGLA]) == Alltrim(aTrbGen[TG_SIGLA])})) > 0
			aNfItem[nAuxItem][IT_TRIBGEN][nPosGen][nPosRefGen] += (nAtual-nTotAcum)
		EndIf
	EndIf

Else

	For nX := 1 To Len(aNFItem)
		If !Empty(nCpoBase) // so se existir a base, no caso de Dif. de Aliquota nao existe
			//Soh somar as bases da mesma aliquota, porque o rateio eh soh para os itens da mesma aliquota
			If (MaFisRet(nX,cCpoAliq)==nAliquota )
				nBaseTot+=IIf(!aNfItem[nX][IT_DELETED],MaFisRet(nX,cCpoBase),0)
			EndIf
		Else
			If nBaseTot <= 0
				nVlrTot+=IIf(!aNfItem[nX][IT_DELETED],MaFisRet(nX,cReferencia),0)
			EndIf
		EndIf
	Next nX

	If cPaisLoc $"ARG/PER"
		nDecimais := MsDecimais( aNFCab[NF_MOEDA] )
	Endif

	For nX := 1 to Len(aNfItem)
		If !aNfItem[nX][IT_DELETED]
			If nAtual <> 0 .And. nAtual == nTotAcum .And. cPaisLoc == "BRA"
				Exit
			Endif
			If !Empty(nCpoBase) // so se existir a base, no caso de Dif. de Aliquota nao existe
				//O rateio de impostos eh feito com base na base calculada para cada item
				nFator := MaFisRet(nX,cCpoBase)/nBaseTot
			Else
				If nBaseTot <= 0
					nFator := MaFisRet(nX,cReferencia)/nVlrTot
				EndIf
			EndIf
			If ValType(nCpoAliq) == "A"
				nAliqItem := aNfItem[nX][nCpoAliq[1]][nCpoAliq[2]]
			Else
				nAliqItem := aNfItem[nX][Val(nCpoAliq)]
			EndIf

			If nAliqItem == nAliquota

				If nX <> nItemNao
					MaFisSomaIt(nX,.F.)
				Endif

				If lAuxItem
					nAuxItem := nX
					lAuxItem := .F.
				EndIf

				nPosItRef := Ascan(aItemRef,{|x| x[1] == cReferencia})

				If nPosItRef > 0
					If aItemRef[nPosItRef][4] .And. aItemRef[nPosItRef][5]
						If ValType(aPosCpo) == "A"
							nTotAcum += aNfItem[nX][aPosCpo[1]][aPosCpo[2]]:= NoRound(nFator*nAtual,2)
						Else
							nTotAcum += aNfItem[nX][Val(aPosCpo)]:= NoRound(nFator*nAtual,2)
						EndIf
					Else
						If ValType(aPosCpo) == "A"
							nTotAcum += aNfItem[nX][aPosCpo[1]][aPosCpo[2]]:= IIf(cPaisLoc$"PAR/PER" , NoRound(nFator*nAtual,nDecimais) , nFator*nAtual )
						Else
							nTotAcum += aNfItem[nX][Val(aPosCpo)] := IIf(cPaisLoc$"PAR/PER" , NoRound(nFator*nAtual,nDecimais) , nFator*nAtual )
						EndIf
					EndIf
				Else
					If ValType(aPosCpo) == "A"
						nTotAcum += aNfItem[nX][aPosCpo[1]][aPosCpo[2]]:= IIf(cPaisLoc$"PAR/PER" , NoRound(nFator*nAtual,nDecimais) , nFator*nAtual )
					Else
						nTotAcum += aNfItem[nX][Val(aPosCpo)] := IIf(cPaisLoc$"PAR/PER" , NoRound(nFator*nAtual,nDecimais) , nFator*nAtual )
					EndIf
				Endif
			EndIf
		EndIf
	Next nX

	If !lAuxItem .And. nAtual <> nTotAcum
		If CReferencia == 'IT_BASEICM'
			For NX := 1 To Len(aNfItem)
				lSomadif :=(aNfItem[nx][aPosCpo[1]][aPosCpo[2]]	+ (nAtual-nTotAcum)) <= MaFisRet(nX,"IT_VALMERC")
				IF lSomadif
					If ValType(aPosCpo) == "A"
						aNfItem[nx][aPosCpo[1]][aPosCpo[2]] += (nAtual-nTotAcum)
					Else
						aNfItem[nx][Val(aPosCpo)] += (nAtual-nTotAcum)
					EndIf
					EXIT
				endif
			next nx
		ELSE
			If ValType(aPosCpo) == "A"
				aNfItem[nAuxItem][aPosCpo[1]][aPosCpo[2]] += (nAtual-nTotAcum)
			Else
				aNfItem[nAuxItem][Val(aPosCpo)] += (nAtual-nTotAcum)
			EndIf
		ENDIF
	EndIf
EndIf

Return

/*/
MaFisPreCalc - Alexandre Lemes - 28/12/2012
Utilizar esta funcao para alimentar todos dados necessarios
no array aNFItem ANTES do calculo dos impostos pelas funcoes
de impostos, esta e uma funcao PRE-CALCULO, esta funcao deve
ser utilizada para alimentar qualquer posicao do aNFItem com
essa caracteristica
/*/
Static Function MaFisPreCalc(nItem,cCampo)
DEFAULT cCampo	:= ""

If cPaisLoc == "BRA"
	//Grava o conteudo do campo Codigo de Autorização - CODIF - DIAT-SC
	aNfItem[nItem][IT_CODIF] := aNfItem[nItem][IT_PRD][SB_CODIF]
	aNFitem[nItem][IT_B1DIAT]:= aNfItem[nItem][IT_PRD][SB_PRDDIAT]

	//Atualiza a classificacao fiscal de ICMS
	If !isInCallStack("TSFGRVNF")
		If  cCampo$"IT_PRODUTO/IT_TES"  .Or. Len(Alltrim(aNfitem[nItem][IT_CLASFIS]))<3 .Or. ;
		(aNfitem[nItem][IT_TIPONF] == "D" .And. !Empty(aNFItem[nItem][IT_RECORI]) .And.  aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_CLIFOR] == "C" )

			If aSX6[MV_STFRETE] .And. (AllTrim(aNFCab[NF_ESPECIE]) $ "CTR/CTE/CTA/CTF" .Or. "NFST"$AllTrim(aNFCab[NF_ESPECIE]))
				aNfitem[nItem][IT_CLASFIS] := "0" + aNFItem[nItem][IT_TS][TS_SITTRIB] // Conforme parecer da Consultoria Tributaria emitido no chamado SCSFW2
			Else
				If aNfitem[nItem][IT_TIPONF] == "D" .And. !Empty(aNFItem[nItem][IT_RECORI]) .And. aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_CLIFOR] == "C" .And. aSX6[MV_CSTORI]
					dbSelectArea("SD2")
					MsGoto( aNFItem[nItem][IT_RECORI] )
					aNfitem[nItem][IT_CLASFIS] := SD2->D2_CLASFIS
				Else
					//Se o preco de venda for menor que o preço de pauta não aplica a redução
					//Atende ao Decreto N 51703 DE 31/07/2014 PARA RS
					If ((aPos[FP_F4_RDBSICM] .And. aNFItem[nItem][IT_TS][TS_RDBSICM] == "2") .And. ((aNfItem[nItem][IT_VALMERC] / aNfItem[nItem][IT_QUANT]) < aNfItem[nItem][IT_PAUTIC]))
						aNfItem[nItem][IT_CLASFIS] := aNfItem[nItem][IT_PRD][SB_ORIGEM] + "00"
					Else
						aNfitem[nItem][IT_CLASFIS] := aNfItem[nItem][IT_PRD][SB_ORIGEM] + aNFItem[nItem][IT_TS][TS_SITTRIB]
					EndIf
				EndIf
			EndIf
		Endif
		aNfItem[nItem][IT_LIVRO][LF_CLASFIS] := aNfItem[nItem][IT_CLASFIS]
	EndIF

	//Atualiza Natureza da Operacao/Prestacao.
	aNfItem[nItem][IT_NATOPER] := IIf( aPos[FP_F4_NATOPER] , aNFItem[nItem][IT_TS][TS_NATOPER] , "" )

	//Atualiza Natureza da Receita
	//Por se tratar de Natureza da RECEITA, faco as validacoes apenas para notas fiscais de saida

	If ( aNFCab[NF_TIPONF] $ "DB" .Or. aNFItem[nItem][IT_TS][TS_PODER3] =="D" ) .And. !Empty(aNFItem[nItem][IT_RECORI])
		If aNFCab[NF_TIPONF] $ "DB"
			If ( aNFCab[NF_CLIFOR] == "C")
				dbSelectArea("SD2")
				MsGoto(aNFItem[nItem][IT_RECORI])
				aNfItem[nItem][IT_TABNTRE] := SD2->D2_TNATREC
				aNfItem[nItem][IT_CODNTRE] := SD2->D2_CNATREC
				aNfItem[nItem][IT_GRPNTRE] := SD2->D2_GRUPONC
				aNfItem[nItem][IT_DATNTRE] := SD2->D2_DTFIMNT
			Else
				dbSelectArea("SD1")
				MsGoto(aNFItem[nItem][IT_RECORI])
				aNfItem[nItem][IT_TABNTRE] := SD1->D1_TNATREC
				aNfItem[nItem][IT_CODNTRE] := SD1->D1_CNATREC
				aNfItem[nItem][IT_GRPNTRE] := SD1->D1_GRUPONC
				aNfItem[nItem][IT_DATNTRE] := SD1->D1_DTFIMNT
			EndIf
		EndIf
	Else
		If aNfCab[NF_ROTINA] == "MATA461"  .AND. ((aPos[FP_C6_TNATREC]).And.(aPos[FP_C6_CNATREC]).And.;
				(aPos[FP_C6_GRPNATR]).And. (aPos[FP_C6_DTFIMNT])) .And. !Empty(SC6->C6_TNATREC)
			// Se nao pegou da excecao busca SC6
			aNfItem[nItem][IT_TABNTRE] := SC6->C6_TNATREC
			aNfItem[nItem][IT_CODNTRE] := SC6->C6_CNATREC
			aNfItem[nItem][IT_GRPNTRE] := SC6->C6_GRPNATR
			aNfItem[nItem][IT_DATNTRE] := SC6->C6_DTFIMNT
			// Se nao pegou da SC6 busca SF4
		Elseif ((aPos[FP_F4_TNATREC]).And.(aPos[FP_F4_CNATREC]).And.(aPos[FP_F4_GRPNATR]).And.(aPos[FP_F4_DTFIMNT])) .And. !Empty(SF4->F4_TNATREC)
			aNfItem[nItem][IT_TABNTRE] := SF4->F4_TNATREC
			aNfItem[nItem][IT_CODNTRE] := SF4->F4_CNATREC
			aNfItem[nItem][IT_GRPNTRE] := SF4->F4_GRPNATR
			aNfItem[nItem][IT_DATNTRE] := SF4->F4_DTFIMNT
			// Se nao pegou SF4 busca do SB1
		Elseif ((aPos[FP_B1_TNATREC]).And.(aPos[FP_B1_CNATREC]).And.(aPos[FP_B1_GRPNATR]).And.(aPos[FP_B1_DTFIMNT]))
			aNfItem[nItem][IT_TABNTRE] := aNfItem[nItem][IT_PRD][SB_TNATREC]
			aNfItem[nItem][IT_CODNTRE] := aNfItem[nItem][IT_PRD][SB_CNATREC]
			aNfItem[nItem][IT_GRPNTRE] := aNfItem[nItem][IT_PRD][SB_GRPNATR]
			aNfItem[nItem][IT_DATNTRE] := aNfItem[nItem][IT_PRD][SB_DTFIMNT]
		EndIf

		//Prioridade absoluta de preenchimento (SF7)
		If !Empty(aNFitem[nItem][IT_EXCECAO]) .And. !Empty(aNfItem[nItem][IT_EXCECAO][21]) .And. !Empty(aNfItem[nItem][IT_EXCECAO][22])//Busca pela Excecao
			aNfItem[nItem][IT_TABNTRE] := aNfItem[nItem][IT_EXCECAO][21]
			aNfItem[nItem][IT_CODNTRE] := aNfItem[nItem][IT_EXCECAO][22]
			aNfItem[nItem][IT_GRPNTRE] := aNfItem[nItem][IT_EXCECAO][23]
			aNfItem[nItem][IT_DATNTRE] := aNfItem[nItem][IT_EXCECAO][24]
		EndIf
	EndIF

EndIf

//Atualiza o preco unitario do item.
//Alteração feita em conjunto com Materiais e Faturamento, para que seja possível informar quantidade no complemento de preço
If (aNFitem[nItem][IT_TIPONF ]$"PI" .OR. (aNFitem[nItem][IT_TIPONF ]=="C" .AND. aNfCab[NF_TPCOMPL] <> '2' )  ).And. (cPaisLoc == "BRA" .Or. aTes[TS_QTDZERO] == "1")
	aNfItem[nItem][IT_PRCUNI]  := aNfItem[nItem][IT_VALMERC]
Elseif aNFitem[nItem][IT_TIPONF ]$"DB" .And. cPaisLoc == "PAR" .And. aSX6[MV_DESCSAI]=='1' .And. Alltrim(cFunName) == "MATA465N" .And. ( aNFitem[nItem][IT_DESCONTO] > 0 .OR.  aNFitem[nItem][IT_DESCTOT] > 0 ) .And. cCampo <> "IT_TES"
	aNFitem[nItem][IT_VALMERC] -= (aNFitem[nItem][IT_DESCONTO]+aNFitem[nItem][IT_DESCTOT])
	aNFitem[nItem][IT_PRCUNI]  := aNFitem[nItem][IT_VALMERC]/Max(aNFitem[nItem][IT_QUANT],1)
EndIf

If cPaisLoc == "URU"
   aNfItem[nItem][IT_TOTAL]  := aNfItem[nItem][IT_VALMERC]
EndIf

If cPaisLoc == "ARG" .And. (cCampo == "IT_VALMERC") .And. aNfCab[NF_OPERNF] =='E' .And. Alltrim(FunName()) $ "MATA465N"
	If aNfCab[NF_OPERNF] =='S'
		nPosDes := aScan(aHeader, {|x| Alltrim(x[2]) == "D2_DESC"})
	Else
		nPosDes := aScan(aHeader, {|x| Alltrim(x[2]) == "D1_DESC"})
	EndIf
	If aCols[nItem][nPosDes] > 0
		aNFitem[nItem][IT_DESCONTO] := aNFitem[nItem][IT_VALMERC] * (aCols[nItem][nPosDes]/100)
	EndIf
EndIf

Return Nil

/*/
MaFisVDescZF - Edson Maricate - 08.12.1999
Executa o calculo do Valor do Desconto da ZF.
Retorno
ExpN1: Item.
/*/
Static Function MaFisVDescZF(nItem)
Local nOldVlr  := aNfItem[nItem][IT_DESCZF]
Local lConsumo := aNFItem[nItem][IT_TS][TS_CONSUMO] == "S"
Local lExecuta := .T.
Local cUFCliFor := xFisCodIBGE(IIf(aNfCab[NF_OPERNF] == "S", aNfCab[NF_UFDEST], aNfCab[NF_UFORIGEM]))
Local cMunZFMALC := "1100106|1100304|1200203|1200104|1200252|1302603|1303569|1303536|1304062|1400456|1400100|1400159|1600303|1600600|"
/*
Foram consideradas as fontes abaixo para compor a lista dos municípios que formam a ZFM , ALCs e COREs que pertencam a zona incentivada
http://www.suframa.gov.br/suframa_fale_conosco_faq_internamento.cfm
http://www.suframa.gov.br/invest/zona-franca-de-manaus-alc.cfm
http://site.suframa.gov.br/assuntos/modelo-zona-franca-de-manaus/area-de-beneficios
http://tdn.totvs.com/pages/releaseview.action?pageId=336409606
*/

// Flag p/ determinar operacao interna na ZFM/ALC para definir se o ICMS deve ou nao ser descontado.
// Atencao: Eh interna em relacao aos municipios que fazem parte da ZFM/ALC/CORE e nao interna em relacao aos estados!
Local lIntALCZFM := AllTrim(aNFCab[NF_M0CODMUN]) $ cMunZFMALC .And. AllTrim(cUFCliFor+aNfCab[NF_CODMUN]) $ cMunZFMALC .AND. substr(aNfItem[nItem][IT_CF],1,1) == "5"

If aNFCab[NF_TIPONF] $ "DB" .Or. aNFItem[nItem][IT_TS][TS_PODER3] == "D"
	If !Empty(aNFItem[nItem][IT_RECORI])
		If aNFCab[NF_TIPONF] $ "DB"
			If aNFCab[NF_CLIFOR] == "C" .And. cPaisLoc == "BRA"
				dbSelectArea("SD2")
				MsGoto(aNFItem[nItem][IT_RECORI])
				If SD2->D2_DESCZFR > 0
					aNfItem[nItem][IT_DESCZF]:=  (SD2->D2_DESCZFR/SD2->D2_QUANT) * (aNfItem[nItem][IT_QUANT]) //(((aNfItem[nItem][IT_BASEICM] / (1-(SD2->D2_PICM/100)) ) * SD2->D2_PICM ) / 100 )
				EndIf
				If SD2->D2_DESCZFP > 0
					aNfItem[nItem][IT_DESCZFPIS]:=(SD2->D2_DESCZFP/SD2->D2_QUANT)* (aNfItem[nItem][IT_QUANT])
				EndIf
				If SD2->D2_DESCZFC > 0
					aNfItem[nItem][IT_DESCZFCOF]:=(SD2->D2_DESCZFC/SD2->D2_QUANT)* (aNfItem[nItem][IT_QUANT])
				EndIf

				//Se for devolução de venda para Zona Franca de Manaus, e houver calculado desconto do ICMS, irei zerar a base de cálculo e valor
				//pois na saída não houve o cálculo do ICMS, logo na devolução também não deve ter o cálculo, desta forma a informação do ICMS não
				//será gravada na CD2, resolvendo assim o erro "610  Total da NF difere do somatório dos Valores que compõe o Valor Total da NF"
				//na transmissão da NFE.
				IF aNfItem[nItem][IT_DESCZF] > 0 .And. SD2->D2_VALICM == 0
					aNfItem[nItem][IT_BASEICM] := 0
					aNfItem[nItem][IT_VALICM]  := 0
				EndIF

				lExecuta := .F.
			EndIf
		EndIf
	EndIf
EndIf

If lExecuta

	If aNFItem[nItem][IT_TS][TS_CONSUMO] == " " // Garante se o produto na operacao eh material de consumo mesmo que na TES nao tenha sido informado
		If (aNFItem[nItem][IT_TS][TS_INCIDE] == "S" .Or. (aNFItem[nItem][IT_TS][TS_INCIDE] == "F" .And. aNFCab[NF_TPCLIFOR] == "F" .And. aNFCab[NF_CLIFOR] == "C" )) .And.;
			( Substr(aNfItem[nItem][IT_CF],2,3)$"91 /92 /97 " .Or. (Substr(aNfItem[nItem][IT_CF],2,2) $ "55" .And. Substr(aNfItem[nItem][IT_CF],4,1)<>" ")) .And. aNFItem[nItem][IT_TS][TS_IPI] <> "R"
			lConsumo := .T.
		Endif
	EndIf

	If aNfCab[NF_CLIFOR] == "C" .And. aNfCab[NF_SUFRAMA] .And. !aNFitem[nItem][IT_TIPONF ] $ "BD" .And. !aNfCab[NF_LINSCR] .And. ;
		aNfItem[nItem][IT_PRD][SB_IMPZFRC] $ " N" .And. aNFItem[nItem][IT_TS][TS_ISS] <> "S" .And. aNFItem[nItem][IT_TS][TS_ICM] == "S" .And. !lConsumo .And. aSX6[MV_DESCZF] .And.;
		( aNfCab[NF_OPERNF] == "S" .And. aNfCab[NF_TPCLIFOR] <> "F" ) .And. aNfCab[NF_CNPJ] <> SM0->M0_CGC .And. !lIntALCZFM
		aNfItem[nItem][IT_DESCZF]  := NoRound(aNfItem[nItem][IT_VALICM],2)
		MaItArred(nItem,{"IT_DESCZF"})
		aNfItem[nItem][IT_BASEICM] := 0
		aNfItem[nItem][IT_VALICM]  := 0

		If aNfCab[NF_ROTINA] $ "MATA461|FATA701" .Or. FunName() == "MATA920"
			aNfItem[nItem][IT_VALMERC] -= ( aNfItem[nItem][IT_DESCZF]) -  nOldVlr
			If aNfCab[NF_TIPONF] $ "CPI" .And. FunName() == "MATA920"
				aNfItem[nItem][IT_PRCUNI]:= ( aNfItem[nItem][IT_VALMERC] - (aNfItem[nItem][IT_DESCONTO]+ aNfItem[nItem][IT_DESCTOT]) )
			Else
				aNfItem[nItem][IT_PRCUNI]:= ( aNfItem[nItem][IT_VALMERC] - (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT]) ) / aNfItem[nItem][IT_QUANT]
			EndIf
		EndIf

	Else

		aNfItem[nItem][IT_DESCZF] := 0

	EndIf

	aNfItem[nItem][IT_DESCZFPIS] := 0
	aNfItem[nItem][IT_DESCZFCOF] := 0

EndIf

Return

/*/
 MaFisVTot - Edson Maricate -13.12.1999
 Atualiza os valores totais do item
/*/
Function MaFisVTot(nItem)

Local alAreaX   := {}
Local alAreaY   := {}
Local nImp      := 0
Local nValImp   := 0
Local nImposto  := 0
Local lDescInc  := (cPaisLoc <> "BRA" .And. aNfCab[NF_OPERNF]=="S" .And. aSX6[MV_DESCSAI]=='1')
Local nAgrPisPas:= IIf( aTes[TS_AGRPIS] == "1" .And. aTes[TS_PSCFST]  <> "1" , aNfItem[nItem,IT_VALPS2] , 0 ) + IIf( aTes[TS_AGRCOF] == "1" .And. aTes[TS_PSCFST] <> "1" , aNfItem[nItem,IT_VALCF2] , 0 )
Local nPisCofST := IIf( aTes[TS_PSCFST] == "1" .And. aTes[TS_APSCFST] == "1" , aNfItem[nItem,IT_VALPS3] + aNfItem[nItem,IT_VALCF3] , 0 ) // Pis/Cofins ST - sera somado ao total do documento
Local nFretAut  := IIf( !aSX6[MV_FRETAUT] , 0 , aNfItem[nItem][IT_VALICA] )
Local lDSenarEnt	:= .F.
Local lDSenarSai	:= .F.
Local lIsInclui		:= .F.

If cPaisLoc $ "ARG|MEX|PER|COL|VEN" .And. isMemVar("Inclui")
	If Inclui
		lIsInclui := .T.
	EndIf
EndIf

If cPaisLoc $ "MEX|ARG|PER|COL|VEN"
	cFunName := Iif(Type("cFunName")=="U",Upper(AllTrim(FunName())),cFunName)
	If (cPaisLoc == "MEX" .and. Alltrim(cFunName) == "MATA465N" .And. aSX6[MV_DESCDVI] == .F. .And. aSX6[MV_DESCSAI] == "1") .or. ;
	   (cPaisLoc $ "ARG|MEX|PER|COL|VEN" .and. Alltrim(cFunName) $ "MATA465N|MATA462DN" .And. aSX6[MV_DESCSAI] == "1")
		lDescInc := .T.
	EndIf
EndIf

Do Case
Case aNFitem[nItem][IT_TIPONF ] == "P"
	aNfItem[nItem][IT_TOTAL]	:= aNfItem[nItem][IT_FRETE] + IIf(aTes[TS_DESPICM] == "3",0,aNfItem[nItem][IT_DESPESA]) + IIf(aTes[TS_DESPICM] == "3",0,aNfItem[nItem][IT_SEGURO])+;
		aNfItem[nItem][IT_VALIPI]+IIf(aTes[TS_INCSOL]$"A,N,D",0,aNfItem[nItem][IT_VALSOL])+;
		aNfItem[nItem][IT_VALEMB]+nFretAut+nAgrPisPas+nPisCofST+;
		aNfItem[nItem][IT_DESNTRB]+aNfItem[nItem][IT_TARA]+;
		aNfItem[nItem][IT_ACRESCI]
OtherWise
	Do Case
	Case aTes[TS_AGREG] == "N"
		aNfItem[nItem][IT_TOTAL]	:= aNfItem[nItem][IT_FRETE] + IIf(aTes[TS_DESPICM] == "3",0,aNfItem[nItem][IT_DESPESA]) + IIf(aTes[TS_DESPICM] == "3",0,aNfItem[nItem][IT_SEGURO])+;
			IIf(aTes[TS_IPI] == 'R',0,aNfItem[nItem][IT_VALIPI]) + IIf(aTes[TS_INCSOL]$"A,N,D",0,aNfItem[nItem][IT_VALSOL])+;
			aNfItem[nItem][IT_VALEMB]+nAgrPisPas+nPisCofST+;
			aNfItem[nItem][IT_DESNTRB]+aNfItem[nItem][IT_TARA]+;
			aNfItem[nItem][IT_ACRESCI]
		aNfItem[nItem][IT_VNAGREG] := aNfItem[nItem][IT_VALMERC]-(aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT])
	Case aTes[TS_AGREG] == "I" .Or. aTes[TS_AGREG] == "B"
		aNfItem[nItem][IT_TOTAL]	:= aNfItem[nItem][IT_VALMERC] + aNfItem[nItem][IT_FRETE] + IIf(aTes[TS_DESPICM] == "3",0,aNfItem[nItem][IT_DESPESA]) + IIf(aTes[TS_DESPICM] == "3",0,aNfItem[nItem][IT_SEGURO])+;
			IIf(aTes[TS_IPI] == 'R',0,aNfItem[nItem][IT_VALIPI])+ IIf(aTes[TS_INCSOL]$"A,N,D".And.aTes[TS_ICM]<>"N",0,aNfItem[nItem][IT_VALSOL]) - IIf(lDescInc,0,(aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT]))+;
			If(aNFitem[nItem][IT_TIPONF ]<>"I",aNfItem[nItem][IT_VALICM]+(Iif(aNfCab[NF_PPDIFAL],aNfItem[nItem][IT_DIFAL]+aNfItem[nItem][IT_VALCMP]+aNfItem[nItem][IT_VFCPDIF],0)),0) + aNfItem[nItem][IT_VALEMB]+nFretAut+nAgrPisPas+nPisCofST+;
			aNfItem[nItem][IT_DESNTRB]+aNfItem[nItem][IT_TARA] + aNfItem[nItem][IT_AFRMIMP]+;
			aNfItem[nItem][IT_ACRESCI]
			aNfItem[nItem][IT_VNAGREG] := 0
			If	(AllTrim(aNFCab[NF_ESPECIE]) $ "CTR/CTE" .Or. "NFST"$AllTrim(aNFCab[NF_ESPECIE]))
				If aTes[TS_CRPRST] <> 0  .And. !(aTes[TS_INCSOL] $ "A,N,D" .And. aTes[TS_ICM] <> "N")
					aNfItem[nItem][IT_TOTAL] += 	(aNfItem[nItem][IT_VLCSOL] - aNfItem[nItem][IT_VALSOL])
				EndIf
			EndIf
			// Se o parâmetro está habilitado significa que não foi informado o II com o Valor Aduaneitro, então devo somar para que fique no total da NF.
            IF aSX6[MV_EIC0064]
                 aNfItem[nItem][IT_TOTAL] += aNfItem[nItem][IT_VALII]
            EndIf
	OtherWise
			aNfItem[nItem][IT_TOTAL]	:= aNfItem[nItem][IT_VALMERC] + aNfItem[nItem][IT_FRETE] + ;
			IIf(aTes[TS_DESPICM] == "3" .Or. aTes[TS_DESPICM] == "4" , 0 , aNfItem[nItem][IT_DESPESA] ) + ;
			IIf(aTes[TS_DESPICM] == "3", 0 , aNfItem[nItem][IT_SEGURO] ) +;
			IIf(aTes[TS_IPI] == 'R', 0 , aNfItem[nItem][IT_VALIPI]) + ;
			IIf(aTes[TS_INCSOL]$"A,N,D" , 0 ,aNfItem[nItem][IT_VALSOL] ) + ;
			IIf((aNFitem[nItem][IT_TIPONF ]$"DB" .And. cPaisLoc =="PAR" .And. aSX6[MV_DESCSAI] == "1" ), (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT]) , 0 ) - ;
			IIf(lDescInc, 0, IIf(cPaisLoc $ "PER|MEX|VEN" .And. !lIsInclui  .And. AllTrim(FunName()) $ "MATA467N|MATA462N|MATA465N|MATA102DN", 0,(aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT])))+;			
			aNfItem[nItem][IT_VALEMB]+nFretAut + nAgrPisPas + nPisCofST+;
			aNfItem[nItem][IT_DESNTRB]+aNfItem[nItem][IT_TARA]+;
			aNfItem[nItem][IT_ACRESCI]
			aNfItem[nItem][IT_TOTAL] := aNfItem[nItem][IT_TOTAL] + IIF (cPaisLoc == "MEX" .and. AllTrim(FunName()) $ "MATA466N" .And. !lIsInclui .And. aSX6[MV_DESCSAI]=='2' .And. aNfCab[NF_TIPODOC] $ "07|06",(aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT]),0)

			IF cPaisLoc == "ARG" .And. lDescInc .And. Alltrim(cFunName) == "MATA465N" .And. Alltrim(cEspecie) == "NCC" .And. aSX6[MV_DESCSAI] == "1" .And. Empty(aNfItem[nItem][IT_NFORI])
				aNfItem[nItem][IT_TOTAL]	-= aNfItem[nItem][IT_DESCONTO]
			EndIf

			//Indica se o valor da deducao sera agregado ao Total da NF ou nao, em conj TS_AGREG = D ou R
			//Conforme Anexo IV, item 8 letra B e item B5 do RICMS MG
			//TS_AGRDRED = "1" - Agrega o valor da deducao
			//TS_AGRDRED = "2" - Abate o valor da deducao, como ja era feito antes da implementacao
			If aTes[TS_AGREG]$"DR" .And. aTes[TS_AGRDRED]=="1"
				aNfItem[nItem][IT_TOTAL]	+= IIf(Empty(aNfItem[nItem][IT_RECORI]) .Or. aTes[TS_AGREG]$"DR" , aNfItem[nItem][IT_DEDICM] , 0 )
			ElseIf aTes[TS_AGREG]$"DR" .And. (aTes[TS_AGRDRED]=="2" .Or. Empty(aTes[TS_AGRDRED]))
				aNfItem[nItem][IT_TOTAL]	-= IIf(Empty(aNfItem[nItem][IT_RECORI]) .Or. aTes[TS_AGREG]$"DR" , aNfItem[nItem][IT_DEDICM] , 0 )
			EndIf

			aNfItem[nItem][IT_VNAGREG] := 0
	EndCase
EndCase

//Adiantamento - Mexico
If cPaisLoc == "MEX" .And. aPos[FP_D2_VALADI]
	aNfItem[nItem][IT_TOTAL] -= aNfItem[nItem][IT_ADIANT]
EndIf

//Adiantamento - Peru
If cPaisLoc == "PER" .and. aPos[FP_F1_ADIANT]
	aNfItem[nItem][IT_TOTAL] -= aNfItem[nItem][IT_ADIANTTOT]
EndIf

aNfItem[nItem][IT_TOTAL] += Iif(aTes[TS_AGRPIS] == "P" , aNFitem[nItem][IT_VALPS2] , 0 ) + Iif(aTes[TS_AGRCOF]=="C",aNFitem[nItem][IT_VALCF2],0)
aNfItem[nItem][IT_TOTAL] -= Iif(aTes[TS_AGRPIS] == "D" , aNFitem[nItem][IT_VALPS2] , 0 ) + Iif(aTes[TS_AGRCOF]=="D",aNFitem[nItem][IT_VALCF2],0)
aNfItem[nItem][IT_TOTAL] += Iif(aTes[TS_AGRISS] == "1", aNFitem[nItem][IT_VALISS], 0)

If aTes[TS_AGRPIS]=="P" .And. aTes[TS_AGRCOF]=="C" .And. (aTes[TS_AGREG]=="I" .Or. aTes[TS_AGREG]=="A") .And. !aTes[TS_INTBSIC]$"123"
	If Abs( NoRound(aNfItem[nItem][IT_BASEICM],2) - NoRound(aNfItem[nItem][IT_TOTAL],2) ) == 0.01
		aNfItem[nItem][IT_TOTAL] := aNfItem[nItem][IT_BASEICM]
	EndIf
EndIf
//ICMS Diferido Incentivo abate de gado - o valor diferido sera somado ao total da NF e a duplicata
If aTes[TS_PICMDIF]<>0 .And. aTes[TS_ICMSDIF]=="4"
	aNfItem[nItem][IT_TOTAL] += aNfItem[nItem][IT_ICMSDIF]
EndIf

//Decreto nro 43.080/02
If aNfItem[nItem][IT_BSSEMDS] > 0
	aNfItem[nItem][IT_TOTAL] -= ( aNfItem[nItem][IT_ICSEMDS] - aNfItem[nItem][IT_VALICM] )
EndIf

If	aNFItem[nItem][IT_TS][TS_AGRPEDG] <> "3" .And. aNfItem[nItem][IT_VALPEDG] > 0
	aNfItem[nItem][IT_TOTAL] += aNfItem[nItem][IT_VALPEDG]
EndIf

// Calcula ICMS Diferido e Desconta na NF e Fatura
If aNFItem[nItem][IT_TS][TS_ICMSDIF] == "6"
	aNfItem[nItem][IT_TOTAL] 	-= aNfItem[nItem][IT_ICMSDIF]
EndIf //issue DSERFIS1-8601	



aNfItem[nItem][IT_BASEDUP] := 0

If aTes[TS_DUPLIC] <>"N" .Or. lCalculPCC
	aNfItem[nItem][IT_BASEDUP] := aNfItem[nItem][IT_TOTAL]
	If aSX6[MV_DPAGREG] .And. aTes[TS_AGREG] == "N"
		aNfItem[nItem][IT_BASEDUP] += aNfItem[nItem][IT_VALMERC]
	EndIf
	If aTes[TS_AGREG]=="G"
		aNfItem[nItem][IT_BASEDUP] += aNfItem[nItem][IT_VALICM] - aNfItem[nItem][IT_BASEDUP]
		If aTes[TS_OPERSUC]=="1" .And. aNfCab[NF_SIMPSC]<>"1" .And. aNFCab[NF_SIMPNAC]<>"1" .And. nAgrPisPas > 0
			aNfItem[nItem][IT_BASEDUP] -= ((nAgrPisPas * aNfItem[nItem][IT_ALIQICM]) /100)
			aNfItem[nItem][IT_BASEDUP] += nAgrPisPas
		Endif
	EndIf
	If aTes[TS_AGREG]=="H"
		aNfItem[nItem][IT_BASEDUP] += (aNfItem[nItem][IT_VALSOL]+aNfItem[nItem][IT_VALIPI]) - aNfItem[nItem][IT_BASEDUP]
	EndIf
	If aTes[TS_AGREG]=="F"
		aNfItem[nItem][IT_BASEDUP] -= aNfItem[nItem][IT_VALMERC]
	EndIf
	If aNFitem[nItem][IT_TIPONF ]=='I'
		aNfItem[nItem][IT_BASEDUP]	-= aNfItem[nItem][IT_VALICM]
	EndIf
	If aTes[TS_PICMDIF]<>0 .And. aTes[TS_ICMSDIF]$" ,1,2" .And. aTes[TS_ICM] == "S"
		MaItArred(nItem, { "IT_ICMSDIF" } )
		aNfItem[nItem][IT_BASEDUP]	-= aNfItem[nItem][IT_ICMSDIF]
	EndIf
	If (aNfCab[NF_RECISS]=="1".And. aSX6[MV_DESCISS] .And. aNfCab[NF_OPERNF]=="S".And. aSX6[MV_TPABISS]=="1")
		If (aNfItem[nItem][IT_VALISS] > aSX6[MV_VRETISS]) .OR.;
			aTes[TS_FRETISS] == "2" .And. IIF(aPos[FP_A1_FRETISS],IIF(aNfCab[NF_FRETISS] == "2",.T.,.F.),.F.)
			aNfItem[nItem][IT_BASEDUP]	-= aNfItem[nItem][IT_VALISS]
		EndIf
	EndIf
	If aTes[TS_INCSOL]=="D"
		aNfItem[nItem][IT_BASEDUP]	-= aNfItem[nItem][IT_VALSOL]
	EndIf
	If aTes[TS_AGREG]=="E"
		aNfItem[nItem][IT_BASEDUP]	-= aNfItem[nItem][IT_DEDICM]
	EndIf

	
	//Fundersul - sera reduzido do total da duplicata
	If cPaisLoc =="BRA" .And.  aTes[TS_CLFDSUL] == "1"
		aNfItem[nItem][IT_BASEDUP]	-= aNfItem[nItem][IT_VALFDS]
	Endif

	//Funrural - Abate valor da Duplicata quando é devolução de compra.
	If aNfCab[NF_TIPONF] == "D" .And. aNfItem[nItem][IT_BASEFUN] > 0 .And. aNfCab[NF_OPERNF] == "S"
		aNfItem[nItem][IT_BASEDUP] -= aNfItem[nItem][IT_FUNRURAL]	
	EndIF



	//Saída   - So desconta quando eu não pago;So não irei descontar no valor do titulo, se o comprador for pessoa Juridica, pois só não pagarei se o cliente for Juridico.
	//Entrada - So desconta quando eu pago; So desconto no valor do titulo, se o vendedor for pessoa Fisica, pois só pagarei, se eu for pessoa Juridica e estiver comprando de pessoa fisica.
	//Caso o senar seja deduzido do valor total da duplicada, quando ocorrer a devolução também deverá deduzir, para que a operação seja anulada corretamente.
	lDSenarSai	:=  cPaisLoc =="BRA" .AND. SM0->M0_PRODRUR$"FL13"	     .And. Iif(Len(Alltrim(aNfCab[NF_CNPJ]))< 14,"F","J") == "J"
	lDSenarEnt	:=  cPaisLoc =="BRA" .AND. RetPessoa(SM0->M0_CGC) $ "J" .And. (Iif(Len(Alltrim(aNfCab[NF_CNPJ]))< 14,"F","J") == "F" .Or. aNfCab[NF_TIPORUR] == "F")
	If cPaisLoc =="BRA" .And. aTes[TS_ALSENAR] > 0 .And. (!(aNfCab[NF_TPCLIFOR]$"X")) .And. ;
	   ( (aNfCab[NF_OPERNF] == "S" .And. lDSenarSai ) .OR. ;										//Deduz na venda
	     (aNfCab[NF_OPERNF] == "E" .And. lDSenarEnt)  .OR. ;	     								//Deduz na compra
	     (Alltrim(aNfCab[NF_TIPONF]) $ "DB" .AND. aNfCab[NF_OPERNF] == "E" .AND. lDSenarSai) .OR.;	//Se deduziu senar na venda também deverá deduzir senar na devolução de venda
	     (Alltrim(aNfCab[NF_TIPONF]) $ "DB" .AND. aNfCab[NF_OPERNF] == "S" .AND. lDSenarEnt)  )		//Se deduziu senar na compra também deverá deduzir senar na devolução de compra
		aNfItem[nItem][IT_BASEDUP]	-= aNfItem[nItem][IT_VLSENAR]
	Endif

	If cPaisLoc =="BRA" .And.  aNfItem[nItem][IT_VLINCMG] > 0
		aNfItem[nItem][IT_BASEDUP]	+= aNfItem[nItem][IT_VLINCMG]
	Endif

Else
	//O F4_DUPLIST e utilizado para gerar um titulo somente com o valor
	//do ICMS-ST e foi implementado no MATA461 para NF de Remessa na
	//saida, aqui foi implemntado para notas fiscais de entrada respeitan
	//do o mesmo conceito utilizado na saida de gerar o titulo somente se
	//Gera Duplicatas F4_DUPLIC estiver = NAO
	If aNfCab[NF_OPERNF] == "E" .And. aTes[TS_DUPLIST] == "1"
		aNfItem[nItem][IT_BASEDUP] += aNfItem[nItem][IT_VALSOL]
	EndIf
	//O F4_DUPLIPI tem o mesmo efeito do F4_DUPLIST, porém para o IPI
	If aNfCab[NF_OPERNF] == "E" .And. aTes[TS_DUPLIPI] == "1"
		aNfItem[nItem][IT_BASEDUP] += aNfItem[nItem][IT_VALIPI]
	EndIf
EndIf
// Verifica se a TES possui tratamento para Impostos Variaveis
If !Empty(aTes[TS_SFC])
	For nImposto := 1 to Len(aTes[TS_SFC])
		nImp := NumCpoImpVar(RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1))
		If  aTes[TS_DUPLIC] <> "N" .And. aNFitem[nItem][IT_TIPONF ]<>'B'
			Do Case
				Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="1"
					nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
				Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="2"
					nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
				Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="3"
					nValImp:=0
			EndCase
			aNfItem[nItem][IT_BASEDUP] += nValImp
		Endif

		Do Case
			Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="1"
				nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
			Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="2"
				nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
			Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="3"
				nValImp:=0
		EndCase
		aNfItem[nItem][IT_TOTAL] += nValImp
	Next nImposto
EndIf

IF xFisGrossIR(nItem, aNFItem, aNfCab, "DUP") //Verifica se deverá considerar GrossUp do IRRF na BaseDup
	aNfItem[nItem][IT_BASEDUP] 	:= aNfItem[nItem][IT_BASEDUP] / ( 1 - ( aNfItem[nItem][IT_ALIQIRR] / 100 ) )
EndIF
//          TRATAMENTO EXPECIFICO PARA LOCALIZADO PERU
// Quando o cálculo do ISC for por unidade, ou seja, se houver
// alguma exceção fiscal,  o valor do campo especifico FF_VLRISC > 0
// é gravado no campo customizado D1_VLRISC ou D2_VLRISC.
// Se não houver nenhuma exceção fiscal, mas no produto o valor do
// campo especíco B1_VLRISC  > 0 então no campo especifico D1_VLRISC
// ou D2_VLRISC é gravado o seu valor.
// Caso não seja nenhuma das opções anteriores o valor do campo é ze-
// rado.

If cPaisLoc $ "PER"
	alAreaX := SFC->(GetArea())
	alAreaY := SFF->(GetArea())
	aNfItem[nItem][IT_VLRISC] := 0
	SFC->(DbSetOrder(2))
	If SFC->(MsSeek(xFilial("SFC")+aNfItem[nItem][IT_TES]+"ISC"))
		SFF->(DbSetOrder(3))
		If SFF->(MsSeek(xFilial("SFF")+SFC->FC_IMPOSTO)) .And. SFF->FF_VLRISC > 0
			aNfItem[nItem][IT_VLRISC] := SFF->FF_VLRISC
		EndIf
		If aNfItem[nItem][IT_VLRISC] = 0 .And. aNfItem[nItem][IT_PRD][SB_VLRISC] > 0
			aNfItem[nItem][IT_VLRISC] := aNfItem[nItem][IT_PRD][SB_VLRISC]
		EndIf
	EndIf
	RestArea(alAreaX)
	RestArea(alAreaY)
EndIf

Return

/*/
MaFisCFO- Edson Maricate -13.12.1999
Processa o Codigo Fiscal do item especificado
Sintaxe   ExpC1 := MaFisCFO(ExpN1,ExpC2,[ExpA1])
Parametros
ExpN1: Item
ExpC2: Codigo Fiscal Original ( Opcional )
ExpA1: Array de parametros opcional a ser enviado quando a funcao e chamada de fora da matxfis. Estrutura:
1 - Identificador do parametro ( mnemonico )
2 - Conteudo
Retorno ExpC1: Codigo Fiscal de Operacao
/*/
Function MaFisCFO(nItem,cAuxCF,aDados)

Local cCfo	    := IIf( cAuxCF == Nil , aTes[TS_CF] , cAuxCF )
Local cRetCF    := ""
Local cOperNf   := ""
Local cTpCliFor := ""
Local cMVEstado	:= ""
Local cUfOrigem := ""
Local cUfDest   := ""
Local cTpComp   := ""
Local cInscri   := ""
Local cRestoCfo := ""
Local cContr	:= ""
Local cConvCfo	:= ""
Local lInscrito := .T.
Local lUsaCfps	:= .F.
Local nX        := 0
Local cUfCliDest:= ""
Local cCltdest  := ""
Local cEspecie  := ""
Local cCfoTES	:= ""

// Ao utilizar o Protheus com varias Filiais e possivel que em alguns processos como o de inclusao de Notas Fiscais o usuario altere
// a filial atraves da Dialog de seleçao de filiais, com isso se faz necessario que os parametros SX6 sejam novamente carregados para
// a filial corrente refazendo o cache realizado na variavel aSX6, esta nova carga e controlada pela variavel cSX6FilAnt
If cSX6FilAnt <> cFilAnt
	aSX6 := GParMxFis(@cSX6FilAnt)
EndIf

cMVEstado := aSX6[MV_ESTADO]
cUfOrigem := cMVEstado
lUsaCfps  := aSX6[MV_USACFPS]
cConvCfo  := aSX6[MV_CONVCFO]
cCfoTES   := aSX6[MV_CFOTES] //Define CFOPs que não sofrerão alteração, sera o cadastrado da SF4

If cCfo == "99943" //-- CFOP TMS
	cCodCli := aNfCab[NF_CODCLIFOR]
	cLojCli := aNfCab[NF_LOJA]
	cSegCli := Posicione("SA1",1,xFilial("SA1")+cCodCli+cLojCli,"A1_SATIV1")
	If !Empty(cSegCli)
		cCfo := Posicione("DY5",2,xFilial("DY5")+cSegCli,"DY5_CF")
	EndIf
EndIf

If ValType( aDados ) == "A"

	cUfOrigem := cMVEstado
	cUfDest   := cMVEstado

	For nX := 1 To Len(aDados)
		Do Case
			Case aDados[nX, 1] == "OPERNF"
				cOperNF   := aDados[nX, 2]
			Case aDados[nX, 1] == "TPCLIFOR"
				cTpCliFor := aDados[nX, 2]
			Case aDados[nX, 1] == "UFORIGEM"
				cUfOrigem := aDados[nX, 2]
			Case aDados[nX, 1] == "UFDEST"
				cUfDest   := aDados[nX, 2]
			Case aDados[nX, 1] == "TPCOMP"
				cTpComp   := aDados[nX, 2]
			Case aDados[nX, 1] == "INSCR"
				cInscri   := aDados[nX, 2]
				lInscrito := !(Empty(cInscri).Or."ISENT" $ cInscri)
			Case aDados[nX, 1] == "CONTR"
				cContr    := aDados[nX, 2]
		EndCase
	Next nX

	If Len(aDados)> 5
		If aPos[FP_F4_VENPRES]
			If SF4->F4_VENPRES == "1" .And. aDados[2][2] == "F" .And. aDados[1][2] == "S" .And. aDados[6][2] == "S"
				cUfDest := cUfOrigem
			EndIf
		EndIf
	EndIf

	//Verifica a indicacao de contribuinte ou nao do ICMS pelo cadastro do Cliente
	If !Empty(cContr)
		// Contribuinte
		If cContr == "1"
			lInscrito := .T.
			// Nao Contribuinte
		ElseIf cContr == "2"
			lInscrito := .F.
		Endif
	Endif

Else

	If aNFCab[NF_TIPONF] <> "B"
		cUfOrigem := aNfCab[NF_UFORIGEM]
	Else
		If (aTes[TS_PODER3] == "D" .Or. aTes[TS_PODER3] == "R" .Or. aTes[TS_PODER3] == "N") .And. aNfCab[NF_OPERNF] == "E"
			cUfOrigem := aNfCab[NF_UFORIGEM]
		EndiF
	EndIf

	cOperNf  := aNfCab[NF_OPERNF]
	cTpCliFor:= aNfCab[NF_TPCLIFOR]
	cUfDest  := aNfCab[NF_UFDEST]
	cTpComp  := aNfCab[NF_TPCOMP]
	lInscrito:= !aNfCab[NF_LINSCR]
	cCltdest  := aNfCab[NF_CLIDEST]
	cUfCliDest := aNfCab[NF_UFCDEST]
	cEspecie := aNfCab[NF_ESPECIE]

EndIf

cRestoCfo := SubStr(cCfo,2,Len(cCfo)-1)

IF aTes[TS_VENPRES] == "1" .And. aNfCab[NF_TPCLIFOR] == "F" .And. aNfCab[NF_OPERNF] == "S" .And. aNfCab[NF_TPFRETE] == "S"
	aNfCab[NF_UFDEST] := aNfCab[NF_UFORIGEM]
	cUfDest := cUfOrigem
	// Se houver alteração do estado de destino reposiciono a tabela CFC UF x UF.
	MaSeekCFC(2,nItem)
EndIf

If cPaisLoc == "BRA"
	If SubStr(cCfo,1,3) == "999" .Or. SubStr(cCfo,1,3) == "000" .Or. SubStr(cCfo,1,4) $ "1601#1602#5601#5602#1664#2664#5664#5665#5666#6664#6665#6666"+cCfoTES
		cRetCF := cCfo
	Else
		If cOperNf == "E"
			If (cUfOrigem == "EX" .Or. cTpCliFor == "X" .Or. cUfDest == "EX") .And. !(SubStr(cCfo,1,4) $ "1663#2663")
				cRetCF := "3"
			Else
				/*==========================================================|
				|CA  |	CONHECIMENTO AEREO                                  |
				|CTA |	CONHECIMENTO DE TRANSPORTE AQUAVIARIO               |
				|CTE |	CONHECIMENTO DE TRANSPORTE ELETRONICO               |
				|CTF |	CONHECIMENTO DE TRANSPORTE FERROVIARIO              |
				|CTM |	CONHECIMENTO DE TRANSPORTE MULTIMODAL DE CARGAS     |
				|CTR |	CONHECIMENTO DE TRANSPORTE RODOVIARIO               |
				|NFST|	NOTA FISCAL DE SERVICO DE TRANSPORTE                |
				|==========================================================*/
				
				If (AllTrim(cEspecie) $ "CTR/CTE/CTA/CA/CTF") .Or. ("NFST" $ AllTrim(cEspecie))
					If (Empty(cCltdest) .And. (cUfOrigem <> aSX6[MV_ESTADO] .Or. cUfDest <> aSX6[MV_ESTADO])) .Or. (!Empty(cCltdest) .And. cUfOrigem <> cUfCliDest)
						cRetCF := '2'
					Else
						cRetCF := '1'
					EndIf
				ElseIf (!Empty(cCltdest) .And. cUfOrigem == cUfCliDest) .Or. (Empty(cCltdest) .And. cUfOrigem == cUfDest)
					cRetCF := '1'
				ElseIf !cUfOrigem == "EX" .And. !cUfDest == "EX"
					cRetCF := "2"
				Else
					cRetCF := SubStr(cCfo,1,1)
				EndIf
			EndIf
		Else
			If Iif(nModulo <> 43, cUfDest == cUfOrigem .And. cTpCliFor <> "X", cUfDest == cUfOrigem)
				cRetCF := "5"
				If cConvCfo == "1"
					// Caso seja operacao com consumidor final troca a terminacao
					// do CFOP
					If (cTpCliFor == "F" .Or. !lInscrito) .And. AllTrim( cRestoCfo ) == "655"
						cRestoCfo := "656" + Space( Len( cRestoCfo ) - 3 )
					EndIf
					If (cTpCliFor == "F" .Or. !lInscrito) .And. AllTrim( cRestoCfo ) == "107"
						cRestoCfo := "101" + Space( Len( cRestoCfo ) - 3 )
					EndIf
					If (cTpCliFor == "F" .Or. !lInscrito) .And. AllTrim( cRestoCfo ) == "108"
						cRestoCfo := "102" + Space( Len( cRestoCfo ) - 3 )
					EndIf
				EndIf
			ElseIf Iif(nModulo <> 43,(cUfDest <> "EX" .And. cTpCliFor == "X") .Or. ( cTpCliFor <> "X"  .And. cUfOrigem <> "EX" ),;
						( cUfOrigem <> cUfDest  .And. cUfDest <> "EX" ))
				// Conversao do CFO interestadual
				cRetCF := "6"

				If cConvCfo == "1"
					If !lInscrito
						If AllTrim( cRestoCfo ) == "102"
							// Caso seja operacao interestadual para nao inscritos
							// altera o final do CFO de 102 para 108
							cRestoCfo := "108" + Space( Len( cRestoCfo ) - 3 )
						ElseIf AllTrim( cRestoCfo ) == "101"
							// Caso seja operacao interestadual para nao inscritos
							// altera o final do CFO de 101 para 107
							cRestoCfo := "107" + Space( Len( cRestoCfo ) - 3 )
						ElseIf AllTrim( cRestoCfo ) == "106"
							// Caso seja operacao interestadual para nao inscritos
							// altera o final do CFO de 106 para 108
							cRestoCfo := "108" + Space( Len( cRestoCfo ) - 3 )
						EndIf
					EndIf
					// Caso seja operacao com consumidor final troca a terminacao
					// do CFOP
					If (cTpCliFor == "F" .Or. !lInscrito) .And. AllTrim( cRestoCfo ) == "655"
						cRestoCfo := "656" + Space( Len( cRestoCfo ) - 3 )
					EndIf
				EndIf
			Else
				Iif (SubStr(cCfo,1,4) $ "5663#6663",cRetCF := SubStr(cCfo,1,1),cRetCF := "7")
			EndIf
		EndIf

		//Em caso de devolução de venda presencial para consumidor final, fundamentação Legal: Art. 136 e 138 do RICMS/SP"
		If aTes[TS_VENPRES] == "1" .And. aNfCab[NF_TPCLIFOR] == "F" .And. aNfCab[NF_OPERNF] == "E" .And. aNfitem[nItem][IT_TIPONF] == "D"
			cRetCF := "1"
		EndIf

		//Venda de Combistiveis a Consumidor Final em operacao interestadual
		//mantem o CFOP 5667 ao inves de 6667 conforme Ajuste Sinief 05/2009.
		//http://www1.fazenda.gov.br/confaz/confaz/ajustes/2009/aj_005_09.htm
		If cOperNF == "S" .And. cTpCliFor <> "R" .And. AllTrim(cCfo) == "5667" .And. ( cUfOrigem <> cUfDest )
			If cConvCfo == "1" .And. aSX6[MV_SNEFCFO]
				cRetCF := "5"
			EndIf
		EndIf

		// Tratamento para Complemento de Frete
		If cTpComp == "F" .And. cConvCfo=="1"
			cRetCF += IIf(SubStr(cCfo,2,3)$"931/932/933/949/351/352/353/354/355/356/360",SubStr(cCfo,2,3),"352")
		Else
			cRetCF += cRestoCfo
		EndIf
	EndIf

	// Ajuste do CFO para fora do estado quando for 4 digitos
	If Left(cRetCf,4) == "6405" .And. cConvCfo == "1"
		cRetCf := "6404"+SubStr(cRetCf,5)
	EndIf

	If lUsaCfps .And. Left(LTrim(cCfo),1)=="9"
		cRetCf := "9"+cRestoCfo
	EndIf

	// Verifica os CFOPS de Importacao e Exportacao.
	If SubStr(cRetCF,1,2) == "79"
		SX5->(dbSetOrder(1))
		If !SX5->(MsSeek(xFilial("SX5")+"13"+cRetCF))
			cRetCf := "7949"
		EndIf
	EndIf

Else
	cRetCF:=Alltrim(cCfo)
EndIf

If ValType( aDados ) <> "A"
	aNfItem[nItem][IT_CF] := PadR(cRetCF,Len(SF4->F4_CF))
Endif

Return ( cRetCF )

/*/
MaExcecao-Eduardo/Edson   -09.12.1999
Calculo das Excecoes fiscais
/*/
Function MaExcecao( nItem , cCampo )

Local aArea		:= GetArea()
Local aAreaSF7	:= SF7->(GetArea())
Local aExcecao	:= {}
Local aExceFat	:= {}
Local cGRTrib	:= ""
Local cUfOriDes	:= ""
Local cChave	:= ""
Local cHistSF7	:= ""
Local cAls		:= "SF7"
Local cOrigem	:= ""
Local cSiTrib	:= ""
Local nScan		:= 0
Local lExecuta	:= .T.
Local lSS1		:= .F.
Local lClasFis	:= Len( Alltrim( aNfItem[nItem][IT_CLASFIS] ) ) == 3
Local bCompareF7:= Nil
Local aExceAux	:= {}
Default cCampo	:= ""

/* Estrutura do Array aExcecao
[01] - Aliq. de ICMS Interna
[02] - Aliq. de ICMS Externa
[03] - Margem de Lucro Presumida
[04] - Grupo de Tributacao
[05] - "S"
[06] - Aliq. de ICMS Destino
[07] - Refere-se ao ISS "S/N"
[08] - Valor do Solidario de Pauta
[09] - Valor do IPI de Pauta
[10] - Valor do PIS
[11] - Valor Cofins
[12] - Aliquota do PIS
[13] - Aliquota do Cofins
[14] - Reducao da base de calculo do ICMS
[15] - Reducao da base de calculo do IPI
[16] - Icms Pauta
[17] - Aliquota de IPI
[18] - Reducao da base de calculo do PIS
[19] - Reducao da base de calculo da COFINS
[20] - Pauta Produto "S/N"
[21] - Tab. Natureza da Receita
[22] - Codigo Natureza da Receita
[23] - Grupo Natureza da Receita
[24] - Data Final Nat. Receita
[25] - Preço Unitário de Cigarro para cálculo da Substituição tributária de Cigarros para PIS e COFINS
[26] - Reducao da base de calculo do ICMS ST
[27] - ID do Historico das alteracoes
[28] - Codigo de Origem
[29] - Codigo de Situacao Tributaria
[30] - MVA operação de frete
[31] - UF de Busca
[32] - Pauta FOB
[33] - Redução da Base Difal
*/

If Empty( cGrTrib := aNFItem[nItem,IT_GRPTRIB] )
	cGrTrib := PadR( aNfItem[nItem][IT_PRD][SB_GRTRIB] ,Len(SF7->F7_GRTRIB))
EndIf

If !Empty(cGRTrib)

	If aPos[FP_F7_ORIGEM] .And. aPos[FP_F7_SITTRIB]

		/* O trecho abaixo foi copiado da funcao MaFisPreCalc(), pois as pilhas de recalculo possuem a chamada da MaExcecao() antes
		   da MaFisPreCalc() - onde eh definida a Classificacao Fiscal. Por este motivo, preciso garantir que a informacao do
		   IT_CLASFIS esteja correta para utilizar nas comparacoes da Excecao Fiscal.
		   Essa alteracao foi feita para que nao se faca necessario alterar todas as pilhas de recalculo, considerando a chamada da
		   MaFisPreCalc() antes da MaExcecao(). Essa mudanca sera feita na re-estruturacao das pilhas da MATXFIS.
		   */
		If  cCampo $ "IT_PRODUTO/IT_TES" .Or. !lClasFis
			If aSX6[MV_STFRETE] .And. ( AllTrim( aNFCab[NF_ESPECIE] ) $ "CTR/CTE/CTA/CTF" .Or. "NFST"$AllTrim( aNFCab[NF_ESPECIE] ) )
				aNfitem[nItem][IT_CLASFIS] := "0" + aNFItem[nItem][IT_TS][TS_SITTRIB]
			Else
				If aNfitem[nItem][IT_TIPONF] == "D" .And. !Empty(aNFItem[nItem][IT_RECORI]) .And. aNFCab[NF_OPERNF] == "E"
					dbSelectArea("SD2")
					MsGoto( aNFItem[nItem][IT_RECORI] )
					aNfitem[nItem][IT_CLASFIS] := SD2->D2_CLASFIS
				Else
					aNfitem[nItem][IT_CLASFIS] := aNfItem[nItem][IT_PRD][SB_ORIGEM] + aNFItem[nItem][IT_TS][TS_SITTRIB]
				EndIf
			EndIf
		Endif
		/* Verifico a necessidade de utilizar os codigos de origem e situacao tributaria
		   na comparacao junto ao Grupo Tributario, e que a cada item ocorra essa
		   verificacao para consistir a utilizacao do correto registro da SF7
		   */
		cOrigem		:= Iif( lClasFis , SubStr(aNfItem[nItem][IT_CLASFIS],1,1) , aNfItem[nItem][IT_PRD][SB_ORIGEM] )
		cSitTrib	:= Iif( lClasFis , SubStr(aNfItem[nItem][IT_CLASFIS],2,2) , aNFItem[nItem][IT_TS][TS_SITTRIB] )

		bCompareF7	:= {|x| !Empty(x[IT_EXCECAO]) .And. x[IT_EXCECAO,4]+x[IT_EXCECAO,28]+x[IT_EXCECAO,29] == cGRTrib+cOrigem+cSitTrib }
	Else
		bCompareF7	:= {|x| !Empty(x[IT_EXCECAO]) .And. x[IT_EXCECAO,4]==cGRTrib}
	Endif

	nScan := aScan( aNfItem , bCompareF7 )
	If nScan == 0
		dbSelectArea("SF7")
		SF7->(dbSetOrder(1))
		SF7->(MsSeek(xFilial("SF7")+avKey(cGRTrib,"F7_GRTRIB")+avKey(aNFCab[NF_GRPCLI],"F7_GRPCLI")))
		cChave := "SF7->F7_FILIAL == xFilial('SF7') .AND. SF7->F7_GRTRIB == '" + cGRTrib + "' .AND. SF7->F7_GRPCLI == '"+aNFCab[NF_GRPCLI] + "'"

		If aPE[PE_MFISEXCE]
			lExecuta  := Execblock("MFISEXCE",.F.,.F.,{Alias(),Recno()})
			IIF(Valtype(lExecuta)=="L",lExecuta,.T.)
		Endif
		If lHistorico
			//Se for reprocessamento,  e tiver habilitado para buscar os Historico Fiscais,
			//verifico se o ID do historico da Excecao e igual ao que foi gravado na Nota. Se for
			//igual é porque nao teve alterações na Excecao após a emissão. Se for diferente,
			//é porque teve alterações no cadastro, e entao os dados são carregados da tabela de
			//Historico(SS1).

			If( aNfCab[NF_CLIFOR]=="C" .And. aNfCab[NF_TIPONF]<>"D") .Or.( aNfCab[NF_CLIFOR]=="F" .And. aNfCab[NF_TIPONF]$"D|B")
				cHistSF7 :=  (cAlsItem)->D2_IDSF7
			Else
				cHistSF7 :=  (cAlsItem)->D1_IDSF7
			EndIf

			If  cPaisLoc == "BRA" .And. Alltrim(SF7->F7_IDHIST) <> Alltrim(cHistSF7)
				dbSelectArea("SS1")
				dbSetOrder(1)
				MsSeek(xFilial("SS1")+cHistSF7+avKey(cGRTrib,"S1_GRTRIB")+avKey(aNFCab[NF_GRPCLI],"F7_GRPCLI"))
				cAls   := "SS1"
				cChave := "SS1->S1_FILIAL == xFilial('SS1') .AND. SS1->S1_IDHIST == '" + cHistSF7  + "' .And. SS1->S1_GRTRIB == '" + cGRTrib + "' .AND. SS1->S1_GRPCLI == '" + aNFCab[NF_GRPCLI] + "'"
				lSS1 := .T.
			EndIf
		EndIf

		cChave := &('{||'+cChave+'}')
		While !(cAls)->(Eof()) .AND. Eval(cChave) .And. lExecuta

		If ((!aPos[FP_F7_MSBLQD]) .Or. (aPos[FP_F7_MSBLQD] .And. (SF7->F7_MSBLQD > date() .Or. Empty(SF7->F7_MSBLQD)))) // validação par anão considerar item bloqueado por data
			If aPos[FP_F7_UFBUSCA] .And. (aNfCab[NF_OPERNF] == "E" .Or. (aNfCab[NF_OPERNF] == "S" .And. aNFCab[NF_TIPONF] == "D"))
				cUfOriDes := IIf(IIf(lSS1,  SS1->S1_UFBUSCA == "2", SF7->F7_UFBUSCA == "2") , aNFCab[NF_UFDEST] , aNFCab[NF_UFORIGEM] )
			ElseIf aPos[FP_F7_UFBUSCA] .And. IntTms() .And. nModulo == 43 //SIGATMS
				cUfOriDes := IIf(IIf(lSS1,  SS1->S1_UFBUSCA == "2", SF7->F7_UFBUSCA == "2"), aNFCab[NF_UFDEST] , aNFCab[NF_UFORIGEM])
			Else
				cUfOriDes := aNFCab[NF_UFORIGEM]
			EndIf

			/* Abaixo eh feita a validacao dos campos utilizados como chave de combinacao da Excecao Fiscal
			   Campos utilizados:
			   	- F7_EST (conforme campo F7_UFBUSCA, a comparacao sera com Uf Destino ou Uf Origem)
			   	- F7_TIPOCLI (compara com o tipo do cliente definido pelos cadastros A1/A2)
			   	- F7_ORIGEM (origem do pruduto, que esta definida no primeiro caracter dos campos D1/D2_CLASFIS)
			   	- F7_SITTRIB(situacao tributaria do produto, que esta definida no segundo e terceiro caracter
			   	  dos campos D1/D2_CLASFIS) */

			If	aNFCab[NF_TIPONF] == "D" .And.;
				IIf(lSS1, ( cUfOriDes == SS1->S1_EST .Or. SS1->S1_EST == "**" ), ( cUfOriDes == SF7->F7_EST .Or. SF7->F7_EST == "**" )) .And.;
				IIf(lSS1, ( aNfCab[NF_TPCLIFOR] == SS1->S1_TIPOCLI .Or. SS1->S1_TIPOCLI == "*" ), (aNfCab[NF_TPCLIFOR] == SF7->F7_TIPOCLI .Or. SF7->F7_TIPOCLI == "*" )) .And.;
				Iif(lSS1 .And. aPos[FP_S1_ORIGEM], ( cOrigem == SS1->S1_ORIGEM .Or. Empty(SS1->S1_ORIGEM) ) , Iif( aPos[FP_F7_ORIGEM] , ( cOrigem == SF7->F7_ORIGEM .Or. Empty(SF7->F7_ORIGEM) ) , .T. ) ) .And.;
				Iif(lSS1 .And. aPos[FP_S1_SITTRIB], ( cSitTrib == SS1->S1_SITTRIB .Or. Empty(SS1->S1_SITTRIB) ) , Iif( aPos[FP_F7_SITTRIB] , ( cSitTrib == SF7->F7_SITTRIB .Or. Empty(SF7->F7_SITTRIB) ) , .T. ) )

				aadd(aExcecao,IIf(lSS1, SS1->S1_ALIQINT, SF7->F7_ALIQINT))
				aadd(aExcecao,IIf(lSS1, SS1->S1_ALIQEXT, SF7->F7_ALIQEXT))
				aadd(aExcecao,IIf(lSS1, SS1->S1_MARGEM, SF7->F7_MARGEM))
				aadd(aExcecao,IIf(lSS1, SS1->S1_GRTRIB, SF7->F7_GRTRIB))
				aadd(aExcecao,"S")
				aadd(aExcecao,IIf(lSS1, SS1->S1_ALIQDST, SF7->F7_ALIQDST))
				aadd(aExcecao,IIf(lSS1, SS1->S1_ISS, SF7->F7_ISS))
				If cPaisLoc == "BRA"
					aadd(aExcecao,IIf(lSS1, SS1->S1_VLR_ICM, SF7->F7_VLR_ICM))
					aadd(aExcecao,IIf(lSS1, SS1->S1_VLR_IPI, SF7->F7_VLR_IPI))
					aadd(aExcecao,IIf(lSS1, SS1->S1_VLR_PIS, SF7->F7_VLR_PIS))
					aadd(aExcecao,IIf(lSS1, SS1->S1_VLR_COF, SF7->F7_VLR_COF))
					aadd(aExcecao,IIf(lSS1, SS1->S1_ALIQPIS, SF7->F7_ALIQPIS))
					aadd(aExcecao,IIf(lSS1, SS1->S1_ALIQCOF, SF7->F7_ALIQCOF))
					aadd(aExcecao,IIf(lSS1, SS1->S1_BASEICM, SF7->F7_BASEICM))
					aadd(aExcecao,IIf(lSS1, SS1->S1_BASEIPI, SF7->F7_BASEIPI))
					aadd(aExcecao,IIf(lSS1, SS1->S1_VLRICMP, SF7->F7_VLRICMP))
					aadd(aExcecao,IIf(lSS1, SS1->S1_ALIQIPI, SF7->F7_ALIQIPI))
					aadd(aExcecao,IIf(lSS1, SS1->S1_REDPIS,  SF7->F7_REDPIS))
					aadd(aExcecao,IIf(lSS1, SS1->S1_REDCOF,  SF7->F7_REDCOF))
					aadd(aExcecao,IIf(lSS1, SS1->S1_ICMPAUT, SF7->F7_ICMPAUT))
					aadd(aExcecao,Iif(aPos[FP_F7_TNATREC], IIf(lSS1, SS1->S1_TNATREC, SF7->F7_TNATREC),""))
					aadd(aExcecao,Iif(aPos[FP_F7_CNATREC], IIf(lSS1, SS1->S1_CNATREC, SF7->F7_CNATREC),""))
					aadd(aExcecao,Iif(aPos[FP_F7_GRUPONC], IIf(lSS1, SS1->S1_GRUPONC, SF7->F7_GRUPONC),""))
					aadd(aExcecao,Iif(aPos[FP_F7_DTFIMNT], IIf(lSS1, SS1->S1_DTFIMNT, SF7->F7_DTFIMNT),CtoD("")))
					aadd(aExcecao,Iif(aPos[FP_F7_PRCUNIC], IIf(lSS1, SS1->S1_PRCUNIC, SF7->F7_PRCUNIC),0))
					aadd(aExcecao,Iif(aPos[FP_F7_BSICMST], IIf(lSS1, SS1->S1_BSICMST, SF7->F7_BSICMST),0))
					aadd(aExcecao,Iif(aPos[FP_F7_IDHIST],  IIf(lSS1, SS1->S1_IDHIST,  SF7->F7_IDHIST), ""))
					aadd(aExcecao,Iif(aPos[FP_F7_ORIGEM],  IIf(lSS1, SS1->S1_ORIGEM,  cOrigem ), ""))
					aadd(aExcecao,Iif(aPos[FP_F7_SITTRIB], IIf(lSS1, SS1->S1_SITTRIB, cSitTrib), ""))
					aadd(aExcecao, Iif( lSS1 .And. aPos[FP_MV_MVAFS1],  &(aSX6[MV_MVAFRE]), IIf(aPos[FP_MV_MVAFRE] , &(aSX6[MV_MVAFRE]),0)))
					aadd(aExcecao, Iif( lSS1, SS1->S1_UFBUSCA, SF7->F7_UFBUSCA))
					aadd(aExcecao,Iif(aPos[FP_F7_PAUTFOB], IIf(lSS1, SS1->S1_PAUTFOB, SF7->F7_PAUTFOB),0))
					aadd(aExcecao, Iif(aPos[FP_F7_BASCMP], IIf(lSS1, SS1->S1_BASCMP, SF7->F7_BASCMP),0))
				Else
					aadd(aExcecao,0)
					aadd(aExcecao,0)
					aadd(aExcecao,0)
					aadd(aExcecao,0)
					aadd(aExcecao,0)
					aadd(aExcecao,0)
					aadd(aExcecao,0)
					aadd(aExcecao,0)
					aadd(aExcecao,0)
					aadd(aExcecao,0)
					aadd(aExcecao,0)
					aadd(aExcecao,0)
					aadd(aExcecao,0)
					aadd(aExcecao,"")
					aadd(aExcecao,"")
					aadd(aExcecao,"")
					aadd(aExcecao,CToD(""))
					aadd(aExcecao,0)
					aadd(aExcecao,0)
					aadd(aExcecao,"")
					aadd(aExcecao,"")
					aadd(aExcecao,"")
					aadd(aExcecao,0)
					aadd(aExcecao,0)
					aadd(aExcecao,0)
					aadd(aExcecao,0)
				EndIf
			Else
				If aPos[FP_F7_UFBUSCA] .And. aNfCab[NF_OPERNF] == "E"
					cUfOriDes := IIf(IIf(lSS1,  SS1->S1_UFBUSCA == "2", SF7->F7_UFBUSCA == "2") , aNFCab[NF_UFORIGEM] , aNFCab[NF_UFDEST] )
				ElseIf aPos[FP_F7_UFBUSCA] .And. IntTms() .And. nModulo == 43 //SIGATMS
					cUfOriDes := IIf(IIf(lSS1,  SS1->S1_UFBUSCA == "2", SF7->F7_UFBUSCA == "2")  , aNFCab[NF_UFORIGEM] , aNFCab[NF_UFDEST] )
				Else
					cUfOriDes := aNFCab[NF_UFDEST]
				EndIf

				/* Abaixo eh feita a validacao dos campos utilizados como chave de combinacao da Excecao Fiscal
				   Campos utilizados:
				   	- F7_EST (conforme campo F7_UFBUSCA, a comparacao sera com Uf Destino ou Uf Origem)
				   	- F7_TIPOCLI (compara com o tipo do cliente definido pelos cadastros A1/A2)
				   	- F7_ORIGEM (origem do pruduto, que esta definida no primeiro caracter dos campos D1/D2_CLASFIS)
				   	- F7_SITTRIB(situacao tributaria do produto, que esta definida no segundo e terceiro caracter
				   	  dos campos D1/D2_CLASFIS)*/

				If	aNFCab[NF_TIPONF] != "D" .And.;
					IIf(lSS1, ( cUfOriDes == SS1->S1_EST .Or. SS1->S1_EST == "**"), ( cUfOriDes == SF7->F7_EST .Or. SF7->F7_EST == "**")) .And.;
					IIf(lSS1, ( aNfCab[NF_TPCLIFOR] == SS1->S1_TIPOCLI .Or. SS1->S1_TIPOCLI == "*" ), (aNfCab[NF_TPCLIFOR] == SF7->F7_TIPOCLI .Or. SF7->F7_TIPOCLI == "*" )) .And.;
					Iif(lSS1, ( cOrigem == SS1->S1_ORIGEM .Or. Empty(SS1->S1_ORIGEM) ) , Iif( aPos[FP_F7_ORIGEM] , ( cOrigem == SF7->F7_ORIGEM .Or. Empty(SF7->F7_ORIGEM) ) , .T. ) ) .And.;
					Iif(lSS1, ( cSitTrib == SS1->S1_SITTRIB .Or. Empty(SS1->S1_SITTRIB) ) , Iif( aPos[FP_F7_SITTRIB] , ( cSitTrib == SF7->F7_SITTRIB .Or. Empty(SF7->F7_SITTRIB) ) , .T. ) )

					aadd(aExcecao, IIf(lSS1, SS1->S1_ALIQINT, SF7->F7_ALIQINT))
					aadd(aExcecao, IIf(lSS1, SS1->S1_ALIQEXT, SF7->F7_ALIQEXT))
					aadd(aExcecao, IIf(lSS1, SS1->S1_MARGEM, SF7->F7_MARGEM))
					aadd(aExcecao, IIf(lSS1, SS1->S1_GRTRIB, SF7->F7_GRTRIB))
					aadd(aExcecao, "S")
					aadd(aExcecao, IIf(lSS1, SS1->S1_ALIQDST, SF7->F7_ALIQDST))
					aadd(aExcecao, IIf(lSS1, SS1->S1_ISS, SF7->F7_ISS))
					If cPaisLoc == "BRA"
						aadd(aExcecao, IIf(lSS1, SS1->S1_VLR_ICM, SF7->F7_VLR_ICM))
						aadd(aExcecao, IIf(lSS1, SS1->S1_VLR_IPI, SF7->F7_VLR_IPI))
						aadd(aExcecao, IIf(lSS1, SS1->S1_VLR_PIS, SF7->F7_VLR_PIS))
						aadd(aExcecao, IIf(lSS1, SS1->S1_VLR_COF, SF7->F7_VLR_COF))
						aadd(aExcecao, IIf(lSS1, SS1->S1_ALIQPIS, SF7->F7_ALIQPIS))
						aadd(aExcecao, IIf(lSS1, SS1->S1_ALIQCOF, SF7->F7_ALIQCOF))
						aadd(aExcecao, IIf(lSS1, SS1->S1_BASEICM, SF7->F7_BASEICM))
						aadd(aExcecao, IIf(lSS1, SS1->S1_BASEIPI, SF7->F7_BASEIPI))
						aadd(aExcecao, IIf(lSS1, SS1->S1_VLRICMP, SF7->F7_VLRICMP))
						aadd(aExcecao, IIf(lSS1, SS1->S1_ALIQIPI, SF7->F7_ALIQIPI))
						aadd(aExcecao, IIf(lSS1, SS1->S1_REDPIS, SF7->F7_REDPIS))
						aadd(aExcecao, IIf(lSS1, SS1->S1_REDCOF, SF7->F7_REDCOF))
						aadd(aExcecao, IIf(lSS1, SS1->S1_ICMPAUT, SF7->F7_ICMPAUT))
						aadd(aExcecao, Iif(aPos[FP_F7_TNATREC],IIf(lSS1, SS1->S1_TNATREC, SF7->F7_TNATREC),""))
						aadd(aExcecao, Iif(aPos[FP_F7_CNATREC],IIf(lSS1, SS1->S1_CNATREC, SF7->F7_CNATREC),""))
						aadd(aExcecao, Iif(aPos[FP_F7_GRUPONC],IIf(lSS1, SS1->S1_GRUPONC, SF7->F7_GRUPONC),""))
						aadd(aExcecao, Iif(aPos[FP_F7_DTFIMNT],IIf(lSS1, SS1->S1_DTFIMNT, SF7->F7_DTFIMNT),CtoD("")))
						aadd(aExcecao, Iif(aPos[FP_F7_PRCUNIC],IIf(lSS1, SS1->S1_PRCUNIC, SF7->F7_PRCUNIC),0))
						aadd(aExcecao, Iif(aPos[FP_F7_BSICMST],IIf(lSS1, SS1->S1_BSICMST, SF7->F7_BSICMST),0))
						aadd(aExcecao, Iif(aPos[FP_F7_IDHIST], IIf(lSS1, SS1->S1_IDHIST,  SF7->F7_IDHIST), ""))
						aadd(aExcecao, Iif(aPos[FP_F7_ORIGEM], IIf(lSS1, SS1->S1_ORIGEM,  cOrigem), ""))
						aadd(aExcecao, Iif(aPos[FP_F7_SITTRIB],IIf(lSS1, SS1->S1_SITTRIB, cSitTrib),""))
						aadd(aExcecao, Iif( lSS1 .And. aPos[FP_MV_MVAFS1],  &(aSX6[MV_MVAFRE]), IIf(aPos[FP_MV_MVAFRE] , &(aSX6[MV_MVAFRE]),0)))
						aadd(aExcecao, Iif( lSS1, SS1->S1_UFBUSCA, SF7->F7_UFBUSCA))
						aadd(aExcecao, Iif(aPos[FP_F7_PAUTFOB], IIf(lSS1, SS1->S1_PAUTFOB, SF7->F7_PAUTFOB),0))
						aadd(aExcecao, Iif(aPos[FP_F7_BASCMP], IIf(lSS1, SS1->S1_BASCMP, SF7->F7_BASCMP),0))
					Else
						aadd(aExcecao,0)
						aadd(aExcecao,0)
						aadd(aExcecao,0)
						aadd(aExcecao,0)
						aadd(aExcecao,0)
						aadd(aExcecao,0)
						aadd(aExcecao,0)
						aadd(aExcecao,0)
						aadd(aExcecao,0)
						aadd(aExcecao,0)
						aadd(aExcecao,0)
						aadd(aExcecao,0)
						aadd(aExcecao,0)
						aadd(aExcecao,"")
						aadd(aExcecao,"")
						aadd(aExcecao,"")
						aadd(aExcecao,CToD(""))
						aadd(aExcecao,0)
						aadd(aExcecao,0)
						aadd(aExcecao,"")
						aadd(aExcecao,"")
						aadd(aExcecao,"")
						aadd(aExcecao,0)
						aadd(aExcecao,0)
						aadd(aExcecao,0)
						aadd(aExcecao,0)
					EndIf
					Exit
				EndIf
			EndIf
		EndIf
			(cAls)->(dbSkip())
		EndDo
		If aPE[PE_MAEXCEFISC]
			aExceAux :=  ExecBlock("MAEXCEFISC",.F.,.F.,{ aExcecao, {nItem, cGRTrib, cUfOriDes, cOrigem,cSitTrib, aNFCab[NF_ESPECIE], aNfCab[NF_TIPONF], aNFCab[NF_OPERNF], aNfCab[NF_CLIFOR], aNFCab[NF_CLIEFAT]}})
			If Len(aExceAux) >= 33
				aExcecao := aExceAux
			EndIf
		EndIf
	Else
		aExcecao := aNfItem[nScan][IT_EXCECAO]
	EndIf

	If cPaisLoc == "BRA" .And. aNFCab[NF_OPERNF]=="S" .And. !Empty(aNFCab[NF_CLIEFAT])
		nScan := aScan(aNfItem,{|x| !Empty(x[IT_EXCEFAT]) .And. x[IT_EXCEFAT,4] == cGRTrib })
		If nScan == 0
			If SF7->(dbSeek(xFilial("SF7") + avKey(cGRTrib,"F7_GRTRIB") + avKey(aNFCab[NF_GRPFAT],"F7_GRPCLI") ) )
				If aPE[PE_MFISEXCE]
					lExecuta  := Execblock("MFISEXCE",.F.,.F.,{Alias(),Recno()})
					IIF(Valtype(lExecuta)=="L",lExecuta,.T.)
				Endif
				While !SF7->(Eof()).And.SF7->F7_FILIAL==xFilial("SF7") .And. SF7->F7_GRTRIB == cGRTrib .And. SF7->F7_GRPCLI == aNFCab[NF_GRPFAT] .And. lExecuta
					//Para o tratamento da exceção do cliente do faturamento,
					//por ser utilizado apenas para PIS e COFINS, não irá considerar o
					//o tratamento  de destino e origem.
					If 	( aNfCab[NF_TIPOFAT] == SF7->F7_TIPOCLI .Or. SF7->F7_TIPOCLI == "*" )
						aadd(aExceFat,SF7->F7_ALIQINT)
						aadd(aExceFat,SF7->F7_ALIQEXT)
						aadd(aExceFat,SF7->F7_MARGEM)
						aadd(aExceFat,SF7->F7_GRTRIB)
						aadd(aExceFat,"S")
						aadd(aExceFat,SF7->F7_ALIQDST)
						aadd(aExceFat,SF7->F7_ISS)
						aadd(aExceFat,SF7->F7_VLR_ICM)
						aadd(aExceFat,SF7->F7_VLR_IPI)
						aadd(aExceFat,SF7->F7_VLR_PIS)
						aadd(aExceFat,SF7->F7_VLR_COF)
						aadd(aExceFat,SF7->F7_ALIQPIS)
						aadd(aExceFat,SF7->F7_ALIQCOF)
						aadd(aExceFat,SF7->F7_BASEICM)
						aadd(aExceFat,SF7->F7_BASEIPI)
						aadd(aExceFat,SF7->F7_VLRICMP)
						aadd(aExceFat,SF7->F7_ALIQIPI)
						aadd(aExceFat,SF7->F7_REDPIS)
						aadd(aExceFat,SF7->F7_REDCOF)
						aadd(aExceFat,SF7->F7_ICMPAUT)
						aadd(aExceFat,Iif(aPos[FP_F7_TNATREC],SF7->F7_TNATREC,""))
						aadd(aExceFat,Iif(aPos[FP_F7_CNATREC],SF7->F7_CNATREC,""))
						aadd(aExceFat,Iif(aPos[FP_F7_GRUPONC],SF7->F7_GRUPONC,""))
						aadd(aExceFat,Iif(aPos[FP_F7_DTFIMNT],SF7->F7_DTFIMNT,CtoD("")))
						aadd(aExceFat,Iif(aPos[FP_F7_PRCUNIC],SF7->F7_PRCUNIC,0))
						aadd(aExceFat,Iif(aPos[FP_F7_BSICMST],SF7->F7_BSICMST,0))
						aadd(aExceFat,"") //IDHIST
						aadd(aExceFat,Iif(aPos[FP_F7_ORIGEM],cOrigem,""))
						aadd(aExceFat,Iif(aPos[FP_F7_SITTRIB],cSitTrib,""))
						aadd(aExceFat, Iif( aPos[FP_MV_MVAFRE] , &(aSX6[MV_MVAFRE]),0))
						aadd(aExceFat, SF7->F7_UFBUSCA)
						aadd(aExceFat,Iif(aPos[FP_F7_PAUTFOB],SF7->F7_PAUTFOB,0))
						aadd(aExceFat,Iif(aPos[FP_F7_BASCMP],SF7->F7_BASCMP,0))
						Exit
					EndIf
					SF7->(dbSkip())
				EndDo
			EndIf
		Else
			aExceFat := aNfItem[nScan][IT_EXCEFAT]
		EndIf
		If aPE[PE_MAEXCEFISC]
			  aExceAux :=  ExecBlock("MAEXCEFISC",.F.,.F.,{ aExceFat, {nItem, cGRTrib, cUfOriDes, cOrigem,cSitTrib, aNFCab[NF_ESPECIE], aNfCab[NF_TIPONF], aNFCab[NF_OPERNF], aNfCab[NF_CLIFOR],aNFCab[NF_CLIEFAT]} })
			  If Len(aExceAux) >= 33
				aExceFat := aExceAux
			EndIf
		EndIf
	EndIf
EndIf

// Intervenção para que o SIGAAGRO sobreecreva a exceção
If FindFunction("OGXUtlOrig") //Usa sigaagro
	If OGXUtlOrig() .and.FindFunction("AgrICMPaut")
		If Empty(aExcecao)
			aadd(aExcecao,0)
			aadd(aExcecao,0)
			aadd(aExcecao,0)
			aadd(aExcecao,cGRTrib)
			aadd(aExcecao,"S")
			aadd(aExcecao,0)
			aadd(aExcecao,"")
			aadd(aExcecao,0)
			aadd(aExcecao,0)
			aadd(aExcecao,0)
			aadd(aExcecao,0)
			aadd(aExcecao,0)
			aadd(aExcecao,0)
			aadd(aExcecao,0)
			aadd(aExcecao,0)
			aadd(aExcecao,0)
			aadd(aExcecao,0)
			aadd(aExcecao,0)
			aadd(aExcecao,0)
			aadd(aExcecao,0)
			aadd(aExcecao,"")
			aadd(aExcecao,"")
			aadd(aExcecao,"")
			aadd(aExcecao,CToD(""))
			aadd(aExcecao,0)
			aadd(aExcecao,0)
			aadd(aExcecao,"")
			aadd(aExcecao,"")
			aadd(aExcecao,"")
			aadd(aExcecao,0)
			aadd(aExcecao,0)
			aadd(aExcecao,0)
			aadd(aExcecao,0)
		Endif
		
		AgrICMPaut(aNfCab, aNfItem, nItem, @aExcecao )
		
		If aPE[PE_MAEXCEFISC] // mantem a funcionalidade do ponto de entrada.
			aExceAux :=  ExecBlock("MAEXCEFISC",.F.,.F.,{ aExcecao, {nItem, cGRTrib, cUfOriDes, cOrigem,cSitTrib, aNFCab[NF_ESPECIE], aNfCab[NF_TIPONF], aNFCab[NF_OPERNF], aNfCab[NF_CLIFOR], aNFCab[NF_CLIEFAT]}})
			If Len(aExceAux) >= 33
				aExcecao := aExceAux
			EndIf
		EndIf
	EndIF
Endif

aNfItem[nItem][IT_EXCECAO] := aExcecao
aNfItem[nItem][IT_EXCEFAT] := aExceFat

If Len(aExcecao) > 0
	aNfItem[nItem][IT_IDSF7] := aExcecao[27]
EndIf

RestArea(aAreaSF7)
RestArea(aArea)

Return(aExcecao)

/*/
MaFisAjIt - Gustavo Rueda  -13/12/2007
Funcao de consistencias dos ajustes dos documentos fiscais.
Parametros
nXX -> Numero do item.
nTipo -> Tipo de processamento. 1=Item a item, 2=Todos Items
/*/
Function MaFisAjIt(nXX,nTipo)
Local aArea		:= SB1->(GetArea())
Local aGrava	:= {}
Local aBkpaCls	:= {}
Local cItem		:= Iif("E"$aNfCab[NF_OPERNF],"0001", "01")
Local cSeq		:= "001"
Local cUfLanc	:= ""
Local cPrdImp	:= ""
Local cIFCOMP	:= ""
Local cBase		:= ""
Local cAliq		:= ""
Local cValor	:= ""
Local cTpLanc	:= ""
Local cVL197	:= ""
Local nI		:= 0
Local nX		:= 0
Local nPosSeq	:= 0
Local nII		:= 0
Local nIF		:= 0
Local nZ		:= 0
Local nAliqVal	:= 0
Local nValor	:= 0
Local nBase		:= 0
Local nAliq		:= 0
Local lGerou	:= .F.
Local lHasRefl	:= .F.
Local cCmp0460  := ""
Local cCodRefl	:= ""
Local cGeraGNRE := ""
Local cCMPOrig  := ""
Local aParam	:= {}

Default	nXX	  := 1
Default	nTipo := 1

//Define se a funcao sera executada para todos os itens (aNfItem) ou para o item corrente
nII := Iif(nTipo==1,nXX,1)
nIF	:= Iif(nTipo==1,nXX,Len(aNfItem))
If Len(aNfItem)>0
	For nZ := nII To nIF
		//Verifica se a linha do item foi deletada
		If aNfItem[nZ,IT_DELETED]
			Loop
		EndIf

		//Inicializa o TES correspondente ao item corrente
		MaFisTes(aNfItem[nZ,IT_TES],,nZ)

		For nI := 1 To Len(aNFItem[nZ][IT_TS][TS_LANCFIS])
			lHasRefl	:=	.F.
			//Verifica qual eh a UF do codigo de ajuste corrente
			cUfLanc := Substr(aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1],1,2)
			//Informacao Complementar do Codigo de Ajuste
			cIFCOMP	:=	aNFItem[nZ][IT_TS][TS_LANCFIS,nI,2]
			If aPos[FP_CC7_CLANC]//Complemento para registro 0460
				cCmp0460:=	aNFItem[nZ][IT_TS][TS_LANCFIS,nI,4]
			Endif
			cCodRefl:=	aNFItem[nZ][IT_TS][TS_LANCFIS,nI,3]
			//Produto Importado: exclusivo para o codigo SC10000018
			If aNfCab[NF_OPERNF] == "S" .And. aPos[FP_B1_IMPORT]
				dbSelectArea("SD2")
				dbGoTo(aNfItem[nZ,IT_RECNOSB1])
				cPrdImp := SB1->B1_IMPORT
			Endif

			cGeraGNRE := aNFItem[nZ][IT_TS][TS_LANCFIS,nI,5]
			cCMPOrig := aNFItem[nZ][IT_TS][TS_LANCFIS,nI,6]

			//Verifica se a UF do codigo de ajuste corresponde a UF do MV_ESTADO
			If cUfLanc $ aSX6[MV_ESTADO] .OR. ( Len(aNFItem[nZ][IT_TS][ TS_LANCFIS , nI , 1 ] ) == 8 .AND. ;
													 SubStr( aNFItem[nZ][IT_TS][ TS_LANCFIS , nI , 1 ]  ,3,1) == '2' .AND.  ;
													 cUfLanc $aNFCab[NF_UFDEST]) .Or. (cCMPOrig =="3" .And. !EmpTy(aNFItem[nZ][IT_TS][TS_LANCFIS,nI,3]))

				//Captura o proximos codigo de sequencia a ser utilizado
				If Len(aGrava) > 0
					nPosSeq	 :=	7
					aBkpaCls :=	aClone(aGrava)
					aSort(aBkpaCls,,,{|aX,aY| aX[nPosSeq]<aY[nPosSeq]})
					cSeq :=	aBkpaCls[Len(aBkpaCls),nPosSeq]
					cSeq  := Soma1(cSeq)
				EndIf				
				// Campo que determina se o lancamento eh de Apuracao (1) ou de NF (2)

				// Alguns codigos de ajuste sao validados pelo proprio MATXFIS, ou seja, as regras sao pre-estabelecidas no codigo fonte, porem
				//foi criado o mecanismo para configuracao dos Codigos de Ajuste utilizando o Cadastro de Reflexo (CE0) junto ao Cadastro de
				//Lancamentos (CC7). Desta forma as regras serao configuradas pelo proprio usuario, que definira Base, Aliquota e Valor do Codigo
				//atraves da tabela CE0.
				// Os codigos que ja eram validadas no MATXFIS foram mantidos por questao de legado. Os demais alem desses codigos deverao ser
				//configurados conforme explicacao acima.

				cTpLanc := Iif( Len( aNFItem[nZ][IT_TS][ TS_LANCFIS , nI , 1 ] ) == 10 , "2" , "1" )

				//Apenas verifico os codigos do MATXFIS caso seja Ajuste de Documento Fiscal e nao possua um Codigo de Reflexo relacionado
				If cTpLanc == "2" .And. Empty( aNFItem[nZ][IT_TS][TS_LANCFIS,nI,3] )
					lGerou := .T.
					cItem  := aNfItem[nZ,IT_ITEM]
					//000 - OPERACAO NORMAL
					If Right(aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1],TamSx3("CC8_CODIGO")[1])=="000"	.And.;
						cUfLanc $ ("MG/MA/MS/PB/SE") .And. aNfItem[nZ,IT_VALICM]>0 .And. aNfItem[nZ,IT_VALISS]==0 .and. aNfItem[nZ][IT_VALSOL]==0 .and. aNfItem[nZ][IT_VALFECP]==0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALICM],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
				   		// Outros créditos; Op.Própria; Resp.: Informativo;Apur.: Informativo; Mercadoria;Simples Nacional
					//Tratamento do FECP de SE
					ElseIf cUfLanc$("SE") .AND. aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"SE70010000" .And. aNfItem[nZ][IT_VALFECP]>0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQFECP], aNfItem[nZ,IT_VALFECP],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//Tratamento do FECP ST de SE
					ElseIf cUfLanc$("SE") .AND. aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"SE71010000" .And. aNfItem[nZ][IT_VFECPST]>0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASESOL], aNfItem[nZ,IT_ALIQFECP], aNfItem[nZ][IT_VFECPST],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					ElseIf cUfLanc=="MG" .And. aNfCab[NF_OPERNF]=="E"  .And. aNFCab[NF_SIMPNAC] == "1" .And. aNFItem[nZ][IT_TS][TS_LFICM] == "T" .And. (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"MG10990505")
						aAdd(aGrava, {aNfItem[nZ,IT_ITEM], aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALICM],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						//Informativo; Op.ST; Resp.: Informativo; Apur.: Informativo; Mercadoria; Op. Normal.
					ElseIf cUfLanc=="MG" .And. aNfCab[NF_OPERNF]=="E"  .And. aNFCab[NF_SIMPNAC] == "1" .And. aNFItem[nZ][IT_TS][TS_LFICM] == "T"  .And. (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"MG91990000") .And. aNfItem[nZ,IT_VALSOL] >0
						aAdd(aGrava, {aNfItem[nZ,IT_ITEM], aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASESOL], aNfItem[nZ,IT_ALIQSOL], aNfItem[nZ,IT_VALSOL],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						// Lançamentos de Sub-apuração de ICMS.
					ElseIf Alltrim(cUfLanc)$"ES/PA" .And. SubStr(aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1],4,1)$"3/4/5" .And. aNfItem[nZ,IT_VALICM] >0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALICM],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						//001 - DIFERENCIAL ALIQUOTA (SC=002 e 003)
						//001 - ESTORNO DE CREDITO
					ElseIf ( Right(aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1],TamSx3("CC8_CODIGO")[1])=="001" .And.;
						cUfLanc $ ("GO") .And. (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"GO50009001") .And. aNFCab[NF_SIMPNAC] == "1") .And. aNfItem[nZ,IT_VALICM] >0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALICM],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						//005 - ST - DIF ALIQUOTA
					ElseIf aNfItem[nZ,IT_VALCMP]>0 .And.;
						(((Right(aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1],TamSx3("CC8_CODIGO")[1])$"001/005" .And. cUfLanc $ ("MG/MS/PB/SE")) .Or.;
						(AllTrim(aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1])$"SC40000002/SC40000003")) .Or. (AllTrim(aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1])$"RJ70000002"))	//Tratamento conforme codigos da tabela tb54, tb55 e tb129.
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQCMP]-aNfItem[nZ,IT_ALIQICM]- aNfItem[nZ,IT_ALIQFECP] , aNfItem[nZ,IT_VALCMP]-aNfItem[nZ,IT_VALFECP],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						//002 - TRANSFERENCIA DE CREDITO
					ElseIf Right(aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1],TamSx3("CC8_CODIGO")[1])=="002" .And.;
						cUfLanc $ ("MG/MS/PB/SE") .And. aNFItem[nZ][IT_TS][TS_TRFICM]=="1".And. aNfItem[nZ,IT_VALMERC] >0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALMERC],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					ElseIf cUfLanc $ ("RS")  .And. (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RS10009029") .And. aNfCab[NF_OPERNF]=="E" .And. aNFItem[nZ][IT_TS][TS_TRFICM]=="1"
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALMERC],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					ElseIf cUfLanc $ ("GO")  .And. (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"GO71003005|GO71003006") .And. aNfCab[NF_OPERNF]=="E"  .And. aNfItem[nZ][IT_VALSOL] >0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1",aNfItem[nZ,IT_BASESOL], aNfItem[nZ,IT_ALIQSOL], aNfItem[nZ][IT_VALSOL],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
								//004 - ANTECIPACAO TRIBUTARIA
					ElseIf Right(aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1],TamSx3("CC8_CODIGO")[1])=="004" .And.;
						cUfLanc $ ("MA/MS/MG/PB/SE") .And. aNFItem[nZ][IT_TS][TS_ANTICMS]=="1" .And. aNfItem[nZ,IT_VALANTI] > 0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALANTI],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						//008 - ATIVO PERMANENTE
					ElseIf ( (Right(aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1],TamSx3("CC8_CODIGO")[1])=="008" .And.;
						cUfLanc $ ("MG/MS/PB/SE")) .Or. aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"PA40000001/SC40000002/AL00000004") .And. aNfItem[nZ,IT_VALCMP]>0 .And.;
						(SubStr(aNfItem[nZ,IT_CF],2,3)$"91 " .Or. SubStr(aNfItem[nZ,IT_CF],2,3)$"551")
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALCMP],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					ElseIf cUfLanc $ ("MG") .And. (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"MG10000503") .And. aNfCab[NF_OPERNF]=="E" .And.  aNfItem[nZ,IT_BASNDES] > 0  .And. aNfItem[nZ,IT_ICMNDES] > 0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASNDES], 0, aNfItem[nZ,IT_ICMNDES],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						//009 - CREDITO PRESUMIDO
					ElseIf !Empty(aNFItem[nZ][IT_TS][TS_TPCPRES]) .And. aNfItem[nZ][IT_LIVRO][LF_CRDPRES] > 0 .And. aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"ES10000100"
						If aNFItem[nZ][IT_TS][TS_TPCPRES] =="C"
							aAdd(aGrava, {aNfItem[nZ,IT_ITEM], aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ][IT_LIVRO][LF_VALCONT], aNFItem[nZ][IT_TS][TS_CRDPRES], aNfItem[nZ][IT_LIVRO][LF_CRDPRES],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						ElseIf aNFItem[nZ][IT_TS][TS_TPCPRES] =="R"
							aAdd(aGrava, {aNfItem[nZ,IT_ITEM], aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNFItem[nZ][IT_TS][TS_CRDPRES], aNfItem[nZ][IT_LIVRO][LF_CRDPRES],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						EndIf
					ElseIf ( (Right(aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1],TamSx3("CC8_CODIGO")[1])=="009" .And.;
						cUfLanc $ ("MA/MS/SE")) .Or. aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"PA10000997" ) .And. aNfItem[nZ][IT_LIVRO][LF_CRDPRES] > 0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ][IT_LIVRO][LF_VALCONT], aNFItem[nZ][IT_TS][TS_CRDPRES], aNfItem[nZ][IT_LIVRO][LF_CRDPRES],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						lGerou	:=	.T.
						//003 - COMPENSACAO DE SALDO;//004 - ANTECIPACAO TRIBUTARIA;//006 - REEMBOLSO COMERCIAL;//007 - DESCONTO PELO ICMS;//010 - LANCAMENTO EXTEMPORANEO;//011 - RESTITUICAOO DE ICMS/ST - RESSARCIMENTO;//012 - RESTITUICAOO DE ICMS/ST - ABATIMENTO;//013 - RESTITUICAOO DE ICMS/ST - CREDITAMENTO;//014 - ST - TRANSPORTE
					ElseIf(Right(aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1],TamSx3("CC8_CODIGO")[1])=="014" .And.;
						cUfLanc == "MG".And. aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"MG10001014/MG71091014/MG91001014/MG91011014/MG91021014" .And. aNfItem[nZ,IT_VALSOL]>0)
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASESOL], aNfItem[nZ,IT_ALIQSOL], aNfItem[nZ,IT_VALSOL],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						//015 - ORIGEM EM AUTUACOES;//016 - ICMS - IMPORTACAO (COMBUSTIVEIS);//017 - IMPORTACAO;//018 - CRÉDITO PRESUMIDO NAS SAÍDAS DE MERCADORIAS SUBSEQUENTES À IMPORTAÇÃO
					Elseif (Right(aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1],TamSx3("CC8_CODIGO")[1])=="018" .And.;
						cUfLanc $ ("SC") .Or. aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"SC10000018") .And. aNfCab[NF_OPERNF]=="S" .And. cPrdImp == "S".And. aNfItem[nZ,IT_BASEICM] >0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], 3, aNfItem[nZ,IT_BASEICM]*3/100,cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						//019 - CREDITO PRESUMIDO NAS SAIDAS DE PEIXES CRUSTACEOS E MOLUSCOS
					ElseIf ( (Right(aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1],TamSx3("CC8_CODIGO")[1])=="019" .And.;
						cUfLanc $ ("SC")) .Or. aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"SC10000019" ) .And. aNfItem[nZ][IT_LIVRO][LF_CRDPRES] > 0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ][IT_LIVRO][LF_VALCONT], aNFItem[nZ][IT_TS][TS_CRDPRES], aNfItem[nZ][IT_LIVRO][LF_CRDPRES],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					ElseIf cUfLanc $ ("SC") .And. aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"SC10000033" .And. aNfItem[nZ][IT_LIVRO][LF_CRDPRES] > 0 .And. aNfCab[NF_OPERNF]=="S"
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ][IT_LIVRO][LF_VALCONT], aNFItem[nZ][IT_TS][TS_CRDPRES], aNfItem[nZ][IT_LIVRO][LF_CRDPRES],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						//023 - TRANSFERENCIA DE CREDITO ACUMULADO
					ElseIf ( Right(aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1],TamSx3("CC8_CODIGO")[1])=="023" .And.;
						cUfLanc $ ("GO") .And. aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"GO40999023") .And. aNfItem[nZ,IT_VALICM] >0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALICM],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						//027 - RECEBIDO EM TRANSFERENCIA
					ElseIf ( Right(aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1],TamSx3("CC8_CODIGO")[1])=="027" .And.;
						cUfLanc $ ("GO") .And. aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"GO10990027") .And. aNfItem[nZ,IT_VALICM] >0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALICM],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						//029 - CREDITO DE ICMS EMITIDO NA ENTRADA DE MERCADORIA ADQUIRIDA DE FORNECEDORES ENQUADRADOS NO SIMPLES NACIONAL
					ElseIf ( Right(aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1],TamSx3("CC8_CODIGO")[1])=="029" .And.;
						cUfLanc $ ("GO") .And. (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"GO10009029") .And. aNFCab[NF_SIMPNAC] == "1") .And. aNfItem[nZ,IT_VALICM]>0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALICM],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					ElseIf cUfLanc $ ("PA")  .And. (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"PA00000999") .And. aNfCab[NF_OPERNF]=="E" .And. aNFCab[NF_SIMPNAC] == "1" .And. aNfItem[nZ,IT_VALICM]>0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALICM],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						//034 - CREDITO PRESUMIDO NA ENTRADA DE MERCADORIA ADQUIRIDA DE FORNECEDORES ENQUADRADOS NO SIMPLES NACIONAL
					ElseIf (Right(aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1],TamSx3("CC8_CODIGO")[1])=="034" .And.;
						(cUfLanc $ ("SC") .Or. aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"SC10000034") .And. aNfCab[NF_OPERNF]=="E"  .And. aNFCab[NF_SIMPNAC] == "1" .And. aNfItem[nZ,IT_VALICM] >0)
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALICM],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						//999 - OUTROS AJUSTES
						//DIFERENCIAL DE ALIQUOTA SOBRE MATERIAL DE USO/CONSUMO
					ElseIf (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"MG10000504/MG20000504/PA40000002/PA70000017/PB90990018/SC40000003/ES70009702") .And. ;
						aNfItem[nZ,IT_VALCMP]>0 .And. (SubStr(aNfItem[nZ,IT_CF],2,3)$"97 " .Or. SubStr(aNfItem[nZ,IT_CF],2,3)$"556")
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALCMP],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						//ESTORNO DE CREDITO
					ElseIf (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"MA50000000/MS50000000/MS40000000/MS40000999/MS50000999/PA50000999/SC50000999/SC51000999") ;
						.And. aNFItem[nZ][IT_TS][TS_ESTCRED]>0 .And. aNfItem[nZ,IT_ESTCRED]>0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_VALICM], aNFItem[nZ][IT_TS][TS_ESTCRED], aNfItem[nZ,IT_ESTCRED],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						//ICMS DIFERIDO
					ElseIf (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"AL99999323/AL99999324/AL99999325/AL99999326/AL99999327") .And.;
						aNFItem[nZ][IT_TS][TS_PICMDIF]>0 .And. aNFItem[nZ][IT_TS][TS_PICMDIF]<>100 .And. aNfItem[nZ,IT_ICMSDIF]>0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_ICMSDIF],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						//FECOP RN
					Elseif (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RN10000002") .And.;
						cUfLanc $ ("RN") .And. aNFItem[nZ][IT_TS][TS_ISEFERN]=="2" .And. aNfItem[nZ,IT_VFECPRN] > 0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALFECRN], aNfItem[nZ,IT_VFECPRN], cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					Elseif (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RN11000001") .And.;
						cUfLanc $ ("RN") .And. aNFItem[nZ][IT_TS][TS_ISEFERN]=="2" .And. aNfItem[nZ,IT_VFESTRN] > 0 .And. Substr(aNfItem[nZ,IT_CF],1,1)=="5"
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASESOL], aNfItem[nZ,IT_ALFECRN], aNfItem[nZ,IT_VFESTRN], cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					Elseif (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RN11000002") .And.;
						cUfLanc $ ("RN") .And. aNFItem[nZ][IT_TS][TS_ISEFERN]=="2" .And. aNfItem[nZ,IT_VFESTRN] > 0 .And. Substr(aNfItem[nZ,IT_CF],1,1)=="2"
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASESOL], aNfItem[nZ,IT_ALFECRN], aNfItem[nZ,IT_VFESTRN], cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					Elseif (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RN70000001") .And.;
						cUfLanc $ ("RN") .And. aNFItem[nZ][IT_TS][TS_ISEFERN]=="2" .And. aNfItem[nZ,IT_VFECPRN] > 0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALFECRN], aNfItem[nZ,IT_VFECPRN], cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					Elseif (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RN71000001") .And.;
						cUfLanc $ ("RN") .And. aNFItem[nZ][IT_TS][TS_ISEFERN]=="2" .And. aNfItem[nZ,IT_VFESTRN] > 0 .And. Substr(aNfItem[nZ,IT_CF],1,1)=="5"
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASESOL], aNfItem[nZ,IT_ALFECRN], aNfItem[nZ,IT_VFESTRN], cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					Elseif (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RN71000002") .And.;
						cUfLanc $ ("RN") .And. aNFItem[nZ][IT_TS][TS_ISEFERN]=="2" .And. aNfItem[nZ,IT_VFESTRN] > 0 .And. Substr(aNfItem[nZ,IT_CF],1,1)=="2"
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASESOL], aNfItem[nZ,IT_ALFECRN], aNfItem[nZ,IT_VFESTRN], cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					Elseif (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RN00000002") .And.;
						cUfLanc $ ("RN") .And. aNFItem[nZ][IT_TS][TS_ANTICMS]=="1" .And. aNfItem[nZ,IT_VALANTI] > 0 .And. ;
						Substr(aNfItem[nZ,IT_CF],1,1)=="2"
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASESOL], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALANTI],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					Elseif (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RN70000003") .And.;
						cUfLanc $ ("RN") .And. aNFItem[nZ][IT_TS][TS_ANTICMS]=="1" .And. aNfItem[nZ,IT_VALANTI] > 0 .And. ;
						Substr(aNfItem[nZ,IT_CF],1,1)=="2"
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASESOL], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALANTI],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//Crédito
					Elseif (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RN00000010") .And. cUfLanc $ ("RN") .And. aNfCab[NF_OPERNF]=="E" .And. 	aNFItem[nZ][IT_TS][TS_CREDST]<>"3" .And. ;
						Substr(aNfItem[nZ,IT_CF],1,1)=="2" .And.  aNfItem[nZ,IT_VALSOL]>0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASESOL], aNfItem[nZ,IT_ALIQSOL], aNfItem[nZ,IT_VALSOL],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//Débitos Especiais
					Elseif (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RN70000005") .And. cUfLanc $ ("RN") .And. aNfCab[NF_OPERNF]=="E" .And. Substr(aNfItem[nZ,IT_CF],1,1)=="2" .And. aNfItem[nZ,IT_VALSOL] >0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASESOL], aNfItem[nZ,IT_ALIQSOL], aNfItem[nZ,IT_VALSOL],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//Còdigo informativo não leva antecipação
					Elseif (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RN99990004") .And. cUfLanc $ ("RN").And. aNfItem[nZ,IT_VALSOL]>0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASESOL], aNfItem[nZ,IT_ALIQSOL], aNfItem[nZ][IT_VALSOL],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						//Diferencia de alíquota de Ativo Permanente
					Elseif (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RN70009002") .And. cUfLanc $ ("RN") .And. aNfCab[NF_OPERNF]=="E" .And. SubStr(aNfItem[nZ,IT_CF],2,3)$"551|552|352" .And. aNfItem[nZ][IT_VALCMP] > 0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASESOL], aNfItem[nZ][IT_ALIQSOL], aNfItem[nZ][IT_VALSOL],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//Diferencia de alíquota de Serv. de Transporte
					ElseIf aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RN70001004" .And. aNfCab[NF_OPERNF]=="E"  .And. (AllTrim(aNFCab[NF_ESPECIE]) $ "CTR/CTE" .Or. "NFST"$AllTrim(aNFCab[NF_ESPECIE])) .And. aNfItem[nZ,IT_VALCMP]>0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASESOL], aNfItem[nZ][IT_ALIQSOL], aNfItem[nZ][IT_VALSOL],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//Diferencia de alíquota de Ativo Permanente
					Elseif (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RN70009005") .And.	cUfLanc $ ("RN") .And. aNfCab[NF_OPERNF]=="E" .And. SubStr(aNfItem[nZ,IT_CF],2,3)$"551|552|352" .And. aNfItem[nZ][IT_VALCMP] > 0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ][IT_ALIQICM], aNfItem[nZ][IT_VALCMP],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//Diferencia de alíquota Uso e Consumo
					Elseif (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RN70009006") .And.	cUfLanc $ ("RN") .And. aNfCab[NF_OPERNF]=="E" .And. SubStr(aNfItem[nZ,IT_CF],2,3)$"556|557|352" .And. aNfItem[nZ][IT_VALCMP] > 0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ][IT_ALIQICM], aNfItem[nZ][IT_VALCMP],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						//CRÉDITO PRESUMIDO NA SAÍDA RONDÔNIA
					Elseif (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RO10000012/RO10000006/RO10000007/RO10000003") .And.	cUfLanc $ ("RO") .And. aNfCab[NF_OPERNF]=="S" .And. aNfItem[nZ][IT_LIVRO][LF_CRPRERO] > 0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_VALICM], aNFItem[nZ][IT_TS][TS_CRPRERO], aNfItem[nZ][IT_LIVRO][LF_CRPRERO],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						//Notas Fiscais de saídas com isenção - Rondônia
					Elseif (Right(aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1],TamSx3("CC8_CODIGO")[1])$"009/016/017/068/078/083/130/021/022/037/086/116") .And.	cUfLanc $ ("RO") .And. aNfCab[NF_OPERNF]=="S" .And. aNFItem[nZ][IT_TS][TS_LFICM] $"I".And. aNfItem[nZ,IT_VALICM] >0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1",aNfItem[nZ,IT_BASEICM], aNfItem[nZ][IT_ALIQICM], aNfItem[nZ][IT_VALICM],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						//Diferencia de alíquota de Ativo Permanente
					Elseif (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RO40000001/ES70009701") .And.	cUfLanc $ ("RO/ES") .And. aNfCab[NF_OPERNF]=="E" .And. SubStr(aNfItem[nZ,IT_CF],2,3)$"551|552|352" .And. aNfItem[nZ][IT_VALCMP] > 0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ][IT_ALIQICM], aNfItem[nZ][IT_VALCMP],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//Redução de Base de Calculo
					Elseif (Right(aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1],TamSx3("CC8_CODIGO")[1])$"165/166/170/175/183/195") .And. cUfLanc $ ("RO") .And. aNfCab[NF_OPERNF]=="S" .And. aNFItem[nZ][IT_TS][TS_BASEICM]>0 .And. aNFItem[nZ][IT_TS][TS_LFICM] $"IO" .And. aNFItem[nZ][IT_TS][TS_CONSUMO]$"SO"
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM],aNfItem[nZ,IT_ALIQICM],aNFItem[nZ][IT_TS][TS_BASEICM],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//Diferencial de alíquota de transporte
					ElseIf aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"ES70009703" .And. aNfCab[NF_OPERNF]=="E"  .And. (AllTrim(aNFCab[NF_ESPECIE]) $ "CTR/CTE" .Or. "NFST"$AllTrim(aNFCab[NF_ESPECIE])) .And. aNfItem[nZ,IT_VALCMP]>0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ][IT_ALIQICM], aNfItem[nZ][IT_VALCMP],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						//Diferencia de alíquota Uso e consumo
					Elseif (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RO40000002") .And.	cUfLanc $ ("RO") .And. aNfCab[NF_OPERNF]=="E" .And. SubStr(aNfItem[nZ,IT_CF],2,3)$"556|557|352" .And. aNfItem[nZ,IT_VALCMP]>0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ][IT_ALIQICM], aNfItem[nZ][IT_VALCMP],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						//DEBITO POR TRANSFERENCIA DE SALDO CREDOR
					ElseIf Alltrim(aNFItem[nZ][IT_CF]) $ "5601/5602" .And. aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RS40009193" .And. aNfItem[nZ,IT_VALICM]>0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALICM],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//CÓDIGOS DO ESTADO RIO GRANDE DO SUL
					//Antecipação de ICMS Rio Grande do Sul
					ElseIf aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RS10000106/RS40000313" .And. aNFItem[nZ][IT_TS][TS_ANTICMS]=="1" .And. aNfItem[nZ,IT_VALANTI] > 0 .And. aNFCab[NF_UFDEST] == "RS" .And. aNFCab[NF_UFORIGEM] <> "RS"
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALANTI],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//Devolução de Mercadoria recebida pra uso e consumo
					ElseIf aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RS10000206" .And. aNfCab[NF_OPERNF]=="S" .And. aNFCab[NF_TIPONF] $ "D" .And. SubStr(aNfItem[nZ,IT_CF],2,3)$"556" .And. aNfItem[nZ][IT_VALICM] >0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1",aNfItem[nZ,IT_BASEICM], aNfItem[nZ][IT_ALIQICM], aNfItem[nZ][IT_VALICM],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//Créditos presumidos - LIVRO I, ART. 32, LXIII - LEITE FLUIDO
					ElseIf aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RS10009269" .And. aNfCab[NF_OPERNF]=="S" .And. aNFCab[NF_UFORIGEM] == "RS" .And. aNFCab[NF_UFDEST] <> "RS" .AND. aNfItem[nZ][IT_LIVRO][LF_CRDPRES] > 0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1",aNfItem[nZ,IT_VALICM], aNFItem[nZ][IT_TS][TS_CRDPRES], aNfItem[nZ][IT_LIVRO][LF_CRDPRES],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//Créditos presumidos - LIVRO I, ART. 32, CVII.LEITE DE PROD.PROP.PROD.RUR
					ElseIf aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RS10009314" .And. aNfCab[NF_OPERNF]=="E" .And. SubStr(aNfItem[nZ,IT_CF],1,1)$"1" .And. aNfItem[nZ][IT_LIVRO][LF_CRDPRES] > 0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1",aNfItem[nZ,IT_VALICM], aNFItem[nZ][IT_TS][TS_CRDPRES], aNfItem[nZ][IT_LIVRO][LF_CRDPRES],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					ElseIf aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RS10009906" .And. aNfCab[NF_OPERNF]=="E" .AND. cUfLanc $ ("RS") .And. !aNFItem[nZ][IT_TS][TS_LFICM]=="Z" .And. aNfItem[nZ][IT_VALICM] > 0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1",aNfItem[nZ,IT_BASEICM], aNfItem[nZ][IT_ALIQICM], aNfItem[nZ][IT_VALICM],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//DÉBITOS POR RESPONSABILIDADE - ICMS DIFERIDO DO DOCUMENTO DE SAÍDA
					ElseIf aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RS40000010" .And. aNfCab[NF_OPERNF]=="S" .AND. cUfLanc $ ("RS") .And. aNfItem[nZ][IT_ICMSDIF] >0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1",0, 0, aNfItem[nZ][IT_ICMSDIF],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						//Diferencial de Aliquota calculado na Entrada de Outros Débitos
					ElseIf (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RS40000113") .And. aNfItem[nZ,IT_VALCMP]>0 .And. aNfCab[NF_OPERNF]=="E" .And. aNfCab[NF_UFORIGEM] <> "RS"
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM],aNfItem[nZ,IT_ALIQCMP] - aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALCMP],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						//Diferencial de Aliquota calculado na Entrada de Débitos Especiais
					ElseIf (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"MG70001001") .And. aNfItem[nZ,IT_VALCMP]>0 .And. aNfCab[NF_OPERNF]=="E" .And. aNfCab[NF_UFORIGEM] <> "MG"
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALCMP],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
						//Outros Débitos
					ElseIf aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"ES40000400" .And.  aNfItem[nZ,IT_VALICM] >0
						aAdd(aGrava, {aNfItem[nZ,IT_ITEM], aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALICM],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					// Códigos do RS onde o débito se dá por uma nota fiscal emitida no final do período
					ElseIf aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RS40000213/RS40001010/RS40009913/RS40000010/RS41009705" .And. aNfCab[NF_OPERNF]=="S" .And. aNFItem[nZ][IT_TS][TS_LFICM]=="Z" .And. aNfItem[nZ,IT_VALMERC]>0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1",0, 0, aNfItem[nZ][IT_VALMERC],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					// Códigos do RS onde o crédito se dá por uma nota fiscal emitida no final do período
					ElseIf aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RS10009906/RS10009269/RS10000106/RS10009314/RS10000206/" .And. aNfCab[NF_OPERNF]=="E" .And. aNFItem[nZ][IT_TS][TS_LFICM]=="Z" .And. aNfItem[nZ,IT_VALMERC]>0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1",0, 0, aNfItem[nZ][IT_VALMERC],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//Debitos Especiais; Op.ST; Resp.:propria; Apur.:Recolhimento espontaneo; Mercadoria;ST interna
					//Débitos especiais; Op. ST; Resp. Solidária, Apur.; Recolhimento Espontâneo. Mercadoria; Op. Normal.
					ElseIf cUfLanc=="MG" .And. (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"MG71010501/MG71110000")  .And. aNfItem[nZ][IT_VALSOL] >0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1",0, 0, aNfItem[nZ][IT_VALSOL],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					ElseIf cUfLanc=="ES".And. aNfCab[NF_OPERNF]=="E" .And. aNfCab[NF_UFORIGEM] <> "ES" .And. (aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"ES71000712") .And. aNFItem[nZ][IT_TS][TS_ANTICMS]=="1" .And. aNfItem[nZ,IT_VALANTI] > 0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALANTI],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//"Créditos por Transferência" - LIVRO I,ART.59,I,"A" -ESTABELECIMENTO MESMA EMPRESA - Saída
					ElseIf cUfLanc$("RS") .AND. aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RS10009004" .And. aNfCab[NF_OPERNF]=="S"
						aAdd(aGrava, {aNfItem[nZ,IT_ITEM], aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", 0, 0, aNfItem[nZ,IT_VALMERC], cSeq, cIFCOMP, cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//"Créditos por Transferência" - LIVRO I, ART.58, II, NOTA01, B, E ART.58, II, "A" do RICMS/RS - Entrada
					ElseIf cUfLanc$("RS") .AND. aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RS10009031" .And. aNfCab[NF_OPERNF]=="E"
						aAdd(aGrava, {aNfItem[nZ,IT_ITEM], aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", 0, 0, aNfItem[nZ,IT_VALMERC], cSeq, cIFCOMP, cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//"Ressarcimento de ICMS ST decorrente da venda para contribuinte localizado em outra unidade da fereção
					ElseIf cUfLanc$("SC") .AND. aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"SC11000002" .And. aNfCab[NF_OPERNF]=="S" .And. SubStr(aNfItem[nZ,IT_CF],1,1)$"6" .And. aNfItem[nZ,IT_VALSOL]>0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASESOL], aNfItem[nZ,IT_ALIQSOL], aNfItem[nZ,IT_VALSOL],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//Crédito proporcional a mercadoria recebida com ST quando efetuada nova retenção
					ElseIf cUfLanc$("SC") .AND. aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"SC10000030" .And. aNfCab[NF_OPERNF]=="E"  .And. aNFItem[nZ][IT_TS][TS_SITTRIB]=="60" .And. aNfItem[nZ,IT_VALICM] >0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALICM],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//ICMS devido na importação
					ElseIf cUfLanc$("SC") .AND. aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"SC70000005" .And. aNfCab[NF_OPERNF]=="E" .And. SubStr(aNfItem[nZ,IT_CF],1,1)$"3" .And. aNfItem[nZ,IT_VALICM] >0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALICM],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//Crédito presumido na saída de mercadorias importadas do exterior
					ElseIf cUfLanc$("SC") .AND. aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"SC10000013" .And. aNfCab[NF_OPERNF]=="S" .And. aNfItem[nZ][IT_LIVRO][LF_CRDPRES] > 0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNFItem[nZ][IT_TS][TS_CRDPRES], aNfItem[nZ][IT_LIVRO][LF_CRDPRES],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//Estorno de Débito - Produtos Primários - ICMS recolhido antecipadamente
					ElseIf cUfLanc$("RO") .AND. aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RO20000002" .And. aNfCab[NF_UFORIGEM]=="RO" .And. aNfCab[NF_OPERNF]=="S" .And. aNFItem[nZ][IT_TS][TS_SITTRIB]$"10/60" .And. aNfItem[nZ,IT_VALICM] >0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALICM],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//ICMS devido pelo remetente relativo ao servico de transportadora de outra UF, RICM - art. 220, I
					ElseIf cUfLanc$("ES") .AND. aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"ES70001706" .And. aNfCab[NF_UFORIGEM]=="ES" .And. aNfCab[NF_OPERNF]=="S" .And. SubStr(aNfItem[nZ,IT_CF],1,1)$"6" .And. aNfItem[nZ,IT_AUTONOMO] > 0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICA], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALICA],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//Débito de ICMS devido pela entrada de mercadorias sujeitas ao regime de substituição tributária
					ElseIf aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"SC41000002" .AND. aNFCab[NF_OPERNF] == "E" .AND. aNFItem[nZ][IT_TS][TS_ANTICMS] == "1" .AND. SubStr(aNfItem[nZ,IT_CF],1,1)$"2" .And. aNfItem[nZ,IT_VALANTI] > 0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALANTI],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//"Outros débitos" do ICMS ST, tais os débitos do RICMS, Livro III, arts. 53-A e 53-C
					ElseIf aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RS41009705" .AND. aNFCab[NF_OPERNF] == "E" .AND. aNFItem[nZ][IT_TS][TS_ANTICMS] == "1" .AND. SubStr(aNfItem[nZ,IT_CF],1,1)$"2/3" .And. aNfItem[nZ,IT_VALANTI] > 0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALANTI],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					ElseIf aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RS41009705" .AND. aNFCab[NF_OPERNF] == "E" .AND. aNFItem[nZ][IT_TS][TS_COMPL]=="S" .AND. SubStr(aNfItem[nZ,IT_CF],1,1)$"2/3" .And. aNfItem[nZ,IT_VALCMP] > 0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM], aNfItem[nZ,IT_VALCMP],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//Diferencial de alíquota FECP Rio de Janeiro
					ElseIf cUfLanc$("RJ") .AND. aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RJ70000006" .AND. aNFCab[NF_OPERNF] == "E" .And. aNfItem[nZ][IT_VALFECP]>0 .AND. aNfItem[nZ,IT_VALCMP]>0
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQFECP], aNfItem[nZ,IT_VALFECP],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//Fecp na Importação para o Rio de Janeiro
					ElseIf cUfLanc$("RJ") .AND. aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RJ70000005".AND. aNFCab[NF_OPERNF] == "E" .And. aNfItem[nZ][IT_VALFECP]>0 .AND. SubStr(aNfItem[nZ,IT_CF],1,1)$"3"
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQFECP], aNfItem[nZ,IT_VALFECP],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//Valor de ICMS na operação de importação para o Estado do Rio de Janeiro.
					ElseIf cUfLanc$("RJ") .AND. aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"RJ70000001".AND. aNFCab[NF_OPERNF] == "E" .And. aNfItem[nZ][IT_VALICM]>0 .AND. SubStr(aNfItem[nZ,IT_CF],1,1)$"3"
						aAdd(aGrava, {cItem, aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1], "1", aNfItem[nZ,IT_BASEICM], aNfItem[nZ,IT_ALIQICM]-aNfItem[nZ,IT_ALIQFECP], aNfItem[nZ,IT_VALICM]-aNfItem[nZ,IT_VALFECP],cSeq,cIFCOMP,cTpLanc,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					//Deducoes do FECOMP - MS
					ElseIf cUfLanc$("MS") .And. aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]$"MS60000011" .And. aNfItem[nZ][IT_VALICM]>0 .And. aNfItem[nZ][IT_VALFECP]>0
						aAdd(aGrava, { cItem , aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1] , "1" , aNfItem[nZ,IT_BASEICM] , aNfItem[nZ,IT_ALIQFECP] , aNfItem[nZ,IT_VALFECP] , cSeq , cIFCOMP , cTpLanc ,"",cCmp0460,cCodRefl,cGeraGNRE,cCMPOrig})
					Else
						lGerou	:= .F.
					EndIf
				Else
					//Tratamento para:
					//Estados sem a publicação de tabela de ajustes de ICMS ou;
					//Codigos de Ajuste de Apuracao com Reflexo relacionado ou;
					//Novo mecanismo de configuracao para Codigos de Ajuste de NF
					If aDic[AI_CE0]
						CE0->(dbSetOrder(1))

						//O campo CC7_CODREF podera ser utilizado em qualquer tipo de Codigo (Apuracao ou de NF). Portanto, sempre que
						//este campo for preenchido (posicao 3 do array TS_LANCFIS) devera ser priorizado na consulta a tabela CE0.
						If !Empty( aNFItem[nZ][IT_TS][TS_LANCFIS,nI,3] )
							If CE0->( MsSeek( xFilial( "CE0" ) + aNFItem[nZ][IT_TS][TS_LANCFIS,nI,3] ) )
								lHasRefl	:=	.T.
							Endif

						//Quando nao utilizar o campo CC7_CODREF, para os codigos de Apuracao ainda existe a possibilidade do reflexo
						//ter sido associado atraves do campo CDO_CODREF (que esta no proprio cadastro do Ajuste).
						Elseif cPaisLoc == "BRA" .And. cTpLanc == '1'
							If aPos[FP_CDO_CODREF]
								CDO->(dbSetOrder(1))
								If CDO->( MsSeek( xFilial( "CDO" ) + aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1] ) )
									If CE0->( MsSeek( xFilial( "CE0" ) + CDO->CDO_CODREF ) )
										lHasRefl	:=	.T.
									Endif
								Endif
							Endif
						Endif
						If lHasRefl
							aParam	:= array(11)
							aParam[1] := aNFItem[nZ][IT_TS][TS_LANCFIS,nI,1]
							aParam[2] := cSeq
							aParam[3] := cIFCOMP
							aParam[4] := cTpLanc
							aParam[5] := cCmp0460
							aParam[6] := cCodRefl
							aParam[7] := cGeraGNRE
							aParam[8] := cCMPOrig
							aParam[9] := ""
							aParam[10] := ""
							aParam[11] := ""
							
							lGerou := MaCalcRefl(aGrava,nZ,nI,aParam)
						Endif
					Endif					
				EndIf
			EndIf
		Next nI
		
		//Processa Códigos Declaratorios
		MaCodDecl(nZ)
		For nX := 1 To Len(aNFItem[nZ][IT_CODDECL])
			lHasRefl	:=	.F.
			//Verifica qual eh a UF do codigo de ajuste corrente
			cUfLanc  := Substr(aNFItem[nZ][IT_CODDECL,nX,1],1,2)			
			cCodRefl :=	aNFItem[nZ][IT_CODDECL,nX,3]
			cCMPOrig := "4"
			cTpLanc	 := ""
			cCmp0460 := aNFItem[nZ][IT_CODDECL,nX,2]
			cIFCOMP  := ""
			cGeraGNRE:= ""

			//Verifica se a UF do codigo de ajuste corresponde a UF do MV_ESTADO
			If cUfLanc $ aSX6[MV_ESTADO] .And. !Empty(cCodRefl)			

				If aDic[AI_CE0]
					CE0->(dbSetOrder(1))					
					If CE0->( MsSeek( xFilial( "CE0" ) + aNFItem[nZ][IT_CODDECL,nX,3] ) )
						lHasRefl	:=	.T.
					Endif				
					If lHasRefl
						//Captura o proximos codigo de sequencia a ser utilizado
						If Len(aGrava) > 0
							nPosSeq	 :=	7
							aBkpaCls :=	aClone(aGrava)
							aSort(aBkpaCls,,,{|aX,aY| aX[nPosSeq]<aY[nPosSeq]})
							cSeq :=	aBkpaCls[Len(aBkpaCls),nPosSeq]
							cSeq := Soma1(cSeq)
						EndIf

						aParam	:= array(11)
						aParam[1] := aNFItem[nZ][IT_CODDECL,nX,1]
						aParam[2] := cSeq
						aParam[3] := cIFCOMP
						aParam[4] := cTpLanc
						aParam[5] := cCmp0460
						aParam[6] := cCodRefl
						aParam[7] := cGeraGNRE
						aParam[8] := cCMPOrig
						aParam[9] := aNFItem[nZ][IT_CODDECL,nX,4]
						aParam[10] := aNFItem[nZ][IT_TS][TS_NRLIVRO]
						aParam[11] := aNFItem[nZ][IT_CODDECL,nX,2]
						
						lGerou := MaCalcRefl(aGrava,nZ,nX,aParam)
					Endif
				Endif
			Endif
		Next nX
	Next nZ
EndIf
RestArea(aArea)

Return aGrava

/* FUNCOES PARA CALCULO DE IMPOSTOS - LOCALIZADOS E IMPOSTOS VARIAVEIS (BRASIL) */

/*/
MaFisBSIV - Edson Maricate  -02.02.2000
Executa o calculo da Base dos Impostos Variaveis
Parametros
ExpN1: Numero do Imposto ( 1 a X )
ExpN2: Item a ser calculado
/*/
Static Function MaFisBSIV(nImposto,nItem)

Local nBaseRet
Local nImp     := Len(aTes[TS_SFC])
Local nImpde   := IIF(nImposto==Nil,1,nImposto)
Local nImpAte  := IIF(nImposto==Nil,nImp,nImposto)

Private aInfo   //Definida como private pois é usada numa macro    := {}
// Verifica se a TES possui tratamento para Impostos Variaveis
If !Empty(aTes[TS_SFC])
	If nImpde>0 .And. nImpAte>0
		For nImposto := nImpDe to nImpAte
			// Executa o calculo atraves da Funcao cadastrada no SFB
			aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
			nImp:=NumCpoImpVar(aInfo[2])
			If aNfCab[NF_OPERNF] == "E"
				If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
					If cPaisLoc <> "BRA"
						nBaseRet := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo)')
						If ValType(nBaseRet) == "N"
							aNfItem[nItem][IT_BASEIMP][nImp]:= nBaseRet
						EndIf
					Else
						aNfItem[nItem][IT_BASEIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"B",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
					EndIf
					aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
				EndIf
			Else
				If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
					If cPaisLoc <> "BRA"
						nBaseRet :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo)')
						If ValType(nBaseRet) == "N"
							aNfItem[nItem][IT_BASEIMP][nImp]:= nBaseRet
						EndIf
					Else
						aNfItem[nItem][IT_BASEIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"B",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
					EndIf
					aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
				EndIf
			EndIf
		Next nImposto
	Endif
Else
	// Zera todas as aliquotas.
	For nImposto := 1 to NMAXIV
		aNFItem[nItem][IT_BASEIMP][nImposto]:= 0
		aNfItem[nItem][IT_DESCIV][nImposto] := {"","",""}
	Next nImposto
EndIf

Return Nil

/*/
MaFisAliqIV - Edson Maricate-02.02.2000
Executa o calculo da Aliquota dos Impostos Variaveis
Parametros
ExpN1: Numero do Imposto ( 1 a 6 )
ExpN2: Item a ser calculado
/*/
Static Function MaFisAliqIV(nImposto,nItem)

Local nAliqImp
Local nImp	  :=Len(aTes[TS_SFC])
Local nImpde  :=IIF(nImposto==Nil,1,nImposto)
Local nImpAte :=IIF(nImposto==Nil,nImp,nImposto)
Local nMv_ALQIPM	:= aSX6[MV_ALQIPM]
Local cMV_AGENTE    := aSX6[MV_AGENTE]
Local alAreaX
Local alAreaY
Local alAreaZ
Local nlTotal := 0
Local nlCont  := 0
Local nlMinDIG := aSX6[MV_MINDETR]
Private aInfo 									  //Definida como private pois é usada numa macro
// Verifica se a TES possui tratamento para Impostos Variaveis
If cPaisLoc=="PER"  .And. aPos[FP_B1_VMINDET]
	nlMinDIG := Iif( aNfItem[nItem][IT_PRD][SB_VMINDET] > 0 , aNfItem[nItem][IT_PRD][SB_VMINDET] , nlMinDIG )
EndIf

If !Empty(aTes[TS_SFC])
	If nImpde>0 .And. nImpAte>0
		For nImposto := nImpDe to nImpAte
			//       Tratamento especifico para localizado PERU
			// Abaixo estão as aliquotas dos impostos variáveis de acordo
			// com as regras de ISC, IGV, PIV e DIG. Caso não seja nenhum
			// desses executa normalmente como se fosse não localizado

			//Caso nao seja localizado Peru, executa o padrão
			If cPaisLoc $ "PER"
				alAreaX := SFC->(GetArea())
				alAreaY := SF4->(GetArea())
				alAreaZ := GetArea()

				If aTes[TS_SFC][nImposto][SFC_IMPOSTO] $ "IGV"
					DbSelectArea("SF4")
					DbSetOrder(1)
					If MsSeek(xFilial("SF4")+aTes[TS_CODIGO])
						If (SF4->F4_CALCIGV <> "2" .And. SF4->F4_CALCIGV <> "3")

							// Executa o calculo atraves da Funcao cadastrada no SFB
							aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
							nImp:=NumCpoImpVar(aInfo[2])
							If aNfCab[NF_OPERNF] == "E"
								If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
									If cPaisLoc <> "BRA"
										nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("A",'+Str(nItem)+',aInfo)')
										If ValType(nAliqImp) == "N"
											aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp

											//          TRATAMENTO EXPECIFICO PARA LOCALIZADO PERU
											// Quando o TES for referente ao imposto do IGV, o valor do IPM, o
											// qual é uma porcentagem do IGV,o valor da base, aliquota e valor do
											// imposto é gravado nos campos _BASIMP3, _ALQIMP3 e VALIMP3.
											// O valor da base é a mesma utilizada para o cálculo do IGV.
											// O valor da alíqutoa é proveniente de um paramêtro chamado
											// MV_ALQIPM.
											// O valor do imposto é a multiplicação da base pelo valor da aliquota
											// NO CASO ABAIXO APENAS A ALIQUOTA DO IMPOSTO é PREENCHIDA PARA ENTRA-
											// DA.

											aNfItem[nItem][IT_ALIQIMP][3]:= nMv_ALQIPM
										EndIf
									Else
										aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
									EndIf
								EndIf
							Else
								If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
									If cPaisLoc <>"BRA"

										nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("A",'+Str(nItem)+',aInfo)')

										If ValType(nAliqImp) == "N"
											aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp

											//          TRATAMENTO EXPECIFICO PARA LOCALIZADO PERU
											// NO CASO ABAIXO APENAS A ALIQUOTA DO IMPOSTO é PREENCHIDA PARA SAIDA.

											aNfItem[nItem][IT_ALIQIMP][3]:= nMv_ALQIPM

										EndIf
									Else
										aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
									EndIf
								EndIf
							EndIf
						EndIf
					EndIf
				ElseIf aTes[TS_SFC][nImposto][SFC_IMPOSTO] $ "PIV"

					// Executa o calculo atraves da Funcao cadastrada no SFB
					aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
					nImp:=NumCpoImpVar(aInfo[2])
					If aNfCab[NF_OPERNF] == "E"

						If aNfCab[NF_CLIFOR] $ "F"

							If SubStr(cMV_AGENTE,2,1) == "S" .And.  SA2->A2_AGENRET <> "1"

								If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
									If cPaisLoc <> "BRA"

										nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("A",'+Str(nItem)+',aInfo)')

										If ValType(nAliqImp) == "N"
											aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp
										EndIf
									Else
										aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
									EndIf
								EndIf

							EndIf

						ElseIf aNfCab[NF_CLIFOR] $ "C"

							If SA1->A1_AGENTE == "2"

								If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
									If cPaisLoc <> "BRA"

										nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("A",'+Str(nItem)+',aInfo)')

										If ValType(nAliqImp) == "N"
											aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp
										EndIf
									Else
										aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
									EndIf
								EndIf
							EndIf
						EndIf
					Else
						If aNfCab[NF_CLIFOR] $ "C"

							If SA1->A1_AGENTE == "2"

								If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
									If cPaisLoc <>"BRA"

										nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("A",'+Str(nItem)+',aInfo)')

										If ValType(nAliqImp) == "N"
											aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp

										EndIf
									Else
										aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
									EndIf
								EndIf

							EndIf

						ElseIf aNfCab[NF_CLIFOR] $ "F"

							If SubStr(cMV_AGENTE,2,1) == "S" .And.  SA2->A2_AGENRET <> "1"

								If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
									If cPaisLoc <>"BRA"

										nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("A",'+Str(nItem)+',aInfo)')

										If ValType(nAliqImp) == "N"
											aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp

										EndIf
									Else
										aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
									EndIf
								EndIf

							EndIf

						EndIf

					EndIf

				ElseIf aTes[TS_SFC][nImposto][SFC_IMPOSTO] $ "DIG"

					nlTotal := MaRetBasT(,,,.T.)

					nlTOtal += aNfCab[NF_FRETE] + aNfCab[NF_DESPESA] + aNfCab[NF_SEGURO] - (aNfCab[NF_DESCONTO]+aNfCab[NF_DESCTOT]) + aNfCab[NF_ACRESCI]

					If AllTrim(Upper(FunName())) $ "MATA465N/MATA466N/MATA467N/MATA101N/MATA121" .And. aNFCab[NF_TXMOEDA] <> 0

						nlTotal := nlTotal * aNFCab[NF_TXMOEDA]

					ElseIf AllTrim(Upper(FunName())) $ "MATA410"

						nlTotal := xMoeda(nlTotal,M->C5_MOEDA,1,dDataBase)

					EndIf
					If nlTotal > nlMinDIG

						// Executa o calculo atraves da Funcao cadastrada no SFB

						MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)

						aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
						nImp:=NumCpoImpVar(aInfo[2])
						If aNfCab[NF_OPERNF] == "E"

							If aNfCab[NF_CLIFOR] $ "F"

								If SubStr(cMV_AGENTE,3,1) == "S" .And.  SA2->A2_AGENRET <> "1"

									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
										If cPaisLoc <> "BRA"

											nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("A",'+Str(nItem)+',aInfo)')

											If ValType(nAliqImp) == "N"
												aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp
											EndIf
										Else
											aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
										EndIf
									EndIf

								EndIf

							ElseIf aNfCab[NF_CLIFOR] $ "C"

								If SubStr(cMV_AGENTE,1,1) == "N" .And.  SA1->A1_AGENTE == "3"

									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
										If cPaisLoc <> "BRA"

											nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("A",'+Str(nItem)+',aInfo)')

											If ValType(nAliqImp) == "N"
												aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp
											EndIf
										Else
											aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
										EndIf
									EndIf
								EndIf
							EndIf
						Else

							If aNfCab[NF_CLIFOR] $ "C"

								If SubStr(cMV_AGENTE,1,1) == "N" .And.  SA1->A1_AGENTE == "3"

									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
										If cPaisLoc <>"BRA"

											nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("A",'+Str(nItem)+',aInfo)')

											If ValType(nAliqImp) == "N"
												aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp

											EndIf
										Else
											aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
										EndIf
									EndIf

								EndIf

							ElseIf aNfCab[NF_CLIFOR] $ "F"

								If SubStr(cMV_AGENTE,3,1) == "S" .And.  SA2->A2_AGENRET <> "1"

									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
										If cPaisLoc <>"BRA"

											nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("A",'+Str(nItem)+',aInfo)')

											If ValType(nAliqImp) == "N"
												aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp

											EndIf
										Else
											aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
										EndIf
									EndIf

								EndIf

							EndIf

						EndIf
					EndIf
				Else
					// Executa o calculo atraves da Funcao cadastrada no SFB
					aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
					nImp:=NumCpoImpVar(aInfo[2])
					If aNfCab[NF_OPERNF] == "E"
						If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
							If cPaisLoc <> "BRA"

								nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("A",'+Str(nItem)+',aInfo)')
								If ValType(nAliqImp) == "N"
									aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp
								EndIf
							Else
								aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
							EndIf
						EndIf
					Else
						If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
							If cPaisLoc <>"BRA"
								nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("A",'+Str(nItem)+',aInfo)')
								If ValType(nAliqImp) == "N"
									aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp
								EndIf
							Else
								aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
							EndIf
						EndIf
					EndIf
				EndIf
				RestArea(alAreaX)
				RestArea(alAreaY)
				RestArea(alAreaZ)
			Else
				// Executa o calculo atraves da Funcao cadastrada no SFB
				aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
				nImp:=NumCpoImpVar(aInfo[2])
				If aNfCab[NF_OPERNF] == "E"
					If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
						If cPaisLoc <> "BRA"

							nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("A",'+Str(nItem)+',aInfo)')

							If ValType(nAliqImp) == "N"
								aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp
							EndIf
						Else
							aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
						EndIf
					EndIf
				Else
					If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
						If cPaisLoc <>"BRA"

							nAliqImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("A",'+Str(nItem)+',aInfo)')

							If ValType(nAliqImp) == "N"
								aNfItem[nItem][IT_ALIQIMP][nImp]:= nAliqImp

							EndIf
						Else
							aNfItem[nItem][IT_ALIQIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"A",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
						EndIf
					EndIf
				EndIf
			EndIf
		Next nImposto
	Endif
Else
	// Zera todas as aliquotas.
	For nImposto := 1 to NMAXIV
		aNFItem[nItem][IT_ALIQIMP][nImposto]:= 0
	Next nImposto
EndIf
Return Nil

/*/
MaFisVLIV - Edson Maricate  -02.02.2000
Executa o calculo do Valor dos Impostos Variaveis
Parametros
ExpN1: Numero do Imposto ( 1 a X )
ExpN2: Item a ser calculado
/*/
Static Function MaFisVLIV(nImposto,nItem)

Local nValImp  := 0
Local nImp		:=Len(aTes[TS_SFC])
Local nImpde 	:=IIF(nImposto==Nil,1,nImposto)
Local nImpAte	:=IIF(nImposto==Nil,nImp,nImposto)
Local cMV_AGENTE  	:= aSX6[MV_AGENTE]
Local alAreaX
Local alAreaY
Local alAreaZ
Local nlCont := 0
Local nlTotal := 0
Local nlMinDIG 		:= aSX6[MV_MINDETR]
Local nlTxMoeda := 0
Private aInfo   									//Definida como private pois é usada numa macro
// Verifica se a TES possui tratamento para Impostos Variaveis
If cPaisLoc=="PER"  .And. aPos[FP_B1_VMINDET]
	nlMinDIG := Iif(aNfItem[nItem][IT_PRD][SB_VMINDET] > 0 , aNfItem[nItem][IT_PRD][SB_VMINDET] , nlMinDIG)
EndIf

If !Empty(aTes[TS_SFC])
	If nImpde>0 .And. nImpAte>0
		For nImposto := nImpDe to nImpAte
			//       Tratamento especifico para localizado PERU
			// Abaixo estão os cálculos dos impostos variáveis de acordo
			// com as regras de ISC,IGV, PIV e DIG. Caso não seja nenhum
			// desses executa normalmente como se fosse não localizado

			//Caso seja não seja localizado Peru, executa padrão
			If cPaisLoc $ "PER"
				alAreaX := SFC->(GetArea())
				alAreaY := SF4->(GetArea())
				alAreaZ := GetArea()

				If aTes[TS_SFC][nImposto][SFC_IMPOSTO] $ "IGV"
					DbSelectArea("SF4")
					DbSetOrder(1)
					If MsSeek(xFilial("SF4")+aTes[TS_CODIGO])
						If (SF4->F4_CALCIGV <> "2" .And. SF4->F4_CALCIGV <> "3")

							// Executa o calculo atraves da Funcao cadastrada no SFB
							aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
							nImp:=NumCpoImpVar(aInfo[2])
							If aNfCab[NF_OPERNF] == "E"
								If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
									If cPaisLoc <> "BRA"
										nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("V",'+Str(nItem)+',aInfo)')
										If ValType(nValImp) == "N"
											aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
											//          TRATAMENTO EXPECIFICO PARA LOCALIZADO PERU
											// Quando o TES for referente ao imposto do IGV, o valor do IPM, o
											// qual é uma porcentagem do IGV,o valor da base, aliquota e valor do
											// imposto é gravado nos campos _BASIMP3, _ALQIMP3 e VALIMP3.
											// O valor da base é a mesma utilizada para o cálculo do IGV.
											// O valor da alíqutoa é proveniente de um paramêtro chamado
											// MV_ALQIPM.
											// O valor do imposto é a multiplicação da base pelo valor da aliquota
											// NO CASO ABAIXO APENAS O VALOR DO IMPOSTO é PREENCHIDO PARA ENTRADA,
											// SENDO QUE OS VALORRES DA BASE E DA ALIQUOTA Já FORAM PREENCHIDOS AN-
											// TERIORMENTE.

											aNfItem[nItem][IT_VALIMP][3]:= aNfItem[nItem][IT_BASEIMP][3] * (aNfItem[nItem][IT_ALIQIMP][3]/100)
										EndIf
									Else
										aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
									EndIf
								EndIf
							Else
								If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
									If cPaisLoc <>"BRA"
										nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("V",'+Str(nItem)+',aInfo)')
										If ValType(nValImp) == "N"
											aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
											//          TRATAMENTO EXPECIFICO PARA LOCALIZADO PERU
											// NO CASO ABAIXO APENAS O VALOR DO IMPOSTO é PREENCHIDO PARA SáIDA,
											// SENDO QUE OS VALORRES DA BASE E DA ALIQUOTA Já FORAM PREENCHIDOS AN-
											// TERIORMENTE.

											aNfItem[nItem][IT_VALIMP][3]:= aNfItem[nItem][IT_BASEIMP][3] * (aNfItem[nItem][IT_ALIQIMP][3]/100)
										EndIf
									Else
										aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
									EndIf
								EndIf
							EndIf
							// Verifica as Propriedades do Imposto
							Do Case
								Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="1"
									nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
								Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="2"
									nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
								Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="3"
									nValImp:=0
							EndCase
							aNfItem[nItem][IT_BASEDUP] += nValImp
							Do Case
								Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="1"
									nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
								Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="2"
									nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
								Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="3"
									nValImp:=0
							EndCase
							aNfItem[nItem][IT_TOTAL] += nValImp
						EndIf
					EndIf

				ElseIf aTes[TS_SFC][nImposto][SFC_IMPOSTO] $ "PIV"

					// Executa o calculo atraves da Funcao cadastrada no SFB
					aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
					nImp:=NumCpoImpVar(aInfo[2])
					If aNfCab[NF_OPERNF] == "E"

						If aNfCab[NF_CLIFOR] $ "F"

							If SubStr(cMV_AGENTE,2,1) == "S" .And.  SA2->A2_AGENRET <> "1"

								If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
									If cPaisLoc <> "BRA"

										nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("V",'+Str(nItem)+',aInfo)')

										If ValType(nValImp) == "N"
											aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
										EndIf
									Else
										aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
									EndIf
								EndIf
							EndIf

						ElseIf aNfCab[NF_CLIFOR] $ "C"

							If SA1->A1_AGENTE == "2"

								If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
									If cPaisLoc <> "BRA"

										nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("V",'+Str(nItem)+',aInfo)')

										If ValType(nValImp) == "N"
											aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
										EndIf
									Else
										aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
									EndIf
								EndIf
							EndIf
						EndIf
					Else
						If aNfCab[NF_CLIFOR] $ "C"
							If SA1->A1_AGENTE == "2"
								If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
									If cPaisLoc <>"BRA"

										nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("V",'+Str(nItem)+',aInfo)')

										If ValType(nValImp) == "N"
											aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
										EndIf
									Else
										aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
									EndIf
								EndIf
							EndIf
						ElseIf aNfCab[NF_CLIFOR] $ "F"

							If SubStr(cMV_AGENTE,2,1) == "S" .And.  SA2->A2_AGENRET <> "1"

								If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
									If cPaisLoc <>"BRA"

										nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("V",'+Str(nItem)+',aInfo)')

										If ValType(nValImp) == "N"
											aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
										EndIf
									Else
										aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
									EndIf
								EndIf
							EndIf
						EndIf
					EndIf
					// Verifica as Propriedades do Imposto
					Do Case
						Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="1"
							nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
						Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="2"
							nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
						Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="3"
							nValImp:=0
					EndCase
					aNfItem[nItem][IT_BASEDUP] += nValImp
					Do Case
						Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="1"
							nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
						Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="2"
							nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
						Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="3"
							nValImp:=0
					EndCase
					aNfItem[nItem][IT_TOTAL] += nValImp

				ElseIf aTes[TS_SFC][nImposto][SFC_IMPOSTO] $ "DIG"

					nlTotal := MaRetBasT(,,,.T.)

					nlTOtal += aNfCab[NF_FRETE] + aNfCab[NF_DESPESA] + aNfCab[NF_SEGURO] - (aNfCab[NF_DESCONTO]+aNfCab[NF_DESCTOT]) + aNfCab[NF_ACRESCI]

					If AllTrim(Upper(FunName())) $ "MATA465N/MATA466N/MATA467N/MATA101N/MATA121" .And. aNFCab[NF_TXMOEDA] <> 0

						nlTotal := nlTotal * aNFCab[NF_TXMOEDA]

					ElseIf AllTrim(Upper(FunName())) $ "MATA410"

						nlTotal := xMoeda(nlTotal,M->C5_MOEDA,1,dDataBase)

					EndIf
					If nlTotal > nlMinDIG
						// Executa o calculo atraves da Funcao cadastrada no SFB

						MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)

						aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
						nImp:=NumCpoImpVar(aInfo[2])
						If aNfCab[NF_OPERNF] == "E"

							If aNfCab[NF_CLIFOR] $ "F"

								If SubStr(cMV_AGENTE,3,1) == "S" .And.  SA2->A2_AGENRET <> "1"

									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])

										If cPaisLoc <> "BRA"

											nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("V",'+Str(nItem)+',aInfo)')

											If ValType(nValImp) == "N"
												aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
											EndIf
										Else
											aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
										EndIf

									EndIf

								EndIf

							ElseIf aNfCab[NF_CLIFOR] $ "C"

								If SubStr(cMV_AGENTE,1,1) == "N" .And.  SA1->A1_AGENTE == "3"

									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])

										If cPaisLoc <> "BRA"

											nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("V",'+Str(nItem)+',aInfo)')

											If ValType(nValImp) == "N"
												aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
											EndIf
										Else
											aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
										EndIf

									EndIf

								EndIf

							EndIf

						Else

							If aNfCab[NF_CLIFOR] $ "C"

								If SubStr(cMV_AGENTE,1,1) == "N" .And.  SA1->A1_AGENTE == "3"

									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
										If cPaisLoc <>"BRA"

											nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("V",'+Str(nItem)+',aInfo)')

											If ValType(nValImp) == "N"
												aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
											EndIf
										Else
											aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
										EndIf
									EndIf

								EndIf

							ElseIf aNfCab[NF_CLIFOR] $ "F"

								If SubStr(cMV_AGENTE,3,1) == "S" .And.  SA2->A2_AGENRET <> "1"

									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
										If cPaisLoc <>"BRA"

											nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("V",'+Str(nItem)+',aInfo)')

											If ValType(nValImp) == "N"
												aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
											EndIf
										Else
											aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
										EndIf
									EndIf

								EndIf

							EndIf


						EndIf
						// Verifica as Propriedades do Imposto
						Do Case
							Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="1"
								nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
							Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="2"
								nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
							Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="3"
								nValImp:=0
						EndCase
						aNfItem[nItem][IT_BASEDUP] += nValImp
						Do Case
							Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="1"
								nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
							Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="2"
								nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
							Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="3"
								nValImp:=0
						EndCase
						aNfItem[nItem][IT_TOTAL] += nValImp
					EndIf
				Else

					// Executa o calculo atraves da Funcao cadastrada no SFB
					aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
					nImp:=NumCpoImpVar(aInfo[2])
					If aNfCab[NF_OPERNF] == "E"
						If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
							If cPaisLoc <> "BRA"

								nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("V",'+Str(nItem)+',aInfo)')

								If ValType(nValImp) == "N"
									aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
								EndIf
							Else
								aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
							EndIf
						EndIf
					Else
						If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
							If cPaisLoc <>"BRA"

								nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("V",'+Str(nItem)+',aInfo)')

								If ValType(nValImp) == "N"
									aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
								EndIf
							Else
								aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
							EndIf
						EndIf
					EndIf
					// Verifica as Propriedades do Imposto
					Do Case
						Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="1"
							nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
						Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="2"
							nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
						Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="3"
							nValImp:=0
					EndCase
					aNfItem[nItem][IT_BASEDUP] += nValImp
					Do Case
						Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="1"
							nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
						Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="2"
							nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
						Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="3"
							nValImp:=0
					EndCase
					aNfItem[nItem][IT_TOTAL] += nValImp

				EndIf

				RestArea(alAreaX)
				RestArea(alAreaY)
				RestArea(alAreaZ)
			Else

				// Executa o calculo atraves da Funcao cadastrada no SFB
				aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
				nImp:=NumCpoImpVar(aInfo[2])
				If aNfCab[NF_OPERNF] == "E"
					If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
						If cPaisLoc <> "BRA"

							nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("V",'+Str(nItem)+',aInfo)')

							If ValType(nValImp) == "N"
								aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
							EndIf
						Else
							aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMENT],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
						EndIf
					EndIf
				Else
					If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
						If cPaisLoc <>"BRA"

							nValImp :=  &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("V",'+Str(nItem)+',aInfo)')

							If ValType(nValImp) == "N"
								aNfItem[nItem][IT_VALIMP][nImp]:= nValImp
							EndIf
						Else
							aNfItem[nItem][IT_VALIMP][nImp]:= ExecBlock(aTes[TS_SFC][nImposto][SFB_FORMSAI],.F.,.F.,{"V",nItem,aInfo},(Left(aTes[TS_SFC][nImposto][SFB_FORMENT],2)=="U_"))
						EndIf
					EndIf
				EndIf
				// Verifica as Propriedades do Imposto
				Do Case
					Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="1"
						nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
					Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="2"
						nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
					Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="3"
						nValImp:=0
				EndCase
				aNfItem[nItem][IT_BASEDUP] += nValImp
				Do Case
					Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="1"
						nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
					Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="2"
						nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
					Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="3"
						nValImp:=0
				EndCase
				aNfItem[nItem][IT_TOTAL] += nValImp

			EndIf
		Next nImposto
	Endif
Else
	// Zera todas as aliquotas.
	For nImposto := 1 to NMAXIV
		aNFItem[nItem][IT_VALIMP][nImposto]:= 0
	Next nImposto
EndIf

Return Nil

/*/
MaFisNameIV - Edson Maricate-02.02.2000
Preeche o nome dos impostos Variaveis
Parametros
ExpN1: Numero do Imposto ( 1 a 6 )
ExpN2: Item a ser calculado
/*/
Static Function MaFisNameIV(nImposto,nItem)

Local nImpde  := IIf(nImposto==Nil,1,nImposto)
Local nImpAte := IIF(nImposto==Nil,Len(aTes[TS_SFC]),nImposto)

// Verifica se a TES possui tratamento para Impostos Variaveis
If !Empty(aTes[TS_SFC])
	If nImpde>0 .And. nImpAte>0
		For nImposto := nImpDe to nImpAte
			// Executa o calculo atraves da Funcao cadastrada no SFB
			If	aNfCab[NF_OPERNF] == "E"
				If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
					nImp:=NumCpoImpVar(RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1))
					aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
				EndIf
			Else
				If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
					nImp:=NumCpoImpVar(RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVRSI]),1))
					aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
				EndIf
			EndIf
		Next nImposto
	Endif
Else
	For nImposto := 1 to NMAXIV
		aNfItem[nItem][IT_DESCIV][nImposto] := {"","",""}
	Next nImposto
EndIf

Return Nil

/*/
MaFisImpIV - Alexandre Lemes -27/11/2013
Funcao que dispara o calculo dos impostos localizados.
A Funcao sofreu um refactory em 27/11/2013 em razao da baixa performance ao calcular os impostos por Total do pais
Argentina. O projeto de melhoria de performance do calculo dos impostos localizados foi dividido por fases sendo
que o refacture desta funcao foi a FASE I.
Parametros
ExpN1: Item
ExpC2: Referencia Fiscal vinda da MaFisRecal()
ExpL3: Flag ao editar os campos de despesas acessorias do
do documento fiscal serve para evitar o recalculo
desnecessario dos imposto por total
ExpL4: Indica se a chamada da funcao vem da edicao de um
campo de cabecalho do documento fiscal (Despesas acessorias)
/*/
Static Function MaFisImpIV(nItem,cCampo,lExecuta,lDespesas)

Local aCposArred  := {"IT_DESCONTO","IT_FRETE","IT_DESPESA","IT_SEGURO","IT_VALEMB","IT_TOTAL","IT_VALMERC","IT_VNAGREG","IT_BASEDUP","IT_ADIANT","IT_DESCTOT","IT_ACRESCI","IT_VLR_FRT","IT_DESNTRB"}
Local aCalcular   := aClone( aTes[TS_SFC] )
Local aAreaSFB	:= SFB->(GetArea())
Local cNumCpo     := ""
Local nX		  := 0
Local nY 		  := 0
Local nG          := 0
Local nZ          := 0
Local nIV         := 0
Local nBaseIV     := 0
Local nAliquota   := 0
Local nValorIV    := 0
Local nImpAnt     := 0
Local nPosImp     := 0
Local nVlrRateado := 0
Local nBseRateado := 0
Local nBseRateio  := 0
Local nFator      := 0
Local nPosItRef   := 0
Local nDecimais	  := IIf( cPaisLoc $ "ARG/PER" , MsDecimais(aNFCab[NF_MOEDA]) , 0 )
Local lRefazNFCab := .T.
Local lPasaIB	  := .F.
Local aAreaSFC	  := SFC->(GetArea())
Local nOrdSFC	  := SFC->(IndexOrd())
Local lMinIb	  := SuperGetMV("MV_IBMIN",.T.,.F.)
Local lLojaIb 	  := .T.
Local nCountIT	  := 0
Local nUltItem	  := 0
Local nPosTESM	:= 0

DEFAULT cCampo	 := ""
DEFAULT lExecuta := .T.
DEFAULT lDespesas:= .F.

If cPaisLoc == "PER" .and. aPos[FP_F1_ADIANT]
	AADD(aCposArred,"IT_ADIANTTOT")
EndIf
If lNotRemito .and. IIF(cPaisLoc == "ARG", IIF(Type("lLocxAuto") <> "U" .and. lLocxAuto, Iif(Type("cUltCpo") <> "U", cCampo == cUltCpo,.T.),MaFisRet(nItem,"IT_VALMERC")>0 .and. !Empty(MaFisRet(nItem,"IT_TES"))), .T.)
	//Tratamento para calculo do impostos variaveis localizados especifico para o SIGAEIC.
	If (Type("lFacImport")=="L" .And. lFacImport)
		PRIVATE aImposEIC := {}
		SD1->(MsSeek(xFilial("SD1")+SF1->F1_DOC+SF1->F1_SERIE+SF1->F1_FORNECE+SF1->F1_LOJA+aNfItem[nItem][IT_PRODUTO]+StrZero(nItem,TamSx3("D1_ITEM")[1])))
		A100IniImp(SD1->D1_SERIE,SD1->D1_DOC,SD1->D1_TEC,,,,,,,nItem)
		If Len(aImposEic) > 0
			For nX := 1 To Len(aImposEIC)
				nIV := NumCpoImpVar(Right(aImposEIC[nX,6],1))
				If nIV > 0
					SFB->(MsSeek(xFilial("SFB")+aImposEIC[nX,4]))
					aNFItem[nItem][IT_BASEIMP][nIV]	:=	aImposEIC[nX,7]
					aNfItem[nItem][IT_DESCIV][nIV]	:=	{aImposEIC[nX,4],SFB->FB_DESCR,Posicione("SFC",1,xFilial("SFC")+aImposEIC[nX][2]+aImposEIC[nX][3]+aImposEIC[nX][4],"FC_CALCULO")}
					aNFItem[nItem][IT_VALIMP][nIV]	:=	aImposEIC[nX,9]
					aNFItem[nItem][IT_ALIQIMP][nIV]	:=	aImposEIC[nX,5]
				Endif
			Next nX
		Endif
	Else
		If cPaisLoc == "ARG"
			If Type("aTesMXF") <> "U"
				nPosTESM := Ascan(aTesMXF,{|X| X[1] == nItem})
				If nPosTESM > 0
					aTesMXF[nPosTESM][2] := aClone(aTes)
				Else
					AADD(aTesMXF,{nItem,aClone(aTes)})
				EndIf
			EndIf
		EndIf
		//Rotina que LIMPA os impostos calculados no Item,a TES pode ter sido alterada por outra.
		For nIV := 1 to NMAXIV
			If aNfItem[nItem][IT_DESCIV][nIV][3] == "T" .And. Ascan( aCalcular ,{ |x| Right(Alltrim(x[9]),1) == NumCpoImpVar( nIV ) } ) == 0
				Aadd(aCalcular,{"",aNfItem[nItem][IT_DESCIV][nIV][1],"","","","",0,aNfItem[nItem][IT_DESCIV][nIV][2],"D1_VALIMP"+NumCpoImpVar(nIV),"","","","","","","","","",aNfItem[nItem][IT_DESCIV][nIV][3],Nil,0,aNFItem[nItem][IT_ALIQIMP][nIV]} )
			Endif
			aNfItem[nItem][IT_DESCIV][nIV]	:=	{"","",""}
			aNFItem[nItem][IT_BASEIMP][nIV]	:=	0
			aNFItem[nItem][IT_VALIMP][nIV]	:=	0
			aNFItem[nItem][IT_ALIQIMP][nIV]	:=	0

			Aadd( aCposArred , "IT_BASEIV"+NumCpoImpVar(nIV) )
			Aadd( aCposArred , "IT_VALIV"+NumCpoImpVar(nIV)  )

		Next nIV
		If cPaisLoc == "ARG" .and. aNfItem[nItem][IT_DELETED] .and. ((CCO->(FieldPos("CCO_IMMINR")) > 0 .and. ALLTRIM(aNfItem[nItem][IT_TES]) $ SuperGetMV("MV_IBIMPOR",.T.,"")) .or. ASCAN(aCalcular,{|X|SUBSTR(X[2],1,2) $ "IB"}) > 0)
			SFC->(DbSetOrder(2))
			SFB->(DbSetOrder(1))
			SFC->(dbSeek(XFILIAL("SFC")+aNfItem[nItem][IT_TES]))
			Do While !SFC->(eof()) .and. aNfItem[nItem][IT_TES]==SFC->FC_TES
				If SFB->(dbSeek(XFILIAL("SFB")+SFC->FC_IMPOSTO))
					If sfb->fb_classif=='1'
						lPasaIB := .T.
						Exit
					EndIf
				EndIf
				SFC->(DBSKIP())
			EndDo
			SFC->(DbSetOrder(nOrdSFC))
			RestArea(aAreaSFC)
			RestArea(aAreaSFB)
		Endif
		//Rotina principal que dispara o calculo de TODOS o impostos variaveis localizados.
		If Len(aCalcular) > 0 .And. (!aNfItem[nItem][IT_DELETED] .or. lPasaIB == .T.)

			If AllTrim(Upper(FunName())) == "LOJA701" //SIGALOJA
				//Verifica qual eh o ultimo item valido que nao esta deletado
				nCountIT := Len(aNfItem)
				While nCountIT >= 1
					If !aNfItem[nCountIT][IT_DELETED]
						nUltItem := nCountIT
						Exit
					EndIf
					nCountIT--
				End
			EndIf

			For nIV := 1 To Len(aCalcular)
				If aCalcular[nIV][SFC_CALCULO] <> "T"
					MaFisCalcIV(nIV,nItem, .F. )
					MaFisAliqIV(nIV,nItem)
					MaFisVLIV(nIV,nItem)
				Else
					If Len(aCalcular[nIV]) < 22
						MaFisCalcIV(nIV,nItem, .T. )
						MaFisAliqIV(nIV,nItem)
					EndIf
					cNumCpo := Right(Alltrim(aCalcular[nIV][SFB_CPOVREI]),1)
					nNumCpo := NumCpoImpVar( cNumCpo )
					If Len(aCalcular[nIV]) < 22
						nImpAnt  := MaFisRet(nItem,"IT_VALIV" + cNumCpo)
						MaFisVLIV(nIV,nItem)
						nValorIV := MaFisRet(nItem,"IT_VALIV" + cNumCpo)
						nAliquota:= MaFisRet(nItem,"IT_ALIQIV"+ cNumCpo)
					Else
						If MaFisRet(,"NF_BASEIV"+cNumCpo) < MaFisRet(,"NF_MINIV"+cNumCpo)
							nBaseIV	 := 0
							nValorIV := 0
						Else
							nBaseIV  := MaFisRet(,"NF_BASEIV"+cNumCpo)
							nValorIV :=	MaFisRet(,"NF_VALIV"+cNumCpo)
						Endif
						nAliquota := aCalcular[nIV][22]
					EndIf

					If Left(aCalcular[nIV][2],2) == "IB" .And. aNFCab[NF_TPCLIFOR] != "F" .And. ( Isincallstack('Lj7DescPro') .Or. Isincallstack("Lj7ZeraDesc") .Or. Isincallstack("Lj7LimpDes") ) //.Or. Isincallstack("LjTelaCard")
						If nItem == nUltItem
							lLojaIb:= .T.
						Else
							lLojaIb:= .F.
						EndIf
					Else
						lLojaIb:= .T.
					EndIf

					If lLojaIb .And. lExecuta .And. !( Alltrim(cCampo) $  "PRODUTO|QUANT|PRCUNI" ) .And. aNfItem[nItem][IT_VALMERC] > 0 .And. ;
						( ( Len(aCalcular[nIV])  < 22 .And. ( Round(nValorIV,3) > 0 .Or. ;
						( IF(Left(aCalcular[nIV][2],2) == "IB" .And. aNFCab[NF_TPCLIFOR] != "F",.T.,nImpAnt > 0) .And. Round(nValorIV,3) == 0) ) ) .Or. ;
						( Len(aCalcular[nIV]) == 22 .And. nBaseIV > 0 ) )
						If nBaseIV > 0
							If "MATA143" $ Upper(Funname()) .And. cpaisLoc=="ARG"   // Avaliar a possibilidade de nao refazer as somas do cabecalho em todas as situacoes de alteracao
 								lRefazNFCab := .F.
 							EndIf
						EndIf
						nBseRateio  := 0
						nBseRateado := 0
						nVlrRateado := 0
						aEval(aNfItem,{|x| nBseRateio += IIf( !x[IT_DELETED] .And. x[IT_ALIQIMP][nNumCpo] == nAliquota  , x[IT_BASEIMP][nNumCpo] , 0 ) } )

						For nX := 1 to Len(aNfItem)
							If !aNfItem[nX][IT_DELETED]
								If aNfItem[nX][IT_TES] <> aTes[TS_CODIGO]
									If cPaisLoc == "ARG"
										If Type("aTesMXF") <> "U"
											nPosTESM := Ascan(aTesMXF,{|X| X[1] == nX})
										EndIf
										If nPosTESM > 0
											aTes := aClone(aTesMXF[nPosTESM][2])
										Else
											MaFisTes(aNfItem[nX][IT_TES],aNfItem[nX][IT_RECNOSF4],nX)
										EndIf
									Else
										MaFisTes(aNfItem[nX][IT_TES],aNfItem[nX][IT_RECNOSF4],nX)
									EndIf
								EndIf

								nFator := aNFItem[nX][IT_BASEIMP][nNumCpo] / nBseRateio

								If aNFItem[nX][IT_ALIQIMP][nNumCpo] == nAliquota
									If nX <> nItem .or. (nModulo == 12 .and. Left(aCalcular[nIV][2],2) =="IB" .and.!Isincallstack('mata465n'))
									   	aNfCab[NF_DESCONTO]	-= aNfItem[nX][IT_DESCONTO]
										aNfCab[NF_FRETE]	-= aNfItem[nX][IT_FRETE]
										aNfCab[NF_DESPESA]	-= aNfItem[nX][IT_DESPESA]
										aNfCab[NF_SEGURO]	-= aNfItem[nX][IT_SEGURO]
										aNfCab[NF_VALEMB]	-= aNfItem[nX][IT_VALEMB]
										aNfCab[NF_TOTAL]	-= aNfItem[nX][IT_TOTAL]
										aNfCab[NF_VALMERC]	-= aNfItem[nX][IT_VALMERC]-aNfItem[nX][IT_VNAGREG]
										aNfCab[NF_VNAGREG] 	-= aNfItem[nX][IT_VNAGREG]
										aNfCab[NF_BASEDUP]	-= aNfItem[nX][IT_BASEDUP]
										aNfCab[NF_PESO]		-= aNfItem[nX][IT_PESO]
										aNFCab[NF_ADIANT]	-= aNfItem[nX][IT_ADIANT]
										aNfCab[NF_DESCTOT]  -= aNfItem[nX][IT_DESCTOT]
										aNfCab[NF_ACRESCI]	-= aNfItem[nX][IT_ACRESCI]
										aNfCab[NF_VLR_FRT]	-= aNfItem[nX][IT_VLR_FRT]
										aNfCab[NF_DESNTRB]	-= aNfItem[nX][IT_DESNTRB]
										aNfCab[NF_TARA]		-= aNfItem[nX][IT_TARA]
										If cPaisLoc == "PER" .and. aPos[FP_F1_ADIANT]
											aNfCab[NF_ADIANTTOT]	-= aNfItem[nX][IT_ADIANTTOT]
										EndIf
										For nG := 1 To NMAXIV
											aNfCab[NF_BASEIMP][nG] -= aNfItem[nX][IT_BASEIMP][nG]
											aNfCab[NF_VALIMP][nG]  -= aNfItem[nX][IT_VALIMP][nG]
											aNfCab[NF_VLRORIG][nG] -= aNfItem[nX][IT_VALIMP][nG]
											If aNfItem[nX][IT_BASEIMP][nG]<>0 .Or. aNfItem[nX][IT_VALIMP][nG] <> 0
												MaFisResumo(aNfItem[nX][IT_BASEIMP][nG],aNfItem[nX][IT_ALIQIMP][nG],aNfItem[nX][IT_VALIMP][nG],aNfItem[nX][IT_DESCIV][nG][1],aNfItem[nX][IT_DESCIV][nG][2],"IV"+NumCpoImpVar(nG),,,.F.)
											EndIf
										Next nG
										If nIV == Len(aCalcular)
											MaFisLFToLivro(nX,@aAuxOri,.F.)
											For nZ := 1 to Len(aCposArred)  // Executa a correcao nos arredondamentos.
												nY := aScan( aItemRef , {|x| x[1] == aCposArred[nZ]} )
												If aItemRef[nY][4]
													If !aItemRef[nY][5]
														If ValType(aItemRef[nY][2]) == "A"
															aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] += aItemDec[nX][2][nY]
															aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] -= aItemDec[nX][1][nY]
														Else
															aNfItem[nX][Val(aItemRef[nY][2])] += aItemDec[nX][2][nY]
															aNfItem[nX][Val(aItemRef[nY][2])] -= aItemDec[nX][1][nY]
														EndIf
														aSaveDec[nY] += aItemDec[nX][1][nY]
														aSaveDec[nY] -= aItemDec[nX][2][nY]
													Else
														If ValType(aItemRef[nY][2]) == "A"
															aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] -= aItemDec[nX][2][nY]
															aNfItem[nX][aItemRef[nY][2][1]][aItemRef[nY][2][2]] += aItemDec[nX][1][nY]
														Else
															aNfItem[nX][Val(aItemRef[nY][2])] -= aItemDec[nX][2][nY]
															aNfItem[nX][Val(aItemRef[nY][2])] += aItemDec[nX][1][nY]
														EndIf
													EndIf
													aItemDec[nX][1][nY]:= 0
													aItemDec[nX][2][nY]:= 0
												EndIf
											Next nZ
										EndIf
									Endif

									If nBaseIV > 0
										nPosItRef   := Ascan(aItemRef,{|x| x[1] == "IT_BASEIV"+cNumCpo })
										nBseRateado += aNFItem[nX][IT_BASEIMP][nNumCpo] := IIf( aItemRef[nPosItRef][4] .And. aItemRef[nPosItRef][5] , NoRound( nFator * nBaseIV , 2 ) , IIf(cPaisLoc$"PAR/PER",NoRound(nFator*nBaseIV,nDecimais) , nFator * nBaseIV )  )
									EndIf
									nPosItRef   := Ascan(aItemRef,{|x| x[1] == "IT_VALIV"+cNumCpo })
									If cPaisLoc == "ARG"
										aNFItem[nX][IT_TOTAL] -= aNFItem[nX][IT_VALIMP][nNumCpo]
									EndIf
									nVlrRateado += aNFItem[nX][IT_VALIMP][nNumCpo] := IIf( aItemRef[nPosItRef][4] .And. aItemRef[nPosItRef][5] , NoRound( nFator * nValorIV , 2 ) , IIf(cPaisLoc$"PAR/PER",NoRound(nFator*nValorIV,nDecimais) , nFator * nValorIV )  )
									If cPaisLoc == "ARG"
										aNFItem[nX][IT_TOTAL] += aNFItem[nX][IT_VALIMP][nNumCpo]
									EndIf
								EndIf
								If Len(aNfItem) == nX
									If nBaseIV > 0 .And. nBaseIV <> nBseRateado
										aNfItem[Len(aNfItem)][IT_BASEIMP][nNumCpo]+= (nBaseIV-nBseRateado)
									EndIf
									If nValorIV <> nVlrRateado
										aNfItem[Len(aNfItem)][IT_VALIMP][nNumCpo] += (nValorIV-nVlrRateado)
									EndIf
								EndIf
								If nX <> nItem // nItemNao
									If nBaseIV > 0
										MaFisVLIV(Ascan(aTes[TS_SFC],{|x| Substr(x[10],10,1) ==  cNumCpo }) , nX )
										If (nfator<>0) .AND. (cPaisLoc == "ARG")
											aNfItem[nX][IT_VALIMP][nNumCpo] := aNfItem[nX][IT_VALIMP][nNumCpo] * nFator
										EndIf
									EndIf
									If cPaisLoc<> "ARG" .And. nIV == Len(aCalcular)
										MaFisVTot(nX)     // tem o len do aTES
										MaItArred(nX,aCposArred)
									EndIf

								EndIf
								If cPaisLoc=="ARG"
									MaFisVTot(nX)     // tem o len do aTES
									MaItArred(nX,aCposArred)
								EndIf
							EndIf

						Next nX

						If lRefazNFCab
							aAuxOri := {}
							aNfCab[NF_LIVRO]	:= {}
							aNfCab[NF_IMPOSTOS]	:= {}
							aNfCab[NF_IMPOSTOS2]:= {}
							aNfCab[NF_DESCONTO]	:= 0
							aNfCab[NF_DESCTOT]	:= 0
							aNfCab[NF_ACRESCI]	:= 0
							aNfCab[NF_FRETE]	:= 0
							aNfCab[NF_DESPESA]	:= 0
							aNfCab[NF_SEGURO]	:= 0
							aNfCab[NF_VALEMB]	:= 0
							aNfCab[NF_TOTAL]	:= 0
							aNfCab[NF_VALMERC]	:= 0
							aNfCab[NF_VNAGREG]  := 0
							aNfCab[NF_BASEDUP]	:= 0
							aNfCab[NF_PESO]		:= 0
							aNfCab[NF_VLR_FRT]  := 0
							aNfCab[NF_DESNTRB]  := 0
							aNfCab[NF_ADIANT]   := 0
							aNfCab[NF_BASEIMP]	:= Array(NMAXIV)
							aNfCab[NF_BASEIMP]	:= Afill(aNfCab[NF_BASEIMP],0)
							aNfCab[NF_VALIMP]	:= Array(NMAXIV)
							aNfCab[NF_VALIMP]	:= Afill(aNfCab[NF_VALIMP],0)
							aNfCab[NF_MINIMP]	:= Array(NMAXIV)
							aNfCab[NF_MINIMP]	:= Afill(aNfCab[NF_MINIMP],0)
							aNfCab[NF_VLRORIG]	:= Array(NMAXIV)
							aNfCab[NF_VLRORIG]	:= Afill(aNfCab[NF_VLRORIG],0)
							If cPaisLoc == "PER" .and. aPos[FP_F1_ADIANT]
								aNfCab[NF_ADIANTTOT]   := 0
							EndIf
							For nX := 1 to Len(aNfItem)
								If nItem <> nX  .Or. lDespesas .or. (nModulo == 12 .and. Left(aCalcular[nIV][2],2) =="IB" .and. !Isincallstack('mata465n'))
									If !aNfItem[nX][IT_DELETED]
										aNfCab[NF_DESCONTO]+= aNfItem[nX][IT_DESCONTO]
										aNfCab[NF_FRETE]   += aNfItem[nX][IT_FRETE]
										aNfCab[NF_DESPESA] += aNfItem[nX][IT_DESPESA]
										aNfCab[NF_SEGURO]  += aNfItem[nX][IT_SEGURO]
										aNfCab[NF_VALEMB]  += aNfItem[nX][IT_VALEMB]
										aNfCab[NF_TOTAL]   += aNfItem[nX][IT_TOTAL]
										aNfCab[NF_VALMERC] += aNfItem[nX][IT_VALMERC]-aNfItem[nX][IT_VNAGREG]
										aNfCab[NF_VNAGREG] += aNfItem[nX][IT_VNAGREG]
										aNfCab[NF_BASEDUP] += aNfItem[nX][IT_BASEDUP]
										aNfCab[NF_PESO]	   += aNfItem[nX][IT_PESO]
										aNfCab[NF_ADIANT]  += aNfItem[nX][IT_ADIANT]
										aNfCab[NF_DESCTOT] += aNfItem[nX][IT_DESCTOT]
										aNfCab[NF_ACRESCI] += aNfItem[nX][IT_ACRESCI]
										aNfCab[NF_VLR_FRT] += aNfItem[nX][IT_VLR_FRT]
										aNfCab[NF_DESNTRB] += aNfItem[nX][IT_DESNTRB]
										aNfCab[NF_TARA]	   += aNfItem[nX][IT_TARA]

										If cPaisLoc == "PER" .and. aPos[FP_F1_ADIANT]
											aNfCab[NF_ADIANTTOT]  += aNfItem[nX][IT_ADIANTTOT]
										EndIF
										For nG := 1 To NMAXIV
											aNfCab[NF_BASEIMP][nG]+= aNfItem[nX][IT_BASEIMP][nG]
											aNfCab[NF_VALIMP][nG] += aNfItem[nX][IT_VALIMP][nG]
											aNfCab[NF_VLRORIG][nG]+= aNfItem[nX][IT_VALIMP][nG]

											If aNfItem[nX][IT_BASEIMP][nG]<>0 .Or. aNfItem[nX][IT_VALIMP][nG] <> 0
												MaFisResumo(aNfItem[nX][IT_BASEIMP][nG],aNfItem[nX][IT_ALIQIMP][nG],aNfItem[nX][IT_VALIMP][nG],aNfItem[nX][IT_DESCIV][nG][1],aNfItem[nX][IT_DESCIV][nG][2],"IV"+NumCpoImpVar(nG),,,.T.)
											EndIf
										Next nG
										If nIV == Len(aCalcular)
											MaFisLFToLivro(nX,@aAuxOri,.T.)
										EndIf
									EndIf
								Endif
							Next nX

						EndIf

						If aNfItem[nItem][IT_TES] <> aTes[TS_CODIGO]
							If cPaisLoc == "ARG"
								If Type("aTesMXF") <> "U"
									nPosTESM := Ascan(aTesMXF,{|X| X[1] == nItem})
								EndIf
								If nPosTESM > 0
									aTes := aClone(aTesMXF[nPosTESM][2])
								Else
									MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
									If Type("aTesMXF") <> "U" .and. nPosTESM == 0
										AADD(aTesMXF,{nItem,aClone(aTes)})
									EndIf
								EndIf
							Else
								MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
							EndIf
						EndIf
					Endif
				EndIf
			Next nIV
		EndIf
	EndIf
EndIf
Return
/*
MaRetIncIV - Leandro C.G. - Data   14/01/02
Retorna valores de impostos referentes a um item de NF que incidem no custo, Duplicata, ou Nota
Parametros:
nItem	- Numero do item da Nota Fiscal
cOpc	- 1- Custo 2- Nota 3- Duplicata
Obs.: Considera que o arquivo de itens da Nota Fiscal ja esta posicionado no registro correto e que
as variaveis de calculo de impostos do programa MatxFis ja estao inicializadas
*/
Function MaRetIncIV(nItem,cOpc)

Local aDescImp 	:=	{}	//Descricao/Codigo de todos os impostos que incidem no item
Local aValImp	:=	{}	//Array com os valores de todos os impostos que incidem no item
Local nImposVar	:=	0	//Valor dos impostos variaveis que incidem no custo
Local aSFC		:=	{} //Array com as propriedades dos impostos do item
Local aRet 		:= {} //Array com os impostos e valores que sao somados ou subtraidos no custo
/*						[1] - Codigo do imposto
[2] - Valor positivio (quando imposto e creditado) e negativo (+/-)
*/
Local nI		:=	0	//controle de loop
//Consistindo parametros
If Empty(nItem)
	Return( 0 )
EndIf

If aNfItem[nItem][IT_TES] <> aTes[TS_CODIGO]
	MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
EndIf

aSFC	 :=	aClone(aTes[TS_SFC])

aDescImp :=	aNFItem[nItem,IT_DESCIV]		//Descricao/Codigo dos impostos
aValImp  :=	aNFItem[nItem,IT_VALIMP]		//Valor dos Impostos

//Buscando valores referentes aos impostos
For nI := 1 to Len(aSFC)
	nPosImp	:=	Ascan(aDescImp,{|x| x[1] == aSFC[nI][SFC_IMPOSTO]})
	If nPosImp > 0
		Do Case
			Case cOpc == '1'
				If aSFC[nI][SFC_CREDITA] <> '3'
					nImposVar	:=	aValImp[nPosImp] * If(aSFC[nI][SFC_CREDITA] == '1', 1 , -1)
					Aadd(aRet, {aSFC[nI][SFC_IMPOSTO], nImposVar})
				Endif
			Case cOpc == '2'
				If aSFC[nI][SFC_INCNOTA] <> '3'
					nImposVar	+=	aValImp[nPosImp] * If(aSFC[nI][SFC_INCNOTA] == '1', 1 , -1)
				Endif
			Case cOpc == '3'
				If aSFC[nI][SFC_INCDUPL] <> '3'
					nImposVar	+=	aValImp[nPosImp] * If(aSFC[nI][SFC_INCDUPL] == '1', 1 , -1)
				Endif
		EndCase
	Endif
Next nI

Return(IIf(cOpc=="1",aRet,nImposVar))

/*
MaFisCalcIV - 03.04.2009
Executa o calculo do Valor dos Impostos Variaveis
Parametros
ExpN1: Numero do Imposto ( 1 a X )
ExpN2: Item a ser calculado
/*/
Static Function MaFisCalcIV(nImposto,nItem,lImpTot)
Local lRet		:= .T.
Local nValImp	:= 0
Local nImp		:=Len(aTes[TS_SFC])
Local nImpde	:=IIF(nImposto==Nil,1,nImposto)
Local nImpAte	:=IIF(nImposto==Nil,nImp,nImposto)
Local xImposto
Local nMv_ALQIPM	:= aSX6[MV_ALQIPM]
Local cMV_AGENTE  	:= aSX6[MV_AGENTE]
Local alAreaX
Local alAreaY
Local alAreaZ
Local nlTotal    := 0
Local nlCont     := 0
Local nlMinDIG   	:= aSX6[MV_MINDETR]
Local nlBaseDIG  := 0
Local nX		 := 0
Local nG		 := 0

Private aInfo  //Definida como private pois é usada numa macro
// Verifica se a TES possui tratamento para Impostos Variaveis
If cPaisLoc=="PER"  .And. aPos[FP_B1_VMINDET]
	nlMinDIG := Iif( aNfItem[nItem][IT_PRD][SB_VMINDET] > 0 , aNfItem[nItem][IT_PRD][SB_VMINDET] , nlMinDIG )
EndIf

If cPaisLoc == "BRA" .Or. lNotRemito
	If !Empty(aTes[TS_SFC])
		If nImpde>0 .And. nImpAte>0
			nImposto := nImpDe
			While (nImposto <= nImpAte) .And. lRet

				If cPaisLoc $ "PER"
					alAreaX := SFC->(GetArea())
					alAreaY := SF4->(GetArea())
					alAreaZ := GetArea()

					If aTes[TS_SFC][nImposto][SFC_IMPOSTO] $ "IGV"
						DbSelectArea("SF4")
						DbSetOrder(1)
						// VERIFICAR A NECESSIDADE DESTE SEEK -> POIS AQUI UTILIZA A REFERENCIA aTes[TS_CODIGO] para posicionar na SF4
						If MsSeek(xFilial("SF4")+aTes[TS_CODIGO])
							If (SF4->F4_CALCIGV <> "2" .And. SF4->F4_CALCIGV <> "3")
								aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
								nImp:=NumCpoImpVar(aInfo[2])
								If aNfCab[NF_OPERNF] == "E"
									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
										If lImpTot
											xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BA")')
										Else
											xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BAV")')
										Endif
										If ValType(xImposto) == "A"
											aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
											aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
											aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]

											aNfItem[nItem][IT_BASEIMP][3] := xImposto[1]
											aNfItem[nItem][IT_ALIQIMP][3] := nMv_ALQIPM
											aNfItem[nItem][IT_VALIMP][3]  := xImposto[1]*(nMv_ALQIPM/100)
										Else
											aNfItem[nItem][IT_BASEIMP][nImp] := xImposto
											lRet := .F.
											aNfItem[nItem][IT_BASEIMP][3] := xImposto
										EndIf
										aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
									EndIf
								Else
									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
										If lImpTot
											xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BA")')
										Else
											xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BAV")')
										Endif
										If ValType(xImposto) == "A"
											aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
											aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
											aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]

											aNfItem[nItem][IT_BASEIMP][3] := xImposto[1]
											aNfItem[nItem][IT_ALIQIMP][3] := nMv_ALQIPM
											aNfItem[nItem][IT_VALIMP][3]  := xImposto[1]*(nMv_ALQIPM/100)
										Else
											aNfItem[nItem][IT_BASEIMP][nImp]:= xImposto
											lRet := .F.
											aNfItem[nItem][IT_BASEIMP][3] := xImposto
										EndIf
										aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
									EndIf
								EndIf
								If lRet
									Do Case
										Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="1"
											nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
										Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="2"
											nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
										Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="3"
											nValImp:=0
									EndCase
									aNfItem[nItem][IT_BASEDUP] += nValImp
									Do Case
										Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="1"
											nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
										Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="2"
											nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
										Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="3"
											nValImp:=0
									EndCase
									aNfItem[nItem][IT_TOTAL] += nValImp
								Endif
							EndIf
						EndIf

					ElseIf aTes[TS_SFC][nImposto][SFC_IMPOSTO] $ "PIV"
						aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
						nImp:=NumCpoImpVar(aInfo[2])
						If aNfCab[NF_OPERNF] == "E"
							If aNfCab[NF_CLIFOR] $ "F"
								If SubStr(cMV_AGENTE,2,1) == "S" .And.  SA2->A2_AGENRET <> "1"
									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
										If lImpTot
											xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BA")')
										Else
											xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BAV")')
										Endif
										If ValType(xImposto) == "A"
											aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
											aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
											aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]
										Else
											aNfItem[nItem][IT_BASEIMP][nImp] := xImposto
											lRet := .F.
										EndIf
										aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
									EndIf
								EndIf
							ElseIf aNfCab[NF_CLIFOR] $ "C"

								If  SA1->A1_AGENTE == "2"

									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
										If lImpTot
											xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BA")')
										Else
											xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BAV")')
										Endif
										If ValType(xImposto) == "A"
											aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
											aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
											aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]
										Else
											aNfItem[nItem][IT_BASEIMP][nImp] := xImposto
											lRet := .F.
										EndIf
										aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
									EndIf
								EndIf
							EndIf

						Else
							If aNfCab[NF_CLIFOR] $ "C"
								If SA1->A1_AGENTE == "2"
									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
										If lImpTot
											xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BA")')
										Else
											xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BAV")')
										Endif
										If ValType(xImposto) == "A"
											aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
											aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
											aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]
										Else
											aNfItem[nItem][IT_BASEIMP][nImp]:= xImposto
											lRet := .F.
										EndIf
										aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
									EndIf

								EndIf
							ElseIf aNfCab[NF_CLIFOR] $ "F"
								If SubStr(cMV_AGENTE,2,1) == "S" .And.  SA2->A2_AGENRET <> "1"

									If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
										If lImpTot
											xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BA")')
										Else
											xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BAV")')
										Endif
										If ValType(xImposto) == "A"
											aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
											aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
											aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]
										Else
											aNfItem[nItem][IT_BASEIMP][nImp]:= xImposto
											lRet := .F.
										EndIf
										aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
									EndIf
								EndIf
							EndIf
						EndIf
						If lRet
							Do Case
								Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="1"
									nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
								Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="2"
									nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
								Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="3"
									nValImp:=0
							EndCase
							aNfItem[nItem][IT_BASEDUP] += nValImp
							Do Case
								Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="1"
									nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
								Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="2"
									nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
								Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="3"
									nValImp:=0
							EndCase
							aNfItem[nItem][IT_TOTAL] += nValImp
						Endif

					ElseIf aTes[TS_SFC][nImposto][SFC_IMPOSTO] $ "DIG"

						nlTotal := MaRetBasT(,,,.T.)

						nlTOtal += aNfCab[NF_FRETE] + aNfCab[NF_DESPESA] + aNfCab[NF_SEGURO] - (aNfCab[NF_DESCONTO]+aNfCab[NF_DESCTOT]) + aNfCab[NF_ACRESCI]

						If AllTrim(Upper(FunName())) $ "MATA465N/MATA466N/MATA467N/MATA101N/MATA121" .And. aNFCab[NF_TXMOEDA] <> 0

							nlTotal := nlTotal * aNFCab[NF_TXMOEDA]

						ElseIf AllTrim(Upper(FunName())) $ "MATA410"

							nlTotal := xMoeda(nlTotal,M->C5_MOEDA,1,dDataBase)

						EndIf
						If nlTotal > nlMinDIG

							If aNfCab[NF_RECIV]
								aNfCab[NF_RECIV] := .F.
								MaRecurDIG(.T.)
							EndIf

							MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
							aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
							nImp:=NumCpoImpVar(aInfo[2])
							If aNfCab[NF_OPERNF] == "E"

								If aNfCab[NF_CLIFOR] $ "F"

									If SubStr(cMV_AGENTE,3,1) == "S" .And.  SA2->A2_AGENRET <> "1"

										If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
											If lImpTot
												xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BA")')
											Else
												xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BAV")')
											Endif
											If ValType(xImposto) == "A"
												aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
												aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
												aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]
											Else
												aNfItem[nItem][IT_BASEIMP][nImp] := xImposto
												lRet := .F.
											EndIf
											aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
										EndIf

									EndIf

								ElseIf aNfCab[NF_CLIFOR] $ "C"

									If SubStr(cMV_AGENTE,1,1) == "N" .And.  SA1->A1_AGENTE == "3"

										If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
											If lImpTot
												xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BA")')
											Else
												xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BAV")')
											Endif
											If ValType(xImposto) == "A"
												aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
												aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
												aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]
											Else
												aNfItem[nItem][IT_BASEIMP][nImp] := xImposto
												lRet := .F.
											EndIf
											aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
										EndIf
									EndIf

								EndIf
							Else
								If aNfCab[NF_CLIFOR] $ "C"

									If SubStr(cMV_AGENTE,1,1) == "N" .And.  SA1->A1_AGENTE == "3"

										If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
											If lImpTot
												xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BA")')
											Else
												xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BAV")')
											Endif
											If ValType(xImposto) == "A"
												aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
												aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
												aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]
											Else
												aNfItem[nItem][IT_BASEIMP][nImp]:= xImposto
												lRet := .F.
											EndIf
											aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
										EndIf
									EndIf

								ElseIf aNfCab[NF_CLIFOR] $ "F"
									If SubStr(cMV_AGENTE,3,1) == "S" .And.  SA2->A2_AGENRET <> "1"
										If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
											If lImpTot
												xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BA")')
											Else
												xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BAV")')
											Endif
											If ValType(xImposto) == "A"
												aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
												aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
												aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]
											Else
												aNfItem[nItem][IT_BASEIMP][nImp]:= xImposto
												lRet := .F.
											EndIf
											aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
										EndIf
									EndIf
								EndIf
							EndIf
							If lRet
								Do Case
									Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="1"
										nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
									Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="2"
										nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
									Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="3"
										nValImp:=0
								EndCase
								aNfItem[nItem][IT_BASEDUP] += nValImp
								Do Case
									Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="1"
										nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
									Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="2"
										nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
									Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="3"
										nValImp:=0
								EndCase
								aNfItem[nItem][IT_TOTAL] += nValImp
							Endif
						Else
							aNfCab[NF_RECIV] := .T.
							MaRecurDIG(.F.)
						EndIf
					Else
						aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
						nImp:=NumCpoImpVar(aInfo[2])
						If aNfCab[NF_OPERNF] == "E"
							If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
								If lImpTot
									xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BA")')
								Else
									xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BAV")')
								Endif
								If ValType(xImposto) == "A"
									aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
									aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
									aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]
								Else
									aNfItem[nItem][IT_BASEIMP][nImp] := xImposto
									lRet := .F.
								EndIf
								aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
							EndIf
						Else
							If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
								If lImpTot
									xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BA")')
								Else
									xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BAV")')
								Endif
								If ValType(xImposto) == "A"
									aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
									aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
									aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]
								Else
									aNfItem[nItem][IT_BASEIMP][nImp]:= xImposto
									lRet := .F.
								EndIf
								aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
							EndIf
						EndIf
						If lRet
							Do Case
								Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="1"
									nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
								Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="2"
									nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
								Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="3"
									nValImp:=0
							EndCase
							aNfItem[nItem][IT_BASEDUP] += nValImp
							Do Case
								Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="1"
									nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
								Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="2"
									nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
								Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="3"
									nValImp:=0
							EndCase
							aNfItem[nItem][IT_TOTAL] += nValImp
						Endif

					EndIf
					RestArea(alAreaX)
					RestArea(alAreaY)
					RestArea(alAreaZ)
				Else
					aInfo := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],RIGHT(Alltrim(aTes[TS_SFC][nImposto][SFB_CPOVREI]),1)}
					nImp:=NumCpoImpVar(aInfo[2])
					If aNfCab[NF_OPERNF] == "E"
						If !Empty(aTes[TS_SFC][nImposto][SFB_FORMENT])
							If lImpTot
								xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BA")')
							Else
								xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMENT]+'("B",'+Str(nItem)+',aInfo,"BAV")')
							Endif

							IF aNFitem[nItem][IT_TIPONF]$"DB" .AND. cPaisLoc == "PAR" .AND. aSX6[MV_DESCSAI]=='1' .AND. Alltrim(cFunName) == "MATA465N" .AND. ( aNFitem[nItem][IT_DESCONTO]>0  .OR.  aNFitem[nItem][IT_DESCTOT]>0 )
								xImposto += (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT])
							EndIf

							If ValType(xImposto) == "A"
								aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
								aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
								aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]
							Else
								aNfItem[nItem][IT_BASEIMP][nImp] := IIF(ValType(xImposto) == "U",0,xImposto)
								lRet := .F.
							EndIf
							aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
						EndIf
					Else
						If !Empty(aTes[TS_SFC][nImposto][SFB_FORMSAI])
							If lImpTot
								xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BA")')
							Else
								xImposto := &(aTes[TS_SFC][nImposto][SFB_FORMSAI]+'("B",'+Str(nItem)+',aInfo,"BAV")')
							Endif
							If ValType(xImposto) == "A"
								aNfItem[nItem][IT_BASEIMP][nImp] := xImposto[1]
								aNfItem[nItem][IT_ALIQIMP][nImp] := xImposto[2]
								aNfItem[nItem][IT_VALIMP][nImp]	 := xImposto[3]
							Else
								aNfItem[nItem][IT_BASEIMP][nImp]:= IIF(ValType(xImposto) == "U",0,xImposto)
								lRet := .F.
							EndIf
							aNfItem[nItem][IT_DESCIV][nImp] := {aTes[TS_SFC][nImposto][SFC_IMPOSTO],aTes[TS_SFC][nImposto][SFB_DESCR],aTes[TS_SFC][nImposto][SFC_CALCULO]}
						EndIf
					EndIf
					If lRet
						Do Case
							Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="1"
								nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
							Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="2"
								nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
							Case aTes[TS_SFC][nImposto][SFC_INCDUPL]=="3"
								nValImp:=0
						EndCase
						aNfItem[nItem][IT_BASEDUP] += nValImp
						Do Case
							Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="1"
								nValImp:=aNfItem[nItem][IT_VALIMP][nImp]
							Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="2"
								nValImp:=-aNfItem[nItem][IT_VALIMP][nImp]
							Case aTes[TS_SFC][nImposto][SFC_INCNOTA]=="3"
								nValImp:=0
						EndCase
						aNfItem[nItem][IT_TOTAL] += nValImp
					Endif
				EndIf
				nImposto++
			Enddo
		Endif
	Else
		For nImposto := 1 to NMAXIV
			aNFItem[nItem][IT_BASEIMP][nImposto] := 0
			aNfItem[nItem][IT_DESCIV][nImposto]	 := {"","",""}
			aNFItem[nItem][IT_VALIMP][nImposto]	 := 0
			aNFItem[nItem][IT_ALIQIMP][nImposto] := 0
		Next nImposto
	EndIf
EndIf
Return(lRet)

/*
MaRetIncIV - Leandro C.G. - 14/01/02
Retorna valores de impostos referentes a um item de NF que incidem no custo, Duplicata, ou Nota
*/
Function NumCpoImpVar(xCpoLiv)
Local cCpo,xRet
cCpo:="123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
xRet:=0
If !Empty(xCpoLiv)
	If ValType(xCpoLiv)=="C"
		xRet:=At(xCpoLiv,cCpo)
	ElseIf ValType(xCpoLiv)=="N"
		If xCpoLiv>0
			xRet:=Substr(cCpo,xCpoLiv,1)
		Endif
	Endif
Endif
Return(xRet)

/*/
MaFisCalAl- Bruno Sobieski - 29.08.2003
Executa o calculo da Aliquota dos Impostos Variaveis
Esta funcao foi criada para nao tirar a propriedade de STATIC da funcao MAFISAliqIV
Parametros
ExpN1: Numero do Imposto ( 1 a 6 )
ExpN2: Item a ser calculado
*/
Function MaFisCalAl(nImposto,nItem)

MaFisAliqIV(nImposto,nItem)

Return

Static Function MAFisZero()
Return 0.0001

/*/
MaRetBasT - Bruno Sobieski -21.10.2004
Retorna a base total de um imposto, dependendo da aliquota
/*/
Function MaRetBasT(cNumImp,nItem,nAliq,llTot)
Local nBase	  :=	0
Local nX	  :=	0	//controle de loop
Local nY	  :=  0
Default llTot := .F.
//Local nPosImp	:=	aScan(aNfCab[NF_IMPOSTOS],{|x| x[IMP_COD] ==aDesc[1] .And.	x[IMP_ALIQ]==nAliq })

//nBase		:=	MaFisRet(nlcont,'IT_BASEIV'	+cNumImp)
If cPaisLoc == "BRA" .Or. lNotRemito
	For nX := 1 To Len(aNFItem)
		If !aNfItem[nX][IT_DELETED]
			/*Calcula o valor total da nota fiscal com os impostos de todos itens "PER"*/
			If llTot
				nBase += aNFItem[nX,IT_VALMERC]

				If aNfItem[nX][IT_TES] <> aNFItem[nX][IT_TS][TS_CODIGO]
					MaFisTes(aNfItem[nX][IT_TES],aNfItem[nX][IT_RECNOSF4],nX)
				EndIf

				For nY := 1 to Len(aNFItem[nX][IT_TS][TS_SFC])
					If aNFItem[nX][IT_TS][TS_SFC][nY][SFC_IMPOSTO] <> "DIG"
						nBase += MaFisRet(nX,'IT_VALIV'+ RIGHT(Alltrim(aNFItem[nX][IT_TS][TS_SFC][nY][SFB_CPOVREI]),1))
					EndIf
				Next nY
			Else
				If MaFisRet(nX,'IT_ALIQIV'+cNumImp) == nAliq
					nBase += MaFisRet(nX,'IT_BASEIV'+cNumImp)
				Endif
			EndIf

		Endif
	Next nX
EndIf
Return nBase

/*
MaRecurDIG - FELIPE V. NAMBARA      Data 25/11/2009
Calcula os valores dos impostos variaveis dos itens anteriores no caso da DETRAÇÃO DIG no localizado PERU
ParametrosllFlag - Identifica se haverá ou não a recursão
*/
Function MaRecurDIG(llFlag)
Local nlCont    := 1
Local nlCont2   := 1
Local nlCont3	:= 1
Local nlCont4   := 1
Local nG        := 0
Local nRs		:= 0
Local nRs2		:= 0
Local _IdxF3a   := 0
Local _IdxF3b   := 0
Local _IdxF3c   := 0
Local _IdxF3d   := 0
Local _IdxF3e   := 0
Local _IdxF3f   := 0
Local nlItens   := 0
Local nContador := 0

For nlCont4 := 1 To Len(aNfItem)
	If !aNfItem[nlCont4][IT_DELETED]
		nlItens++
	EndIf
Next nlCont4

If llFlag

	For nlCont := 1 To Len(aNfItem) -1
		If !aNfItem[nlCont][IT_DELETED]  .And. nlItens > 1

			MaFisTes(aNfItem[nlCont][IT_TES],aNfItem[nlCont][IT_RECNOSF4],nlCont)

			If Len(aNFItem[nlCont][IT_TS][TS_SFC]) > 0

				For nlCont2 := 1 To Len(aNFItem[nlCont][IT_TS][TS_SFC])
					If aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_IMPOSTO] $ "DIG"
						nG := 0
						nImp:=NumCpoImpVar(RIGHT(Alltrim(aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFB_CPOVREI]) ,1))

						aNfCab[NF_BASEIMP][nImp] -= aNfItem[nlCont][IT_BASEIMP][nImp]
						aNfCab[NF_VALIMP][nImp]  -= aNfItem[nlCont][IT_VALIMP][nImp]
						aNfCab[NF_VLRORIG][nImp]  -= aNfItem[nlCont][IT_VALIMP][nImp]

						If aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCNOTA] $ "1"
							aNfCab[NF_TOTAL]      -= aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
						ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCNOTA] $ "2"
							aNfCab[NF_TOTAL]      += aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
						EndIf

						If aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCDUPL] $ "1"
							aNfCab[NF_BASEDUP]    -= aNfItem[nlCont][IT_BASEIMP][1]*(1 + aNfItem[nlCont][IT_ALIQIMP][1]/100)
						ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCDUPL] $ "2"
							aNfCab[NF_BASEDUP]    -= aNfItem[nlCont][IT_BASEIMP][1]*(1 + aNfItem[nlCont][IT_ALIQIMP][1]/100)
						EndIf

						aNfCab[NF_VALMERC]    -= aNfItem[nlCont][IT_VALMERC]

						nRS	 := aScan(aNfCab[NF_IMPOSTOS],{|x| x[IMP_COD] == "DIG" .AND. x[IMP_ALIQ] == aNfItem[nlCont][IT_ALIQIMP][nImp] })
						nRS2 := aScan(aNfCab[NF_IMPOSTOS2],{|x| x[IMP_COD] == "DIG" })

						If nRs > 0
							aNfCab[NF_IMPOSTOS][nRS][IMP_BASE] 	-= aNfItem[nlCont][IT_BASEIMP][nImp]
							aNfCab[NF_IMPOSTOS][nRS][IMP_VAL]  	-= aNfItem[nlCont][IT_VALIMP][nImp]
						EndIf

						If nRs2 > 0
							aNfCab[NF_IMPOSTOS2][nRS2][3] 	-= aNfItem[nlCont][IT_BASEIMP][nImp]
							aNfCab[NF_IMPOSTOS2][nRS2][4]  	-= aNfItem[nlCont][IT_VALIMP][nImp]
						EndIf

						_IdxF3a := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_VALCONT" } )
						_IdxF3b := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_BASIMP"+Alltrim(Str(nImp)) } )
						_IdxF3c := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_VALIMP"+Alltrim(Str(nImp)) } )
						_IdxF3f := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_TES" } )

						nContador:=nlCont3
						For nContador := 2 To Len(aNFCab[NF_LIVRO])
							nlCont3:=nContador
							If aNfCab[NF_LIVRO][nlCont3][_IdxF3f] $ aNfItem[nlCont][IT_TES]
								Exit
							EndIf
						Next

						If ValType(aNfItem[nlCont][IT_BASEIMP][nImp]) == "N" .And. ValType(aNfItem[nlCont][IT_ALIQIMP][nImp]) == "N"

							aNfCab[NF_LIVRO][nlCont3][_IdxF3a] -= aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
							aNfCab[NF_LIVRO][nlCont3][_IdxF3b] -= aNfItem[nlCont][IT_BASEIMP][nImp]
							aNfCab[NF_LIVRO][nlCont3][_IdxF3c] -= aNfItem[nlCont][IT_VALIMP][nImp]
						EndIf
						//Recalcula o imposto DIG para todos os itens anteriores
						If !MaFisCalcIV(nlCont2,nlCont,(nG>0))

							MaFisAliqIV(nlCont2,nlCont)

							If nG == 0
								MaFisVLIV(nlCont2,nlCont)
							Endif
						Endif
					ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_IMPOSTO] $ "ISC"

						nImp:=NumCpoImpVar(RIGHT(Alltrim(aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFB_CPOVREI]),1 ))

						aNfCab[NF_BASEIMP][nImp] -= aNfItem[nlCont][IT_BASEIMP][nImp]
						aNfCab[NF_VALIMP][nImp]  -= aNfItem[nlCont][IT_VALIMP][nImp]
						aNfCab[NF_VLRORIG][nImp]  -= aNfItem[nlCont][IT_VALIMP][nImp]

						If aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCNOTA] $ "1"
							aNfCab[NF_TOTAL]      -= aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
						ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCNOTA] $ "2"
							aNfCab[NF_TOTAL]      += aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
						EndIf

						If aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCDUPL] $ "1"
							aNfCab[NF_BASEDUP]    -= aNfItem[nlCont][IT_BASEIMP][1]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
						ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCDUPL] $ "2"
							aNfCab[NF_BASEDUP]    += aNfItem[nlCont][IT_BASEIMP][1]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
						EndIf

						aNfCab[NF_VALMERC]    -= aNfItem[nlCont][IT_VALMERC]

						nRS	 := aScan(aNfCab[NF_IMPOSTOS],{|x| x[IMP_COD] == "ISC" .And. x[IMP_ALIQ] == aNfItem[nlCont][IT_ALIQIMP][nImp] })
						nRS2 := aScan(aNfCab[NF_IMPOSTOS2],{|x| x[IMP_COD] == "ISC" })

						If nRs > 0
							aNfCab[NF_IMPOSTOS][nRS][IMP_BASE] 	-= aNfItem[nlCont][IT_BASEIMP][nImp]
							aNfCab[NF_IMPOSTOS][nRS][IMP_VAL]  	-= aNfItem[nlCont][IT_VALIMP][nImp]
						EndIf

						If nRs2 > 0
							aNfCab[NF_IMPOSTOS2][nRS2][3] 	-= aNfItem[nlCont][IT_BASEIMP][nImp]
							aNfCab[NF_IMPOSTOS2][nRS2][4]  	-= aNfItem[nlCont][IT_VALIMP][nImp]
						EndIf

						_IdxF3a := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_VALCONT" } )
						_IdxF3b := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_BASIMP"+Alltrim(Str(nImp)) } )
						_IdxF3c := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_VALIMP"+Alltrim(Str(nImp)) } )
						_IdxF3f := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_TES" } )

						nContador:=nlCont3
						For nContador := 2 To Len(aNFCab[NF_LIVRO])
							nlCont3:=nContador
							If aNfCab[NF_LIVRO][nlCont3][_IdxF3f] $ aNfItem[nlCont][IT_TES]
								Exit
							EndIf
						Next

						If ValType(aNfItem[nlCont][IT_BASEIMP][nImp]) == "N" .And. ValType(aNfItem[nlCont][IT_ALIQIMP][nImp]) == "N"

							aNfCab[NF_LIVRO][nlCont3][_IdxF3a] -= aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
							aNfCab[NF_LIVRO][nlCont3][_IdxF3b] -= aNfItem[nlCont][IT_BASEIMP][nImp]
							aNfCab[NF_LIVRO][nlCont3][_IdxF3c] -= aNfItem[nlCont][IT_VALIMP][nImp]

						EndIf

					ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_IMPOSTO] $ "IGV"

						nImp:=NumCpoImpVar( RIGHT ( Alltrim(aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFB_CPOVREI] ),1 ))

						aNfCab[NF_BASEIMP][nImp] -= aNfItem[nlCont][IT_BASEIMP][nImp]
						aNfCab[NF_VALIMP][nImp]  -= aNfItem[nlCont][IT_VALIMP][nImp]
						aNfCab[NF_VLRORIG][nImp]  -= aNfItem[nlCont][IT_VALIMP][nImp]

						aNfCab[NF_BASEIMP][3] -= aNfItem[nlCont][IT_BASEIMP][3]
						aNfCab[NF_VALIMP][3]  -= aNfItem[nlCont][IT_VALIMP][3]
						aNfCab[NF_VLRORIG][3]  -= aNfItem[nlCont][IT_VALIMP][3]

						If aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCNOTA] $ "1"
							aNfCab[NF_TOTAL]      -= aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
						ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCNOTA] $ "2"
							aNfCab[NF_TOTAL]      += aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
						EndIf

						If aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCDUPL] $ "1"
							aNfCab[NF_BASEDUP]    -= aNfItem[nlCont][IT_BASEIMP][1]*(1 + aNfItem[nlCont][IT_ALIQIMP][1]/100)
						ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCDUPL] $ "2"
							aNfCab[NF_BASEDUP]    -= aNfItem[nlCont][IT_BASEIMP][1]*(1 + aNfItem[nlCont][IT_ALIQIMP][1]/100)
						EndIf

						aNfCab[NF_VALMERC]    -= aNfItem[nlCont][IT_VALMERC]

						nRS	 := aScan(aNfCab[NF_IMPOSTOS],{|x| x[IMP_COD] == "IGV" .And. x[IMP_ALIQ] == aNfItem[nlCont][IT_ALIQIMP][nImp] })
						nRS2 := aScan(aNfCab[NF_IMPOSTOS2],{|x| x[IMP_COD] == "IGV" })

						If nRs > 0
							aNfCab[NF_IMPOSTOS][nRS][IMP_BASE] 	-= aNfItem[nlCont][IT_BASEIMP][nImp]
							aNfCab[NF_IMPOSTOS][nRS][IMP_VAL]  	-= aNfItem[nlCont][IT_VALIMP][nImp]
						EndIf

						If nRs2 > 0
							aNfCab[NF_IMPOSTOS2][nRS2][3] 	-= aNfItem[nlCont][IT_BASEIMP][nImp]
							aNfCab[NF_IMPOSTOS2][nRS2][4]  	-= aNfItem[nlCont][IT_VALIMP][nImp]
						EndIf

						_IdxF3a := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_VALCONT" } )
						_IdxF3b := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_BASIMP"+Alltrim(Str(nImp)) } )
						_IdxF3c := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_VALIMP"+Alltrim(Str(nImp)) } )
						_IdxF3d := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_BASIMP3" } )
						_IdxF3e := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_VALIMP3" } )
						_IdxF3f := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_TES" } )

						nContador:=nlCont3
						For nContador := 2 To Len(aNFCab[NF_LIVRO])
							nlCont3:=nContador
							If aNfCab[NF_LIVRO][nlCont3][_IdxF3f] $ aNfItem[nlCont][IT_TES]
								Exit
							EndIf
						Next

						If ValType(aNfItem[nlCont][IT_BASEIMP][nImp]) == "N" .And. ValType(aNfItem[nlCont][IT_ALIQIMP][nImp]) == "N"

							aNfCab[NF_LIVRO][nlCont3][_IdxF3a] -= aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
							aNfCab[NF_LIVRO][nlCont3][_IdxF3b] -= aNfItem[nlCont][IT_BASEIMP][nImp]
							aNfCab[NF_LIVRO][nlCont3][_IdxF3c] -= aNfItem[nlCont][IT_VALIMP][nImp]
							aNfCab[NF_LIVRO][nlCont3][_IdxF3d] -= aNfItem[nlCont][IT_BASEIMP][3]
							aNfCab[NF_LIVRO][nlCont3][_IdxF3e] -= aNfItem[nlCont][IT_VALIMP][3]
						EndIf

					ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_IMPOSTO] $ "PIV"

						nImp:=NumCpoImpVar(RIGHT(Alltrim(aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFB_CPOVREI]) ,1))

						aNfCab[NF_BASEIMP][nImp] -= aNfItem[nlCont][IT_BASEIMP][nImp]
						aNfCab[NF_VALIMP][nImp]  -= aNfItem[nlCont][IT_VALIMP][nImp]
						aNfCab[NF_VLRORIG][nImp]  -= aNfItem[nlCont][IT_VALIMP][nImp]

						If aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCNOTA] $ "1"
							aNfCab[NF_TOTAL]      -= aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
						ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCNOTA] $ "2"
							aNfCab[NF_TOTAL]      += aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
						EndIf

						If aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCDUPL] $ "1"
							aNfCab[NF_BASEDUP]    -= aNfItem[nlCont][IT_BASEIMP][1]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
						ElseIf aNFItem[nlCont][IT_TS][TS_SFC][nlCont2][SFC_INCDUPL] $ "2"
							aNfCab[NF_BASEDUP]    -= aNfItem[nlCont][IT_BASEIMP][1]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
						EndIf

						aNfCab[NF_VALMERC]    -= aNfItem[nlCont][IT_VALMERC]

						nRS	 := aScan(aNfCab[NF_IMPOSTOS],{|x| x[IMP_COD] == "PIV" .And. x[IMP_ALIQ] == aNfItem[nlCont][IT_ALIQIMP][nImp] })
						nRS2 := aScan(aNfCab[NF_IMPOSTOS2],{|x| x[IMP_COD] == "PIV" })

						If nRs > 0
							aNfCab[NF_IMPOSTOS][nRS][IMP_BASE] 	-= aNfItem[nlCont][IT_BASEIMP][nImp]
							aNfCab[NF_IMPOSTOS][nRS][IMP_VAL]  	-= aNfItem[nlCont][IT_VALIMP][nImp]
						EndIf

						If nRs2 > 0
							aNfCab[NF_IMPOSTOS2][nRS2][3] 	-= aNfItem[nlCont][IT_BASEIMP][nImp]
							aNfCab[NF_IMPOSTOS2][nRS2][4]  	-= aNfItem[nlCont][IT_VALIMP][nImp]
						EndIf

						_IdxF3a := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_VALCONT" } )
						_IdxF3b := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_BASIMP"+Alltrim(Str(nImp)) } )
						_IdxF3c := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_VALIMP"+Alltrim(Str(nImp)) } )
						_IdxF3f := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_TES" } )

						nContador:=nlCont3
						For nContador := 2 To Len(aNFCab[NF_LIVRO])
							nlCont3:=nContador
							If aNfCab[NF_LIVRO][nlCont3][_IdxF3f] $ aNfItem[nlCont][IT_TES]
								Exit
							EndIf
						Next

						If ValType(aNfItem[nlCont][IT_BASEIMP][nImp]) == "N" .And. ValType(aNfItem[nlCont][IT_ALIQIMP][nImp]) == "N"

							aNfCab[NF_LIVRO][nlCont3][_IdxF3a] -= aNfItem[nlCont][IT_BASEIMP][nImp]*(1 + aNfItem[nlCont][IT_ALIQIMP][nImp]/100)
							aNfCab[NF_LIVRO][nlCont3][_IdxF3b] -= aNfItem[nlCont][IT_BASEIMP][nImp]
							aNfCab[NF_LIVRO][nlCont3][_IdxF3c] -= aNfItem[nlCont][IT_VALIMP][nImp]
						EndIf
					EndIf
				Next nlCont2

				aNfCab[NF_RECIV] := .F.
			EndIf
			MaFisSomaIt(nlCont,.T.)
		EndIf
	Next nlCont
Else
	For nlCont := 1 To Len(aNfItem)

		If !aNfItem[nlCont][IT_DELETED] .And. aNfCab[NF_VALIMP][5] > 0

			nRS	 := aScan(aNfCab[NF_IMPOSTOS],{|x| x[IMP_COD] == "DIG" .And. x[IMP_ALIQ] == aNfItem[nlCont][IT_ALIQIMP][5] })
			nRS2 := aScan(aNfCab[NF_IMPOSTOS2],{|x| x[IMP_COD] == "DIG" })

			If nRs > 0
				aDel(aNfCab[NF_IMPOSTOS],nRS)
				aSize(aNfCab[NF_IMPOSTOS],Len(aNfCab[NF_IMPOSTOS]) -1)
			EndIf

			If nRs2 > 0
				aDel(aNfCab[NF_IMPOSTOS2],nRS2)
				aSize(aNfCab[NF_IMPOSTOS2],Len(aNfCab[NF_IMPOSTOS2]) -1)
			EndIf

			_IdxF3a := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_VALCONT" } )
			_IdxF3b := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_BASIMP5" } )
			_IdxF3c := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_VALIMP5" } )
			_IdxF3f := AScan( aNfCab[NF_LIVRO][1],{|x| x == "F3_TES" } )

			nContador:=nlCont3
			For nContador := 2 To Len(aNFCab[NF_LIVRO])
				nlCont3:=nContador
				If aNfCab[NF_LIVRO][nlCont3][_IdxF3f] $ aNfItem[nlCont][IT_TES]
					Exit
				EndIf
			Next

			aNfCab[NF_LIVRO][nlCont3][_IdxF3b] -= aNfItem[nlCont][IT_BASEIMP][5]
			aNfCab[NF_LIVRO][nlCont3][_IdxF3c] -= aNfItem[nlCont][IT_VALIMP][5]

			aNfItem[nlCont][IT_BASEIMP][5] := 0
			aNfItem[nlCont][IT_VALIMP][5]  := 0
			aNfItem[nlCont][IT_ALIQIMP][5] := 0
		EndIf
	Next nlCont

	aNfCab[NF_BASEIMP][5] := 0
	aNfCab[NF_VALIMP][5]  := 0
	aNfCab[NF_VLRORIG][5]  := 0
EndIf

Return()

/*/
MaFisBSICM - Edson Maricate -08.12.1999
Executa o calculo da Base do ICMS do Item.
/*/
Static Function MaFisBSICM( nItem , lReproc , lZF , lICDif , cCampo, lAgreg )

Local nSalvaBase  := 0
Local lIncide     := .F.
Local nReduzICMS  := 0
Local nReduzAnt	 := 0
Local nDespOri    := 0
Local nBsFrete    := 0
Local nAliqAgr    := 0
Local lRet        := .F.
Local lVlr_Frt    := .F.
Local lDevTot     := aSX6[MV_DEVTOT]
Local lRedBIcm    := aSX6[MV_REBICM]
Local nAuxBicms   := 0
Local nRed43080   := 0
Local nIncLeitMG  := 0
Local aMaICMVeic  := {} //usado no PE MaICMVeic
Local aMaCalcICMS := {}
Local aPautICMS   := {}
Local aAreaSC6    := {}
Local nPautaICMS  := aNfItem[nItem][IT_PRD][SB_INT_ICM]
Local nPautICFOB  :=  IIf( !Empty(aNFitem[nItem,IT_EXCECAO]) .And. aNFItem[nItem,IT_EXCECAO,32] > 0 , aNFItem[nItem,IT_EXCECAO,32], Iif (aNfItem[nItem][IT_UFXPROD][UFP_PAUTFOB] > 0, aNfItem[nItem][IT_UFXPROD][UFP_PAUTFOB], aNfItem[nItem][IT_PRD][SB_MV_PAUTFOB]))
Local aMvUfirce   := {}
Local cOrigUf 	:= ""
Local nCustoEnt	:= 0
Local nPerc		:= 0
Local nBaseCalc 	:= 0
Local aAliqAgr	:= {}
Local nPerNort	:= 0
Local nPerSul		:= 0
Local nPerImp		:= 0
Local nAliqDed := 0
Local nIndice  := 0
Local lIndVFut := .F.
Local lPISImp  := .F.
Local lCOFImp  := .F.

Default lZF       := .F.
Default lICDif    := .F.
Default cCampo    := ""
Default lAgreg    := .T.

//Abaixo grava no item se a NF foi emitida sob norma específica e se deva indicar dessa forma na geração do SpedFiscal
aNfItem[nItem][IT_NORESPE] := aNFItem[nItem][IT_TS][TS_NORESPE]

//O bloco a seguir providencia para que em operações de devolução e ou beneficiamento quando o parametro MV_DEVTOT = .T.
//o valor da BASE do ICMS seja igual a Base do Imposto do documento Original quando a devolução e ou beneficiamento for
//igual a do documento original, se houverem despesas acessorias inclusas na base do documento original (Frete, Despesas e Seguro)
//as mesmas deverão ser digitadas manualmente no documento de devolução.
If ( aNFCab[NF_TIPONF] $ "DB" .Or. aNFItem[nItem][IT_TS][TS_PODER3] =="D" ) .And. !Empty(aNFItem[nItem][IT_RECORI]) .And. !RetComp(aNFCab[NF_CLIFOR], aNFItem[nItem][IT_RECORI])
	If aNFCab[NF_TIPONF] $ "DB"
		If ( aNFCab[NF_CLIFOR] == "C")
			dbSelectArea("SD2")
			MsGoto(aNFItem[nItem][IT_RECORI])
			If aNfItem[nItem][IT_QUANT] == SD2->D2_QUANT  .And. (Iif(!lDevTot ,SD2->D2_VALFRE+SD2->D2_SEGURO+SD2->D2_DESPESA==0 , SD2->D2_BASEICM >0) .Or. ;
				(!aNfCab[NF_CALCSUF]$'IN '.And. aSX6[MV_DESCZF] .And. aSX6[MV_DESZFPC] ))

				aNfItem[nItem][IT_BASEICM] := SD2->D2_BASEICM
				aNfItem[nItem][IT_DEDICM]  := IIF(aNFItem[nItem][IT_TS][TS_AGREG]$"DRE" .And. cPaisLoc == "BRA",SD2->D2_DESCICM,0)
				aNfItem[nItem][IT_PREDIC]	:= aNFItem[nItem][IT_TS][TS_BASEICM]
				lRet := .T.
			ElseIf aNfItem[nItem][IT_QUANT] <> SD2->D2_QUANT .And. aNFItem[nItem][IT_TS][TS_DEVPARC]$"1S"
				aNfItem[nItem][IT_BASEICM] := (aNfItem[nItem][IT_QUANT] * SD2->D2_BASEICM)/SD2->D2_QUANT
				aNfItem[nItem][IT_DEDICM]  := IIF(aNFItem[nItem][IT_TS][TS_AGREG]$"DRE" .And. cPaisLoc == "BRA",(aNfItem[nItem][IT_QUANT] * SD2->D2_DESCICM)/SD2->D2_QUANT,0)
				If aNFItem[nItem][IT_TS][TS_AGREG]<>"F"
					aNfItem[nItem][IT_BICMORI]	:= aNfItem[nItem][IT_VALMERC] - (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT]) + IIf(!lZF,aNfItem[nItem][IT_DESCZF],0) +  aNfItem[nItem][IT_ACRESCI]
				EndIf
				lRet := .T.
			EndIf
		Else
			dbSelectArea("SD1")
			MsGoto(aNFItem[nItem][IT_RECORI])
			If aNfItem[nItem][IT_QUANT] == SD1->D1_QUANT .And. Iif(!lDevTot , SD1->D1_VALFRE+SD1->D1_SEGURO+SD1->D1_DESPESA==0 ,SD1->D1_BASEICM > 0)
				aNfItem[nItem][IT_BASEICM] := SD1->D1_BASEICM
				aNfItem[nItem][IT_DEDICM]  := IIF(aNFItem[nItem][IT_TS][TS_AGREG]$"DRE" .And. cPaisLoc == "BRA" ,SD1->D1_DESCICM,0)
				aNfItem[nItem][IT_PREDIC]	:= aNFItem[nItem][IT_TS][TS_BASEICM]
				lRet := .T.
			ElseIf aNfItem[nItem][IT_QUANT] <> SD1->D1_QUANT .AND. aNFItem[nItem][IT_TS][TS_DEVPARC]$"1S"
				aNfItem[nItem][IT_BASEICM] := (aNfItem[nItem][IT_QUANT] * SD1->D1_BASEICM)/SD1->D1_QUANT
				aNfItem[nItem][IT_DEDICM]  := IIF(aNFItem[nItem][IT_TS][TS_AGREG]$"DRE" .And. cPaisLoc == "BRA",(aNfItem[nItem][IT_QUANT] * SD1->D1_DESCICM)/SD1->D1_QUANT,0)
				If aNFItem[nItem][IT_TS][TS_AGREG]<>"F"
					aNfItem[nItem][IT_BICMORI]	:= aNfItem[nItem][IT_VALMERC] - (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT]) + IIf(!lZF,aNfItem[nItem][IT_DESCZF],0) +  aNfItem[nItem][IT_ACRESCI]
				EndIf
				lRet := .T.
			EndIf
		EndIf
		If aNFItem[nItem][IT_TS][TS_ICMSDIF] == "6"
			aNfItem[nItem][IT_DEDICM] += aNfItem[nItem][IT_ICMSDIF]
		EndIf //issue DSERFIS1-8601
	Else
		If ( aNFCab[NF_CLIFOR] == "C")
			dbSelectArea("SD1")
			MsGoto(aNFItem[nItem][IT_RECORI])
			If aNfItem[nItem][IT_QUANT] == SD1->D1_QUANT .And. Iif(!lDevTot , SD1->D1_VALFRE+SD1->D1_SEGURO+SD1->D1_DESPESA==0 ,SD1->D1_BASEICM > 0)
				aNfItem[nItem][IT_BASEICM] := SD1->D1_BASEICM
				aNfItem[nItem][IT_DEDICM]  := IIF(aNFItem[nItem][IT_TS][TS_AGREG]$"DRE" .And. cPaisLoc == "BRA",SD1->D1_DESCICM,0)
				aNfItem[nItem][IT_PREDIC]	:= aNFItem[nItem][IT_TS][TS_BASEICM]
				If aNFItem[nItem][IT_TS][TS_OPERSUC]=="1" .And. (aNfCab[NF_SIMPSC]<>"1" .Or. aNFCab[NF_SIMPNAC]<>"1") .And. SD1->D1_BASEICM <= 0
					lRet := .F.
				Else
					lRet := .T.
				EndIf
			ElseIf aNfItem[nItem][IT_QUANT] <> SD1->D1_QUANT .AND. aNFItem[nItem][IT_TS][TS_DEVPARC]$"1S"
				aNfItem[nItem][IT_BASEICM] := (aNfItem[nItem][IT_QUANT] * SD1->D1_BASEICM)/SD1->D1_QUANT
				aNfItem[nItem][IT_DEDICM]  := IIF(aNFItem[nItem][IT_TS][TS_AGREG]$"DRE" .And. cPaisLoc == "BRA",(aNfItem[nItem][IT_QUANT] * SD1->D1_DESCICM)/SD1->D1_QUANT,0)
				lRet := .T.
			EndIf
		Else
			dbSelectArea("SD2")
			MsGoto(aNFItem[nItem][IT_RECORI])
			If aNfItem[nItem][IT_QUANT] == SD2->D2_QUANT .And. Iif(!lDevTot ,SD2->D2_VALFRE+SD2->D2_SEGURO+SD2->D2_DESPESA==0 , SD2->D2_BASEICM >0)
				aNfItem[nItem][IT_BASEICM] := SD2->D2_BASEICM
				aNfItem[nItem][IT_DEDICM]  := IIF(aNFItem[nItem][IT_TS][TS_AGREG]$"DRE" .And. cPaisLoc == "BRA",SD2->D2_DESCICM,0)
				aNfItem[nItem][IT_PREDIC]	:= aNFItem[nItem][IT_TS][TS_BASEICM]
				lRet := .T.
			ElseIf aNfItem[nItem][IT_QUANT] <> SD2->D2_QUANT
				aNfItem[nItem][IT_BASEICM] := (aNfItem[nItem][IT_QUANT] * SD2->D2_BASEICM)/SD2->D2_QUANT
				aNfItem[nItem][IT_DEDICM]  := IIF(aNFItem[nItem][IT_TS][TS_AGREG]$"DRE" .And. cPaisLoc == "BRA",(aNfItem[nItem][IT_QUANT] * SD2->D2_DESCICM)/SD2->D2_QUANT,0)
				lRet := .T.
			EndIf
			If aNFItem[nItem][IT_TS][TS_ICMSDIF] == "6"
				aNfItem[nItem][IT_DEDICM] += aNfItem[nItem][IT_ICMSDIF]
			EndIf //issue DSERFIS1-8601
		EndIf
	EndIf
EndIf

//Para buscar a data da NF original de Simples Faturamento de Venda com entrega Futura
IF Alltrim(aNfItem[nItem][IT_CF])$aSX6[MV_REMVFUT] .And.  !Empty(aNFItem[nItem][IT_RECORI]) .And.  aNfItem[nItem][IT_INDICE] <> 0 .And. aNfItem[nItem][IT_TS][TS_INDVF] == '1' .And. (!aNFCab[NF_TIPONF] $ "DB")
    dbSelectArea("SD2")
    MsGoto(aNFItem[nItem][IT_RECORI])
    IF Month(SD2->D2_EMISSAO)  <>  Month(aNfCab[NF_DTEMISS]) .Or. Year(SD2->D2_EMISSAO)  <>  Year(aNfCab[NF_DTEMISS])
		dbSelectArea("F0R")
		F0R->(dbSetOrder(1))
		If F0R->(MsSeek(xFilial("F0R")+aNFCab[NF_UFDEST]+AnoMes(SD2->D2_EMISSAO)))
			nIndice := aNFCab[NF_INDICE]/F0R->F0R_INDICE
		EndIf
        lIndVFut := .T.
    EndIf
EndIf

// Carrega a reducao da base do ICMS
If !Empty(aNFitem[nItem,IT_EXCECAO]) .And. aNfItem[nItem,IT_EXCECAO,14] > 0
	nReduzICMS := aNfItem[nItem,IT_EXCECAO,14]
Else
	nReduzICMS := aNFItem[nItem][IT_TS][TS_BASEICM]
EndIf
aNfItem[nItem,IT_PREDIC] := nReduzICMS

//Tratamento para Convênio 139/06, irá verificar CFOP e Campo no TES
IF aLLTRIM(aNfItem[nItem][IT_CF]) $ aSX6[MV_C13906] .AND. aNFItem[nItem][IT_TS][TS_CV139] == "1"
	aNfItem[nItem][IT_CV139] := "1"
Else
	aNfItem[nItem][IT_CV139] := ""
EndIF

//Utilizada função MaFisFECP para obter Aliquota do FECP complementar (IT_ALFCCMP) que sera agregada na base de calculo quando aplicada Difal
//Quando for separada aliquota do fecp do calculo esta função deve ser removida.
/*If aNfCab[NF_PPDIFAL] .And. (aNFItem[nItem][IT_TS][TS_AGREG]$"D" .Or.(aNFItem[nItem][IT_TS][TS_AGREG]$"I" .And. IntTms()))
	MaFisFECP(nItem)
Endif*/

If !lRet
	aNfItem[nItem][IT_DEDICM]:= 0

	lReproc := IIf(lReproc==Nil,.F.,lReproc)

	// Salva  a base do ICMS no reprocessamento.
	nSalvaBase	:= aNfItem[nItem][IT_BASEICM]
	
	// Variaveis para controle de PIS/COFINS importacao (c/ valor ou aliq. zero)
	lPISImp := (aNFItem[nItem][IT_TS][TS_INTBSIC]$"13" .And. (aNfItem[nItem][IT_VALPS2] > 0 .Or. aNFItem[nItem][IT_TS][TS_CSTPIS] $"73"))
	lCOFImp := (aNFItem[nItem][IT_TS][TS_INTBSIC]$"23" .And. (aNfItem[nItem][IT_VALCF2] > 0 .Or. aNFItem[nItem][IT_TS][TS_CSTCOF] $"73"))

	//Operacoes com Sucata - Valor do Pis e Cofins integra a base de calculo do ICMS
	If !(aNFItem[nItem][IT_TS][TS_OPERSUC]=="1" .And. aNfCab[NF_SIMPSC]<>"1" .And. aNFCab[NF_SIMPNAC]<>"1")
		If lPISImp
			aNfItem[nItem][IT_BASEICM] := aNfItem[nItem][IT_BICMORI]
			aNfItem[nItem][IT_BASEICM] += aNfItem[nItem][IT_VALPS2]
		EndIf

		If lCOFImp
			If aNfItem[nItem][IT_BASEICM] <> (aNfItem[nItem][IT_BICMORI]+aNfItem[nItem][IT_VALPS2])
				aNfItem[nItem][IT_BASEICM] := aNfItem[nItem][IT_BICMORI]
			EndIf
			aNfItem[nItem][IT_BASEICM] += aNfItem[nItem][IT_VALCF2]
		EndIf
	EndIf

    // Se o parâmetro está habilitado significa que não foi informado o II no valor aduaneiro então devo somar o II na base do ICMS para ficar correta.
    IF aSX6[MV_EIC0064] .And.  (!(aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C") .And. aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_CLIFOR] =="F" .And. aNFCab[NF_TPCLIFOR] =="X" .And. Substr(aNfItem[nItem][IT_CF],1,1)=="3" .And. lPISImp .And. lCOFImp)
        aNfItem[nItem][IT_BASEICM] += aNfItem[nItem][IT_VALII]
    EndIf
    
	// Calculo da base de ICMS - Valor da Mercadoria
	If aNFItem[nItem][IT_TS][TS_AGREG]<>"F"
		//Alteracao realizada caso o produto tenha o TES configurado
		//para aplicacao de Deducao ICM
		If FunName() == "FRTA010" .And. (aNFItem[nItem][IT_TS][TS_AGREG] == "D" .Or. aNFItem[nItem][IT_TS][TS_AGREG] == "R")
			aNfItem[nItem][IT_BICMORI]	:= aNfItem[nItem][IT_VALMERC] + IIf(!lZF,aNfItem[nItem][IT_DESCZF],0)
		Else
			aNfItem[nItem][IT_BICMORI]	:= aNfItem[nItem][IT_VALMERC] - (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT]) + IIf(!lZF,aNfItem[nItem][IT_DESCZF],0) +  aNfItem[nItem][IT_ACRESCI]
		Endif
		If aNFItem[nItem][IT_TS][TS_ICMSDIF] == "6"
			aNfItem[nItem][IT_BICMORI] -= aNfItem[nItem][IT_ICMSDIF]
		EndIf//issue DSERFIS1-8601
	EndIf

	//Conforme parecer de nossa Consultora Tributaria:
	//Recomendo que a configuração quanto ao DESCONTO CONDICIONAL OU INCONDICIONAL no cadastro do TES, seja
	//tambem aplicado ao calculo do ICMS nas operacoes com a ZFM, de tal forma que quando
	//haja o desconto do PIS e da COFINS e o calculo do ICMS, que este seja feito segundo a
	//configuracao e interpretacao do cliente.
	If aNFItem[nItem][IT_TS][TS_DESCOND] == "1"
		aNfItem[nItem][IT_BICMORI] += (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT])
	EndIf

	If aNFItem[nItem][IT_TS][TS_DESCOND] == "1" .And. lZF
		aNfItem[nItem][IT_BICMORI] += aNfItem[nItem][IT_DESCZFPIS] + aNfItem[nItem][IT_DESCZFCOF]
	EndIf

	If	aSX6[MV_ESTADO] == "BA" .And. aNfCab[NF_UFDEST] == "BA"  .And. aNFCab[NF_SIMPNAC] =="1" .And. aNfItem[nItem][IT_VRDICMS] > 0
		aNfItem[nItem][IT_BICMORI] += aNfItem[nItem][IT_VRDICMS]
	EndIf

	//-- Pauta ICMS por tipo de frete CIF/FOB - PORTARIA 216/2013 - SEFAZ/MT
	If nPautICFOB > 0
		//-- Se tipo frete = FOB utiliza Pauta ICMS-ST informada no parametro MV_PAUTFOB
		If aNfCab[NF_TPFRETE] == "F"
			nPautaICMS := nPautICFOB
		EndIf
	EndIf

	If aPE[PE_PAUTICMS]  //PE para tratamento de pauta de ICMS
		aPautICMS := ExecBlock( "PAUTICMS" , .F. , .F. , { cAliasPROD , Right(cAliasPROD,2)+"_INT_ICM" , nPautaICMS } )
		If aPautICMS[1] == "S"
			nPautaICMS := aPautICMS[2]
		EndIf
	EndIf	

	// Calculo da base de ICMS - Pauta fiscal
	If ( nPautaICMS<>Nil .And.  nPautaICMS<>0 ) .Or. (!Empty(aNFitem[nItem][IT_EXCECAO]) .And. aNfItem[nItem][IT_EXCECAO][16]<>0) .Or. (!Empty(aNfItem[nItem][IT_UFXPROD]) .And. aNfItem[nItem][IT_UFXPROD][UFP_VLICMP]<>0)
		If Len (aNfItem[nItem][IT_EXCECAO])>0 .And. Iif( aNfCab[NF_TPFRETE] == "F" , aNFItem[nItem,IT_EXCECAO,32] > 0 , aNfItem[nItem][IT_EXCECAO][16] > 0 )		
			
			aNfItem[nItem][IT_PAUTIC] := Iif( aNfCab[NF_TPFRETE] == "F" , aNFItem[nItem,IT_EXCECAO,32] , aNfItem[nItem][IT_EXCECAO][16] )
	
			If aNFItem[nItem][IT_TS][TS_PAUTICM] $ " 1"
				If aNfItem[nItem][IT_BICMORI] > 0 .And. Max(aNfItem[nItem][IT_QUANT] * aNfItem[nItem][IT_PAUTIC] ,aNfItem[nItem][IT_BICMORI]) <> aNfItem[nItem][IT_BICMORI]
					aNfItem[nItem][IT_BICMORI] := aNfItem[nItem][IT_QUANT] * aNfItem[nItem][IT_PAUTIC]
				Else
					aNfItem[nItem][IT_PAUTIC] := 0
				EndIf
			Else
				aNfItem[nItem][IT_BICMORI] := aNfItem[nItem][IT_QUANT] * aNfItem[nItem][IT_PAUTIC]				
			EndIf
		ElseIf Len (aNfItem[nItem][IT_UFXPROD])>0 .And. Iif( aNfCab[NF_TPFRETE] == "F" , aNfItem[nItem][IT_UFXPROD][UFP_PAUTFOB] > 0 , aNfItem[nItem][IT_UFXPROD][UFP_VLICMP] > 0 )

			aNfItem[nItem][IT_PAUTIC]	:= Iif( aNfCab[NF_TPFRETE] == "F" , aNfItem[nItem][IT_UFXPROD][UFP_PAUTFOB] , aNfItem[nItem][IT_UFXPROD][UFP_VLICMP] )

			If aNFItem[nItem][IT_TS][TS_PAUTICM] $ " 1"
				If aNfItem[nItem][IT_BICMORI] > 0 .And. Max(aNfItem[nItem][IT_QUANT] * aNfItem[nItem][IT_PAUTIC] , aNfItem[nItem][IT_BICMORI]) <> aNfItem[nItem][IT_BICMORI]
					aNfItem[nItem][IT_BICMORI] := aNfItem[nItem][IT_QUANT] * aNfItem[nItem][IT_PAUTIC]
				Else
					aNfItem[nItem][IT_PAUTIC] := 0
				EndIf
			Else
				aNfItem[nItem][IT_BICMORI] := aNfItem[nItem][IT_PAUTIC]				
			EndIf
		Else
			If !Empty(aNFItem[nItem][IT_VLR_FRT])
				If (aNfItem[nItem][IT_BICMORI]+aNfItem[nItem][IT_FRETE]) < (aNfItem[nItem][IT_QUANT]*nPautaICMS+aNfItem[nItem][IT_VLR_FRT])
					aNfItem[nItem][IT_BICMORI] := aNfItem[nItem][IT_QUANT]*nPautaICMS
					aNfItem[nItem][IT_PAUTIC]  := nPautaICMS
					lVlr_Frt := .T.
				EndIf
			Else				
				If aNFItem[nItem][IT_TS][TS_PAUTICM] $ " 1"
					If aNfItem[nItem][IT_BICMORI] > 0 .And. Max(aNfItem[nItem][IT_QUANT]*nPautaICMS,aNfItem[nItem][IT_BICMORI]) <> aNfItem[nItem][IT_BICMORI]
						aNfItem[nItem][IT_BICMORI] := aNfItem[nItem][IT_QUANT]*nPautaICMS
						aNfItem[nItem][IT_PAUTIC]  := nPautaICMS
					EndIf
				Else
					aNfItem[nItem][IT_BICMORI] := aNfItem[nItem][IT_QUANT]*nPautaICMS
				EndIf
			EndIf
		EndIf
		If !Empty( aSX6[MV_ICMPFAT] )
			aNfItem[nItem][IT_BICMORI] *= aNfItem[nItem][IT_PRD][SB_ICMPFAT]
		EndIf
		If aSX6[MV_ICPAUTA]=="2"
			If aNFItem[nItem][IT_TS][TS_DESPRDIC] $ " 1"
				If lVlr_Frt
					aNfItem[nItem][IT_BICMORI]	+= aNfItem[nItem][IT_VLR_FRT]
				Else
					aNfItem[nItem][IT_BICMORI]	+= aNfItem[nItem][IT_FRETE]
				EndIf
				aNfItem[nItem][IT_BSFRETE]	:= aNfItem[nItem][IT_FRETE]
				If aNFItem[nItem][IT_TS][TS_DESPICM] <> "2" .And. aNFItem[nItem][IT_TS][TS_DESPICM] <> "3"
					aNfItem[nItem][IT_BICMORI]	+= aNfItem[nItem][IT_DESPESA]
					aNfItem[nItem][IT_BICMORI]	+= aNfItem[nItem][IT_SEGURO]
					aNfItem[nItem][IT_BICMORI]	+= aNfItem[nItem][IT_AFRMIMP]
				EndIf
			Else
				If lVlr_Frt
					nDespOri += aNfItem[nItem][IT_VLR_FRT]
				Else
					nDespOri += aNfItem[nItem][IT_FRETE]
				EndIf
				nBsFrete += aNfItem[nItem][IT_FRETE]
				If aNFItem[nItem][IT_TS][TS_DESPICM] <> "2" .And. aNFItem[nItem][IT_TS][TS_DESPICM] <> "3"
					nDespOri += aNfItem[nItem][IT_DESPESA]
					nDespOri += aNfItem[nItem][IT_SEGURO]
				EndIf
			EndIf
		EndIf
	Else
		If aNFItem[nItem][IT_TS][TS_DESPRDIC] $ "1 " .Or. aNFItem[nItem][IT_TS][TS_DESPICM] $ "14"
			aNfItem[nItem][IT_BICMORI]	+= aNfItem[nItem][IT_FRETE]
			aNfItem[nItem][IT_BSFRETE]	:= aNfItem[nItem][IT_FRETE]
			If aNFItem[nItem][IT_TS][TS_DESPICM] <> "2" .And. aNFItem[nItem][IT_TS][TS_DESPICM] <> "3"
				aNfItem[nItem][IT_BICMORI]	+= aNfItem[nItem][IT_DESPESA]
				aNfItem[nItem][IT_BICMORI]	+= aNfItem[nItem][IT_SEGURO]
				aNfItem[nItem][IT_BICMORI]	+= aNfItem[nItem][IT_AFRMIMP]
			EndIf
		Else
			nDespOri += aNfItem[nItem][IT_FRETE]
			nBsFrete += aNfItem[nItem][IT_FRETE]
			If aNFItem[nItem][IT_TS][TS_DESPICM] <> "2" .And. aNFItem[nItem][IT_TS][TS_DESPICM] <> "3"
				nDespOri += aNfItem[nItem][IT_DESPESA]
				nDespOri += aNfItem[nItem][IT_SEGURO]
				nDespOri += aNfItem[nItem][IT_AFRMIMP]
			EndIf
		EndIf

		// A base do ICMS sera somente as despesas acessorias FRETE/SEGURO/DESPESAS usado para tributar o ICMS somente das despesas
		If aNFItem[nItem][IT_TS][TS_DESPICM] == "5" // Somente Despesas Acessorias
			aNfItem[nItem][IT_BICMORI]	:= aNfItem[nItem][IT_FRETE] + aNfItem[nItem][IT_SEGURO] + aNfItem[nItem][IT_DESPESA]
		EndIf

	EndIf
	If (aNFItem[nItem][IT_TS][TS_INCIDE] == "S" .Or. (aNFItem[nItem][IT_TS][TS_INCIDE] == "F" .And. aNFCab[NF_TPCLIFOR] =="F" .And. aNFCab[NF_CLIFOR] =="C")) .And.;
		aNFItem[nItem][IT_TS][TS_IPI] <> "R"
		lIncide := .T.
		If aNFitem[nItem][IT_TIPONF ] <> "P"
			If aNFCab[NF_OPERNF] == "S" .And. aNfCab[NF_OPIRRF] == "EP"
				MaFisIPI(nItem,"BSE|VLR",,"1")
				aNfItem[nItem][IT_BICMORI]	+= aNfItem[nItem][IT_VIPIORI]
				MaFisIPI(nItem,"BSE|VLR")
			Else
				aNfItem[nItem][IT_BICMORI]	+= aNfItem[nItem][IT_VALIPI]
			EndIf		
		Else
			aNfItem[nItem][IT_BICMORI]	:= aNfItem[nItem][IT_VALIPI]
		EndIf
		If aNfItem[nItem][IT_BSFRETE] <> 0
			aNfItem[nItem][IT_BSFRETE]	+= aNfItem[nItem][IT_VALIPI]
		EndIf
		If aNFItem[nItem][IT_TS][TS_IPILICM] <> "1"
			aNfItem[nItem][IT_VIPIBICM]:= NoRound((aNfItem[nItem][IT_VALIPI]))
		Else
			aNfItem[nItem][IT_VIPIBICM]:= 0
		EndIf
	EndIf
	If aNFItem[nItem][IT_TS][TS_IPIVFCF]$"24"
		aNfItem[nItem][IT_BICMORI]+= aNfItem[nItem][IT_IPIVFCF]
	EndIf
	If ((aNFItem[nItem][IT_TS][TS_ICM] <> "N" .Or. lICDif) .And. !aNFitem[nItem][IT_TIPONF ]$"IP") .Or. (aNFitem[nItem][IT_TIPONF ]=="P".And.lIncide) .Or. (aNFCab[NF_SIMPNAC] =="1" .And. aNFItem[nItem][IT_TS][TS_COMPL] == "S" .And. aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST] .And. (aNFItem[nItem][IT_TS][TS_CIAP] == "S" .Or. aNFItem[nItem][IT_TS][TS_CONSUMO] == "S"))
		nAliqAgr := 0
		If aNFItem[nItem][IT_TS][TS_AGRPIS]=="P" .And. !aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"
			nAliqAgr += aNfItem[nItem][IT_ALIQPS2]
		Endif
		If aNFItem[nItem][IT_TS][TS_AGRCOF]=="C" .And. !aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"
			nAliqAgr += aNfItem[nItem][IT_ALIQCF2]
		Endif

		If (aNFItem[nItem][IT_TS][TS_AGREG]=="I" .Or. aNFItem[nItem][IT_TS][TS_AGREG]=="A") .And. !aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"

			//Tratamento para EC87 utilizar aliquota de destino
			If aNfCab[NF_PPDIFAL]
				nAliqAgr += aNfItem[nItem][IT_ALIQCMP]+aNfItem[nItem][IT_ALFCCMP]
			Else
				nAliqAgr += aNfItem[nItem][IT_ALIQICM]
			Endif

			If lAgreg
				If lRedBIcm
					If aSX6[MV_RNDICM]
						aNfItem[nItem][IT_BICMORI]	:= Round(aNfItem[nItem][IT_BICMORI]/( 1 - (nAliqAgr/100)),2)
					Else
						aNfItem[nItem][IT_BICMORI]	:= aNfItem[nItem][IT_BICMORI]/( 1 - (nAliqAgr/100))
					EndIf
				Else
					If aSX6[MV_RNDICM]
						aNfItem[nItem][IT_BICMORI]	:= Round(aNfItem[nItem][IT_BICMORI]/( 1 - (nAliqAgr/100*IIF(nReduzICMS==0,1,nReduzICMS/100))),2)
					Else
						aNfItem[nItem][IT_BICMORI]	:= aNfItem[nItem][IT_BICMORI]/( 1 - (nAliqAgr/100*IIF(nReduzICMS==0,1,nReduzICMS/100)))
						MaItArred(nItem,{"IT_BICMORI"})
					EndIf
				EndIf
			EndIf

			aNfItem[nItem][IT_BSFRETE]	:= Round(aNfItem[nItem][IT_BSFRETE]/( 1 - (nAliqAgr/100*IIF(nReduzICMS==0,1,nReduzICMS/100))),2)
			nDespOri := nDespOri/( 1 - (nAliqAgr/100))
			nBsFrete := nBsFrete/( 1 - (nAliqAgr/100))
		EndIf

		If ( aNFItem[nItem][IT_TS][TS_AGREG]=="D" .Or. aNFItem[nItem][IT_TS][TS_AGREG]=="R" )
			If aNfCab[NF_PPDIFAL] .And. aNFCab[NF_LINSCR] .And. aNfItem[nItem][IT_TS][TS_DEDDIF] $ " 1"
				nAliqDed := aNfItem[nItem][IT_ALIQCMP] + aNfItem[nItem][IT_ALFCCMP]
			Else
				nAliqDed :=	aNfItem[nItem][IT_ALIQICM]
			EndIf
			If (nReduzICMS > 0)
				If aSX6[MV_DBRDIF]
					aNfItem[nItem][IT_DEDICM] := Round(aNfItem[nItem][IT_BICMORI]*nAliqDed/100*(1-(nReduzICMS/100)),2)
				Else
					aNfItem[nItem][IT_DEDICM] := Round(aNfItem[nItem][IT_BICMORI]*nAliqDed/100*(nReduzICMS/100),2)
				EndIf
			Else
				aNfItem[nItem][IT_DEDICM] := aNfItem [nItem][IT_BICMORI]-Round(aNfItem[nItem][IT_BICMORI]*(1-(nAliqDed/100*IIF(nReduzICMS==0,1,nReduzICMS/100))),2)
			EndIf
		EndIf

		If aNFItem[nItem][IT_TS][TS_ICMSDIF] == "6"
			aNfItem[nItem][IT_DEDICM]	:= aNfItem[nItem][IT_ICMSDIF]
		EndIf //issue DSERFIS1-8601

		If (aNFItem[nItem][IT_TS][TS_AGREG]=="E" )
			aNfItem[nItem][IT_DEDICM]	:= aNfItem[nItem][IT_BICMORI]-Round(aNfItem[nItem][IT_BICMORI]*( 1 - (aNfItem[nItem][IT_ALIQICM]/100*IIF(nReduzICMS==0,1,nReduzICMS/100))),2)
		EndIf
		// Salva a base de ICMS original e aplica a reducao.
		If !(aNFItem[nItem][IT_TS][TS_OPERSUC]=="1" .And. aNfCab[NF_SIMPSC]<>"1" .And. aNFCab[NF_SIMPNAC]<>"1")
			If !lPISImp .And. !lCOFImp
				aNfItem[nItem][IT_BASEICM]	:= aNfItem[nItem][IT_BICMORI]
			EndIf
		ElseIf aNFItem[nItem][IT_TS][TS_OPERSUC]=="1" .And. aNfCab[NF_SIMPSC]<>"1" .And. aNFCab[NF_SIMPNAC]<>"1"
			aNfItem[nItem][IT_BASEICM]	:= aNfItem[nItem][IT_BICMORI]
			aNfItem[nItem][IT_BASEICM] += (aNfItem[nItem][IT_VALPS2]+aNfItem[nItem][IT_VALCF2])
		ElseIf aNFItem[nItem][IT_TS][TS_PODER3] =="D" .And. aNfItem[nItem][IT_BASEICM] <= 0
			aNfItem[nItem][IT_BASEICM]	:= aNfItem[nItem][IT_BICMORI]
		Endif

		If nReduzICMS > 0
			//Tratamento realizado para que não seja efetuado cálculo quando a Redução de ICMS for 100% e não gere problemas na NF-e, porém
			//no trecho abaixo será atribuido novamente o percentual informado na TES para que não haja impacto nos demais tratamentos quando houver redução de 100%
			nReduzAnt := nReduzICMS
			nReduzICMS := IIf(nReduzICMS == 100, 0, nReduzICMS)

			//Ao dobrar a base do ICMS(campo F4_BASEICM =200%)o valor do IPI NAO deve ser dobrado quando compor a base do ICMS para operacoes de venda de software
			//aNFItem[nItem][IT_TS][TS_VDASOFT] == "1" (SIM).
			If aNFItem[nItem][IT_TS][TS_VDASOFT] == "1" .And. nReduzICMS >= 100  .And. (aNFItem[nItem][IT_TS][TS_INCIDE] == "S" .Or. (aNFItem[nItem][IT_TS][TS_INCIDE] == "F" .And. aNFCab[NF_TPCLIFOR] =="F" .And. aNFCab[NF_CLIFOR] =="C")) .And. aNFItem[nItem][IT_TS][TS_IPI] <> "R"
				aNfItem[nItem][IT_BASEICM]	:= (aNfItem[nItem][IT_BASEICM] * nReduzICMS /100 ) - aNfItem[nItem][IT_VALIPI]
			Else
				If aNFItem[nItem][IT_TS][TS_BSRDICM] == "2"
					//a base de calculo da reducao sera composta apenas pelo valor da mercadoria sem o valor das
					//despesas acessorias.
					//apos aplicar o percentual de reducao, o valor das despesas acessorias (frete, seguro, despesas) e somado
					nAuxBicms := aNfItem[nItem][IT_VALMERC]
					nAuxBicms := ( nAuxBicms * nReduzICMS / 100 ) + (aNfItem[nItem][IT_FRETE] + aNfItem[nItem][IT_SEGURO] + aNfItem[nItem][IT_DESPESA] + Iif(lIncide,aNfItem[nItem][IT_VALIPI],0) )
					aNfItem[nItem][IT_BASEICM]	:= nAuxBicms
				Else
					aNfItem[nItem][IT_BASEICM]	:= aNfItem[nItem][IT_BASEICM] * nReduzICMS /100
				EndIf
			Endif
			MaItArred(nItem,{"IT_BASEICM"})
			If nReduzICMS <> 200
			   aNfItem[nItem][IT_BSFRETE]	:= aNfItem[nItem][IT_BSFRETE] * nReduzICMS /100
			EndIf
			MaItArred(nItem,{"IT_BSFRETE"})
			If (aNFItem[nItem][IT_TS][TS_INCIDE] == "S"  .Or. (aNFItem[nItem][IT_TS][TS_INCIDE] == "F" .And. aNFCab[NF_TPCLIFOR] =="F" .And. aNFCab[NF_CLIFOR] =="C")) .And.;
				aNFItem[nItem][IT_TS][TS_IPI] <> "R"
				aNfItem[nItem][IT_VIPIBICM]	:= NoRound(aNfItem[nItem][IT_VIPIBICM]* nReduzICMS /100,2)
			Else
				aNfItem[nItem][IT_VIPIBICM]	:= 0
			EndIf

			//Se o preco de venda for menor que o preço de pauta não aplica a redução
			//Atende ao Decreto N 51703 DE 31/07/2014 PARA RS
			If ((aPos[FP_F4_RDBSICM] .And. aNFItem[nItem][IT_TS][TS_RDBSICM] == "2") .And. ((aNfItem[nItem][IT_VALMERC] / aNfItem[nItem][IT_QUANT]) < aNfItem[nItem][IT_PAUTIC]))
				aNfItem[nItem][IT_BASEICM] := aNfItem[nItem][IT_BICMORI]
				aNfItem[nItem][IT_CLASFIS] := aNfItem[nItem][IT_PRD][SB_ORIGEM] + "00"
			EndIf

			//Atribuindo o valor de Redução anterior, caso seja 100% de redução
			If nReduzICMS == 0 .And. nReduzAnt == 100
				nReduzICMS := nReduzAnt
			EndIf

		EndIf
		If aNFItem[nItem][IT_TS][TS_DESPRDIC] == "2"
			aNfItem[nItem][IT_BASEICM] += nDespOri
			aNfItem[nItem][IT_BICMORI] += nDespOri
			aNfItem[nItem][IT_BSFRETE] += nBsFrete
		EndIf

		//retorna o valor para Unidade Fiscal Referencia do Ceará (UFIRCE)
		If 	(aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST] .And. aNFCab[NF_UFDEST] == "CE" .And. aNFCab[NF_LINSCR] .And. anfcab[NF_OPERNF] == "S" .And. aNFItem[nItem][IT_TS][TS_VENPRES] <> "1")
			aMvUfirce := &(aSX6[MV_UFIRCE])
			If (aMvUfirce <> Nil .And. Len(aMvUfirce) == 2 .And. !Empty(aMvUfirce[01]) .And. !Empty(aMvUfirce[02]))
				If aNfItem[nItem][IT_VALMERC] > (aMvUfirce[1] * aMvUfirce[2])
					aNfItem[nItem][IT_BASEICM] := aNfItem[nItem][IT_VALMERC] - (aMvUfirce[1] * aMvUfirce[2])
				EndIf
			EndIf
		EndIf

		//Tratamento para atender o DECRETO N 35.679, de 13 de Outubro de 2010 - Pernambuco
		//Obs. Se o valor real da operação for menor que o cálculo realizado conforme Decreto, será considerado o Valor Real da Operação.
		If aNFCab[NF_OPERNF]=="S" .And. aSX6[MV_ESTADO] == "PE" .And. aNfCab[NF_UFDEST] == "PE"  .And. aNfItem[nItem][IT_TS][TS_CUSENTR] =="1"
			//Posiciono na tabela SD1 para buscar o valor do Custo de Aquisição mais recente
			dbSelectArea("SD1")
			SD1->(DbSetOrder(5))
			SD1->(DbSeek(xFilial("SD1")+aNfItem[nItem][IT_PRODUTO]+'ZZ',.T.))
			SD1->(DbSkip(-1))
			// Tratamento para desconsiderar registro de complemento de frete.
			While  SD1->(!BOF()) .And. (SD1->D1_COD == aNfItem[nItem][IT_PRODUTO] .And. SD1->D1_QUANT  ==  0)
				SD1->(DbSkip(-1))
			EndDo
			IF SD1->D1_COD == aNfItem[nItem][IT_PRODUTO]
				nCustoEnt := SD1->D1_CUSTO
				//Posiciono na tabela SF1 para buscar a UF de origem para efetuar os cálculos
				dbSelectArea("SF1")
				SF1->(dbSetOrder(1))
				If SF1->(dbSeek(xFilial("SF1")+ SD1->D1_DOC + SD1->D1_SERIE + SD1->D1_FORNECE + SD1->D1_LOJA ))
					cOrigUf := SF1->F1_EST
				EndIf
				//Percentual MV_AGRPERC
				aAliqAgr	:= &(aSX6[MV_AGRPERC])
				If aAliqAgr <> Nil
					If Len(aAliqAgr) == 2 .Or. Len(aAliqAgr) == 3
						nPerNort:= IIf(!Empty(aAliqAgr[1]), aAliqAgr[1], 0)
						nPerSul := IIf(!Empty(aAliqAgr[2]), aAliqAgr[2], 0)
					Endif
					If Len(aAliqAgr) == 3
						nPerImp := IIf(!Empty(aAliqAgr[3]), aAliqAgr[3], 0)
					Endif
				EndIf
				//Percentual de acordo com a Ultima Aquisição
				If cOrigUf=="EX"
					nPerc := nPerImp
				ElseIf cOrigUf $ aSX6[MV_NORTE]
					nPerc := nPerNort
				Else
					nPerc := nPerSul
				EndIf
				//Cálculo
				nBaseCalc += nCustoEnt + ((nCustoEnt * nPerc ) / 100)
				//Verifico se o valor calculado pelo D1_CUSTO é menor do que a Base Calculada anteriormente
				If nBaseCalc < aNfItem[nItem][IT_BASEICM]
					nReduzICMS								:= (nBaseCalc / aNfItem[nItem][IT_BASEICM]) * 100
					aNfItem[nItem,IT_PREDIC]				:= nReduzICMS
					aTes[TS_BASEICM]						:= nReduzICMS
					aNFItem[nItem][IT_TS][TS_BASEICM]	:= nReduzICMS
					aNfItem[nItem][IT_BASEICM]			:= nBaseCalc
				Endif
			EndIF
		EndIf

	Else
		aNfItem[nItem][IT_BASEICM]	:= 0
		aNfItem[nItem][IT_BSFRETE]	:= 0
	EndIf
	If lReproc
		aNfItem[nItem][IT_BASEICM]	:= nSalvaBase
	EndIf
Else
	If !((aNFItem[nItem][IT_TS][TS_ICM] <> "N" .Or. lICDif) .And. !aNFitem[nItem][IT_TIPONF ]$"IP") .Or. (aNFitem[nItem][IT_TIPONF ]=="P".And.lIncide)
		aNfItem[nItem][IT_BASEICM]	:= 0
		aNfItem[nItem][IT_BSFRETE]	:= 0
	EndIf
EndIf

//verificacao da reducao da base de calculo do icms conforme decreto RICMS-MG numero 43.080/2002
If aNfItem[nItem][IT_BASEICM] > 0 .And. aNFCab[NF_UFORIGEM] == "MG" .And. aNfItem[nItem][IT_CF] <> '5927'
	nRed43080 := aNfItem[nItem][IT_PRD][SB_PR43080]
	If !Empty(nRed43080)
		If aNFCab[NF_TIPONF] $ "DB" .Or. aNFItem[nItem][IT_TS][TS_PODER3] =="D"
			If aNfItem[nItem][IT_BASEICM] < aNfItem[nItem][IT_VALMERC]
				//aNfItem[nItem][IT_BSSEMDS] := aNfItem[nItem][IT_BASEICM] + ((aNfItem[nItem][IT_VALMERC]*nRed43080)/100) //para guardar a base sem desconto
				// Nas devolucoes, utilizar IT_BICMORI como base sem reducao para que sejam considerados os descontos e acrescimos.
				aNfItem[nItem][IT_BSSEMDS] := aNfItem[nItem][IT_BICMORI]
				aNfItem[nItem][IT_BASEICM] := aNfItem[nItem][IT_BSSEMDS] - ((aNfItem[nItem][IT_BSSEMDS]*nRed43080)/100)
			Else
				aNfItem[nItem][IT_BSSEMDS] := aNfItem[nItem][IT_BASEICM] //para guardar a base sem desconto
				aNfItem[nItem][IT_BASEICM] := aNfItem[nItem][IT_BSSEMDS] - ((aNfItem[nItem][IT_BSSEMDS]*nRed43080)/100)
			Endif
		Else
			aNfItem[nItem][IT_BSSEMDS] := aNfItem[nItem][IT_BASEICM] //para guardar a base sem desconto
			aNfItem[nItem][IT_BASEICM] := aNfItem[nItem][IT_BASEICM] - ((aNfItem[nItem][IT_BASEICM]*nRed43080)/100)
		EndIf
		aNfItem[nItem][IT_PR43080] := nRed43080
		MaItArred(nItem,{"IT_BASEICM"})
	EndIf
EndIf

//verificacao do incentivo prod.leite artigo 207-B RICMS-MG
If aNfItem[nItem][IT_VALMERC]>0 .And. aNFCab[NF_UFORIGEM]=="MG" .And. ((aPos[FP_A2_INCLTMG] .And. SA2->A2_INCLTMG=="1") .Or. (aPos[FP_A1_INCLTMG] .And. SA1->A1_INCLTMG=="1"));
.And. !(AllTrim(aNfCab[NF_ESPECIE]) $ "CTR/CTE/CTA/CA/CTF" .Or. "NFST"$AllTrim(aNfCab[NF_ESPECIE]))
	//Entrada-Devolução
	If aPos[FP_A2_INCLTMG] .And. (aNFCab[NF_OPERNF]=="E" .Or. (aNFCab[NF_UFDEST]=="MG" .And. aNFCab[NF_OPERNF]=="S" .And. aNFCab[NF_TIPONF]$"D"))
		nIncLeitMG := aNfItem[nItem][IT_PRD][SB_PRINCMG]
		If !Empty(nIncLeitMG) .And. SA2->A2_INCLTMG=="1"
			aNfItem[nItem][IT_PRINCMG]	:= nIncLeitMG
		Endif
	Endif
	//Saida
	If aPos[FP_A1_INCLTMG] .And. aNFCab[NF_UFDEST]=="MG" .And. (aNFCab[NF_OPERNF]=="S" .Or. (aNFCab[NF_OPERNF]=="E" .And. aNFCab[NF_TIPONF]$"D"))
		nIncLeitMG := aNfItem[nItem][IT_PRD][SB_PRINCMG]
		If !Empty(nIncLeitMG) .And. SA1->A1_INCLTMG=="1"
			aNfItem[nItem][IT_PRINCMG]	:= nIncLeitMG
		Endif
	Endif
	//tratamento para que seja possível ajustar até 0.02 centavos o valor do campo D1_VLINCMG
	If(aNfItem[nItem][IT_VLINCMG] > 0 .And. ;
	   aNfItem[nItem][IT_VALMERC]*(nIncLeitMG/100) <> aNfItem[nItem][IT_VLINCMG] .And. ;
	   IIf(aNfItem[nItem][IT_VALMERC]*(nIncLeitMG/100) - aNfItem[nItem][IT_VLINCMG]     <  0,;
	      (aNfItem[nItem][IT_VALMERC]*(nIncLeitMG/100) - aNfItem[nItem][IT_VLINCMG])*-1 <= 0.02,;
	       aNfItem[nItem][IT_VALMERC]*(nIncLeitMG/100) - aNfItem[nItem][IT_VLINCMG]     <= 0.02))
	  aNfItem[nItem][IT_VLINCMG]	:= aNfItem[nItem][IT_VLINCMG]
	Else
	  aNfItem[nItem][IT_VLINCMG]	:= aNfItem[nItem][IT_VALMERC]*(nIncLeitMG/100)
	EndIf
EndIf

//Especifico para VEICULOS
If cPaisLoc == "BRA" .And. aSX6[MV_VEICICM] .And. Substr(aNfItem[nItem][IT_CF],1,1)=="5" .And. aNfCab[NF_OPERNF] == "S" .And. aPos[FP_B1_CHASSI] .And. !Empty( aNfItem[nItem][IT_PRD][SB_CHASSI] ) // Alteracao de base para veiculos usados
	If aNfItem[nItem][IT_BASVEIC] == 0
		aAreaSC6 := SC6->(GetArea())
		SC6->(dbSetOrder(1))
		If SC6->( MsSeek(xFilial("SC6")+aNfCab[NF_PEDIDO]+aNfItem[nItem][IT_ITEM]+aNfItem[nItem][IT_PRODUTO]) )
			aNfItem[nItem][IT_BASVEIC] := SC6->C6_BASVEIC
		EndIf
		RestArea(aAreaSC6)
	EndIf
	If nReduzICMS > 0
		aNfItem[nItem][IT_BASEICM] := Round((aNfItem[nItem][IT_BICMORI] - aNfItem[nItem][IT_BASVEIC])*(nReduzICMS/100),2)
	Else
		aNfItem[nItem][IT_BASEICM] -= aNfItem[nItem][IT_BASVEIC]
	EndIf
	If aNfItem[nItem][IT_BASEICM] < 0
		aNfItem[nItem][IT_BASEICM] := 0
	EndIF
EndIf

//ATENCAO!!! Ponto de entrada para uso exclusivo da TOTVS, nao sugerir o uso do mesmo a clientes - GDP FISCAL
If aPE[PE_MAICMVEIC]
	aMaICMVeic := ExecBlock("MaICMVeic",.f.,.f.,{nItem,aNfItem[nItem][IT_BASEICM],aNfItem[nItem][IT_ALIQICM],aNfItem[nItem][IT_VALICM]})
	aNfItem[nItem][IT_BASEICM] := aMaICMVeic[1]
	aNfItem[nItem][IT_ALIQICM] := aMaICMVeic[2]
	aNfItem[nItem][IT_VALICM]  := aMaICMVeic[3]
EndIf

If aPE[PE_MACALCICMS]
	aMaCalcICMS := ExecBlock("MACALCICMS",.f.,.f.,{aNfCab[NF_OPERNF],nItem,aNfItem[nItem][IT_BASEICM],aNfItem[nItem][IT_ALIQICM],aNfItem[nItem][IT_VALICM]})
	IF ValType(aMaCalcICMS) == "A"
		IF Len(aMaCalcICMS) == 3
			aNfItem[nItem][IT_BASEICM] := aMaCalcICMS[1]
			aNfItem[nItem][IT_ALIQICM] := aMaCalcICMS[2]
			aNfItem[nItem][IT_VALICM]  := aMaCalcICMS[3]
		Endif
	Endif
Endif

IF lIndVFut
    aNfItem[nItem][IT_BASEICM]  :=  aNfItem[nItem][IT_BASEICM] * (nIndice)
EndIf

IF aNfCab[NF_SUFRAMA] .And. aSX6[MV_RPCBIZF] .And. (aNfItem[nItem][IT_DESCZFPIS] + aNfItem[nItem][IT_DESCZFCOF]) > 0 .And. aNfCab[NF_UFDEST]$aSX6[MV_RPCBIUF]
	IF ((aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS] + aNfItem[nItem][IT_DESCZFCOF]))<=0) .And. nReduzICMS<=0 .And. ;//Se tiver desconto apenas de pis/cof
		aNfItem[nItem][IT_PRD][SB_IMPZFRC] $ " N"
		aNfItem[nItem][IT_BASEICM] +=((aNfItem[nItem][IT_DESCZFPIS] + aNfItem[nItem][IT_DESCZFCOF]))
	Else
		aNfItem[nItem][IT_BASEICM] += aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS] + aNfItem[nItem][IT_DESCZFCOF])
	EndIf
EndIf

//Tratamento para atender o Decreto n 13.780/2012, a Lei n 7.014/1996 e o Parecer n 26.733/2013
//em resposta do fisco referente Redução na Alíq do ICMS nas vendas e remessas para empresas
// do Simples Nacional nas operações internas - BA
If	aNfItem[nItem][IT_VRDICMS] > 0
	aNFitem[nItem][IT_DESCONTO]-= aNfItem[nItem][IT_VRDICMS]
	aNfItem[nItem][IT_VRDICMS] := 0
EndIf

If	aSX6[MV_ESTADO] == "BA" .And. aNfCab[NF_UFDEST] == "BA"  .And. aNFCab[NF_SIMPNAC] =="1" .And. aNFItem[nItem][IT_TS][TS_FTRICMS] > 0
	If lRet .And. cPaisLoc == "BRA"//Nota de Devolução usando o mesmo valor da nota para a referencia aNfItem[nItem][IT_BASEICM]
		If (aNFCab[NF_CLIFOR] == "C")
			aNfItem[nItem][IT_FTRICMS] 	:=	aNFItem[nItem][IT_TS][TS_FTRICMS]
			aNfItem[nItem][IT_VRDICMS] 	:=	SD2->D2_VRDICMS
			aNFitem[nItem][IT_VALMERC]	-=	aNfItem[nItem][IT_VRDICMS]
			aNfItem[nItem][IT_PRCUNI]	:=	aNFitem[nItem][IT_VALMERC] / aNfItem[nItem][IT_QUANT]
		Else
			aNfItem[nItem][IT_FTRICMS] 	:=	aNFItem[nItem][IT_TS][TS_FTRICMS]
			aNfItem[nItem][IT_VRDICMS] 	:=	SD1->D1_VRDICMS
			aNFitem[nItem][IT_VALMERC]	-=	aNfItem[nItem][IT_VRDICMS]
			aNfItem[nItem][IT_PRCUNI]	:=	aNFitem[nItem][IT_VALMERC] / aNfItem[nItem][IT_QUANT]
		EndIf
	Else
		aNfItem[nItem][IT_FTRICMS] 	:= aNFItem[nItem][IT_TS][TS_FTRICMS]
		aNfItem[nItem][IT_VRDICMS] 	:= Round((aNfItem[nItem][IT_BASEICM] * (aNfItem[nItem][IT_FTRICMS] / 100)),2)
		aNfItem[nItem][IT_BASEICM] 	:= aNfItem[nItem][IT_BASEICM] - aNfItem[nItem][IT_VRDICMS]
		aNFitem[nItem][IT_DESCONTO]	+= aNfItem[nItem][IT_VRDICMS]
	EndIf
EndIf

If	aNFItem[nItem][IT_TS][TS_AGRPEDG] == "1" .And. aNfItem[nItem][IT_VALPEDG] > 0
	aNfItem[nItem][IT_BASEICM] += aNfItem[nItem][IT_VALPEDG]
EndIf

//Para o calculo do FECP de cada ESTADO e necessario as BASES DE CALCULO do ICMS e do ICMS SOLIDARIO
//afim de majorar as aliquotas dos mesmos, por este motivo a chamada GERAL da funcao de calulo do FECP
//deve estar no fim das funcoes de BASE do ICMS e ICMS SOLIDARIO e em nenhum outro ponto da MATXFIS.
//MaFisFECP( nItem , cCampo, lReproc )
Return
/*
MaAliqICM-Eduardo/Edson   -08.12.1999
Calculo da Aliquota para operacoes de ICMS
*/
Static Function MaAliqIcms(nItem,lSolidario,lICDif)
Local nAliquota		:=	IIf( aNfItem[nItem][IT_PRD][SB_PICM] == 0 ,  aSX6[MV_ICMPAD]  ,  aNfItem[nItem][IT_PRD][SB_PICM] )
Local nAlqFecop		:=	IIf( aNfItem[nItem][IT_PRD][SB_FECOP] == "1" , aNfItem[nItem][IT_PRD][SB_ALFECOP] , 0 )
Local cTipoNF		:=	aNfCab[NF_TIPONF]
Local cSimpNac		:=	aSX6[MV_CODREG]
Local cAliqDifST	:=	"2"
Local lFreteAut		:=	aNFItem[nItem][IT_TS][TS_LFICM] <> "N" .And. aNFItem[nItem][IT_TS][TS_FRETAUT] <> "2" .And. aNFItem[nItem][IT_TS][TS_FRETAUT] <> "3" .And. aNfItem[nItem][IT_AUTONOMO]>0
Local cExceRes13	:=	"6107|6108|6929"
Local aMVPPDIFAL 	:= &(aSX6[MV_PPDIFAL])
Local lCalDifal		:= IIf(aNFCab[NF_CLIFOR] == "C", aNFCab[NF_TPCLIFOR] == "F", aNFCab[NF_LINSCR]) .And. aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST] .And. (Iif(valType(aMVPPDIFAL)== "A", Len(aMVPPDIFAL)>0 .And. Year(aNfCab[NF_DTEMISS]) >= aMVPPDIFAL[1][1],.F.))
Local lCalcAliq     := .T.
Local nAliqSN       := 0
Default lSolidario	:=	.F.
Default lICDif		:=	.F.

If ((aNFItem[nItem][IT_TS][TS_ICM] <> "N" .Or. lICDif .Or. (lCalDifal .And. aNfItem[nItem][IT_TS][TS_DIFAL]=="1")) .Or. lSolidario .Or. (aNFCab[NF_SIMPNAC] =="1" .And. aNFItem[nItem][IT_TS][TS_COMPL] == "S" .And. aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST] .And. (aNFItem[nItem][IT_TS][TS_CIAP] == "S" .Or. aNFItem[nItem][IT_TS][TS_CONSUMO] == "S")) .Or. lFreteAut) .And. aNfItem[nItem][IT_TS][TS_ISS]<>"S"

	// Verifica se a nota fiscal eh de Conhecimento de Frete
	If !lSolidario .And. (AllTrim(aNFCab[NF_ESPECIE]) $ "CTR/CTE" .Or. "NFST"$AllTrim(aNFCab[NF_ESPECIE]))
		nAliquota := Val(Substr(aSX6[MV_FRETEST],(AT(aNfCab[NF_UFORIGEM],aSX6[MV_FRETEST])+2),5))
		nAliquota := IIf(nAliquota>0,NoRound(nAliquota,2),12)
	EndIf

	Do Case
		// Verifica se a nota fiscal eh de Conhecimento de Frete
		Case aNfCab[NF_TPCOMP] == "F"
			// Verifica o Parametro MV_FRETEST que contem as Aliq. de ICMS/Frete
			If aSX6[MV_M116FOR] == .F. .And. aNfCab[NF_UFDEST]<>aNfCab[NF_UFORIGEM]
				If aNfCab[NF_UFDEST]$aSX6[MV_NORTE] .And.!(aNfCab[NF_UFORIGEM]$aSX6[MV_NORTE] )
					nAliquota := 7
				Else
					nALiquota := 12 // Aliquota de Frete Fixa em 12%
				EndIf
			ElseIf aSX6[MV_M116FOR] == .T. .And. !Empty(aNfItem[nItem][IT_EXCECAO])
				If SubStr(aNFItem[nItem][IT_TS][TS_CF],1,1) == "1"
					nAliquota := aNfItem[nItem][IT_EXCECAO][01]
				Else
					nAliquota := aNfItem[nItem][IT_EXCECAO][02]
				EndIf
			Else
				nAliquota := Val(Substr(aSX6[MV_FRETEST],(AT(aNfCab[NF_UFORIGEM],aSX6[MV_FRETEST])+2),5))
				nAliquota := IIf(nAliquota>0,NoRound(nAliquota,2),12)
			EndIf
		Case AllTrim(aNFCab[NF_ESPECIE])$"CA"
			// Verifica o Parametro MV_FRETEST que contem as Aliq. de ICMS/Frete
			If aNFCab[NF_LINSCR]
				If aNfCab[NF_UFDEST]$aSX6[MV_NORTE] .And. !(aNfCab[NF_UFORIGEM]$aSX6[MV_NORTE] )
					nAliquota := 7
				Else
					nAliquota := 12 // Aliquota de Frete Fixa em 12%
				EndIf
			EndIf
			// Verifica se a nota fiscal eh de Servicos
		Case ( aNFItem[nItem][IT_TS][TS_ISS] == "S" )
			// Calcula a aliquota do ISS
			If !lSolidario
				nAliquota := If ( aNfItem[nItem][IT_PRD][SB_ALIQISS] == 0 , aSX6[MV_ALIQISS] , aNfItem[nItem][IT_PRD][SB_ALIQISS] )
				// Verifica as Excecoes fiscais
				If ( !Empty(aNFitem[nItem][IT_EXCECAO]) )
					If ( aNFCab[NF_UFORIGEM]==aNFCab[NF_UFDEST])
						If (aNfItem[nItem][IT_EXCECAO][1] > 0)
							nAliquota := aNfItem[nItem][IT_EXCECAO][1] //Aliquota Interna
						EndIf
					Else
						If aNfItem[nItem][IT_EXCECAO][2] > 0
							nAliquota := aNfItem[nItem][IT_EXCECAO][2] //Aliquota Externa
						EndIf
					EndIf
				EndIf
			Else
				nAliquota := 0
			EndIf
		Case ( aNFItem[nItem][IT_TS][TS_PODER3] =="D" ) .And. !Empty(aNFItem[nItem][IT_RECORI]) .And. !lCalDifal .And. aNFItem[nItem][IT_TS][TS_OPERGAR] <> '1' //Devolucao de Poder de Terceiros // Quando for difal ou operacao em garantia Calcula aliq interestadual
				If aNFCab[NF_OPERNF] == "E"
					dbSelectArea("SD2")
					MsGoto( aNFItem[nItem][IT_RECORI] )
					nAliquota  := SD2->D2_PICM
					cTipoNF    := IIf(SD2->D2_TIPO$"IP",SD2->D2_TIPO,cTipoNF)
				Else
					dbSelectArea("SD1")
					MsGoto( aNFItem[nItem][IT_RECORI] )
					//1-no caso da devolucao de sucata preciso pegar a aliquota original para fazer o calulo do icms
					//2-caso em que eh feito o retorno de demonstracao e excede os 60 dias para SP e eh feita NF Compl ICMS
					//3-Tratamento para atender arts. 402 do RICMS-SP/2000 e na Portaria CAT n 22/2007 - Chamado TRCYAF - Retorno Beneficiamento com Suspensão fora do prazo
					If	!(aNFItem[nItem][IT_TS][TS_OPERSUC] == "1" .And. aNfCab[NF_SIMPSC]<>"1" .And. aNFCab[NF_SIMPNAC]<>"1") .And.;
						!(cTipoNF == "B" .And. SD1->D1_TIPO == "N" .And. aSX6[MV_ESTADO] == "SP" .And. AllTrim(aNfItem[nItem][IT_CF])$"5913/6913" .And. (dDataBase-SD1->D1_EMISSAO) > 60 .And. aNFCab[NF_UFORIGEM]==aNFCab[NF_UFDEST]) .And.;
						!(cTipoNF == "N" .And. SD1->D1_TIPO == "B" .And. aSX6[MV_ESTADO] == "SP" .And. (dDataBase-SD1->D1_EMISSAO) > 180 .And. aNFCab[NF_UFORIGEM]==aNFCab[NF_UFDEST])
						nAliquota := SD1->D1_PICM
					EndIF
					cTipoNF    := IIf(SD1->D1_TIPO$"IP",SD1->D1_TIPO,cTipoNF)
				EndIf

				// Flag p/ determinar se a aliquota foi obtida do doc. de origem.
				lCalcAliq := .F.

			// Nas devolucoes sempre pega a aliquota da NF original.
		Case ( aNFCab[NF_TIPONF] == "D" .And. !Empty(aNFItem[nItem][IT_RECORI]) .And. !RetComp(aNFCab[NF_CLIFOR], aNFItem[nItem][IT_RECORI]))
			If aNFCab[NF_TIPONF] == "D"
				If ( aNFCab[NF_CLIFOR] == "C" )
					dbSelectArea("SD2")
					MsGoto( aNFItem[nItem][IT_RECORI] )
					If !Empty(SD2->D2_PICM)
						nAliquota  := SD2->D2_PICM
					EndIf
					cTipoNF    := IIf(SD2->D2_TIPO$"IP",SD2->D2_TIPO,cTipoNF)
					If SD2->D2_DESCZFR > 0 .And. aNfItem[nItem][IT_PRD][SB_IMPZFRC] $ " N"  //  So zera a aliquota se o item nao for importado, pois se for ele mantem a aliquota de icms da saida
						nAliquota := 0
					EndIf
				Else
					dbSelectArea("SD1")
					MsGoto( aNFItem[nItem][IT_RECORI] )
					nAliquota  := SD1->D1_PICM
					If lSolidario .And. nAliquota == 0 .And. cPaisLoc == "BRA"
						nAliquota := SD1->D1_ALIQSOL
					EndIf
					cTipoNF    := IIf(SD1->D1_TIPO$"IP",SD1->D1_TIPO,cTipoNF)
				EndIf
			Else
				If ( aNFCab[NF_CLIFOR] == "C" )
					dbSelectArea("SD1")
					MsGoto( aNFItem[nItem][IT_RECORI] )
					nAliquota  := SD1->D1_PICM
					cTipoNF    := IIf(SD1->D1_TIPO$"IP",SD1->D1_TIPO,cTipoNF)
				Else
					dbSelectArea("SD2")
					MsGoto( aNFItem[nItem][IT_RECORI] )
					nAliquota  := SD2->D2_PICM
					cTipoNF    := IIf(SD2->D2_TIPO$"IP",SD2->D2_TIPO,cTipoNF)
				EndIf
			EndIf

			// Flag p/ determinar se a aliquota foi obtida do doc. de origem.
			lCalcAliq := .F.

			// Tratamento para Exportacao
		Case ( aNFCab[NF_TPCLIFOR] == "X" )
			If nModulo == 43
				If ( aNFCab[NF_CLIFOR]== "C" ) .And. ( aNFCab[NF_UFDEST]<> "X" )
					// Calculo da Aliquota de ICMS para Exportacao
					nAliquota := 12
				EndIf
			ElseIf ( aNFCab[NF_CLIFOR]=="C" )
				// Calculo da Aliquota de ICMS para Exportacao
				nAliquota := 13
			EndIf
			// Verifica as Excecoes fiscais
			If ( !Empty(aNFitem[nItem][IT_EXCECAO]) .And. aNFItem[nItem][IT_EXCECAO][1] > 0 .And. aNfItem[nItem][IT_EXCECAO][7] <> "S" )
				nAliquota := aNFItem[nItem][IT_EXCECAO][1] //Aliquota Interna
			EndIf

			// Tratamento para Nao Inscritos e Consumidores Finais
		Case ( aNFCab[NF_LINSCR] .And. Iif(ValType(aMVPPDIFAL)== "A",!lCalDifal,.F.))
			If ( aNFCab[NF_CLIFOR]=="F" )
				nAliquota := IIf(!Empty( aNfItem[nItem][IT_PRD][SB_PICM] ) , aNfItem[nItem][IT_PRD][SB_PICM] , MaAliqOrig(nItem) )
			EndIf

			If  Year( aNfCab[NF_DTEMISS] ) >= 2013							.And.	;
				( aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST] )				.And.	;
				SubStr( aNfItem[nItem][IT_CLASFIS] , 1 , 1 ) $ "1|2|3|8"	.And.	;
				(Alltrim( aNfItem[nItem][IT_CF]) $cExceRes13 .Or. lCalDifal)
				nAliquota :=  4
			EndIf

			If aNfCab[NF_USAALIQSN]
				If (nAliqSN := MaAliqSimp(nItem, "ICMS")) > 0 
					nAliquota := nAliqSN
				EndIf
			EndIf

			// Tratamento para calculo do FECP
			// Verifica as Excecoes fiscais
			If (!Empty(aNFItem[nItem][IT_EXCECAO]) .And. aNfItem[nItem][IT_EXCECAO][7] <> "S")
				If ( aNFCab[NF_UFORIGEM] == aNFCab[NF_UFDEST] )
					If ( aNFItem[nItem][IT_EXCECAO][1] ) <> 0
						nAliquota := aNFItem[nItem][IT_EXCECAO][1]  //Aliq. de ICMS Interna
					EndIf
				Else
					If (aNFItem[nItem][IT_EXCECAO][2] > 0)
						nAliquota :=  aNFItem[nItem][IT_EXCECAO][2]   //Aliq. de ICMS Externa
					EndIf
				EndIf
			EndIf

			// Tratamento para Operacoes internas com ICMS
		Case ( aNFCab[NF_UFORIGEM] == aNFCab[NF_UFDEST] )

			//Para situações onde a UF de origem é diferente do MV_ESTADO, vindo do TMS, não pode adotar alíquota do MV_ICMPAD, precisa adotar alíquota interna do destino
			If nModulo == 43 .AND. IntTms() .AND. lSolidario .AND. aNFCab[NF_UFORIGEM] <> aSX6[MV_ESTADO] .AND. (AllTrim(aNFCab[NF_ESPECIE]) $ "CTR/CTE" .Or. "NFST"$AllTrim(aNFCab[NF_ESPECIE]))
				//Neste caso precisa adotar o padrão da alíquota do destino, considerando o parâmetro
				nAliquota 	:= Val(Substr(aSX6[MV_FRETEST],(AT(aNfCab[NF_UFORIGEM],aSX6[MV_FRETEST])+2),5))
			EndIF

			If aNfCab[NF_USAALIQSN]
				If (nAliqSN := MaAliqSimp(nItem, "ICMS")) > 0
					nAliquota := nAliqSN
				EndIf
			EndIf

			// Tratamento para calculo do FECP
			// Verifica as Excecoes fiscais
			If (!Empty(aNFItem[nItem][IT_EXCECAO]) .And. aNfItem[nItem][IT_EXCECAO][7] <> "S")
				If ( aNFItem[nItem][IT_EXCECAO][1] ) <> 0
					nAliquota :=  aNFItem[nItem][IT_EXCECAO][1]   //Aliq. de ICMS Interna
				EndIf
			EndIf

			// Tratamento para Operacaoes InterEstaduais com ICMS
		Case ( aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST] )
			If ( aNFCab[NF_TIPONF] <> "D" )
				If ( aNFCab[NF_UFORIGEM] $ aSX6[MV_NORTE] )
					nAliquota := 12
				Else
					nAliquota := IIf( aNFCab[NF_UFDEST] $ aSX6[MV_NORTE] , 7 , 12 )
				EndIf

				// Tratamento para ser levado em consideracao a aliquota de destino
				//	para os cfops 5118/5119/6118/6119
				If aSX6[MV_ESTADO]== 'SP' .And. aNFCab[NF_UFORIGEM]==aSX6[MV_ESTADO] .And. (aNFItem[nItem][IT_CF] $ aSX6[MV_TESVEND]) .And. aNFCab[NF_UFDEST] == aNFCab[NF_UFORIGEM]
					nAliquota := IIf(!Empty( aNfItem[nItem][IT_PRD][SB_PICM] ) , aNfItem[nItem][IT_PRD][SB_PICM] , MaAliqOrig(nItem))
				EndIf
			Else
				// Para devolução deve obter a UF da nota de origem.
				cCmpDevUF := Iif(aNfCab[NF_OPERNF] == "S",aNFCab[NF_UFDEST],aNFCab[NF_UFORIGEM])
				// Calculo da Aliquota de ICMS
				If ( aNFCab[NF_UFORIGEM] $ aSX6[MV_NORTE] )
					nAliquota := IIf( cCmpDevUF $ aSX6[MV_NORTE] , 12 , 7 ) //MV_ICMTRF
				Else
					nAliquota := 12 //MV_ICMTRF
				Endif
			EndIf

		// 	tratamento Resolucao do Senado Federal 13/2012
		//	Aliquota Interestadual de 4% caio
		// Parecer da Consultoria tributaria: http://tdn.totvs.com/pages/viewpage.action?pageId=82477729
		//   Regras para aplicacao da Aliquota de 4%
		// - Operacao Interestadual
		// - Contribuinte do ICMS
		// - Operacao apos 01/01/2013
		// - Origem do item = 1,2,3,8
		// - Excecao 1: CFOP's de Venda destinada a Nao Contribuinte, ainda que possua IE (6107;6108) 	(cExceRes13)
		// - Excecao 2: CFOP de operacao registrada em Cupom Fiscal (6929)								(cExceRes13)
			If  Year( aNfCab[NF_DTEMISS] ) >= 2013							.And.	;
				SubStr( aNfItem[nItem][IT_CLASFIS] , 1 , 1 ) $ "1|2|3|8"	.And.	;
				(!Alltrim( aNfItem[nItem][IT_CF]) $cExceRes13 .Or. lCalDifal)
				nAliquota :=  4
			EndIf

			//Alimento com alíquota interestadual para que possa efetuar o cálculo da Antecipação tributária para Simples Nacional
			If (aNFCab[NF_SIMPNAC] =="1" .AND. aNFCab[NF_CLIFOR] =="F") .Or.;
			(lCalDifal .And. aNfItem[nItem][IT_TS][TS_DIFAL]=="1" .And. (Iif(IntTms() .And. nModulo == 43,iif(aNfCab[NF_TPFRETE] == "F",.T.,.F.),.T.)))
				aNFitem[nItem][IT_ALIQDIF] := nAliquota
			EndIF

			If aNfCab[NF_USAALIQSN]
				If (nAliqSN := MaAliqSimp(nItem, "ICMS")) > 0
					nAliquota := nAliqSN
				EndIf
			EndIf

			If (!Empty(aNFItem[nItem][IT_EXCECAO]))
				If (aNFItem[nItem][IT_EXCECAO][2]) <> 0
					nAliquota :=  aNFItem[nItem][IT_EXCECAO][2]   //Aliq. de ICMS Externa
				EndIf
			EndIf
	EndCase

	// FECOP - CEARA - Caso no SB1 seja configurado para calcular FECOP a aliquota do Solidario sera Majorada em 2% - opcoes informadas no SB1 de 19 % ou  27%
	If (nAlqFecop == 19 .Or. nAlqFecop == 27) .And. aSX6[MV_ESTADO] == "CE" .And. aNFCab[NF_UFDEST] == "CE" .And. aNfCab[NF_OPERNF] == "S"
		nAliquota := nAlqFecop
	EndIf
Else
	nAliquota := 0
EndIf

//----------------------------------------------------
//Tomada de decisao para majoracao da aliquota - FCP
//----------------------------------------------------

MaFisFECP(nItem,,,"ALQ")

// Soh majoro a aliquota se:
// 1 - A aliquota nao foi obtida do docto de origem (lCalcAliq = .T.). Neste caso ja veio majorada.
// 2 - Nao for calculo de ST (lSolidario = .F.). A aliquota do ST sera majorada na propria MaAliqSol.
If lCalcAliq .And. !lSolidario .And. aNfItem[nItem][IT_ALIQFECP] > 0
	nAliquota	+=	aNfItem[nItem][IT_ALIQFECP]
EndIf

If ((aNFItem[nItem][IT_TS][TS_ICM] <> "N" .Or. lICDif .Or. lCalDifal ) .Or. (aNFCab[NF_SIMPNAC] =="1" .And. aNFItem[nItem][IT_TS][TS_COMPL] == "S" .And. (aNFItem[nItem][IT_TS][TS_CIAP] == "S" .Or. aNFItem[nItem][IT_TS][TS_CONSUMO] == "S"))) .Or. lFreteAut ;
	.Or. (IntTms() .And. nModulo == 43 .And. aNFItem[nItem][IT_TS][TS_ICM]=="N" .And. aNFItem[nItem][IT_TS][TS_LFICM]=="T")
	If !lSolidario
		aNFitem[nItem][IT_ALIQICM] := nAliquota
	EndIf
	aNFitem[nItem][IT_TIPONF ] := cTipoNF
Else
	aNFitem[nItem][IT_ALIQICM] := 0
	aNFitem[nItem][IT_TIPONF ] := cTipoNF
EndIf

//Simples Nacional - Aliquota ICMS solidario.
If cSimpNac $ "1/2" .And. lSolidario .And. aNFCab[NF_OPERNF] == "S"
	//Busca RecNo do Produto para verificar campo que trata a aliquota interna
	//a ser tributada para o Simples Nacional através de Exceção Fiscal.
	//O campo deve ser informado no parâmetro MV_ALQDFB1.
	If aNFCab[NF_UFORIGEM] == aNFCab[NF_UFDEST]
		If aPos[FP_MV_ALQDFB1]
			cAliqDifST := aNfItem[nItem][IT_PRD][SB_ALQDFB1]
		Endif
		If cAliqDifST $ "2 "
			aNFitem[nItem][IT_ALIQSOL] := Val(Subs(aSX6[MV_ESTICM] ,AT(aNFCab[NF_UFDEST],aSX6[MV_ESTICM])+2,5))
		EndIf
	Endif
EndIf

//Entrada de Conhecimento de Frete - Aliquota ICMS 4%.
//Valida se informado cliente de destino contribuinte, caso seja não contribuinte deve ser utilizada aliquota interestadual
If (aNFCab[NF_OPERNF] == "E") .And. (Empty(aNfCab[NF_CLIDEST]) .Or. !aNFCab[NF_CLIEDEST]) .And.;
   ((AllTrim(aNFCab[NF_ESPECIE])=="CA"  .And. (aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST] .Or. aNFCab[NF_UFORIGEM]=="BA")) .Or. ;
	((AllTrim(aNFCab[NF_ESPECIE])=="CTE" .And. (aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST] .Or. aNFCab[NF_UFORIGEM]=="BA") .And. aNFCab[NF_MODAL] == "02")))

	aNFitem[nItem][IT_ALIQICM] := 4

	// Verifica as Excecoes fiscais
	If ( !Empty(aNFItem[nItem][IT_EXCECAO]) .And. aNfItem[nItem][IT_EXCECAO][7] <> "S" )
		If ( aNFCab[NF_UFORIGEM] == aNFCab[NF_UFDEST] )
			If ( aNFItem[nItem][IT_EXCECAO][1] ) <> 0
				nAliquota := aNFItem[nItem][IT_EXCECAO][1]  //Aliq. de ICMS Interna
			EndIf
		Else
			If (aNFItem[nItem][IT_EXCECAO][2] > 0)
				nAliquota :=  aNFItem[nItem][IT_EXCECAO][2]   //Aliq. de ICMS Externa
			EndIf
		EndIf
	Else
		nAliquota := 4
	Endif
EndIf

Return(nAliquota)

/*MaAliqOrig - Edson Maricate -13.12.1999
Calculo da Aliquota para operacoes de ICMS
*/
Static Function MaAliqOrig(nItem)

Local nPerIcm
Local cOrig := aNFCab[NF_UFORIGEM]
Local cMVEstIcm := aSX6[MV_ESTICM]

nPerIcm := Val(Subs(cMVEstIcm,AT(cOrig,cMVEstIcm)+2,5))

Return(nPerIcm)

/*
MaAliqDest -Eduardo/Edson   -13.12.1999
Calculo da Aliquota para operacoes de ICMS
*/
Static Function MaAliqDest(nItem)

Local nPerIcm
Local cDestino := aNFCab[NF_UFDEST]

nPerIcm := Val(Subs(aSX6[MV_ESTICM],AT(cDestino,aSX6[MV_ESTICM])+2,5))

//Caso exsita aliquota informada na CFC utiliza esta aliquota.
IF aNfItem[nItem][IT_UFXPROD][UFP_PICM] > 0
	nPerIcm	:= aNfItem[nItem][IT_UFXPROD][UFP_PICM]
EndIf

If !Empty(aSX6[MV_FRETEST]) .And. (aNfCab[NF_TPCOMP] == "F"  .Or. (("/"+AllTrim(aNFCab[NF_ESPECIE])+"/") $"/CTR/CTE/NFST/"))
	nPerICM := Val(Substr(aSX6[MV_FRETEST],(AT(aNfCab[NF_UFDEST],aSX6[MV_FRETEST])+2),5))
	nPerICM := IIf(nPerICM>0,NoRound(nPerICM,2),Val(Subs(aSX6[MV_ESTICM],AT(cDestino,aSX6[MV_ESTICM])+2,5)))
EndIf
If ( !Empty(aNFItem[nItem][IT_EXCECAO]) )
	If ( aNFItem[nItem][IT_EXCECAO][6] ) <> 0
		nPerIcm := aNfItem[nItem][IT_EXCECAO][6]
	EndIf
EndIf

Return(nPerIcm)

/*MaFisVICMS - Edson Maricate -08.12.1999
Executa o calculo do Valor do ICMS  do Item.
*/
Static Function MaFisVICMS(nItem,lReproc,lDif)

Local nSavValICM  := 0
Local nSValICMFR  := 0
Local lCalcDif	  :=	.F.
Local lDevTotal	  := .F.
Local aMaICMVeic  := {} //usado no PE MaICMVeic
Local aMaCalcICMS := {}
Local lDevTot     := aSX6[MV_DEVTOT]
Local lExecDevol := .T.
Local nValIcmsBruto	 := 0 //valor bruto do ICMS, antes de ser submetido ao arredondamento

DEFAULT lReproc   := .F.
Default lDif		:= .F. //Esta variável indica que a MaFisVICMS foi chamada de forma recursiva, deverá recalcular o valor do ICMS porém não deverá refazer o ICMS Diferido.

//Identifico se é diferimento parcial jogando parcela diferida em Outros ou Isento. A referência IT_COLVDIF somente será preenchida para diferimento parcial, se o campo FT_VOPDIF existir e se o campo F4_COLVDIF estiver preenchido.
aNfItem[nItem][IT_COLVDIF]	:= Iif (aNFItem[nItem][IT_TS][TS_COLVDIF] $ '1/2' .AND. aNFItem[nItem][IT_TS][TS_PICMDIF]<>0 .And. aNFItem[nItem][IT_TS][TS_PICMDIF]<>100 .AND. aPos[FP_FT_VOPDIF] , aNFItem[nItem][IT_TS][TS_COLVDIF] , '' )

//Salva o valor do ICMS no reprocessamento.
nSavValICM := aNfItem[nItem][IT_VALICM]
nSValICMFR := aNfItem[nItem][IT_ICMFRETE]

//DIAT - SC
aNFitem[nItem][IT_B1DIAT]:= aNfItem[nItem][IT_PRD][SB_PRDDIAT]

If aNFItem[nItem][IT_TS][TS_ICM] <> "N" .Or. (aNFCab[NF_SIMPNAC] =="1" .And. aNFItem[nItem][IT_TS][TS_COMPL] == "S" .And. aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST] .And. (aNFItem[nItem][IT_TS][TS_CIAP] == "S" .Or. aNFItem[nItem][IT_TS][TS_CONSUMO] == "S"))
	//Calculo do valor do ICMS do item.
	If aNFitem[nItem][IT_TIPONF ] == "I"
		If aNFItem[nItem][IT_TS][TS_AGREG]<>"F"
			aNfItem[nItem][IT_VALICM]	:= aNfItem[nItem][IT_VALMERC]
		EndIf
		aNfItem[nItem][IT_ICMFRETE]	:= 0
	Else
		If !aSX6[MV_RNDICM]
			IF aNfItem[nItem][IT_UFXPROD][UFP_RDCTIMP] > 0 .And. aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_CLIFOR] =="F" .And. aNFCab[NF_TPCLIFOR] =="X" .And. Substr(aNfItem[nItem][IT_CF],1,1)=="3" .And. aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"
				aNfItem[nItem][IT_VALICM]  	:= aNfItem[nItem][IT_BASEICM]*aNfItem[nItem][IT_UFXPROD][UFP_RDCTIMP]/100
			Else
				aNfItem[nItem][IT_VALICM]  	:= aNfItem[nItem][IT_BASEICM]*aNfItem[nItem][IT_ALIQICM]/100
			EndIf
			nValIcmsBruto	:= aNfItem[nItem][IT_VALICM]
			aNfItem[nItem][IT_ICMFRETE]	:= aNfItem[nItem][IT_BSFRETE]*aNfItem[nItem][IT_ALIQICM]/100
		Else
			IF aNfItem[nItem][IT_UFXPROD][UFP_RDCTIMP] > 0 .And. aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_CLIFOR] =="F" .And. aNFCab[NF_TPCLIFOR] =="X" .And. Substr(aNfItem[nItem][IT_CF],1,1)=="3" .And. aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"
				aNfItem[nItem][IT_VALICM]  := Round(aNfItem[nItem][IT_BASEICM]*aNfItem[nItem][IT_UFXPROD][UFP_RDCTIMP]/100,2)
				nValIcmsBruto			   := aNfItem[nItem][IT_BASEICM]*aNfItem[nItem][IT_UFXPROD][UFP_RDCTIMP]/100
			Else
				aNfItem[nItem][IT_VALICM]  := Round(aNfItem[nItem][IT_BASEICM]*aNfItem[nItem][IT_ALIQICM]/100,2)
				nValIcmsBruto	           := aNfItem[nItem][IT_BASEICM]*aNfItem[nItem][IT_ALIQICM]/100
			EndIf
			aNfItem[nItem][IT_ICMFRETE]:= Round(aNfItem[nItem][IT_BSFRETE]*aNfItem[nItem][IT_ALIQICM]/100,2) 
		EndIf

		// Ajuste para NAO pegar aliq original ICMS das NFs de 2012, este ajuste deve ser retirado em 01/01/2014
		If aNFitem[nItem][IT_ALIQICM] == 4
		   lExecDevol := .F.
		EndIf

		// Adicionado tratamento para que o valor de ICMS nao seja obtido da NF de origem em retornos de remessas em garantia.

		// O mesmo tratamento existe na MaAliqICM para que a aliquota nao seja obtida da NF de origem, entao o valor segue a mesma regra.
		If ( aNFCab[NF_TIPONF] $ "DB" .Or. aNFItem[nItem][IT_TS][TS_PODER3] =="D" ) .And. lExecDevol .And. !(aNFItem[nItem][IT_TS][TS_PODER3] == "D" .And. aNFItem[nItem][IT_TS][TS_OPERGAR] == '1')
			If !Empty(aNFItem[nItem][IT_RECORI]) .And. !RetComp(aNFCab[NF_CLIFOR], aNFItem[nItem][IT_RECORI]) .And. !aNfCab[NF_PPDIFAL]
				If aNFCab[NF_TIPONF] $ "DB"
					If ( aNFCab[NF_CLIFOR] == "C")
						dbSelectArea("SD2")
						MsGoto(aNFItem[nItem][IT_RECORI])
						If aPos[FP_D2_ICMSDIF] .AND. (SD2->D2_VALICM > 0 .Or. Abs(aNfItem[nItem][IT_VALICM]-SD2->D2_VALICM)<=1) .And. aNfItem[nItem][IT_QUANT] = SD2->D2_QUANT .And. Iif(!lDevTot , SD2->D2_VALFRE+SD2->D2_SEGURO+SD2->D2_DESPESA==0 , SD2->D2_VALICM >0)
							aNfItem[nItem][IT_VALICM]  := SD2->D2_VALICM
							aNfItem[nItem][IT_ICMSDIF] := Iif(aPos[FP_D2_ICMSDIF],SD2->D2_ICMSDIF,0)
							aNfItem[nItem][IT_VOPDIF] := If(aPos[FP_D2_VOPDIF], SD2->D2_VOPDIF, 0)
							lDevTotal	:=	.T.
						Else
							lCalcDif	:=	.T.
						EndIf
					ElseIF aPos[FP_D1_ICMSDIF]
						dbSelectArea("SD1")
						MsGoto(aNFItem[nItem][IT_RECORI])
						If (SD1->D1_VALICM > 0 .Or. Abs(aNfItem[nItem][IT_VALICM]-SD1->D1_VALICM)<=1) .And. aNfItem[nItem][IT_QUANT] = SD1->D1_QUANT .And. Iif(!lDevTot , SD1->D1_VALFRE+SD1->D1_SEGURO+SD1->D1_DESPESA==0 , SD1->D1_VALICM >0)
							aNfItem[nItem][IT_VALICM] := SD1->D1_VALICM
							aNfItem[nItem][IT_ICMSDIF] := If( aPos[FP_D1_ICMSDIF] ,SD1->D1_ICMSDIF,0)
							aNfItem[nItem][IT_VOPDIF] := If(aPos[FP_D1_VOPDIF], SD1->D1_VOPDIF, 0)
							lDevTotal	:=	.T.
						Elseif aNFItem[nItem][IT_TS][TS_DEVPARC]$"1S" .And. ((SD1->D1_VALICM > 0 .Or. Abs(aNfItem[nItem][IT_VALICM]-SD1->D1_VALICM)<=1) .And. aNfItem[nItem][IT_QUANT] <> SD1->D1_QUANT .And. Iif(!lDevTot , SD1->D1_VALFRE+SD1->D1_SEGURO+SD1->D1_DESPESA==0 , SD1->D1_VALICM >0))
							aNfItem[nItem][IT_VALICM] := SD1->D1_VALICM / SD1->D1_QUANT * aNfItem[nItem][IT_QUANT]
							aNfItem[nItem][IT_ICMSDIF] := If( aPos[FP_D1_ICMSDIF] ,SD1->D1_ICMSDIF / SD1->D1_QUANT * aNfItem[nItem][IT_QUANT],0)
							aNfItem[nItem][IT_VOPDIF] := If(aPos[FP_D1_VOPDIF], SD1->D1_VOPDIF / SD1->D1_QUANT * aNfItem[nItem][IT_QUANT], 0)
							// Se utilizar F4_DEVPARC = SIM segue o fluxo de uma dev. total pois os valores
							// serao proporcionalizados e nao devem ser recalculados posteriormente.
							lDevTotal := .T.
						ElseIf !((SD1->D1_VALICM > 0 .Or. Abs(aNfItem[nItem][IT_VALICM]-SD1->D1_VALICM)<=1) .And. aNfItem[nItem][IT_QUANT] <> SD1->D1_QUANT .And. Iif(!lDevTot , SD1->D1_VALFRE+SD1->D1_SEGURO+SD1->D1_DESPESA==0 , SD1->D1_VALICM >0))
							lCalcDif	:=	.T.
						EndIf
					EndIf
				Else
					If ( aNFCab[NF_CLIFOR] == "C")
						dbSelectArea("SD1")
						MsGoto(aNFItem[nItem][IT_RECORI])
						If (SD1->D1_VALICM > 0 .Or. Abs(aNfItem[nItem][IT_VALICM]-SD1->D1_VALICM)<=1) .And. aNfItem[nItem][IT_QUANT] = SD1->D1_QUANT .And. Iif(!lDevTot , SD1->D1_VALFRE+SD1->D1_SEGURO+SD1->D1_DESPESA==0 , SD1->D1_VALICM >0)
							aNfItem[nItem][IT_VALICM] := SD1->D1_VALICM
							lDevTotal	:=	.T.
						Else
							lCalcDif	:=	.T.
						EndIf
					Else
						dbSelectArea("SD2")
						MsGoto(aNFItem[nItem][IT_RECORI])
						If (SD2->D2_VALICM > 0 .Or. Abs(aNfItem[nItem][IT_VALICM]-SD2->D2_VALICM)<=1) .And. aNfItem[nItem][IT_QUANT] = SD2->D2_QUANT .And. Iif(!lDevTot , SD2->D2_VALFRE+SD2->D2_SEGURO+SD2->D2_DESPESA==0 , SD2->D2_VALICM >0)
							aNfItem[nItem][IT_VALICM] := SD2->D2_VALICM
							lDevTotal	:=	.T.
						Else
							lCalcDif	:=	.T.
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
Else
	aNfItem[nItem][IT_VALICM]	 := 0
	aNfItem[nItem][IT_ICMFRETE] := 0
EndIf
//Retorna o valor do ICMS no reprocessamento para calcular ICMS Diferido.
If !lReproc .AND. !lDif
	If lCalcDif .Or. (!lCalcDif .And. aNFCab[NF_TIPONF] $ "DB" .And. !lDevTotal) .Or. !(aNFCab[NF_TIPONF] $ "DB")
		If lReproc
			aNfItem[nItem][IT_VALICM]   := nSavValICM
		EndIf
		aNfItem[nItem][IT_ICMSDIF] := 0
		If aNFItem[nItem][IT_TS][TS_ICMSDIF] $ "1|3|4|6"
			aNfItem[nItem][IT_ICMSDIF] := aNfItem[nItem][IT_VALICM]
			//Valor do ICMS da Operação - Sem diferimento (Valor como se não tivesse o diferimento)
			aNfItem[nItem][IT_VOPDIF]  := aNfItem[nItem][IT_VALICM]
		EndIf
		If  aNFItem[nItem][IT_TS][TS_PICMDIF]<>0 .And. aNFItem[nItem][IT_TS][TS_PICMDIF]<>100
			aNfItem[nItem][IT_ICMSDIF] := aNfItem[nItem][IT_VALICM]*aNFItem[nItem][IT_TS][TS_PICMDIF]/100
			MaItArred(nItem,{"IT_ICMSDIF"})
		EndIf
		If aNFItem[nItem][IT_TS][TS_ICMSDIF]=="1" .And. aNFItem[nItem][IT_TS][TS_PICMDIF]==100 .And. aNFItem[nItem][IT_TS][TS_ICM] == "N"
			aNfItem[nItem][IT_ICMSDIF] :=	MaFisICDif(nItem)
			//Valor do ICMS da Operação - Sem diferimento (Valor como se não tivesse o diferimento)
			//Quando não calcula ICMS o Valor do ICMS da Operação seria o ICMS Diferido
			aNfItem[nItem][IT_VOPDIF] := aNfItem[nItem][IT_ICMSDIF]
		ElseIf 	(aNFItem[nItem][IT_TS][TS_ICMSDIF]=="3") .Or. (aNFItem[nItem][IT_TS][TS_ICMSDIF]=="4") .Or. (aNFItem[nItem][IT_TS][TS_ICMSDIF]=="1" .And. aNFItem[nItem][IT_TS][TS_PICMDIF]<>100 .And. aNFItem[nItem][IT_TS][TS_ICM] <> "N")
			aNfItem[nItem][IT_VALICM] -= aNfItem[nItem][IT_ICMSDIF]
			nValIcmsBruto			  -= aNfItem[nItem][IT_ICMSDIF]
			//Valor do ICMS da Operação - Sem diferimento (Valor como se não tivesse o diferimento)
			//É o Val.ICMS mais o valor do Diferimento
			aNfItem[nItem][IT_VOPDIF] := aNfItem[nItem][IT_VALICM]+aNfItem[nItem][IT_ICMSDIF]
		Endif

		//Diferimento para PR conforme http://tdn.totvs.com/display/public/softwaregestao/Diferimento+Parcial+do+ICMS+e+ICMS-ST+-+PR
		If (aNFItem[nItem][IT_TS][TS_ICMSDIF]=="5")
			nAliqdif:=(aNfItem[nItem][IT_ALIQICM] * 100/(100-aNFItem[nItem][IT_TS][TS_PICMDIF]) )//Aliquota Cheia
			aNfItem[nItem][IT_ICMSDIF] :=(aNfItem[nItem][IT_BASEICM] * nAliqdif/100) * aNFItem[nItem][IT_TS][TS_PICMDIF]/100
			MaItArred(nItem,{"IT_ICMSDIF"})
			//Valor do ICMS da Operação - Sem diferimento (Valor como se não tivesse o diferimento)
			aNfItem[nItem][IT_VOPDIF] := aNfItem[nItem][IT_VALICM]
		Endif

		//Se for diferimento parcial demonstrando a parcela não diferida em Outros ou Isento, precisa reduzir a base de cálculo do ICMS
		If aNfItem[nItem][IT_COLVDIF] $ '1/2'
			aNfItem[nItem][IT_BASEICM]	:= aNfItem[nItem][IT_BASEICM] * (1-(aNFItem[nItem][IT_TS][TS_PICMDIF]/100))
			MaFisVICMS(nItem,,.T.) //Recalcula o valor do ICMS considerando a base de cálculo reduzida, chamando a MaFisVICMS de forma recursiva.
		EndIF		

		//Guardo o valor do ICMS antes de ser submetido a MaItArred()
		aNfItem[nItem][IT_VICMBRT] := nValIcmsBruto		
		MaItArred(nItem,{"IT_VALICM"})
	EndIf
	//Retorna o valor do ICMS no reprocessamento.
ElseIF !lDif
	aNfItem[nItem][IT_VALICM]   := nSavValICM
	aNfItem[nItem][IT_ICMFRETE] := nSValICMFR
EndIf
//Identifica um valor a ser lancado como estorno de credito/debito na apuracao do ICMS. Este valor
//  eh obtido quando se tem um percentual de estorno definido no cadastro de TES.

// Observacao mais completa pode ser encontrada mais adiante na gravacao do Livro Fiscal.
If aNFItem[nItem][IT_TS][TS_ESTCRED]<>0
	aNfItem[nItem][IT_ESTCRED] := NoRound(aNfItem[nItem][IT_VALICM]*aNFItem[nItem][IT_TS][TS_ESTCRED]/100,2)
Endif

If !Empty(aNfItem[nItem][IT_PR43080])
	aNfItem[nItem][IT_ICSEMDS] := aNfItem[nItem][IT_BSSEMDS]*aNfItem[nItem][IT_ALIQICM]/100
	MaItArred(nItem,{"IT_ICSEMDS"})
	aNfItem[nItem][IT_DS43080] := aNfItem[nItem][IT_ICSEMDS] - aNfItem[nItem][IT_VALICM]
EndIf
//ATENCAO!!! Ponto de entrada para uso exclusivo da TOTVS, nao sugerir o uso do mesmo a clientes - GDP FISCAL
If aPE[PE_MAICMVEIC]
	aMaICMVeic := ExecBlock("MaICMVeic",.f.,.f.,{nItem,aNfItem[nItem][IT_BASEICM],aNfItem[nItem][IT_ALIQICM],aNfItem[nItem][IT_VALICM]})
	aNfItem[nItem][IT_BASEICM] := aMaICMVeic[1]
	aNfItem[nItem][IT_ALIQICM] := aMaICMVeic[2]
	aNfItem[nItem][IT_VALICM]  := aMaICMVeic[3]
EndIf

If aPE[PE_MACALCICMS]
	aMaCalcICMS := ExecBlock("MACALCICMS",.f.,.f.,{aNfCab[NF_OPERNF],nItem,aNfItem[nItem][IT_BASEICM],aNfItem[nItem][IT_ALIQICM],aNfItem[nItem][IT_VALICM]})
	IF ValType(aMaCalcICMS) == "A"
		IF Len(aMaCalcICMS) == 3
			aNfItem[nItem][IT_BASEICM] := aMaCalcICMS[1]
			aNfItem[nItem][IT_ALIQICM] := aMaCalcICMS[2]
			aNfItem[nItem][IT_VALICM]  := aMaCalcICMS[3]
		Endif
	Endif
Endif

If aNFItem[nItem][IT_TS][TS_CPRESPR] > 0 .And. aNFCab[NF_OPERNF] == "S" // CREDITO PRESUMIDO - PR - Art.631-A do RICMS/2008
	aNfItem[nItem][IT_CPRESPR] := aNfItem[nItem][IT_VALICM]*(aNFItem[nItem][IT_TS][TS_CPRESPR]/100)
Endif

IF !aNFCab[NF_TIPONF] $ "DB" .AND. !aNfCab[NF_PPDIFAL] .AND. aNfItem[nItem,IT_PREDIC] == 0 .AND. aNFItem[nItem][IT_TS][TS_AGREG]$"D/R/E"
	//Se for agrega D, R ou E e não possuir redução de base de cálculo e também não for Difal, significa que a dedução de ICMS será exatamente o valor do ICMS já calculado
	//Esta alteração se deve pelo motivo de arredondamento, existem situações onde IT_DEDICM fica com diferença de centavos do IT_VALICM, pois existem
	//tratamento de round indevidamente para estas referências. Desta forma estou assegurando que o valor de dedução de ICMS será exatamente igual ao valor de ICMS.
	aNfItem[nItem][IT_DEDICM]	:= aNfItem[nItem][IT_VALICM]
EndIF

If aNFItem[nItem][IT_TS][TS_ICMSDIF] == "6"
	aNfItem[nItem][IT_DEDICM]	:= aNfItem[nItem][IT_ICMSDIF]
EndIf //issue DSERFIS1-8601

// Calcula o valor do FECP-Proprio
MaFisFECP(nItem,,lReproc,"BSE|VLR")

Return

/*MaFisICDif - Luccas Curcio - 26.12.2011
Calculo do ICMS Diferido para os casos em que o valor de di-
ferimento de ICM eh o valor total do imposto(F4_PICMDIF=100)
*/
Static Function MaFisICDif(nItem)
Local	nBaseICM	:=	0
Local	nAliqICM	:=	0
Local	nICMSDif	:=	0

Local	aReseta		:=	{aNfItem[nItem][IT_BASEICM],;
aNfItem[nItem][IT_ALIQICM],;
aNfitem[nItem][IT_TIPONF],;
aNfItem[nItem][IT_BICMORI],;
aNfItem[nItem][IT_BSFRETE],;
aNfItem[nItem][IT_DEDICM],;
aNfItem[nItem][IT_VIPIBICM],;
aNFitem[nItem][IT_ALIQDIF],;
aNFitem[nItem][IT_ALIQSOL]}

// Calcula a aliquota e base de ICMS apenas para verificar o valor do ICMS Diferido
// Os valores da base e da aliquota serao posteriormente zerados novamente, pois essa
// situacao acontece apenas quando o campo F4_ICM = Nao, ou seja, todos os valores de
// ICMS da nota deverao estar zerados.

// Chama funcao que calcula base de ICMS
MaFisBSICM(nItem,.F.,,.T.)

// Atribui o valor da base para a variavel que ira calcular o ICMS Diferido
nBaseICM				:=	aNfItem[nItem][IT_BASEICM]

// Reseta variaveis
aNfItem[nItem][IT_BASEICM]		:=	aReseta[1]
aNfItem[nItem][IT_BICMORI]		:=	aReseta[4]
aNfItem[nItem][IT_BSFRETE]		:=	aReseta[5]
aNfItem[nItem][IT_DEDICM]		:=	aReseta[6]
aNfItem[nItem][IT_VIPIBICM]	:=	aReseta[7]

// Chama funcao que calcula aliquota de ICMS
MaAliqIcms(nItem,,.T.)
// Atribui o valor da aliquota para a variavel que ira calcular o ICMS Diferido
nAliqICM				:=	aNfItem[nItem][IT_ALIQICM]
// Reseta variaveis
aNfItem[nItem][IT_ALIQICM]		:=	aReseta[2]
aNfitem[nItem][IT_TIPONF]		:=	aReseta[3]
aNFitem[nItem][IT_ALIQDIF]		:=	aReseta[8]
aNFitem[nItem][IT_ALIQSOL]		:=	aReseta[9]
// Calcula o valor do ICMS Diferido, com base e aliquota 'virtuais'
nICMSDif	:=	nBaseICM * nAliqICM / 100

Return nICMSDif

/*
MaMargem- Edson Maricate -08.12.1999
Calculo da Margem de lucro para calculo do ICMS Solidario.
*/
Static Function MaMargem(nItem)

Local nMargem  := If ( aNfCab[NF_CLIFOR] =='F' .And. aNfCab[NF_OPERNF] == 'E' , aNfItem[nItem][IT_PRD][SB_PICMENT] , aNfItem[nItem][IT_PRD][SB_PICMRET] )
Local lSTD2      := aPos[FP_D2_MARGEM]
Local lSTD1      := aPos[FP_D1_MARGEM]
Local lNotDevol := .T.
Local nAliquota := 0
Local nAlqInter := 0
Local nMargem1  := 0
Local nMargemOri:= 0
Local nX		:= 0
Local lUFOri	:= .F.
Local lIVAAju   := .F.
Local lRastro	 := aPE[PE_MAFISRASTRO]
Local lRastroLot := .F.
Local lMvaFrete  := (aNFItem[nItem][IT_TS][TS_DESPICM]$"1#3#5" .Or. aSX6[MV_DESPICM]) .And. (aNfItem[nItem][IT_FRETE] > 0 .Or. aNfItem[nItem][IT_AUTONOMO] > 0  .Or. aNfCab[NF_AUTONOMO] > 0)
Local nTamMVA := TamSx3("D2_MARGEM")[2]

If aNFCab[NF_TIPONF] == "D"
	If !Empty(aNFItem[nItem][IT_RECORI])
		If ( aNFCab[NF_CLIFOR] == "C" )
			If lSTD2
				dbSelectArea("SD2")
				MsGoto( aNFItem[nItem][IT_RECORI] )
				nMargem	:=	SD2->D2_MARGEM
				lNotDevol	:= .F.
			Endif
		Else
			If lSTD1
				dbSelectArea("SD1")
				MsGoto( aNFItem[nItem][IT_RECORI] )
				nMargem  := SD1->D1_MARGEM
				lNotDevol	:= .F.
			Endif
		Endif
	EndIf
EndIf

If lNotDevol

	// Margem alterada para operação com Frete embutido ou não na base do st
	// RICMS RS, decreto 37699/1997
	If lMvaFrete
		If aNFCab[NF_OPERNF] == "S"  .And.  aNfItem[nItem][IT_PRD][SB_MVAFRP] > 0
			nMargem := aNfItem[nItem][IT_PRD][SB_MVAFRP]
		Elseif aNFCab[NF_OPERNF] == "E"  .And.  aNfItem[nItem][IT_PRD][SB_MVAFRC] > 0
			nMargem := aNfItem[nItem][IT_PRD][SB_MVAFRC]
		Endif
	EndIf
	// Aplica a formula padrao do MVA para encontrar o MVA Ajustado, considerando as aliquotas e a Margem preenchida no Cadastro do Produto
	If aSX6[MV_FISXMVA] .And. aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST] .And. !aNFItem[nItem][IT_TS][TS_CONSUMO]$"S" .And. nMargem > 0
		nAlqInter	:=	Iif( aNfItem[nItem,IT_ALIQICM] > 0 , aNFItem[nItem,IT_ALIQICM] , MaAliqIcms( nItem ) )
		nAliquota	:=	Iif( aNfItem[nItem,IT_ALIQSOL] > 0 , aNFItem[nItem,IT_ALIQSOL] , MaAliqSoli( nItem ) )

		nMargem		:=	Round(( ( ( ( 1 + nMargem / 100 ) * ( 1 - nAlqInter / 100 ) ) / ( 1 - nAliquota / 100 ) ) - 1 ) * 100,nTamMVA)
	EndIf

	// Utiliza o MVA preenchido na tabela CFC (Regras de tributos na esfera estadual)
	If	 aNfItem[nItem][IT_UFXPROD][UFP_MVAES] = "1" .Or. ;
		(aNfItem[nItem][IT_UFXPROD][UFP_MVAES] = "2" .And. aNFCab[NF_OPERNF] == "E"  )   .Or. ;
		(aNfItem[nItem][IT_UFXPROD][UFP_MVAES] = "3" .And. aNFCab[NF_OPERNF] == "S"  )

		If lMvaFrete .And. aNfItem[nItem][IT_UFXPROD][UFP_MVAFRU] > 0
			nMargem := aNfItem[nItem][IT_UFXPROD][UFP_MVAFRU] // Margem para operação com Frete
		ElseIf aNfItem[nItem][IT_UFXPROD][UFP_MARGEM] > 0
			nMargem	:=	aNfItem[nItem][IT_UFXPROD][UFP_MARGEM]
		EndIf

	EndIf
	// Verifica as Excecoes Fiscais
	If ( !Empty(aNFItem[nItem][IT_EXCECAO]) )
		If  lMvaFrete .And. aNFItem[nItem][IT_EXCECAO][30] > 0
			nMargem :=  aNFItem[nItem][IT_EXCECAO][30]   // Margem para operação com Frete
		ElseIf ( aNFItem[nItem][IT_EXCECAO][3] ) <> 0
			nMargem :=  aNFItem[nItem][IT_EXCECAO][3]   //Margem de Lucro Presumida
		EndIf
	EndIf

EndIf

//Tratamento do calculo do IVA Ajustado
//ATENCAO !!! Este tratamento so e relaizado quando o produto possui controle de rastreabilidade por Sub-Lote
IF !Empty(aNfItem[nItem][IT_ANFORI2]) .And. Len(aNfItem[nItem][IT_ANFORI2][1][1]) > 0
	If ( aNfItem[nItem][IT_PRD][SB_IVAAJU] == "1" .And. (Iif(lRastro,lRastroLot := ExecBlock("MAFISRASTRO",.F.,.F.),aNfItem[nItem][IT_PRD][SB_RASTRO]=="S"))  )
		nMargemOri := nMargem
		For nX := 1 to Len (aNfItem[nItem][IT_ANFORI2])
			nAliquota := Iif(aNFItem[nItem,IT_ALIQICM]==0, MaAliqIcms(nItem),aNFItem[nItem,IT_ALIQICM])
			nAlqInter := aNFItem[nItem][IT_ANFORI2][nX][02]
			If !Empty(aNFItem[nItem][IT_ANFORI2][nX][01]) .And. aNFItem[nItem][IT_ANFORI2][nX][01]<>aSX6[MV_ESTADO]
				lUFOri := .T.
			EndIf
			If aSX6[MV_ESTADO] $ 'SP/SC/MG' .And. lUFOri .And. aNFCab[NF_UFDEST] == aSX6[MV_ESTADO] .And. (lRastroLot .Or. aNfItem[nItem][IT_PRD][SB_RASTRO] $ 'S')
				lIVAAju := .T.
			EndIf
			If nAliquota > 12 .And. lIVAAju
				nMargem  := ((((1+nMargem/100)*(1-nAlqInter/100))/(1-nAliquota/100))-1)*100
				nMargem1 += nMargem*(aNFItem[nItem][IT_ANFORI2][nX][3]/100)
				aNFItem[nItem][IT_ANFORI2][nX][4] := nMargem1
				nMargem1 := 0
			EndIf
			If !lIVAAju
				aNFItem[nItem][IT_ANFORI2][nX][4] := nMargemOri
			EndIf
			lUFOri := .F.
			lIVAAju := .F.
		Next nX
	EndIf
EndIf

//Tratamento Antecipacao ICMS - Margem Solidário IVA Ajustado
If aNFItem[nItem][IT_TS][TS_ANTICMS] == "1"
	If ( aNfItem[nItem][IT_PRD][SB_IVAAJU] == "1") .And. (aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST] ) .And. aSX6[MV_ESTADO] $ "SP/SC/MG" .And. aNFCab[NF_TPCLIFOR] <> "X"//Somente entrada usando IVA Ajustado e Antecipacao de ICMS e Estado de São Paulo
		nAliquota := If ( aNfItem[nItem][IT_PRD][SB_PICM] == 0 , aSX6[MV_ICMPAD] ,  aNfItem[nItem][IT_PRD][SB_PICM] )//Alíquota Interna
		// Verifica as Excecoes fiscais
		If ( !Empty(aNFItem[nItem][IT_EXCECAO]) .And. aNfItem[nItem][IT_EXCECAO][7] <> "S")
			If ( aNFItem[nItem][IT_EXCECAO][1] ) <> 0
				nAliquota :=  aNFItem[nItem][IT_EXCECAO][1]   //Aliq. de ICMS Interna
			EndIf
		EndIf
		nAlqInter := Iif(aNFItem[nItem,IT_ALIQICM]==0, MaAliqIcms(nItem),aNFItem[nItem,IT_ALIQICM])//Alíquota interestadual
		If nAliquota > 12 //Aliquota Interna superior a 12%
			nMargem  := ((((1+nMargem/100)*(1-nAlqInter/100))/(1-nAliquota/100))-1)*100 //IVA Ajustado
		EndIf
	EndIf
EndIf

aNFitem[nItem][IT_MARGEM] := nMargem

Return(nMargem)

/*
MaFisBSSol -Edson Maricate  -08.12.1999
Esta rotina tem como objetivo calcular a base do retido/Solid conforme definido no regulamento de ICMS.
*/
Static Function MaFisBSSOL(nItem, cCampo)

Local nBsICMSt    := 0
Local nMargem     := 0
Local nBase 	  := 0
Local nBaseAux	  := 0
Local nBaseOri	  := 0
Local nY		  := 0
Local lValido     := .T.
Local nReduzICMS  := 0
Local lTipoCliFor := .F.
Local cTipoCliFor := ""
Local nVlMercR    := 0
Local cMvEstado	  := aSX6[MV_ESTADO]
Local lSTAtacVar  := IIf( aNFItem[nItem][IT_TS][TS_ATACVAR] == "1" .And. aNfItem[nItem][IT_PRD][SB_PICMENT] == 0 .And. cMvEstado == "CE" .And. aNFCab[NF_OPERNF] == "E" , .T. , .F.)
Local lSTConfCE   := IIf( aNFItem[nItem][IT_TS][TS_STCONF] == "1" .And. aNfItem[nItem][IT_PRD][SB_PICMRET] == 0 .And. cMvEstado == "CE" .And. aNFCab[NF_OPERNF] == "S" , .T. , .F.)
Local lDevTot     := aSX6[MV_DEVTOT]  // Indica se na devolucao total da mercadoria sera considerado no valor da base o valor do frete + despesa + seguro
Local lSomaIpi	  := aSX6[MV_SOMAIPI]
Local lIpiICST    := IIf(aNFItem[nItem][IT_TS][TS_SOMAIPI] == "2" .And. aNfItem[nItem][IT_TIPONF]=="N" , .F. , .T.)
// Controle Regime de Estimativa MT.
Local lRegESim	  := aSX6[MV_REGESIM]
Local lRet		  := .F.
Local nBaseICM	  := 0
Local nPerCaTM    := Iif( aNFItem[nItem][IT_TS][TS_PERCATM]>0 , aNFItem[nItem][IT_TS][TS_PERCATM]  , IIf( aNFCab[NF_PERCATM] > 0 , aNFCab[NF_PERCATM] , aSX6[MV_PERCATM] )   )
Local cMV_UFPST	  := aSX6[MV_UFPST21]
Local lSTPTPer	  := .F.
Local nValPER     := 0
Local lCalSTPe	  := .F.
Local nRedBaST	  := Iif(Len(aNFItem[nItem][IT_EXCECAO]) > 0 .And. aNFItem[nItem][IT_EXCECAO][26] > 0,aNFItem[nItem][IT_EXCECAO][26],aNFItem[nItem][IT_TS][TS_BSICMST])
Local nVlrPTST	  := 0
Local cMVSTPTPER  := aSX6[MV_STPTPER]
Local cMvTpSolCF  := aSX6[MV_TPSOLCF]
Local lMvSolBrut  := aSX6[MV_SOLBRUT]
Local cMVMkpIcPT  := aSX6[MV_MKPICPT]
Local lF4ApliIVA  := aPos[FP_F4_APLIIVA]
Local cCFOPTran   := "5351/5352/5353/5354/5355/5356/5357/5359/5360/6351/6352/6353/6354/6355/6356/6357/6359/6360/6932/5932/7358"
//Tratamento específico de PB para ignorar o tratamento para venda não presencial
Local lNConf21	  := Iif( aNfCab[NF_UFDEST]=="PB" .And. aNfCab[NF_VTOTPED]>0 .And. aNfCab[NF_VTOTPED]<500, .T. ,.F. )
Local nValIEst	  := 0
Local nAliqEst	  := MaFisAIEst(nItem)
Local nAliqAgr	  := 0
Local lAgreg	  := .F.
Local aMaSolICMS  := {}

Local nCustEnt  := 0
Local nBsSTCalc := 0
Local nMrgAjsEn := 0
Local cMvUFBdSt := aSX6[MV_UFBDST]
Local cMvUFBdGo := aSX6[MV_UFBSTGO]
Local cMvUFBdSe := aSX6[MV_BASDSSE]
Local cSimpNac  := aSX6[MV_CODREG]
Local lSTRedu   := aSX6[MV_STREDU]
Local cUfOri    := ""
Local cUfDest   := ""

DEFAULT cCampo	:= ""
// Carrega o tipo do cliente pagador ou destinario
If !Empty(aNfCab[NF_PNF_TPCLIFOR])
	lTipoCliFor := aNfCab[NF_PNF_TPCLIFOR]$cMvTpSolCF
	cTipoCliFor := aNfCab[NF_PNF_TPCLIFOR]
Else
	lTipoCliFor := aNfCab[NF_TPCLIFOR]$cMvTpSolCF
	cTipoCliFor := aNfCab[NF_TPCLIFOR]
EndIf

// Carrega a reducao da base do ICMS
If !Empty(aNFitem[nItem,IT_EXCECAO]) .And. aNfItem[nItem,IT_EXCECAO,14] > 0
	nReduzICMS := aNfItem[nItem,IT_EXCECAO,14]
Else
	nReduzICMS := aNFItem[nItem][IT_TS][TS_BASEICM]
EndIf

aNfItem[nItem][IT_PREDST]  :=	nRedBaST

// Controle automatico para utilizacao de Pauta ou Calculo ST por percentual PAUTA x Valor Operacao.
nVlrPTST := IIf(aNFItem[nItem][IT_TS][TS_AGREG]<>"F", IIf (aNfItem[nItem][IT_PRCMEDP] <= 0, aNfItem[nItem][IT_VALMERC], aNfItem[nItem][IT_PRCMEDP]) - IIf(aNFItem[nItem][IT_TS][TS_AGREG]$"DR",aNfItem[nItem][IT_DEDICM],0),0) + Iif(aNFItem[nItem][IT_TS][TS_INCIDE] == "", aNfItem[nItem][IT_VALIPI], 0) + aNfItem[nItem][IT_DESPESA]
If Empty(aSX6[MV_B1PTST])
	lSTPTPer	:= Iif(aNfCab[NF_UFDEST] $ cMVSTPTPER,.T.,.F.)
	nValPER		:= Val(Transform(Substr(cMVSTPTPER,At(aNfCab[NF_UFDEST],cMVSTPTPER)+2,4),"@E 99.99"))
Else
	lSTPTPer	:= aNfItem[nItem][IT_PRD][SB_B1PTST] > 0
	nValPER		:= aNfItem[nItem][IT_PRD][SB_B1PTST]
Endif

If lSTPTPer .And. nValPER > 0 .And. nVlrPTST > 0
	If (!Empty(aNFitem[nItem][IT_EXCECAO]) .And. (nVlrPTST/aNfItem[nItem][IT_EXCECAO][8]) >= nValPER) .Or. ;
	   (!Empty(aNFitem[nItem][IT_UFXPROD]) .And. (nVlrPTST/aNfItem[nItem][IT_UFXPROD][UFP_VL_ICM]) >= nValPER) .Or. ;
		aNfItem[nItem][IT_PRD][SB_VLR_ICM] <> 0 .And.( nVlrPTST / aNfItem[nItem][IT_PRD][SB_VLR_ICM] ) >= nValPER
		lCalSTPe := .T.
	EndIf
EndIf 

// Verifica se deve-se calcular o ICMS solidario
If aNFItem[nItem][IT_TS][TS_MKPCMP]<>"1" .And. !(aNFitem[nItem][IT_TIPONF ]$'IP') .And. IIf(aNfCab[NF_OPERNF]=="S".And.aNFCab[NF_CLIFOR] == "C",lTipoCliFor,.T.)
	If aNFCab[NF_TIPONF]$"DB"
		If !Empty(aNFItem[nItem][IT_RECORI])
			If ( aNFCab[NF_CLIFOR] == "C")
				dbSelectArea("SD2")
				MsGoto( aNFItem[nItem][IT_RECORI] )
				dbSelectArea("SF2")
				dbSetOrder(1)
				If MsSeek(xFilial("SF2")+(SD2->D2_DOC+SD2->D2_SERIE+SD2->D2_CLIENTE+SD2->D2_LOJA))
					If aNfItem[nItem][IT_QUANT] == SD2->D2_QUANT  .And.  Iif(!lDevTot, aPos[FP_D2_ALIQSOL] .And. SD2->D2_VALFRE+SD2->D2_SEGURO+SD2->D2_DESPESA==0,aPos[FP_D2_ALIQSOL])
						aNfItem[nItem][IT_BASESOL] := SD2->D2_BRICMS
						lValido := .F.
					ElseIf aNfItem[nItem][IT_QUANT] <> SD2->D2_QUANT .And. Iif(!lDevTot, aPos[FP_D2_ALIQSOL] .And. SD2->D2_VALFRE+SD2->D2_SEGURO+SD2->D2_DESPESA==0,aPos[FP_D2_ALIQSOL])

						aNfItem[nItem][IT_BASESOL] := (SD2->D2_BRICMS/SD2->D2_QUANT)* aNfItem[nItem][IT_QUANT]
						lValido := .F.
					Else
						If SF2->F2_TIPOCLI$cMvTpSolCF
							lValido := .T.
						Else
							lValido := .F.
						EndIf
					EndIf
				EndIf
			Else
				dbSelectArea("SD1")
				MsGoto( aNFItem[nItem][IT_RECORI] )
				dbSelectArea("SF1")
				dbSetOrder(1)
				If MsSeek(xFilial("SF1")+(SD1->D1_DOC+SD1->D1_SERIE+SD1->D1_FORNECE+SD1->D1_LOJA))
					If aNfItem[nItem][IT_QUANT] == SD1->D1_QUANT .And. Iif(!lDevTot, aPos[FP_D1_ALIQSOL]  .And. SD1->D1_VALFRE+SD1->D1_SEGURO+SD1->D1_DESPESA==0 , aPos[FP_D1_ALIQSOL])
						// Tratamento de ICMS-ST conforme decreto 29.560/2008 para o estado do Ceara.
						// Conforme o decreto que visa atender atacadista e varejistas do ceara atraves de aliquot
						// a especificas de ICMS-ST.estas sao utilizadas conforme o anexo III do decreto que e com
						// posta de varias caracteristicas tais como operação(somente)de entrada, origem do forne
						// cedor, se e optante do simples nacional, aliquota interna do produto, se o destinatario
						// e atacadista ou varejista. Segundo consulta realizada ao JIRA para tratamento de
						// devolucao.Neste caso emitiu parecer que ao devolver compras realizadas com este calculo
						// o ICMS-ST nao devera ser calculado para a nota de devolucao de compras.
						If aNfItem[nItem][IT_PRD][SB_PICMENT] == 0 .And. cMvEstado == "CE" .And. ( Substr(SM0->M0_CNAE,1,2) == "46" .Or. Substr(SM0->M0_CNAE,1,2) == "47" )
							aNfItem[nItem][IT_BASESOL] := 0
						Else
							aNfItem[nItem][IT_BASESOL] := SD1->D1_BRICMS
						EndIf
						lValido := .F.
					ElseIf SF1->F1_BRICMS > 0
						aNfItem[nItem][IT_BASESOL] := SD1->D1_BRICMS * (aNfItem[nItem][IT_QUANT] / SD1->D1_QUANT)
						lValido := .F.
					Else
						lValido := .F.
					EndIf
				Endif
			Endif
		ElseIf !lTipoCliFor
			lValido := .F.
		EndIf
	EndIf
	If lValido
		// Calculo do Solidario pela Margem de lucro
		If (aNfItem[nItem][IT_PRD][SB_VLR_ICM] == 0 .And. ((Empty(aNFitem[nItem][IT_EXCECAO]) .Or. aNfItem[nItem][IT_EXCECAO][8]==0) .And. (Empty(aNFitem[nItem][IT_UFXPROD]) .Or. aNfItem[nItem][IT_UFXPROD][UFP_VL_ICM]==0))) .Or.;
			(!Empty(aNFitem[nItem][IT_EXCECAO]) .And. aNfItem[nItem][IT_EXCECAO][20] == "2" .And. aNfItem[nItem][IT_EXCECAO][8] == 0) .Or.;
			IiF(lSTPTPer,IiF(lCalSTPe,.T.,.F.),.F.)
			If (aNfItem[nItem][IT_MARGEM] > 0 .And. aNFItem[nItem][IT_TS][TS_APLREDP]<> "1") .Or. ( lSTAtacVar .And. aNFItem[nItem][IT_TS][TS_APLREDP]<> "1").Or. ( lSTConfCE .And. aNFItem[nItem][IT_TS][TS_APLREDP]<> "1")

				nMargem := aNfItem[nItem][IT_MARGEM]

				// Se o campo novo estiver preenchido vale a regra do campo novo.
				// caso contrario continua com o parametro MV_STREDU. A regra eh a mesma.
				// Se lSTRedu = .T. significa que sera aplicada a reducao no valor da mercadoria
				// antes de somar os demais valores que fazem parte da base e da aplicacao do MVA.
				// Se lSTRedu = .F. significa que serao somados todos os valores que
				// fazem parte da base do ST, aplicado o MVA, e por ultimo a base sera reduzida.
				If !Empty(aNfItem[nItem][IT_TS][TS_STREDU])
					lSTRedu := aNfItem[nItem][IT_TS][TS_STREDU] == "1"
				Else
					lSTRedu := aSX6[MV_STREDU]
				EndIf

				If lSomaIpi
					If !lSTRedu
						aNfItem[nItem][IT_BASESOL] := IIf(aNFItem[nItem][IT_TS][TS_AGREG]<>"F",IIf (aNfItem[nItem][IT_PRCMEDP] <= 0, aNfItem[nItem][IT_VALMERC], aNfItem[nItem][IT_PRCMEDP])-IIf(aNFItem[nItem][IT_TS][TS_AGREG]$"D",aNfItem[nItem][IT_DEDICM],0),0)
					Else
						If nRedBaST > 0 .And. aNFItem[nItem][IT_TS][TS_INCSOL]<>'A'
							nVlMercR := ((aNfItem[nItem][IT_VALMERC])*nRedBaST)/100
						Else
							nVlMercR := (aNfItem[nItem][IT_VALMERC])
						Endif
						aNfItem[nItem][IT_BASESOL] := IIf(aNFItem[nItem][IT_TS][TS_AGREG]<>"F",IIf (aNfItem[nItem][IT_PRCMEDP] <= 0, nVlMercR, aNfItem[nItem][IT_PRCMEDP]) - IIf(aNFItem[nItem][IT_TS][TS_AGREG]$"DR",aNfItem[nItem][IT_DEDICM],0),0)
					Endif
				Else
					If !lSTRedu
						//Devo dobrar o valor da base sem as despesas
						If nRedBaST == 200
							aNfItem[nItem][IT_BASESOL] := (IIf(aNfItem[nItem][IT_PRCMEDP] <= 0, aNfItem[nItem][IT_VALMERC], aNfItem[nItem][IT_PRCMEDP]) * nRedBaST / 100 )
						Else
							aNfItem[nItem][IT_BASESOL] := IIf(aNFItem[nItem][IT_TS][TS_AGREG]<>"F",IIf (aNfItem[nItem][IT_PRCMEDP] <= 0, aNfItem[nItem][IT_VALMERC], aNfItem[nItem][IT_PRCMEDP]) - IIf(aNFItem[nItem][IT_TS][TS_AGREG]$"DR",aNfItem[nItem][IT_DEDICM],0),0)+Iif(!lIpiICST, 0, aNfItem[nItem][IT_VALIPI])
						EndIf
					Else
						If nRedBaST > 0 .And. aNFItem[nItem][IT_TS][TS_INCSOL]<>'A'
							nVlMercR := ((aNfItem[nItem][IT_VALMERC])*nRedBaST)/100
						Else
							nVlMercR := (aNfItem[nItem][IT_VALMERC])
						Endif
						aNfItem[nItem][IT_BASESOL] := IIf(aNFItem[nItem][IT_TS][TS_AGREG]<>"F", IIf (aNfItem[nItem][IT_PRCMEDP] <= 0, nVlMercR, aNfItem[nItem][IT_PRCMEDP]) - IIf(aNFItem[nItem][IT_TS][TS_AGREG]$"DR",aNfItem[nItem][IT_DEDICM],0),0)+Iif(!lIpiICST, 0, aNfItem[nItem][IT_VALIPI])
					Endif
				Endif

				IF aNFItem[nItem][IT_TS][TS_BSICMRE] == "1" .And. aNfItem[nItem][IT_PRD][SB_UVLRC] > 0 .And.  aNFCab[NF_UFDEST] == aNFCab[NF_UFORIGEM] .And. aNfCab[NF_OPERNF] == "S"
					aNfItem[nItem][IT_BASESOL]	:= aNfItem[nItem][IT_PRD][SB_UVLRC]	* aNfItem[nItem][IT_QUANT]
				EndIf
				If ((aNFItem[nItem][IT_TS][TS_DESPICM] <> "2" .And. aNFItem[nItem][IT_TS][TS_DESPICM] <> "4") .OR. aSX6[MV_DESPICM])
					aNfItem[nItem][IT_BASESOL] += 	aNfItem[nItem][IT_SEGURO]+aNfItem[nItem][IT_DESPESA]+aNfItem[nItem][IT_FRETE]
				EndIf
				If aNFItem[nItem][IT_TS][TS_FRETAUT] == "2"
					aNfItem[nItem][IT_BASESOL] += aNfItem[nItem][IT_AUTONOMO]
				EndIf

				If aNFItem[nItem][IT_TS][TS_AGREG]<>"F"
					If !lMvSolBrut .Or. aNFItem[nItem][IT_TS][TS_STDESC] == "1"
						aNfItem[nItem][IT_BASESOL] -=  (aNfItem[nItem][IT_DESCONTO] + aNfItem[nItem][IT_DESCTOT] )
					EndIf
				EndIf

				// Se nao calcular o ICMS Normal soma-lo na base de ICMS ST
				If ((aNfItem[nItem][IT_VALICM] == 0 .And. aNfItem[nItem][IT_DESCZF] == 0) .Or.;
				    (aSX6[MV_ESTADO] == "AM" .And. aNFCab[NF_OPERNF] == "S" .And. aNFItem[nItem][IT_TS][TS_AGREG] == "I" .And.;
				    (AllTrim(aNFCab[NF_ESPECIE]) $ "CTR/CTE" .Or. "NFST"$AllTrim(aNFCab[NF_ESPECIE]))))
					If aNFItem[nItem][IT_TS][TS_ICMSST] <> "2" .and. !empty(aNFItem[nItem][IT_TS][TS_ICMSST])
						If aNfItem[nItem][IT_VALICM] == 0
							nAliqAgr += MaAliqIcms(nItem,.T.)
						Else
							nAliqAgr += aNfItem[nItem][IT_ALIQICM]
						EndIf
						lAgreg := .T.
					EndIf
					If aNFItem[nItem][IT_TS][TS_AGRPIS]=="P"
						nAliqAgr += aNfItem[nItem][IT_ALIQPS2]
						lAgreg := .T.
					EndIf
					If aNFItem[nItem][IT_TS][TS_AGRCOF]=="C"
						nAliqAgr += aNfItem[nItem][IT_ALIQCF2]
						lAgreg := .T.
					EndIf
				EndIf
				If lAgreg
					aNfItem[nItem][IT_BASESOL] := aNfItem[nItem][IT_BASESOL] / (1-(nAliqAgr /100))
				EndIf
				If !aSX6[MV_DSZFSOL]
					aNfItem[nItem][IT_BASESOL] += (aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS] + aNfItem[nItem][IT_DESCZFCOF]))
				EndIf

				IF aNfCab[NF_SUFRAMA] .And. !(aNfCab[NF_UFDEST] $ aSX6[MV_UFSTZF])
					aNfItem[nItem][IT_BASESOL] += (aNfItem[nItem][IT_DESCZFPIS] + aNfItem[nItem][IT_DESCZFCOF])
				ENDIF
				If aNFItem[nItem][IT_TS][TS_BCPCST] == "1"
					aNfItem[nItem][IT_BASESOL] += aNfItem[nItem][IT_VALPS3] + aNfItem[nItem][IT_VALCF3]
				EndIf
				// Operacoes de venda para consumidor final nao podem ter
				// margem de lucro se o destino for para uso e consumo.
				If (( aNFItem[nItem][IT_TS][TS_CONSUMO]$"S" .And.;
					(	( cTipoCliFor=="F" .And. aNfCab[NF_CLIFOR]=="C" ) .Or. ( aNfCab[NF_CLIFOR]=="F" ) ) .And.;
					aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST] ) .Or. aNFItem[nItem][IT_TS][TS_MKPSOL]=="1") .And. aNFItem[nItem][IT_TS][TS_MKPSOL]<>"3"
					nMargem := 0
				EndIf

				// Para Calulo ICMS-ST Importacao SIGAEIC na classificacao da NFE, neste caso a base a ser considerada e a base do ICMS original
				// enviada pelo SIGAEIC que contem demais contribuicoes e impostos que compoem o valor total da importacao para se obter o ICMST
				If (aNFItem[nItem][IT_TS][TS_AGREG]$"B") .And. nMargem > 0
					aNfItem[nItem][IT_BASESOL] := aNfItem[nItem][IT_BASEICM]
				EndIf

				//Essa validacao foi implementada verificando apenas as referencias: NF_OPERNF, TS_MKPSOL, TS_INCSOL e TS_AGREG.
				//Porem, isso estava causando inconsistencias no calculo de ICMS Solidario originado do TMS.
				//Foi adicionada a validacao da referencia TS_CREDST ,pois conforme chamado da primeira implementacao - TFZGYC, esse campo
				//tambem deve ser verificado.
				If aNfCab[NF_OPERNF]=="S" .And. aNFItem[nItem][IT_TS][TS_MKPSOL] == "1" .And. aNFItem[nItem][IT_TS][TS_INCSOL] == "D" .And. aNFItem[nItem][IT_TS][TS_AGREG] == "I" .And. aNFItem[nItem][IT_TS][TS_CREDST] == "3" .And. AllTrim(aNfItem[nItem][IT_CF])$ cCFOPTran;
					.And. aNfItem[nItem][IT_BASEICM]>0
					aNfItem[nItem][IT_BASESOL] := aNfItem[nItem][IT_BASEICM]
				EndIf

				//Verifica se irá somar o valor do PIS e da COFINS na base de cálculo do ICMS ST.
				//Após somar, se aplicavel, irá incluir o valor do ICMS na base: (base de cálculo / (1-percentual da alíquota do ICMS))
				IF aNfCab[NF_OPERNF]=="E" .And. aNFCab[NF_CLIFOR] =="F" .And. aNFCab[NF_TPCLIFOR] =="X" .And. aNFItem[nItem][IT_TS][TS_INTBSIC]$"123" .AND. Substr(aNfItem[nItem][IT_CF],1,1)=="3"

					// Se vier do SIGAEIC a referencia IT_BASEICM ja contem todos os valores que compoem o valor total da importacao,
					// incluindo o valor do icms. Portanto, nao somar novamente estes tributos na base do ST.
					If !(aNFItem[nItem][IT_TS][TS_AGREG]$"B" .And. nMargem > 0)
						aNfItem[nItem][IT_BASESOL] += aNfItem[nItem][IT_VALPS2] + aNfItem[nItem][IT_VALCF2]
						aNfItem[nItem][IT_BASESOL] := (aNfItem[nItem][IT_BASESOL] / (1-(aNFItem[nItem,IT_ALIQICM]/100)))
					EndIf
				EndIF
				If aNFItem[nItem][IT_TS][TS_INCSOL] <> "A"
					//Tratamento para o IVA Ajustado somente quando a informacao
					//e solicitada do pedido de vendas - planilha financeira
					If (FunName()=="MATA410" .Or. FunName()=="MATC090" .Or.(FunName()=="MATA460A" .And. inclui==.F. .And. altera==.F.));
						.And. aNfItem[nItem][IT_PRD][SB_IVAAJU] == "1" .And. Len(aNfItem[nItem][IT_ANFORI2][1][1]) > 0
						nBaseOri := aNfItem[nItem][IT_BASESOL] //salvo a base original para efetuar o calculo da nova base com o IVA Ajustado
						For nY := 1 To Len (aNfItem[nItem][IT_ANFORI2])//Neste momento verifico se existe a proporcionalidade para calcular a base, pois pode existir quantidades de varios lotes
							If aNfItem[nItem][IT_ANFORI2][nY][3] < aNfItem[nItem][IT_QUANT]
								nBase := ((nBaseOri/aNfItem[nItem][IT_QUANT])*aNfItem[nItem][IT_ANFORI2][nY][3])
								nBase *= (1+(aNfItem[nItem][IT_ANFORI2][nY][4]/100))
								nBaseAux	+=	nBase
								aNfItem[nItem][IT_BASESOL]	:= nBaseAux
							Else
								aNfItem[nItem][IT_BASESOL] := aNfItem[nItem][IT_BASESOL]*(1+(nMargem/100))
							EndIf
						next
					Else
						aNfItem[nItem][IT_BASESOL] := aNfItem[nItem][IT_BASESOL]*(1+(nMargem/100))
					EndIf
				EndIf
				IF aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST] .And. aNFCab[NF_UFDEST]$cMvUFBdSt  .And. ((aNfCab[NF_OPERNF] == "S" .And. aNfCab[NF_TPCLIFOR] == "F" ) .Or. (aNfCab[NF_OPERNF] == "E" .And. aNFItem[nItem][IT_TS][TS_CONSUMO] == "S"))
                    IF aNFCab[NF_UFDEST]$cMvUFBdSe // MV_BASDSSE
						aNfItem[nItem][IT_BASESOL] := (aNfItem[nItem][IT_BASESOL])/(1-((aNfItem[nItem][IT_ALIQSOL]-aNFItem[nItem][IT_ALIQICM])/100))
					ElseIF aNFCab[NF_UFDEST]$cMvUFBdGo // Base Dupla ST para Goias Art. 65 do RCTE/GO. // tdn.totvs.com/pages/releaseview.action?pageId=267797477
						aNfItem[nItem][IT_BASESOL] := (aNfItem[nItem][IT_BASESOL])/(1-((aNfItem[nItem][IT_ALIQSOL])/100))
					Else
						If cSimpNac $ "1/2"
							aNfItem[nItem][IT_BASESOL] := (aNfItem[nItem][IT_BASESOL]-(aNfItem[nItem][IT_BASEICM]*nAliqEst/100))/(1-(aNfItem[nItem][IT_ALIQSOL])/100)
						Else
							aNfItem[nItem][IT_BASESOL] := (aNfItem[nItem][IT_BASESOL]-aNfItem[nItem][IT_VALICM])/(1-(aNfItem[nItem][IT_ALIQSOL])/100)
						Endif
					Endif
				EndIf
				If nReduzICMS > 0 .And. aSX6[MV_BASERET]=="S"
					aNfItem[nItem][IT_BASESOL] := (aNfItem[nItem][IT_BASESOL]*nReduzICMS)/100
					aNfItem[nItem][IT_PREDST]  := nReduzICMS

					If aNFItem[nItem][IT_TS][TS_VDASOFT] == "1" .And. nReduzICMS >= 100 .And. !lSomaIpi
						aNfItem[nItem][IT_BASESOL] -= aNfItem[nItem][IT_VALIPI]*(1+(nMargem/100))
					EndIf
				EndIf
				If nRedBaST > 0 .And. nRedBaST <> 200 .And. aNFItem[nItem][IT_TS][TS_INCSOL]<>'A' .And. !lSTRedu
					If nRedBaST == 100
						aNfItem[nItem][IT_BASESOL] := 0
					Else
						aNfItem[nItem][IT_BASESOL] := (aNfItem[nItem][IT_BASESOL]*nRedBaST)/100
						aNfItem[nItem][IT_PREDST]  :=	nRedBaST
					EndIf
				EndIf
				//Tratamento para Confaz 21/2011. As condicoes para o calculo do ICMS-ST sao para as UF's contidas no parametro
				//MV_UFPST21, para clientes do tipo Consumidor Final e para Vendas nao presenciais, verificado pelo campo F4_VENPRES.
				If (aNFCab[NF_UFDEST] <> aNFCab[NF_UFORIGEM] .And. aNFItem[nItem][IT_TS][TS_VENPRES] <> "1" .And. aNFCab[NF_UFDEST] $ cMV_UFPST .And. cTipoCliFor == "F" .And. ;
					(aNFCab[NF_LINSCR] .Or. SA1->A1_CONTRIB == "2") .And. aNFItem[nItem][IT_TS][TS_MKPSOL]=="1" ) .And. !lNConf21

					aNfItem[nItem][IT_BASESOL]	:= Iif( nReduzICMS > 0 .And. aSX6[MV_BASERET] == "S" , aNfItem[nItem][IT_BASEICM] , aNfItem[nItem][IT_BICMORI] )
				Endif
			ElseIf (aNFCab[NF_UFDEST] <> aNFCab[NF_UFORIGEM] .And. aNFItem[nItem][IT_TS][TS_VENPRES] <> "1" .And. aNFCab[NF_UFDEST] $ cMV_UFPST .And. cTipoCliFor == "F" .And. ;
				(aNFCab[NF_LINSCR] .Or. SA1->A1_CONTRIB == "2") .And. aNFItem[nItem][IT_TS][TS_MKPSOL]=="1" ) .And. !lNConf21
					aNfItem[nItem][IT_BASESOL]	:= Iif( nReduzICMS > 0 .And. aSX6[MV_BASERET] == "S" , aNfItem[nItem][IT_BASEICM] , aNfItem[nItem][IT_BICMORI] )
				//Verifico se devo usar a base de calculo do ICMS Proprio quando reduzida, como base para o ICMS ST.
			ElseIf (aNfItem[nItem][IT_MARGEM] > 0 .And. aNFItem[nItem][IT_TS][TS_APLREDP]=="1") .Or. ( lSTAtacVar .And. aNFItem[nItem][IT_TS][TS_APLREDP]=="1") .Or. ( lSTConfCE .And. aNFItem[nItem][IT_TS][TS_APLREDP]=="1")

				aNfItem[nItem][IT_BASESOL]	:= Iif( nReduzICMS > 0 .And. aSX6[MV_BASERET] == "S" , aNfItem[nItem][IT_BASEICM] , aNfItem[nItem][IT_BICMORI] ) + aNfItem[nItem][IT_VALIPI]
				//Caso Despesa não tenham entrado na base do ICMS Proprio deve ser colocada.
				If aNFItem[nItem][IT_TS][TS_DESPICM] == "2" .Or. aNFItem[nItem][IT_TS][TS_DESPICM] == "3";
					.Or. (aNFItem[nItem][IT_TS][TS_DESPICM]$"14" .And. aNFItem[nItem][IT_TS][TS_DESPRDIC] == "3")
					aNfItem[nItem][IT_BASESOL] += aNfItem[nItem][IT_DESPESA]
					aNfItem[nItem][IT_BASESOL] += aNfItem[nItem][IT_SEGURO]
				EndIf
				If aNFItem[nItem][IT_TS][TS_DESPRDIC] $ "3"
					aNfItem[nItem][IT_BASESOL] += aNfItem[nItem][IT_FRETE]
				EndIf
				aNfItem[nItem][IT_BASESOL] := aNfItem[nItem][IT_BASESOL] * (1+(aNfItem[nItem][IT_MARGEM]/100))
			Elseif aNfItem[nItem][IT_MARGEM] == 0
				If aNFCab[NF_UFDEST] == aNFCab[NF_UFORIGEM] .And. aNFItem[nItem][IT_TS][TS_OBSSOL]=="5" .And. aNFItem[nItem][IT_TS][TS_LFICM]=="Z"
					aNfItem[nItem][IT_BASESOL] := IIf(aNfItem[nItem][IT_PRCMEDP] <= 0, aNfItem[nItem][IT_VALMERC], aNfItem[nItem][IT_PRCMEDP])
				ElseIf	aNfItem[nItem][IT_BASESOL]> 0 .And. (!lMvSolBrut .Or. aNFItem[nItem][IT_TS][TS_STDESC] == "1")
					aNfItem[nItem][IT_BASESOL] -= (aNfItem[nItem][IT_DESCONTO] + aNfItem[nItem][IT_DESCTOT] )
				Endif
			Else
				aNfItem[nItem][IT_BASESOL]	:= 0
			EndIf
		Else
			If !Empty(aNFitem[nItem][IT_EXCECAO]) .And. (aNfItem[nItem][IT_EXCECAO][8]<>0 .Or. aNfItem[nItem][IT_EXCECAO][20]=="2")
				aNfItem[nItem][IT_BASESOL] := aNfItem[nItem][IT_QUANT]*aNfItem[nItem][IT_EXCECAO][8]
				aNfItem[nItem][IT_PAUTST]  := aNfItem[nItem][IT_EXCECAO][8]
			ElseIf !Empty(aNFitem[nItem][IT_UFXPROD]) .And. aNfItem[nItem][IT_UFXPROD][UFP_VL_ICM]<>0
				aNfItem[nItem][IT_BASESOL] := aNfItem[nItem][IT_QUANT]*aNfItem[nItem][IT_UFXPROD][UFP_VL_ICM]
				aNfItem[nItem][IT_PAUTST]  := aNfItem[nItem][IT_UFXPROD][UFP_VL_ICM]
			Else
				aNfItem[nItem][IT_BASESOL] := aNfItem[nItem][IT_QUANT] * aNfItem[nItem][IT_PRD][SB_VLR_ICM]
				aNfItem[nItem][IT_PAUTST]  := aNfItem[nItem][IT_PRD][SB_VLR_ICM]
			EndIf
			If !Empty( aSX6[MV_ICMPFAT] )
				aNfItem[nItem][IT_BASESOL] *= aNfItem[nItem][IT_PRD][SB_ICMPFAT]
			EndIf
			If aSX6[MV_ICPAUTA]=="2" //1=Sem Frete/Despesa/Seguro - 2=Com Frete/Despesa/Seguro
				If !Empty(aNFItem[nItem][IT_VLR_FRT])
					aNfItem[nItem][IT_BASESOL] += aNfItem[nItem][IT_VLR_FRT]+aNfItem[nItem][IT_SEGURO]+aNfItem[nItem][IT_DESPESA]
				Else
					aNfItem[nItem][IT_BASESOL] += aNfItem[nItem][IT_FRETE]+aNfItem[nItem][IT_SEGURO]+aNfItem[nItem][IT_DESPESA]
				EndIf
			EndIf
			nBsICMSt := IIf(aNFItem[nItem][IT_TS][TS_AGREG]<>"F",IIf (aNfItem[nItem][IT_PRCMEDP] <= 0, aNfItem[nItem][IT_VALMERC], aNfItem[nItem][IT_PRCMEDP]) - IIf(aNFItem[nItem][IT_TS][TS_AGREG]$"DR",aNfItem[nItem][IT_DEDICM],0),0)+aNfItem[nItem][IT_VALIPI]+aNfItem[nItem][IT_FRETE]+aNfItem[nItem][IT_SEGURO]+aNfItem[nItem][IT_DESPESA]
			If aNFItem[nItem][IT_TS][TS_FRETAUT] == "2"
				nBSICMSt += aNfItem[nItem][IT_AUTONOMO]
			EndIf
			If !lMvSolBrut .Or. aNFItem[nItem][IT_TS][TS_STDESC] == "1"
				nBsICMSt -= (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT])
			EndIf
			If !aSX6[MV_DSZFSOL]
				nBsICMSt += aNfItem[nItem][IT_DESCZF]
				aNfItem[nItem][IT_BASESOL] += aNfItem[nItem][IT_DESCZF]
			EndIf
			If nReduzICMS > 0 .And. aSX6[MV_BASERET] =="S"
				nBsICMSt := (aNfItem[nItem][IT_BASESOL]*nReduzICMS)/100
				aNfItem[nItem][IT_BASESOL] := (aNfItem[nItem][IT_BASESOL]*nReduzICMS)/100
				aNfItem[nItem][IT_PREDST]  := nReduzICMS

				If aNFItem[nItem][IT_TS][TS_VDASOFT] == "1" .And. nReduzICMS >= 100
					aNfItem[nItem][IT_BASESOL] -= aNfItem[nItem][IT_VALIPI]
				EndIf
			EndIf
			If nRedBaST > 0 .And. aNFItem[nItem][IT_TS][TS_INCSOL]<>'A' .And. !lSTRedu
				aNfItem[nItem][IT_PREDST]  :=	nRedBaST
			EndIf
			If nRedBaST > 0
				If nRedBaST == 100
					nBSICMSt := 0
					aNfItem[nItem][IT_BASESOL] := 0
				Else
					nBsICMSt := (nBsICMSt*nRedBaST)/100
					aNfItem[nItem][IT_BASESOL] := (aNfItem[nItem][IT_BASESOL]*nRedBaST)/100
				EndIf
			EndIf
			//Verifica se irá somar o valor do PIS e da COFINS na base de cálculo do ICMS ST.
			//Após somar irá incluir o valor do ICMS na base: (base de cálculo / (1-percentual da alíquota do ICMS))
			IF aNfCab[NF_OPERNF]=="E" .And. aNFCab[NF_CLIFOR] =="F" .And. aNFCab[NF_TPCLIFOR] =="X" .And. aNFItem[nItem][IT_TS][TS_INTBSIC]$"123" .AND. Substr(aNfItem[nItem][IT_CF],1,1)=="3"
				aNfItem[nItem][IT_BASESOL] += aNfItem[nItem][IT_VALPS2] + aNfItem[nItem][IT_VALCF2]
				aNfItem[nItem][IT_BASESOL] := (aNfItem[nItem][IT_BASESOL] / (1-(aNFItem[nItem,IT_ALIQICM]/100)))
			EndIF
			If ( aNfItem[nItem][IT_MARGEM] > 0 .And. cMVMkpIcPT=="2") .Or. ( lSTAtacVar .And. cMVMkpIcPT=="2") .Or. ( lSTConfCE .And. cMVMkpIcPT=="2")
				nMargem := aNfItem[nItem][IT_MARGEM]
				// Operacoes de venda para consumidor final nao podem ter
				// margem de lucro se o destino for para uso e consumo.
				If (( aNFItem[nItem][IT_TS][TS_CONSUMO]$"SO" .And.;
					(	( cTipoCliFor=="F" .And. aNfCab[NF_CLIFOR]=="C" ) .Or. ( aNfCab[NF_CLIFOR]=="F" ) ) .And.;
					aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST] ) .Or. aNFItem[nItem][IT_TS][TS_MKPSOL]=="1") .And. aNFItem[nItem][IT_TS][TS_MKPSOL]<>"3"
					nMargem := 0
				EndIf
				If aNFItem[nItem][IT_TS][TS_INCSOL] <> "A"
					aNfItem[nItem][IT_BASESOL] := aNfItem[nItem][IT_BASESOL]*(1+(nMargem/100))
					nBsICMSt := nBsICMSt*(1+(nMargem/100))
				EndIf
			EndIf
			// Calculo do valor da base do ICMS Solidario quando o valor da
			// pauta for menor do que o valor do item.
			If (lF4ApliIVA .And. aNFItem[nItem][IT_TS][TS_APLIIVA]$"1/3/4/5" .And. aNfItem[nItem][IT_MARGEM] > 0 ) .Or. ;
				(lF4ApliIVA .And. aNFItem[nItem][IT_TS][TS_APLIIVA]$"1/3" .And. lSTAtacVar) .Or. ;
				(lF4ApliIVA .And. aNFItem[nItem][IT_TS][TS_APLIIVA]$"1/3" .And. lSTConfCE)

				IF aNFItem[nItem][IT_TS][TS_APLIIVA] == "5" .And. aNFItem[nItem][IT_TS][TS_OUTPERC] > 0 .And. nBsICMSt>=(aNfItem[nItem][IT_BASESOL] * (aNFItem[nItem][IT_TS][TS_OUTPERC]/100))
					aNfItem[nItem][IT_BASESOL] := nBsICMSt*(1+(aNfItem[nItem][IT_MARGEM]/100))
					aNfItem[nItem][IT_PAUTST]  := 0
				ElseIF  aNFItem[nItem][IT_TS][TS_APLIIVA] == "4" .And. aNFCab[NF_UFDEST]$aSX6[MV_UFPAUTA].And. nBsICMSt>(aNfItem[nItem][IT_BASESOL] * (75/100))
				    aNfItem[nItem][IT_BASESOL] := nBsICMSt*(1+(aNfItem[nItem][IT_MARGEM]/100))
					aNfItem[nItem][IT_PAUTST]  := 0
				ElseIF aNFItem[nItem][IT_TS][TS_APLIIVA]$"1/3" .And. ( nBsICMSt >= aNfItem[nItem][IT_BASESOL] )
					aNfItem[nItem][IT_BASESOL] := nBsICMSt*(1+(aNfItem[nItem][IT_MARGEM]/100))
					aNfItem[nItem][IT_PAUTST]  := 0
				ElseIF aNFItem[nItem][IT_TS][TS_APLIIVA] == "3"
					aNfItem[nItem][IT_BASESOL] := nBsICMSt*(1+(aNfItem[nItem][IT_MARGEM]/100))
					aNfItem[nItem][IT_PAUTST]  := 0
				EndIf
			EndIf
			// Calculo do valor total para acertar o ICMS de Pauta
			// A pauta nao pode ser menor que o valor comercializado
			If !aSX6[MV_ICMPAUT]
				If ( nBsICMSt > aNfItem[nItem][IT_BASESOL] )
					aNfItem[nItem][IT_BASESOL] := nBsICMSt
					aNfItem[nItem][IT_PAUTST]  := 0
				EndIf
			EndIf
			//Confaz 21/2011. As condicoes para o calculo do ICMS-ST sao para as UF's contidas no parametro
			//MV_UFPST21, para clientes do tipo Consumidor Final e para Vendas nao presenciais, verificado pelo campo F4_VENPRES.
			If (aNFCab[NF_UFDEST] <> aNFCab[NF_UFORIGEM] .And. aNFItem[nItem][IT_TS][TS_VENPRES] <> "1" .And. aNFCab[NF_UFDEST] $ cMV_UFPST .And. cTipoCliFor == "F" .And. ;
				(aNFCab[NF_LINSCR] .Or. SA1->A1_CONTRIB == "2") .And. aNFItem[nItem][IT_TS][TS_MKPSOL]=="1" ) .And. !lNConf21
				aNfItem[nItem][IT_BASESOL]	:= Iif( nReduzICMS > 0 .And. aSX6[MV_BASERET] == "S" , aNfItem[nItem][IT_BASEICM] , aNfItem[nItem][IT_BICMORI] )
			Endif
		EndIf
		If aNFItem[nItem][IT_TS][TS_IPIVFCF]$"34"
			aNfItem[nItem][IT_BASESOL]+= aNfItem[nItem][IT_IPIVFCF]
		EndIf
		//Base de Calculo do ICMS ST nas operacoes substituidos do MT,
		//com base no CNAE do Anexo XI e XVI do RICMS/MT de acordo com
		//os art. 87-J-6 ao art. 87-J-16 do RICMS/MT e decreto 392/2011
		If lRegESim .And. aPos[FP_A1_REGESIM] .And. aPos[FP_A2_REGESIM] .And. aPos[FP_A1_PERCATM];
			.And. aPos[FP_B1_REGESIM] .And. aNFItem[nItem][IT_TS][TS_MKPCMP]<>"1"
			//Base Original de ICMS.
			nBaseICM := aNfItem[nItem][IT_BASEICM] + Iif(aNFItem[nItem][IT_TS][TS_INCIDE] == "N", aNfItem[nItem][IT_VALIPI], 0)
			nBaseOri := aNfItem[nItem][IT_BICMORI] + Iif(aNFItem[nItem][IT_TS][TS_INCIDE] == "N", aNfItem[nItem][IT_VALIPI], 0)
			If ( aNfCab[NF_OPERNF]=="S" .And. !aNFCab[NF_TIPONF] $ "DB" ) .Or. ( aNfCab[NF_OPERNF]=="E" .And. aNFCab[NF_TIPONF] $ "DB" )
				If aNfCab[NF_REGESIM]=="1" .And. aNfItem[nItem][IT_PRD][SB_REGESIM] == "1"
					lRet := .T.
				EndIf
			ElseIf ( aNfCab[NF_OPERNF]=="E" .And. !aNFCab[NF_TIPONF] $ "DB" ) .Or. ( aNfCab[NF_OPERNF]=="S" .And. aNFCab[NF_TIPONF] $ "DB" )
				If aNfCab[NF_REGESIM] == "1" .And. aNfItem[nItem][IT_PRD][SB_REGESIM] == "1"
					lRet := .T.
				EndIf
			EndIf
			nValIEst := aNfItem[nItem][IT_VALICM]
			If cSimpNac $ "1/2" .And. (aNFCab[NF_OPERNF] == "S" .Or. (aNfCab[NF_OPERNF]=="E" .And. aNFCab[NF_TIPONF] $ "DB"))
				nBaseICM := aNfItem[nItem][IT_BASEICM]

				/* Na devolucao de venda faco a inversao das UF's para
				que a aliquota utilizada no calculo seja a mesma da venda,
				visto que ela nao eh gravada em nenhum campo. Desta forma o
				valor de nValIEst eh calculado na devolucao seguindo a mesma
				logica da NF original. */
				If aNFCab[NF_OPERNF] == "S"
					cUfOri := aNFCab[NF_UFORIGEM]
					cUfDest := aNFCab[NF_UFDEST]
				ElseIf aNfCab[NF_OPERNF] == "E" .And. aNFCab[NF_TIPONF] $ "DB"
					cUfOri :=  aNFCab[NF_UFDEST]
					cUfDest :=  aNFCab[NF_UFORIGEM]
				EndIf

				// Calculo da Aliquota de ICMS
				If ( cUfOri $ aSX6[MV_NORTE] )
					nAliqEst := 12 //MV_ICMTRF
				Else
					nAliqEst := IIf( cUfDest $ aSX6[MV_NORTE] , 7 , 12 ) //MV_ICMTRF
				EndIf

				nValIEst := aNfItem[nItem][IT_BASEICM]*(nAliqEst/100)

				If aSX6[MV_RNDICM]
					nValIEst := Round(nValIEst,2)
				Else
					nValIEst := NoRound(nValIEst,2)
				EndIf
			EndIf
			Do Case
				//Saida fora de MT
				Case aNFCab[NF_UFORIGEM] <> "MT" .And. aNFCab[NF_UFDEST] == "MT" .And. lRet
					If aNfCab[NF_OPERNF]=="E" .Or. (aNfCab[NF_OPERNF]=="S" .And. !aNFCab[NF_TIPONF]$"DB")
						aNfItem[nItem][IT_BASRESI] := nValIEst+( nBaseOri *(nPerCaTM/100))
						aNfItem[nItem][IT_VALRESI] := nBaseOri *(nPerCaTM/100)
					EndIf
				//Entrada fora MT
				Case aNFCab[NF_UFORIGEM] == "MT" .And. aNFCab[NF_UFDEST] <> "MT" .And. lRet
					If aNfCab[NF_OPERNF]=="E" .Or. (aNfCab[NF_OPERNF]=="S" .And. aNFCab[NF_TIPONF]$"DB")
						nPerCaTM := IIf(aNFCab[NF_TIPONF]$"DB" .And. aNFCab[NF_PERCATM] > 0, Iif( aNFItem[nItem][IT_TS][TS_PERCATM]>0 , aNFItem[nItem][IT_TS][TS_PERCATM] , aNfCab[NF_PERCATM] ), nPerCaTM)
						aNfItem[nItem][IT_BASRESI] := nValIEst+((nBaseOri*nPerCaTM)/100)
						aNfItem[nItem][IT_VALRESI] := nBaseOri*(nPerCaTM/100)
					EndIf
				//Saida/Entrada MT
				Case aNFCab[NF_UFORIGEM] == "MT" .And. aNFCab[NF_UFDEST] == "MT" .And. lRet
					If aNfCab[NF_OPERNF]=="S" .Or. ( aNfCab[NF_OPERNF]=="E" .And. aNFCab[NF_TIPONF] $ "D" .And. aNFCab[NF_CLIFOR] == "C" .And.;
														  SA1->A1_REGESIM == "1" .And. !Empty(aNFItem[nItem][IT_RECORI]) )
						aNfItem[nItem][IT_BASRESI] := nValIEst + ( nBaseOri * (aNfItem[nItem][IT_MARGEM]/100) ) * (Iif(aNFItem[nItem][IT_TS][TS_PERCATM]>0,aNFItem[nItem][IT_TS][TS_PERCATM],aNfCab[NF_PERCATM])/100)
						aNfItem[nItem][IT_VALRESI] := ( nBaseOri * (aNfItem[nItem][IT_MARGEM]/100) ) * (Iif(aNFItem[nItem][IT_TS][TS_PERCATM]>0,aNFItem[nItem][IT_TS][TS_PERCATM],aNfCab[NF_PERCATM])/100)
					Else
						aNfItem[nItem][IT_BASRESI] := nValIEst+(nBaseICM*(aNfItem[nItem][IT_MARGEM]/100))*(nPerCaTM/100)  // /(MV_ICMPAD/100)
						aNfItem[nItem][IT_VALRESI] := (nBaseICM*(aNfItem[nItem][IT_MARGEM]/100) ) * (nPerCaTM/100)
					EndIf
			EndCase
		EndIf
	Else
		If 	!aNFCab[NF_TIPONF]$"DB"
			aNfItem[nItem][IT_BASESOL]	:= 0
		EndIf
	EndIf

	//Tratamento para atender o DECRETO N 35.679, de 13 de Outubro de 2010 - Pernambuco para o Ramo de Auto Peças onde no caso de revenda dentro
	//do estado deverá utilizar o custo de entrada para calcular a Base de Cálculo

	If aNFCab[NF_OPERNF]=="S" .And. aSX6[MV_ESTADO] == "PE" .And. aNfCab[NF_UFDEST] == "PE"  .And. aNfItem[nItem][IT_TS][TS_CUSENTR] =="1"

		//Posiciono na tabela SD1 para buscar o valor do Custo de Aquisição mais recente
		DbSelectArea("SD1")
		SD1->(DbSetOrder(5))
		SD1->(DbSeek(xFilial("SD1")+ aNfItem[nItem][IT_PRODUTO]+'ZZ',.T.))
		SD1->(DbSkip(-1))
		IF SD1->D1_COD == aNfItem[nItem][IT_PRODUTO]
			//Valor do custo da aquisição mais recente
			//Conforme Paragrafo 4 do Art. 1 do Decreto não devem ser considerados os descontos ou abatimentos concedidos para determinação
			//do custo da aquisição da Mercadoria
			nCustEnt := SD1->D1_CUSTO + SD1->D1_VALDESC
			If aSX6[MV_FISXMVA] .And. cPaisLoc == "BRA"
				nMrgAjsEn:= SD1->D1_MARGEM
			EndIf

			//Cálculo Base de cálculo ST
			//Somente realizo o cálculo quando o MVA for ajustado
			If nMrgAjsEn > 0
				nBsSTCalc += nCustEnt + ( ( nCustEnt * nMrgAjsEn ) / 100 )
				aNfItem[nItem][IT_BASESOL]	:= nBsSTCalc
			EndIf
		EndIf
	EndIf
Else
	aNfItem[nItem][IT_BASESOL]	:= 0
EndIf

IF aNFItem[nItem][IT_TS][TS_F4_STLIQ] == "1" .AND. aNfItem[nItem][IT_UFXPROD][UFP_MARGSTLIQ] > 0 .AND. (aNfItem[nItem][IT_UFXPROD][UFP_ALIQSTLIQ] >0 .Or. aNfItem[nItem][IT_UFXPROD][UFP_ADICST] > 0)
	If( nReduzICMS > 0 .And. aNFItem[nItem][IT_TS][TS_APLREDP]=="1")
		aNfItem[nItem][IT_BASESOL]	:=	(aNfItem[nItem][IT_BASEICM] +  Iif(aNFItem[nItem][IT_TS][TS_INCIDE] == "N", aNfItem[nItem][IT_VALIPI],0))  * ( 1 + ( aNfItem[nItem][IT_UFXPROD][UFP_MARGSTLIQ]/100 ))
	Else//Recompõe a base do ICMS ST
		aNfItem[nItem][IT_BASESOL]	:=	(aNfItem[nItem][IT_BASEICM]*100/Iif(nReduzICMS <> 0, nReduzICMS,100) +  Iif(aNFItem[nItem][IT_TS][TS_INCIDE] == "N", aNfItem[nItem][IT_VALIPI],0))  * ( 1 + ( aNfItem[nItem][IT_UFXPROD][UFP_MARGSTLIQ]/100 ))
	Endif
EndIF
// Tratamento para o calculo diferenciado de Base para o Estado
// de RN Artigo 944-I.
If aSX6[MV_ALRN944] .And. aPos[FP_B1_PRN944I]
	If aNfItem[nItem][IT_PRD][SB_PRN944I] == "S"
		nBsICMSt := IIf(aNFItem[nItem][IT_TS][TS_AGREG]<>"F",IIf (aNfItem[nItem][IT_PRCMEDP] <= 0, aNfItem[nItem][IT_VALMERC], aNfItem[nItem][IT_PRCMEDP]) - IIf(aNFItem[nItem][IT_TS][TS_AGREG]$"DR",aNfItem[nItem][IT_DEDICM],0),0)+aNfItem[nItem][IT_VALIPI]+aNfItem[nItem][IT_FRETE]+aNfItem[nItem][IT_SEGURO]+aNfItem[nItem][IT_DESPESA]
		aNfItem[nItem][IT_BASESOL]	:= nBsICMSt
	EndIf
EndIf

If aPE[PE_MACSOLICMS]
	aMaSolICMS := ExecBlock("MACSOLICMS",.f.,.f.,{aNfCab[NF_OPERNF],nItem,aNfItem[nItem][IT_BASESOL],aNfItem[nItem][IT_ALIQSOL],aNfItem[nItem][IT_VALSOL]})
	IF ValType(aMaSolICMS) == "A"
		IF Len(aMaSolICMS) == 3
			aNfItem[nItem][IT_BASESOL] := aMaSolICMS[1]
			aNfItem[nItem][IT_ALIQSOL] := aMaSolICMS[2]
			aNfItem[nItem][IT_VALSOL]  := aMaSolICMS[3]
		Endif
	Endif
Endif

MaItArred(nItem,{"IT_BASESOL"})

//Para o calculo do FECP de cada ESTADO e necessario as BASES DE CALCULO do ICMS e do ICMS SOLIDARIO
//afim de majorar as aliquotas dos mesmos, por este motivo a chamada GERAL da funcao de calulo do FECP
//deve estar no fim das funcoes de BASE do ICMS e ICMS SOLIDARIO e em nenhum outro ponto da MATXFIS.
//MaFisFECP(nItem, cCampo)

Return(Nil)

/*/
MaAliqSol- Edson Maricate -08.12.1999
Calculo da Aliquota para operacoes de ICMS Solidario.
/*/
Static Function MaAliqSoli(nItem)

Local nMvIcmPad		:= aSX6[MV_ICMPAD]
Local nAliquota 	:= If ( aNfItem[nItem][IT_PRD][SB_PICM] == 0 , IIf(aNFItem[nItem][IT_TS][TS_ICM]<>"N" .Or. aNFItem[nItem][IT_TS][TS_AGREG]$"B",aNfItem[nItem][IT_ALIQICM],MaAliqIcms(nItem,.T.)), aNfItem[nItem][IT_PRD][SB_PICM] )
Local nAliqInt 		:= If ( aNfItem[nItem][IT_PRD][SB_PICM] == 0 , nMvIcmPad ,  aNfItem[nItem][IT_PRD][SB_PICM] )//Alíquota Interna
Local nAlqFecopST   := Iif( aNfItem[nItem][IT_PRD][SB_FECOP] == "1" , aNfItem[nItem][IT_PRD][SB_ALFECST] , 0 )
Local lSTD2			:= aPos[FP_D2_ALIQSOL]
Local lSTD1			:= aPos[FP_D1_ALIQSOL]
Local cMvEstado		:= aSX6[MV_ESTADO]
Local lSTAtacVar	:= IIf( aNFItem[nItem][IT_TS][TS_ATACVAR] == "1" .And. aNfItem[nItem][IT_PRD][SB_PICMENT] == 0 .And. cMvEstado == "CE" .And. aNFCab[NF_OPERNF] == "E" , .T. , .F.)
Local lSTConfCE 	:= IIf( aNFItem[nItem][IT_TS][TS_STCONF] == "1" .And. aNfItem[nItem][IT_PRD][SB_PICMRET] == 0 .And. cMvEstado == "CE" .And. aNFCab[NF_OPERNF] == "S" , .T. , .F.)
Local lAliqExc      := .F.
Local cDestino  	:= aNFCab[NF_UFDEST]
Local cSimpNac		:= aSX6[MV_CODREG]
Local cAliqDifST   	:= "2"
Local cMvEstIcm		:= aSX6[MV_ESTICM]
Local lAlFecp		:= .F.
Local lCalcula   	:= .T.
Local lAliqEsp     := .F.

If !Empty( ANFCab[NF_PNF_UF] ) .And. (AllTrim(aNFCab[NF_ESPECIE]) $ "CTR/CTE".Or. "NFST"$AllTrim(aNFCab[NF_ESPECIE])) .And. aNFCab[NF_OPERNF] == "S"
	nAliquota 	:= MaAliqIcms(nItem,.T.)
Else
	If aNFCab[NF_TIPONF] == "D"
		nAliquota 	:= MaAliqOrig(nItem)
		If !Empty(aNFItem[nItem][IT_RECORI])
			If ( aNFCab[NF_CLIFOR] == "C" )
				If lSTD2
					dbSelectArea("SD2")
					MsGoto( aNFItem[nItem][IT_RECORI] )
					nAliquota  	:= SD2->D2_ALIQSOL
					lCalcula := .F.
				Endif
			Else
				If lSTD1 .And. cPaisLoc == "BRA"
					dbSelectArea("SD1")
					MsGoto( aNFItem[nItem][IT_RECORI] )
					nAliquota  := SD1->D1_ALIQSOL
					lCalcula := .F.
				Endif
			Endif
		EndIf
	Else
		If ( aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST] )
			nAliquota 	:= MaAliqDest(nItem)
		EndIf
	EndIf
EndIf

If lCalcula

	If ( !Empty(aNFItem[nItem][IT_EXCECAO]) )
		If ( aNFItem[nItem][IT_EXCECAO][6] ) <> 0
			nAliquota 	:= aNfItem[nItem][IT_EXCECAO][6]
		EndIf
	EndIf

	//Tratamento Antecipacao ICMS  - Aliquota interna deve ser aplicada ao cálculo do ICMS ST
	If aNFItem[nItem][IT_TS][TS_ANTICMS] == "1"
		If ( aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST] ) .And. aNFCab[NF_TPCLIFOR] <> "X"
			nAliquota 	:= If ( aNfItem[nItem][IT_PRD][SB_PICM] == 0 , nMvIcmPad ,  aNfItem[nItem][IT_PRD][SB_PICM] )//Alíquota Interna
			// Verifica as Excecoes fiscais
			If ( !Empty(aNFItem[nItem][IT_EXCECAO]) .And. aNfItem[nItem][IT_EXCECAO][7] <> "S")
				If ( aNFItem[nItem][IT_EXCECAO][1] ) <> 0
					If  aNFCab[NF_OPERNF] == "E" .And. aNfItem[nItem][IT_EXCECAO][31] == "2"//F7->F7_UFBUSCA inverte a aliquota interna para o destino
						nAliquota :=  aNFItem[nItem][IT_EXCECAO][6]	//Aliq. de ICMS Interna do destinatário.
					Else
						nAliquota :=  aNFItem[nItem][IT_EXCECAO][1]   //Aliq. de ICMS Interna
					Endif
				EndIf
			EndIf
		EndIf
	EndIf

	MaFisFECP(nItem,,,"ALQ")

	// Nesta condicao especifica, quando a variavel nAliquota possui o conteudo de IT_ALIQICM (Verificar declaracao),
	// se for uma operacao interna e ja houve a majoracao de IT_ALIQICM (aNfItem[nItem][IT_ALIQFECP] > 0), nao posso
	// majorar novamente pois a referencia IT_ALIQICM ja veio majorada.
	If !(aNfItem[nItem][IT_PRD][SB_PICM] == 0 .And. (aNFItem[nItem][IT_TS][TS_ICM]<>"N" .Or. aNFItem[nItem][IT_TS][TS_AGREG]$"B") .And. aNfCab[NF_UFORIGEM] == aNfCab[NF_UFDEST] .And. aNfItem[nItem][IT_ALIQFECP] > 0 .And. nAliquota == aNfItem[nItem][IT_ALIQICM])
		If	aNfItem[nItem][IT_ALFCST] > 0
			nAliquota += aNfItem[nItem][IT_ALFCST]
		EndIf
	EndIf

	//Tratamento de aliquotas de ICMS-ST conforme decreto 29.560/2008 para o estado do Ceara
	If lSTAtacVar
		If Substr(SM0->M0_CNAE,1,2) == "46" // Atacadistas
			If nAliqInt == 7
				If aNFCab[NF_UFORIGEM] == "CE" // Ceara
					nAliquota := 2.70
				ElseIf aNFCab[NF_UFORIGEM] $ "SP|RJ|MG|PR|SC|RS" // Sul e Sudeste exceto ES
					nAliquota := 6.80
				Else
					nAliquota := 4.70 // Norte, Nordeste e Centro Oeste e ES
				EndIf
			ElseIf nAliqInt == 12
				If aNFCab[NF_UFORIGEM] == "CE" // Ceara
					nAliquota := 4.60
				ElseIf aNFCab[NF_UFORIGEM] $ "SP|RJ|MG|PR|SC|RS" // Sul e Sudeste exceto ES
					nAliquota := 11.60
				Else
					nAliquota := 8.10 // Norte, Nordeste e Centro Oeste e ES
				EndIf
			ElseIf nAliqInt == 17
				If aNFCab[NF_UFORIGEM] == "CE" // Ceara
					nAliquota := 6.50
				ElseIf aNFCab[NF_UFORIGEM] $ "SP|RJ|MG|PR|SC|RS" // Sul e Sudeste exceto ES
					nAliquota := 16.50
				Else
					nAliquota := 11.50 // Norte, Nordeste e Centro Oeste e ES
				EndIf
			ElseIf nAliqInt == 25
				If aNFCab[NF_UFORIGEM] == "CE" // Ceara
					nAliquota := 7.26
				ElseIf aNFCab[NF_UFORIGEM] $ "SP|RJ|MG|PR|SC|RS" // Sul e Sudeste exceto ES
					nAliquota := 33
				Else
					nAliquota := 25.85 // Norte, Nordeste e Centro Oeste e ES
				EndIf
			Else
				nAliquota := 0
			EndIf

			lAliqEsp := .T. // Flag de aliquota especifica p/ controle da majoracao.

		ElseIf Substr(SM0->M0_CNAE,1,2) == "47" // Varejistas
			If nAliqInt == 7
				If aNFCab[NF_UFORIGEM] == "CE" // Ceara
					nAliquota := 1.05
				ElseIf aNFCab[NF_UFORIGEM] $ "SP|RJ|MG|PR|SC|RS" // Sul e Sudeste exceto ES
					nAliquota := 5.52
				Else
					nAliquota := 3.46 // Norte, Nordeste e Centro Oeste e ES
				EndIf
			ElseIf nAliqInt == 12
				If aNFCab[NF_UFORIGEM] == "CE" // Ceara
					nAliquota := 1.80
				ElseIf aNFCab[NF_UFORIGEM] $ "SP|RJ|MG|PR|SC|RS" // Sul e Sudeste exceto ES
					nAliquota := 9.46
				Else
					nAliquota := 5.93 // Norte, Nordeste e Centro Oeste e ES
				EndIf
			ElseIf nAliqInt == 17
				If aNFCab[NF_UFORIGEM] == "CE" // Ceara
					nAliquota := 2.60
				ElseIf aNFCab[NF_UFORIGEM] $ "SP|RJ|MG|PR|SC|RS" // Sul e Sudeste exceto ES
					nAliquota := 13.40
				Else
					nAliquota := 8.40 // Norte, Nordeste e Centro Oeste e ES
				EndIf
			ElseIf nAliqInt == 25
				If aNFCab[NF_UFORIGEM] == "CE" // Ceara
					nAliquota := 7.26
				ElseIf aNFCab[NF_UFORIGEM] $ "SP|RJ|MG|PR|SC|RS" // Sul e Sudeste exceto ES
					nAliquota := 33
				Else
					nAliquota := 25.85 // Norte, Nordeste e Centro Oeste e ES
				EndIf
			Else
				nAliquota := 0
			EndIf

			lAliqEsp := .T. // Flag de aliquota especifica p/ controle da majoracao.

		EndIf

		If aNFCab[NF_SIMPNAC] =="1"
			If aNFCab[NF_UFORIGEM] == "CE" // Ceara
				nAliquota += 5
			ElseIf aNFCab[NF_UFORIGEM] $ "SP|RJ|MG|PR|SC|RS" // Sul e Sudeste exceto ES
				nAliquota += 7
			Else
				nAliquota += 12
			EndIf

			lAliqEsp := .T. // Flag de aliquota especifica p/ controle da majoracao.

		EndIf
	EndIf

	// Tratamento de aliquotas de ICMS-ST conforme decreto 28.443/2006 para o estado do Ceara
	// Conforme o decreto que visa atender operacoes internas de comercio, atacado, varejo e
	// industria do estado do Ceará atraves de aliquotas especificas de ICMS-ST.
	If lSTConfCE
		If aNFCab[NF_UFDEST] == "CE" //Ceara
			nAliquota := 3
			lAliqEsp := .T. // Flag de aliquota especifica p/ controle da majoracao.
		EndIf
	EndIf

	// Tratamento para o calculo diferenciado de aliquota para o
	// estado de RN Artigo 944-I.
	If aSX6[MV_ALRN944] .And. aPos[FP_B1_PRN944I]
		If aNFCab[NF_UFORIGEM] == "RN" .And. aNfItem[nItem][IT_PRD][SB_PRN944I] == "S"
			nAliquota:= aSX6[MV_ASRN944]
			lAliqEsp := .T. // Flag de aliquota especifica p/ controle da majoracao.
		Else
			If aNfItem[nItem][IT_PRD][SB_PRN944I] == "S"
				nAliquota:= aSX6[MV_AERN944]
				lAliqEsp := .T. // Flag de aliquota especifica p/ controle da majoracao.
			EndIf
		EndIf
	EndIF

	//Simples Nacional - Aliquota ICMS solidario.
	If cSimpNac $ "1/2" .And. aNFCab[NF_OPERNF] == "S"
		//Busca RecNo do Produto para verificar campo que trata a aliquota interna
		//a ser tributada para o Simples Nacional através de Exceção Fiscal.
		//O campo deve ser informado no parâmetro MV_ALQDFB1.
		If aNFCab[NF_UFORIGEM] == aNFCab[NF_UFDEST]
			If aPos[FP_MV_ALQDFB1]
				cAliqDifST := aNfItem[nItem][IT_PRD][SB_ALQDFB1]
			Endif

			//Se houver aliquota na excecao fiscal esta deve prevalecer a aliquota do simples nacional.
			If !Empty(aNFItem[nItem][IT_EXCECAO]) .And. aNFItem[nItem][IT_EXCECAO][6] <> 0
				lAliqExc := .T.
			EndIf

			If !lAliqExc .And. cAliqDifST $ "2 "
				nAliquota := Val(Subs(cMvEstIcm,AT(cDestino,cMvEstIcm)+2,5))
				If aNfItem[nItem][IT_ALFCST] > 0
					nAliquota += aNfItem[nItem][IT_ALFCST]
				EndIf
				lAliqEsp := .F.
			EndIf
		Endif
	EndIf

	// FECOP - CEARA - Caso no SB1 seja configurado para calcular FECOP a aliquota do Solidario sera Majorada em 2% - opcoes informadas no SB1 de 19 % ou  27%
	If (nAlqFecopST == 19 .Or. nAlqFecopST == 27) .And. aSX6[MV_ESTADO] == "CE" .And. aNFCab[NF_UFDEST] == "CE" .And. aNfCab[NF_OPERNF] == "S"
		nAliquota := nAlqFecopST
		lAliqEsp := .T. // Flag de aliquota especifica p/ controle da majoracao.
	EndIf

	// Controle para que caso tenha sido atribuida alguma aliquota
	// especifica para calculo do ICMS-ST o calculo do FCP nao seja
	// efetuado.
	If lAliqEsp .And. aNfItem[nItem][IT_ALFCST] > 0
		aNfItem[nItem][IT_BSFCPST] := 0
		aNfItem[nItem][IT_ALFCST]  := 0
		aNfItem[nItem][IT_VFECPST] := 0
	EndIf

EndIf

aNFitem[nItem][IT_ALIQSOL] := nAliquota

Return(nAliquota)

/*/
MaFisVSol-Edson Maricate  -08.12.1999
Esta rotina tem como objetivo calcular o valor do ICMS retido/solidario conforme definido do regulamento de ICMS.
/*/
Static Function MaFisVSOL(nItem,cCampo)

Local lDevolRet 	:= aSX6[MV_DEVRET]
Local cMVEstado		:= aSX6[MV_ESTADO]
Local lSTAtacVar	:= IIf( aNFItem[nItem][IT_TS][TS_ATACVAR] == "1" .And. aNfItem[nItem][IT_PRD][SB_PICMENT] == 0 .And. cMVEstado == "CE" .And. aNFCab[NF_OPERNF] == "E" , .T. , .F.)
Local lSTConfCE 	:= IIf( aNFItem[nItem][IT_TS][TS_STCONF] == "1" .And. aNfItem[nItem][IT_PRD][SB_PICMRET] == 0 .And. cMVEstado == "CE" .And. aNFCab[NF_OPERNF] == "S" , .T. , .F.)
Local nRedDec35701 	:= 0
Local cSimpNac		:= aSX6[MV_CODREG]
Local nAliIter  	:= 0
Local nRedICCE		:= 0
Local nRedSTCE		:= 0
Local lRegESim	    := aSX6[MV_REGESIM]
Local cMV_UFPST	    := aSX6[MV_UFPST21]
Local cTipoCliFor   := IIf( !Empty(aNfCab[NF_PNF_TPCLIFOR]) , aNfCab[NF_PNF_TPCLIFOR] , aNfCab[NF_TPCLIFOR] )
Local nRedBaST	  	:= Iif(Len(aNFItem[nItem][IT_EXCECAO]) > 0 .And. aNFItem[nItem][IT_EXCECAO][26] > 0,aNFItem[nItem][IT_EXCECAO][26],aNFItem[nItem][IT_TS][TS_BSICMST])
Local cExceRes13	:=	"6107|6108|6929"
//Tratamento específico de PB para ignorar o tratamento para venda não presencial
Local lNConf21	  := Iif( aNfCab[NF_UFDEST]=="PB" .And. aNfCab[NF_VTOTPED]>0 .And. aNfCab[NF_VTOTPED]<500, .T. ,.F. )
Local nReduzICMS  := 0
Local lCalcula := .T.
Local lConfaz21    := (aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST] .And. aNFItem[nItem][IT_TS][TS_VENPRES] <> "1" .And. aNFCab[NF_UFDEST] $ cMV_UFPST .And. aNFItem[nItem][IT_TS][TS_MKPSOL]=="1" .And. !lNConf21 .And. (aNFCab[NF_LINSCR] .Or. SA1->A1_CONTRIB == "2"))
Local lEntSemICM := (aNFCab[NF_OPERNF] == "E" .And. !aNFCab[NF_TIPONF] $ "DB" .And. aNFCab[NF_SIMPNAC] == "1" .And. (aNFItem[nItem][IT_TS][TS_ICM] == "N" .Or. !cSimpNac $ "1/2"))
Local cMVStAliq     := aSX6[MV_UFSTALQ]
Local lDifCont	:= aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST] .And. aNFCab[NF_UFDEST]$aSX6[MV_BASDSSE] .And. aNFCab[NF_UFDEST]$aSX6[MV_UFBDST] .And. ((aNfCab[NF_OPERNF] == "S" .And. aNfCab[NF_TPCLIFOR] == "F" ) .Or. (aNfCab[NF_OPERNF] == "E" .And. aNFItem[nItem][IT_TS][TS_CONSUMO] == "S"))
Local nAliqSol     := 0
Local aMaSolICMS  	:= {}

DEFAULT cCampo := ""

// Carrega a reducao da base do ICMS
If !Empty(aNFitem[nItem,IT_EXCECAO]) .And. aNfItem[nItem,IT_EXCECAO,14] > 0
	nReduzICMS := aNfItem[nItem,IT_EXCECAO,14]
Else
	nReduzICMS := aNFItem[nItem][IT_TS][TS_BASEICM]
EndIf

If !(aNFitem[nItem][IT_TIPONF ]$'IP')

	If aNfItem[nItem][IT_BASESOL] <> 0

		If aNFCab[NF_TIPONF] $ "DB" .Or. aNFItem[nItem][IT_TS][TS_PODER3] =="D"
			If !Empty(aNFItem[nItem][IT_RECORI])
				If aNFCab[NF_TIPONF] $ "DB"
					If ( aNFCab[NF_CLIFOR] == "C")
						dbSelectArea("SD2")
						MsGoto(aNFItem[nItem][IT_RECORI])
						If (SD2->D2_ICMSRET > 0 .Or. Abs(aNfItem[nItem][IT_VALSOL]-SD2->D2_ICMSRET)<=1 .Or. lDevolRet) .And. aNfItem[nItem][IT_QUANT] = SD2->D2_QUANT .And. Iif(!lDevolRet ,SD2->D2_VALFRE+SD2->D2_SEGURO+SD2->D2_DESPESA==0,SD2->D2_ICMSRET > 0)
							aNfItem[nItem][IT_VALSOL] := SD2->D2_ICMSRET
							lCalcula := .F.
						Else
							If (!aNfCab[NF_CALCSUF]$'IN ' .And. aSX6[MV_DESCZF] .And. aSX6[MV_DESZFPC]) .Or. aNfItem[nItem][IT_QUANT] <> SD2->D2_QUANT
								aNfItem[nItem][IT_VALSOL] := (SD2->D2_ICMSRET / SD2->D2_QUANT) * aNfItem[nItem][IT_QUANT]
								lCalcula := .F.
							EndIf
						EndIf
					Else
						dbSelectArea("SD1")
						MsGoto(aNFItem[nItem][IT_RECORI])
						If (SD1->D1_ICMSRET > 0 .Or. Abs(aNfItem[nItem][IT_VALSOL]-SD1->D1_ICMSRET)<=1 .Or. lDevolRet) .And. aNfItem[nItem][IT_QUANT] = SD1->D1_QUANT .And. Iif(!lDevolRet ,SD1->D1_VALFRE+SD1->D1_SEGURO+SD1->D1_DESPESA==0,SD1->D1_ICMSRET > 0)
							aNfItem[nItem][IT_VALSOL]  := SD1->D1_ICMSRET
							If cPaisLoc == "BRA"
								aNFitem[nItem][IT_ALIQSOL] := SD1->D1_ALIQSOL
							EndIf
							lCalcula := .F.
						Else // Devolução parcial
							If (lDevolRet .And. SD1->D1_ICMSRET > 0) .And. (aNfItem[nItem][IT_QUANT] <> SD1->D1_QUANT)
								aNfItem[nItem][IT_VALSOL] := (SD1->D1_ICMSRET / SD1->D1_QUANT) * aNfItem[nItem][IT_QUANT]
								aNFitem[nItem][IT_ALIQSOL] := SD1->D1_ALIQSOL
								lCalcula := .F.
							EndIf
						EndIf

					EndIf
				Else
					If ( aNFCab[NF_CLIFOR] == "C")
						dbSelectArea("SD1")
						MsGoto(aNFItem[nItem][IT_RECORI])
						If (SD1->D1_ICMSRET > 0 .Or. Abs(aNfItem[nItem][IT_VALSOL]-SD1->D1_ICMSRET)<=1) .And. aNfItem[nItem][IT_QUANT] = SD1->D1_QUANT .And. Iif(!lDevolRet ,SD1->D1_VALFRE+SD1->D1_SEGURO+SD1->D1_DESPESA==0,SD1->D1_ICMSRET > 0)
							// 29.02.2012 - FNC 00000004584/2012-00
							// Independente do valor encontrado (via excecao fiscal ou nao), o valor da base
							// e o valor do imposto deve ser o mesmo da nota original
							aNfItem[nItem][IT_VALSOL] := SD1->D1_ICMSRET
							aNfItem[nItem][IT_BASESOL]:= SD1->D1_BRICMS
							lCalcula := .F.
						EndIf
					Else
						dbSelectArea("SD2")
						MsGoto(aNFItem[nItem][IT_RECORI])
						If (SD2->D2_ICMSRET > 0 .Or. Abs(aNfItem[nItem][IT_VALSOL]-SD2->D2_ICMSRET)<=1) .And. aNfItem[nItem][IT_QUANT] = SD2->D2_QUANT .And. Iif(!lDevolRet ,SD2->D2_VALFRE+SD2->D2_SEGURO+SD2->D2_DESPESA==0,SD2->D2_ICMSRET > 0)
							aNfItem[nItem][IT_VALSOL] := SD2->D2_ICMSRET
							aNfItem[nItem][IT_BASESOL]:= SD2->D2_BRICMS
							lCalcula := .F.
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf

		If lCalcula

			If aNFItem[nItem][IT_TS][TS_INCSOL]=="A"
				aNfItem[nItem][IT_VALSOL] := ( aNfItem[nItem][IT_BASESOL]*(aNfItem[nItem][IT_MARGEM]/100) )
				aNfItem[nItem][IT_VALSOL] := ( aNfItem[nItem][IT_VALSOL] * aNfItem[nItem][IT_ALIQSOL]/100 )
				If nRedBaST > 0
					aNfItem[nItem][IT_VALSOL] := (aNfItem[nItem][IT_VALSOL]*nRedBaST)/100
				EndIf
				MaItArred(nItem,{"IT_VALSOL"})
				aNfItem[nItem][IT_VALICM] -= Max(0,NoRound(aNfItem[nItem][IT_VALSOL]*aNfItem[nItem][IT_ALIQICM]/100,2))
				MaItArred(nItem,{"IT_VALICM"})
			Else
				//Base Dupla ST para Goias Art. 65 do RCTE/GO. // tdn.totvs.com/pages/releaseview.action?pageId=267797477
				IF aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST] .And. (aNFCab[NF_UFDEST]$cMVStAliq .OR. ;
				(aNfCab[NF_OPERNF] == "E" .And. aNFCab[NF_UFORIGEM]$cMVStAliq .And. aNFCab[NF_TIPONF] == "D"  ))  .And. ;
				((aNfCab[NF_OPERNF] == "S" .And. aNfCab[NF_TPCLIFOR] == "F" ) .Or. (aNfCab[NF_OPERNF] == "E" .And. aNFItem[nItem][IT_TS][TS_CONSUMO] == "S"))
					nAliqSol := aNfItem[nItem][IT_ALIQSOL]-aNFItem[nItem][IT_ALIQICM]
				Else
					nAliqSol := aNfItem[nItem][IT_ALIQSOL]
				Endif

				aNfItem[nItem][IT_VALSOL] :=  (aNfItem[nItem][IT_BASESOL] * nAliqSol)/100

				If aNFItem[nItem][IT_TS][TS_CRPRST] == 0
					MaItArred(nItem,{"IT_VALSOL"})
				EndIf
				//Tratamento implementado para os estados de MG e AM referente ao credito presumido do contratante do servico de transporte.
				//    Este tratamento deve refletir o calculo do ICMS Normal de direito do contratante e o ICMS Retido como debito na apuracao
				//    jah deduzindo o Credito presumido.
				//    Ex: Em uma operacao interna, a entrada do CTR no valor de R$1.000,00 deverah ficar da seguinte forma:
				//
				//    ICMS Normal
				//    BC = 1000, Aliq = 18, VL ICMS = 180
				//
				//    ICMS Retido
				//    BC = 1000, Aliq = 18, VL ICMS Ret = 144, CRED PRES = 36
				//
				//    OBS: Este valor retido de 144 eh lancado automaticamente na Apuracao de ICMS/ST em outros debitos devido a configuracao
				//         da TES(F4_CREDST=3)
				//         da TES(F4_CREDST=3)                                                                                                |
				If	!(cMVEstado$"MG/AM" .And.;
					aNFItem[nItem][IT_TS][TS_CRPRST]<>0 .And.;
					(AllTrim(aNFCab[NF_ESPECIE]) $ "CTR/CTE" .Or. "NFST"$AllTrim(aNFCab[NF_ESPECIE])))

					If !lSTAtacVar .And. !lSTConfCE

						//  Reduz o valor do ICMS conforme margem de reducao do ST, para subtrair do valor do ICMS-ST calculado.
						//  Tanto nos casos do campo TS_APLIRED = 1 ou TS_APLIRED = 3, o ICMS só é reduzido para o cálculo do ST
						//	o ICMS prórpio da operação não terá nenhuma alteração.
						If aNFItem[nItem][IT_TS][TS_APLIRED]=="1" .And. nRedBaST > 0
							aNfItem[nItem][IT_VALSOL] -= (aNfItem[nItem][IT_BICMORI] * nRedBaST/100)* Iif(aNFItem[nItem][IT_TS][TS_ALICRST]<=0, nAliqSol/100, aNFItem[nItem][IT_TS][TS_ALICRST]/100)
							// Neste caso iremos reduzir o valor do ICMS conforme foi a redução de BC da ST e/ou conforme a diferença da alíquota
							// vide Help do campo F4_APLIRED para mais detalhes
						ElseIf aNFItem[nItem][IT_TS][TS_APLIRED]=="3" .And. ( nRedBaST > 0)
							If aNfCab[NF_SUFRAMA] .And. aSX6[MV_RPCBIZF] .And.  aNfItem[nItem][IT_DESCZF]> 0 .And. (aNfItem[nItem][IT_DESCZFPIS] + aNfItem[nItem][IT_DESCZFCOF]) > 0 .And. aNfCab[NF_UFDEST]$aSX6[MV_RPCBIUF]
								IF (aNfItem[nItem][IT_DESCZF]-(aNfItem[nItem][IT_DESCZFPIS] + aNfItem[nItem][IT_DESCZFCOF]))==0 // Se tiver desconto apenas de pis/cof
									aNfItem[nItem][IT_VALSOL] -= (((aNfItem[nItem][IT_BICMORI]+((aNfItem[nItem][IT_DESCZFPIS] + aNfItem[nItem][IT_DESCZFCOF]))) * Iif(nRedBaST==0,100,nRedBaST)/100)* ((aNfItem[nItem][IT_ALIQICM]/100)) )
								Else
									aNfItem[nItem][IT_VALSOL] -= (((aNfItem[nItem][IT_BICMORI]+(aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFPIS] + aNfItem[nItem][IT_DESCZFCOF]))) * Iif(nRedBaST==0,100,nRedBaST)/100)* ((aNfItem[nItem][IT_ALIQICM]/100)) )
								EndIf
							Else
								aNfItem[nItem][IT_VALSOL] -= aNfItem[nItem][IT_BICMORI]* Iif(nRedBaST==0,100,nRedBaST)/100*  Iif(aNFItem[nItem][IT_TS][TS_ALICRST]<=0, aNfItem[nItem][IT_ALIQICM]/100, aNFItem[nItem][IT_TS][TS_ALICRST]/100)
							EndIf
							MaItArred(nItem,{"IT_VALSOL"})
						ElseIf aNFItem[nItem][IT_TS][TS_APLIRED]=="4"
							aNfItem[nItem][IT_VALSOL] -= (aNfItem[nItem][IT_BICMORI] * Iif(aNFItem[nItem][IT_TS][TS_ALICRST]<=0, nAliqSol/100, aNFItem[nItem][IT_TS][TS_ALICRST]/100))
						Else
							//Conforme a legislação Lei 9.480 de 17.12.2010 para o Estado de Mato Grosso,
							//Nao deduzir o valor do ICMS proprio no valor de ICMS ST.
							If  aNFItem[nItem][IT_TS][TS_ICMSTMT]=="1"
								IF aNFItem[nItem][IT_TS][TS_ALICRST]<=0
									aNfItem[nItem][IT_VALSOL] -= (aNfItem[nItem][IT_VALICM] + aNfItem[nItem][IT_DESCZF]  - aNfItem[nItem][IT_DESCZFPIS] - aNfItem[nItem][IT_DESCZFCOF])
								Else
									aNfItem[nItem][IT_VALSOL] -= (aNfItem[nItem][IT_BASEICM]* aNFItem[nItem][IT_TS][TS_ALICRST]/100) + (aNfItem[nItem][IT_DESCZF]  - aNfItem[nItem][IT_DESCZFPIS] - aNfItem[nItem][IT_DESCZFCOF])
								EndIf
							Endif
						EndIf
						//Decreto 35.701 de 19/10/2010 para vendas para o estado de Pernambuco
						If aNFItem[nItem][IT_TS][TS_PR35701]<>0 .And. aNFCab[NF_OPERNF]=='S' .And. aNFCab[NF_UFDEST]=="PE"
							If aNfItem[nItem][IT_PAUTST] <> 0
								nRedDec35701 := aNfItem[nItem][IT_VALICM] - ((aNfItem[nItem][IT_VALICM])* aNFItem[nItem][IT_TS][TS_PR35701]/100)
								aNfItem[nItem][IT_VALSOL] := ( (aNfItem[nItem][IT_BASESOL] * nAliqSol)/100 ) - nRedDec35701
							Else
								nRedDec35701 :=((aNfItem[nItem][IT_BASEICM] * aNfItem[nItem][IT_ALIQICM]/100)* aNFItem[nItem][IT_TS][TS_PR35701]/100)
								aNfItem[nItem][IT_VALSOL] := ( (aNfItem[nItem][IT_BASESOL] * nAliqSol)/100 ) - nRedDec35701
							Endif
							MaItArred(nItem,{"IT_VALSOL"})
						EndIf

						//PROTOCOLO ICMS 12/96:  Nas operações interestaduais originárias dos Estados signatários (São Paulo,
						//Rio de Janeiro, Minas Gerais, Rio Grande do Sul, Goiás, Paraná, Tocantins, Espírito Santo, Pernambuco, Bahia e Ceará),
						//destinados aos estabelecimentos situados no Estado do Ceará, fica atribuída ao estabelecimento remetente, na qualidade
						// de sujeito passivo por substituição, a responsabilidade pela retenção e recolhimento do ICMS conforme cálculo abaixo
						If aNFCab[NF_UFORIGEM] $ "SP|RJ|GO|RS|MG|BA|PR|ES|TO|PE|CE" .And. aNFCab[NF_UFDEST] == "CE" .And. aNFItem[nItem][IT_TS][TS_REDBCCE] <> 0
							nRedICCE := ((aNfItem[nItem][IT_BASEICM] * aNfItem[nItem][IT_ALIQICM]/100)* aNFItem[nItem][IT_TS][TS_REDBCCE]/100)

							nRedSTCE := (aNfItem[nItem][IT_BASESOL] * aNFItem[nItem][IT_TS][TS_REDBCCE]/100)
							nRedSTCE := (nRedSTCE * nAliqSol)/100

							aNfItem[nItem][IT_VALSOL] := nRedSTCE - nRedICCE
							MaItArred(nItem,{"IT_VALSOL"})
						Endif

						// Credito Outorgado concedido  no calculo do ICMS Retido nas
						// operacoes Interestaduais com o Estado de MG.
						//RETIRADO O TRATAMENTO DE ACORDO COM A FNC 00000019742/2014
						//	If aNFItem[nItem][IT_TS][TS_CROUTGO] > 0
						//		If aNfItem[nItem][IT_DESCZF] > 0
						//			aNfItem[nItem][IT_VALSOL] += (((aNfItem[nItem][IT_DESCZF]/aNfItem[nItem][IT_ALIQICM]) * 100) * aNFItem[nItem][IT_TS][TS_CROUTGO]/100)
						//		Else
						//			aNfItem[nItem][IT_VALSOL] += (aNfItem[nItem][IT_BASEICM] * aNFItem[nItem][IT_TS][TS_CROUTGO]/100)
						//		EndIf
						//	Endif
					EndIf
				EndIf
			EndIf

			//Credito Presumido(20%) sobre prestacao servico de transporte com ICMS/ST devido ao alienante/remetente
			//  da operacao - Decreto 44.147/2005 (MG)
			//- Esta sendo considerado a entrada deste credito como 100% do valor, sem a deducao (20%).Portanto devo
			//  subtrair do ICMS/ST Retido o valor de credito (20%), gravar na referencia LF_CRPRST que devera ser
			//  tratado na apresentacao das informacoes complementares da apuracao.
			If aNFItem[nItem][IT_TS][TS_CRPRST]<>0
				aNfItem[nItem][IT_VLCSOL]	:=	aNfItem[nItem][IT_VALSOL]
				aNfItem[nItem][IT_VALSOL]	-=	(aNfItem[nItem][IT_VALSOL]/100)*aNFItem[nItem][IT_TS][TS_CRPRST]
				MaItArred(nItem,{"IT_VALSOL"})
			EndIf

			//Cálculo de ICMS ST com carga líquida
			IF aNFItem[nItem][IT_TS][TS_F4_STLIQ] == "1"	.AND. aNfItem[nItem][IT_UFXPROD][UFP_MARGSTLIQ] > 0
    			//Se for Simples e a aliquota do simples estiver preenchida
    			If aNFCab[NF_SIMPNAC] == "1" .And. aNfItem[nItem][IT_UFXPROD][UFP_ADICST] > 0
    			      aNfItem[nItem][IT_ALIQSOL]  :=  aNfItem[nItem][IT_UFXPROD][UFP_ADICST]
                    aNfItem[nItem][IT_VALSOL]   :=  (aNfItem[nItem][IT_BASESOL] * aNfItem[nItem][IT_ALIQSOL]) / 100
               ElseIf aNfItem[nItem][IT_UFXPROD][UFP_ALIQSTLIQ] >0
    				If substr(aNfItem[nItem][IT_LIVRO][LF_CLASFIS],1,1) $ "1/2/3/5/8"
    					aNfItem[nItem][IT_ALIQSOL]	:=	aNfItem[nItem][IT_UFXPROD][UFP_ALIQSTLIQ] + aNfItem[nItem][IT_UFXPROD][UFP_RDCTIMP]
    					aNfItem[nItem][IT_VALSOL] 	:= 	(aNfItem[nItem][IT_BASESOL] * aNfItem[nItem][IT_ALIQSOL]) / 100
    				Else
    				   aNfItem[nItem][IT_ALIQSOL]	:=	aNfItem[nItem][IT_UFXPROD][UFP_ALIQSTLIQ]
    					aNfItem[nItem][IT_VALSOL] 	:= 	(aNfItem[nItem][IT_BASESOL] * aNfItem[nItem][IT_ALIQSOL]) / 100
    				EndIf
    			EndIF
    		EndIf

			//Simples Nacional - ICMS solidario.
			If ((cSimpNac $ "1/2" .And. (aNFCab[NF_OPERNF] == "S" .Or. (aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_TIPONF]$"DB")) .And. aNfItem[nItem][IT_VALSOL] > 0) .Or. lConfaz21 .Or. lEntSemICM)
				If aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST]
					nAliIter := IIf(aNFCab[NF_UFORIGEM] $ "SP|RJ|MG|RS|PR|SC" .And. (aNFCab[NF_UFDEST] $ aSX6[MV_NORTE] .Or. aNFCab[NF_UFDEST] $ cMV_UFPST),7,12)
					If (Year( aNfCab[NF_DTEMISS] ) >= 2013							.And.	;
						SubStr( aNfItem[nItem][IT_CLASFIS] , 1 , 1 ) $ "1|2|3|8"	.And.	;
						!Alltrim( aNfItem[nItem][IT_CF]) $cExceRes13 .And.	;
						(cSimpNac $ "1/2" .Or. aNFCab[NF_SIMPNAC] == "1"))

						nAliIter :=  4
					EndIf
					If Len(aNfItem[nItem][IT_EXCECAO]) > 0 .And. aNfItem[nItem][IT_EXCECAO][7] <> "S"
						If aNfItem[nItem][IT_EXCECAO][2] > 0 .AND. (aNfItem[nItem][IT_EXCECAO][2] == 4 .OR. aNfItem[nItem][IT_EXCECAO][2] == 7 .OR. aNfItem[nItem][IT_EXCECAO][2] == 12)
							/*
							Somente serão permitidas alíquotas interestaduais, conforme parecetr abaixo:
							http://tdn.totvs.com/pages/releaseview.action?pageId=95027214

							Estou verificando se o conteúdo do F7_ALIQEXT é interestadual, pois em algumas situações específicas a alíquota interestadual a ser utilizada não é a padrão
							Por exemplo, SP->MG tem alíquota interestadual padrão de 12, porém pode haver convênio entre os estados permitindo alíquota interestadual de 7 ao invés de 12, então deverá considerar alíquota da exceção
							Um exemplo disso é o caso da Issue http://jiraproducao.totvs.com.br/browse/MSERV-701
							Caso vier outra alíquota que não seja interestadual não será considerada para nAliIter, já que os clientes utilizam o campo F7_ALIQEXT pra informar alíquota reduzida do simples, e não a interestadual
							*/
							nAliIter := aNfItem[nItem][IT_EXCECAO][2] //Aliquota Externa
						EndIf
					EndIf
				Else
					/*

					   Antes de alterar este trecho verificar o seguinte parecer:

					   http://tdn.totvs.com/pages/releaseview.action?pageId=95027214

					   "Deverá ser deduzido a alíquota interna do produto, quando se tratar de
					   operação realizada dentro do Estado, mesmo que o ICMS próprio seja calculado
					   dentro do Simples Nacional." Ou seja, nao devera ser utilizada a aliquota
					   do SIMPLES para deduzir o ICMS proprio do ST.

					   Caso seja utilizaca excecao fiscal, a aliquota considerada nos calculos de
					   ICMS-ST, [IT_ALIQSOL], eh o campo "Aliq. de ICMS Destino" - IT_EXCECAO[6],
					   mesmo que se trate de operacao interna. Nao devera ser utilizado o campo
					   "Aliquota Interna" da excecao - IT_EXCECAO[1] pois este campo eh para o
					   ICMS Proprio apenas.

					*/
					nAliIter := aNfItem[nItem][IT_ALIQSOL]
				EndIf
				If ((aNFCab[NF_SIMPNAC] == "1" .And. aNFItem[nItem][IT_TS][TS_ICMSTMT]=="1") .Or. aNFCab[NF_SIMPNAC] <> "1")
					// Confaz21 - Utilizar tratamento do parametro MV_BASERET
					// Entrada de fornecedores do simples sem ICMS - Utilizar IT_BICMORI quando nao tenho ICMS calculado em IT_BASEICM
					If lConfaz21 .Or. lEntSemICM
						aNfItem[nItem][IT_VALSOL] := (aNfItem[nItem][IT_BASESOL]*(nAliqSol/100)) - (Iif(nReduzICMS > 0 .And. aSX6[MV_BASERET] == "S",aNfItem[nItem][IT_BASEICM],aNfItem[nItem][IT_BICMORI])*(nAliIter/100))
					Else // Demais casos - Utilizar IT_BASEICM p/ considerar a base reduzida (se houver reducao) de ICMS.
 						// Se configurado diferimento + ST (TS_ICMSDIF == 5) preciso somar o valor do ICMS diferido para que não seja deduzido do ICMS-ST o valor do ICMS "cheio" da operação. 						
						aNfItem[nItem][IT_VALSOL] := ((aNfItem[nItem][IT_BASESOL]*(nAliqSol/100)) - Iif(lDifCont,0,(Iif(aNfItem[nItem][IT_BASEICM] > 0 ,aNfItem[nItem][IT_BASEICM],aNfItem[nItem][IT_BICMORI])*(nAliIter/100)))) + IIf(aNFItem[nItem][IT_TS][TS_ICMSDIF]=="5", aNfItem[nItem][IT_ICMSDIF], 0)
					EndIf
				EndIf
			EndIf

			// Campo p/ tratamentos especificos de alguns créditos presumidos que alteram a forma de cálculo do ICMS-ST.
    		If aNfItem[nItem][IT_TS][TS_FCALCPR] == "1" .And. aNfCab[NF_UFORIGEM] == "SC" .And. aNfCab[NF_UFDEST] == "SC" .And. aNfItem[nItem][IT_TS][TS_CRDPRES] > 0
    		    // O valor "cheio" de ST (antes de deduzir o ICMS próprio) é calculado com base na alíquota do destino - a alíquota do crédito presumido.
    			aNfItem[nItem][IT_VALSOL] := aNfItem[nItem][IT_BASESOL] * ((aNfItem[nItem][IT_ALIQSOL] - aNfItem[nItem][IT_TS][TS_CRDPRES]) / 100)
    			// O valor do ICMS próprio a deduzir do ST também é calculado com base na alíquota da operação própria - a alíquota do crédito presumido.
    			aNfItem[nItem][IT_VALSOL] -= aNfItem[nItem][IT_BASEICM] * ((aNfItem[nItem][IT_ALIQICM] - aNfItem[nItem][IT_TS][TS_CRDPRES]) / 100)
				MaItArred(nItem,{"IT_VALSOL"})
    		EndIf

			// Controle p/ nao apresentar valores negativos de ICMS-ST.
			If aNfItem[nItem][IT_VALSOL] < 0
				aNfItem[nItem][IT_VALSOL] := 0
				If aSx6[MV_ZRSTNEG]
					aNfItem[nItem][IT_BASESOL] := 0
				EndIf
			EndIf
		EndIf // lCalcula
	Else
		aNfItem[nItem][IT_VALSOL]	:= 	0
	EndIf
EndIf
// Caso nao haja valor de ICMS solidario deve-se zerar a base
// de calculo do ICMS-ST
//
// Essa alteracao foi comentada devido a uma consulta feita pelo cliente Nestle a Sefaz de Sao Paulo
// onde a Sefaz informa que, mesmo que o valor de ICMS Retido seja zerado, caso exista um valor de Base
// de Calculo, este devera ser informado no documento fiscal e posteriormente no XML (Tag - vBCST).
// Alteracao feita atraves do chamado TGQDW4.
// Foi feito um teste com a transmissao da nota fiscal e nao houve erro de validacao/transmissao.
//Tags:
//	<modBCST>0</modBCST>
//	<vBCST>5.36</vBCST>
//	<pICMSST>18.00</pICMSST>
//	<vICMSST>0</vICMSST>

//If aNfItem[nItem][IT_VALSOL] == 0
//	aNfItem[nItem][IT_BASESOL]	:= 0
//EndIf

//Base de Calculo do ICMS ST nas operacoes substituidos do MT,
//com base no CNAE do Anexo XI e XVI do RICMS/MT de acordo com
//os art. 87-J-6 ao art. 87-J-16 do RICMS/MT e decreto 392/2011
If lRegESim .And. aNfItem[nItem][IT_BASRESI] > 0 .And. aNFItem[nItem][IT_TS][TS_MKPCMP]<>"1" .AND. lCalcula .And. cCampo <> "IT_BASESOL"

	nAliIter := aNfItem[nItem][IT_ALIQSOL]
	If Len(aNfItem[nItem][IT_EXCECAO]) > 0 .And. aNfItem[nItem][IT_EXCECAO][7] <> "S"
		If aNFCab[NF_OPERNF] == "E" .And. aNfItem[nItem][IT_EXCECAO][1] > 0
			nAliIter := aNfItem[nItem][IT_EXCECAO][1]
		ElseIf aNfItem[nItem][IT_EXCECAO][6] > 0
			nAliIter := aNfItem[nItem][IT_EXCECAO][6]
		EndIf
	EndIf

	MaItArred(nItem,{"IT_BASRESI"})

	//-- Validação para zerar a BASE do ICMS ST caso a movimentação se trate de complemento de ICMS ST.
	IF!(aNFitem[nItem][IT_TIPONF ]$'IP')
		aNfItem[nItem][IT_BASESOL] := aNfItem[nItem][IT_BASRESI]/(nAliIter/100)
	ELSE
		aNfItem[nItem][IT_BASESOL] := 0
	ENDIF

	aNfItem[nItem][IT_VALSOL]  := aNfItem[nItem][IT_VALRESI]
	aNfItem[nItem][IT_ALIQSOL] := nAliIter

EndIf

If aPE[PE_MACSOLICMS]
	aMaSolICMS := ExecBlock("MACSOLICMS",.f.,.f.,{aNfCab[NF_OPERNF],nItem,aNfItem[nItem][IT_BASESOL],aNfItem[nItem][IT_ALIQSOL],aNfItem[nItem][IT_VALSOL]})
	IF ValType(aMaSolICMS) == "A"
		IF Len(aMaSolICMS) == 3
			aNfItem[nItem][IT_BASESOL] := aMaSolICMS[1]
			aNfItem[nItem][IT_ALIQSOL] := aMaSolICMS[2]
			aNfItem[nItem][IT_VALSOL]  := aMaSolICMS[3]
		Endif
	Endif
Endif

If aNfItem[nItem][IT_VLSLXML] == 0 //Guarda valor calculado pelo sistema
	aNfItem[nItem][IT_VLSLXML] := aNfItem[nItem][IT_VALSOL]
Endif

MaFisFECP(nItem,,,"BSE|VLR")

Return(Nil)
/*/
MaALIQCMP- Edson Maricate -08.12.1999
Executa o calculo da aliquota do ICMS complementar.
/*/
Static Function MaALIQCMP(nItem)

Local nAliquota	:= aNfItem[nItem][IT_ALIQICM]
Local aMVPPDIFAL 	:= &(aSX6[MV_PPDIFAL])
Local lCalDifal		:= Iif(valType(aMVPPDIFAL) == "A", Len(aMVPPDIFAL) > 0 .And. Year(aNfCab[NF_DTEMISS]) >= aMVPPDIFAL[1][1] .And. aNfItem[nItem][IT_TS][TS_DIFAL] == "1", .F.)

If !(aNFCab[NF_UFORIGEM]$"EX") .And. aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST]

	nAliquota := aNfItem[nItem][IT_PRD][SB_PICM]

	If aNFCab[NF_TIPONF] == "D" .Or. (aNFCab[NF_TIPONF] == "B" .And. aNfCab[NF_OPERNF] == "E" .And. aNFItem[nItem][IT_TS][TS_PODER3]== "D" .And. aSX6[MV_CDIFBEN])   // devolucao ou retorno por beneficiamento conforme alinhamento do chamado TUTZKF
		nAliquota := Iif( nAliquota <> 0 .And. !(lCalDifal .And. aNfCab[NF_OPERNF] == "E" ), nAliquota , MaAliqOrig(nItem) )
		If !Empty(aNFItem[nItem][IT_RECORI])
			If ( aNFCab[NF_CLIFOR] == "C" )
				If aPos[FP_D2_ALIQCMP]
					dbSelectArea("SD2")
					MsGoto( aNFItem[nItem][IT_RECORI] )
					nAliquota := SD2->D2_ALIQCMP
				EndIf
			Else
				If aPos[FP_D1_ALIQCMP]
					dbSelectArea("SD1")
					MsGoto( aNFItem[nItem][IT_RECORI] )
					nAliquota := SD1->D1_ALIQCMP
				Endif
			Endif
		EndIf
	Else
		//Utiliza aliquota destino para Difal na saída
		nAliquota := Iif( nAliquota <> 0 .And. !(lCalDifal .And. aNfCab[NF_OPERNF] == "S" .And. aNFCab[NF_TPCLIFOR]=="F" ), nAliquota , MaAliqDest(nItem) )

		MaFisFECP(nItem,,,"ALQ")

		If aNfItem[nItem][IT_ALFCCMP] > 0 .And. !lCalDifal
			nAliquota	+=	aNfItem[nItem][IT_ALFCCMP]
		Endif
	EndIf

EndIf

aNfItem[nItem][IT_ALIQCMP]	:= nAliquota

Return

/*/
MaFisVComp - Edson Maricate -08.12.1999
Executa o calculo do ICMS Complementar / Antecipacao ICMS
/*/
Static Function MaFisVComp(nItem,lReproc,cCampo)
Local nMargem		:= 0
Local nBase			:= 0
Local nReduzICMS	:= 0
Local nRedICMSCOM	:= 0
Local nVlIcmOri		:= 0
Local nRedAntec		:= 0
Local cSimpNac		:= aSX6[MV_CODREG]
Local nSvValComp	:= 0
Local nSvValAnt		:= 0
Local nUltimo		:= 0
Local nDifal		:= 0
Local nPos			:= 0
Local aMVPPDIFAL	:= &(aSX6[MV_PPDIFAL])
Local lDifal		:= Iif(valType(aMVPPDIFAL)=="A", Len(aMVPPDIFAL)>0 .And. Year(aNfCab[NF_DTEMISS]) >= aMVPPDIFAL[1][1],.F.)
Local nBsAntIc 		:= 0
Local lDevCompra 	:= aNfCab[NF_TIPONF] == "D" .And. aNfCab[NF_OPERNF] == "S" .And. aNFCab[NF_CLIFOR] == "F"
Local lCalcula 		:= .T.
Local cExceRes13	:=	"6107|6108|6929"
Local nAlqIcmOri := aNfItem[nItem][IT_ALIQICM]
Local lDevVda := .F.
Local lCompPrc := .F.
Local lBaseSimp	:= .F. /*Esta variável indica que na compra de simples nacional, com difal com base dupla, ao compor a base dupla o valor a ser retirado/expurgado será considerando alíquota do simples e não alíquota interestadual.
					     Irá seguir a fórmula de cálculo abaixo:
					    	Base de Cálculo X (1  % ICMS que compõe a Alíquota do Simples Nacional (¹) / 100%) = Valor expurgado o imposto (valor sem ICMS);
							Valor expurgado o imposto / (1  Alíquota interna / 100%) = Nova Base de Cálculo;
							Nova Base de Cálculo X (Alíquota Interna  Alíquota Interestadual) = Imposto a Recolher, ou seja, o DIFAL a UF do destino.
					     Link com exemplo do estado da Baha https://www.sefaz.ba.gov.br/contribuinte/tributacao/duvidas/diferenca_aliquota.pdf*/
Local lBicmcpl	:=	Iif(Empty(aNFItem[nItem][IT_TS][TS_BICMCMP]),.F.,.T.)
Local lProcEC87	     := .T.
Local lDevIntegral	:= .F.
Local nBaseICCpl	:=	0
Local nValoICCpl	:=	0
Local nAliqICCpl	:=	0
Local nPercRdICM	:=	0
Local nValoMerc		:=	0
Local lCompIcm		:= .F.


Default lReproc	:= .F.
Default cCampo := ""

//Chamo aqui também a função ChkPPDIFAL, pois precisa ser atualizada aqui nas situações que for executada pelo MaFisAlt e não passar pela MaNewFisTES
//caso a nota fiscal possua itens que calculam difal e itens que não calculam difal (nota conjugada), pode acontecer da referência estar com status do último item
//e o difal pode ser calculado de forma indevida para todos os itens ou simplesmente não ser calculado para nenhum item, já que terá somente o status do último item processado
aNfCab[NF_PPDIFAL] := ChkPPDIFAL( nItem, aMVPPDIFAL )

nSvValComp	:= aNfItem[nItem][IT_VALCMP]
nSvValAnt	:= aNfItem[nItem][IT_VALANTI]

// Reducao no Valor de Antecipação de ICMS
nRedAntec := aNFItem[nItem][IT_TS][TS_REDANT]

// Aliquota p/ calculo do ICMS "Original" quando nao for devolução.
// Nao usar IT_ALIQICM pois a aliquota deve ser sempre a da operacao interestadual,
// ou seja, 7, 12 ou 4 (produtos importados). Se utilizar o IT_ALIQICM e o fornecedor
// for optante do SIMPLES a aliquota no IT_ALIQICM sera, por exemplo, 3.41 e o calculo
// sera feito incorretamente.
If aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST] .And. aNfCab[NF_TIPONF] <> "D"
	nAlqIcmOri := MaFisAIEst(nItem)
EndIf

//Valor do ICMS original, sem a reducao na base de calculo.
nVlIcmOri := aNfItem[nItem][IT_BICMORI] * (nAlqIcmOri / 100)

// Carrega a reducao da base do ICMS
If !Empty(aNFitem[nItem,IT_EXCECAO]) .And. aNfItem[nItem,IT_EXCECAO,14] > 0
	nReduzICMS := aNfItem[nItem,IT_EXCECAO,14]
Else
	nReduzICMS := aNFItem[nItem][IT_TS][TS_BASEICM]
EndIf

If !Empty(aNFitem[nItem,IT_EXCECAO]) .And. aNfItem[nItem,IT_EXCECAO,33] > 0
	nRedICMSCOM := aNfItem[nItem,IT_EXCECAO,33]
Else
	If aNFItem[nItem][IT_TS][TS_BASCMP] > 0
		nRedICMSCOM := aNFItem[nItem][IT_TS][TS_BASCMP]
	Endif
Endif

aNfItem[nItem][IT_VALCMP] := 0
aNfItem[nItem][IT_VALANTI] := 0
aNfItem[nItem][IT_DIFAL] := 0
aNfItem[nItem][IT_PDDES] := 0
aNfItem[nItem][IT_PDORI] := 0
aNfItem[nItem][IT_BASEDES]:= 0

If aNFItem[nItem][IT_TS][TS_COMPL] == "S" .And.(aNFItem[nItem][IT_TS][TS_ICM] $ "S/N" .Or. cSimpNac $ "1") .And. (aNfCab[NF_TIPONF]<>"D" .Or. lDevCompra) .And. !aNfCab[NF_PPDIFAL]

	// Tratamento p/ devolucao de compra com diferencial de aliquota calculado.
	// Necessario para que seja feito o estorno do valor na linha 016 da apuracao.
	If lDevCompra .And. !Empty(aNFItem[nItem][IT_RECORI])
		dbSelectArea("SD1")
		MsGoto(aNFItem[nItem][IT_RECORI])
		If aNfItem[nItem][IT_QUANT] == SD1->D1_QUANT .And. SD1->D1_ICMSCOM > 0
			aNfItem[nItem][IT_VALCMP] := SD1->D1_ICMSCOM
			lCalcula := .F.
		EndIf
	EndIf

	If lCalcula

		If ( aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST] ) .And. aNFItem[nItem][IT_TS][TS_MKPCMP]=="2"
			// Calculo do ICMS Complementar por margem de lucro
			nMargem := aNfItem[nItem][IT_MARGEM]

			//Calculo da Base do ICMS Complementar 

			If !Empty(aNFitem[nItem,IT_EXCECAO]) .And. aNfItem[nItem,IT_EXCECAO,33] > 0
				nPercRdICM := 100 - aNfItem[nItem,IT_EXCECAO,33]
			Else
				If aNFItem[nItem][IT_TS][TS_BASCMP] > 0
					nPercRdICM  := 100 - aNFItem[nItem][IT_TS][TS_BASCMP]
				Endif
			Endif
			nValoMerc	:= aNfItem[nItem][IT_VALMERC]				//Valor da mercadoria		//O2
			nBaseICCpl	:= (nValoMerc * (100 - nPercRdICM)) / 100	//Base ICMS Complementar	//T2

			aNfItem[nItem][IT_BSICARD] := nBaseICCpl 

			//Calculo do Valor do ICMS Complementar 
			nValoICCpl	:= nBaseICCpl * (aNfItem[nItem][IT_ALIQCMP] - aNfItem[nItem][IT_ALIQICM]) / 100	//Valor do ICMS Comp. //V2
			If nValoICCpl < 0
			 	nValoICCpl := nValoICCpl * (-1)
			EndIf 

			aNfItem[nItem][IT_VLICARD] := nValoICCpl

			//Tratamento efetuado para que o IPI NÃO seja considerado na Base de Cálculo do ICC, conforme solicitado na Portaria CAT 75 de 2008, Artigo 2 do
			//Regulamento de ICMS do Estado de São Paulo orienta sobre o assunto, na qual preve fato gerador do ICMS, quando ocorrer a entrada em estabelecimento do
			//Simples Nacional de mercadorias oriundas de outros Estados.
			nBase := IIf(aNFItem[nItem][IT_TS][TS_AGREG]<>"F",aNfItem[nItem][IT_VALMERC]-IIf(aNFItem[nItem][IT_TS][TS_AGREG]$"DR",aNfItem[nItem][IT_DEDICM],0),0)+;
			Iif(aNfCab[NF_TPCLIFOR]=="R" .And. cSimpNac $ "1" .And. aSX6[MV_ESTADO] == "SP" .And. aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST],0,IIf(aNFItem[nItem][IT_TS][TS_INCIDE]$"S",aNfItem[nItem][IT_VALIPI],0))+;
			aNfItem[nItem][IT_FRETE]+aNfItem[nItem][IT_SEGURO]+aNfItem[nItem][IT_DESPESA]+aNfItem[nItem][IT_ICMSDIF] //issue DSERFIS1-8601

			If aNFItem[nItem][IT_TS][TS_AGREG]<>"F"
				nBase -= (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT])
			EndIf

			// Operacoes de venda para consumidor final nao podem ter
			// margem de lucro se o destino for para uso e consumo.
			If aNFItem[nItem][IT_TS][TS_CONSUMO]$"SO" .And.;
				(	( aNfCab[NF_TPCLIFOR]=="F" .And. aNfCab[NF_CLIFOR]=="C" ) .Or.;
				( aNfCab[NF_CLIFOR]=="F" ) ) .And.;
				aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST]
				nMargem := 0
			EndIf

			If nReduzICMS > 0 .And. Iif(lBicmcpl,Iif(aNFItem[nItem][IT_TS][TS_BICMCMP] == "1",.T.,.F.),aSX6[MV_BICMCMP])
				nBase := (nBase*nReduzICMS)/100
				aNfItem[nItem][IT_PREDCMP]	:= nReduzICMS
			EndIf

			If nMargem > 0
				nBase := nBase*(1+(nMargem/100))
				aNfItem[nItem][IT_MVACMP]	:= nMargem
			EndIf

			//EC 87/2015 calculo para estado que aderiram DOLT/SUTRI n 002/2016
			//http://tdn.totvs.com/download/attachments/223929840/Parecer%20Consultoria%20Tribut%C3%A1ria%20Segmentos%20-%20TUESYM%20-%20Base%20de%20c%C3%A1lculo%20do%20diferencial%20de%20al%C3%ADquota%20%E2%80%93%20EC872015%20-%20MG.pdf?version=1&modificationDate=1453393192000&api=v2
			If lDifal .And. aSX6[MV_ESTADO] $ aSX6[MV_BASDENT] .And. aNfCab[NF_OPERNF] == "E" .And. ;
				(!(AllTrim(aNFCab[NF_ESPECIE])$"CTR/CTE/CTA/CA/CTF" .Or. "NFST"$AllTrim(aNFCab[NF_ESPECIE])) .Or. aNFCab[NF_UFDEST] $ aSX6[MV_BASDPUF])

				If aSX6[MV_ESTADO] $ aSX6[MV_BASDEGO] //base de calculo conforme Estado de Goias Decreto 8.519 de 2015 - TVFCPK -TUWAOG
					nBase := aNfItem[nItem][IT_BASEDES] := nBase/(1-(aNfItem[nItem][IT_ALIQCMP]/100)) //Base Destino
				ElseIf aSX6[MV_ESTADO] $ aSX6[MV_BASDSER] //base de calculo conforme Estado de Sergipe http://tdn.totvs.com/pages/releaseview.action?pageId=267800346 - TWFOKI
					nBase := aNfItem[nItem][IT_BASEDES] := nBase/(1-((aNfItem[nItem][IT_ALIQCMP]-aNFItem[nItem,IT_ALIQICM])/100)) //Base Destino
				Else
					If aNFCab[NF_SIMPNAC] == "1" .And. aNfCab[NF_TPCLIFOR]=="F"
						nVlIcmOri := (aNfItem[nItem][IT_BASEICM]*aNfItem[nItem][IT_ALIQDIF]/100)
					EndIf
					If aNFCab[NF_SIMPNAC] == "1" .AND. aNFCab[NF_OPERNF] == "E"
						lBaseSimp	:= aSX6[MV_ESTADO]  $ aSX6[MV_BDSIMP] //MV_BDSIMP somente terá efeito para base dupla e compra de simples nacional
					EndIF
					nBase := aNfItem[nItem][IT_BASEDES] := (nBase- Iif(lBaseSimp, aNfItem[nItem][IT_VALICM] ,Iif(aNFCab[NF_SIMPNAC] == "1" .And. aNfCab[NF_TPCLIFOR]=="F", nVlIcmOri,aNfItem[nItem][IT_VALICM])))/(1-(aNfItem[nItem][IT_ALIQCMP]/100)) //Base Destino
				Endif

				If nRedICMSCOM > 0
					nBase := aNfItem[nItem][IT_BASEDES] := (nBase*nRedICMSCOM)/100
					aNfItem[nItem][IT_PREDCMP]	:= nRedICMSCOM
				Endif
			ElseIf	lDifal .And.	nRedICMSCOM > 0
				nBase := aNfItem[nItem][IT_BASEDES] := (nBase*nRedICMSCOM)/100
				aNfItem[nItem][IT_PREDCMP]	:= nRedICMSCOM
			EndIf

			If aNFCab[NF_SIMPNAC] == "1" .And. aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_CLIFOR] =="F"
				nVlIcmOri := (aNfItem[nItem][IT_BASEICM]*aNfItem[nItem][IT_ALIQDIF]/100)
			EndIf

			IF aSX6[MV_CMPALIQ] //Calcula ICMS Complementar pela diferença entre aliquotas.
				aNfItem[nItem][IT_VALCMP] := (Iif(aNfItem[nItem][IT_BASEDES] > 0,nBase,Iif(Iif(lBicmcpl,Iif(aNFItem[nItem][IT_TS][TS_BICMCMP] == "1",.T.,.F.),aSX6[MV_BICMCMP]),aNfItem[nItem][IT_BASEICM],aNfItem[nItem][IT_BICMORI]))*((aNfItem[nItem][IT_ALIQCMP]- Iif(lBaseSimp , nAlqIcmOri ,aNFItem[nItem,IT_ALIQICM] )  )/100))
			Else
				aNfItem[nItem][IT_VALCMP] := (Iif(aNfItem[nItem][IT_BASEDES] > 0,nBase, Iif(Iif(lBicmcpl,Iif(aNFItem[nItem][IT_TS][TS_BICMCMP] == "1",.T.,.F.),aSX6[MV_BICMCMP]) , aNfItem[nItem][IT_BASEICM] , aNfItem[nItem][IT_BICMORI] )  )*(aNfItem[nItem][IT_ALIQCMP]/100)) -  IIf(lBaseSimp ,aNfItem[nItem][IT_BASEDES] * nAlqIcmOri / 100  , Iif( aNFItem[nItem][IT_TS][TS_COMPRED] $ " 1", aNfItem[nItem][IT_VALICM], nVlIcmOri ))
			Endif

			If aNFItem[nItem][IT_TS][TS_COMPL] == "S" .And. aNFItem[nItem][IT_TS][TS_ICM] == "N" .and. aNFCab[NF_SIMPNAC] =="1" .and. (aNFItem[nItem][IT_TS][TS_CIAP] == "S" .Or. aNFItem[nItem][IT_TS][TS_CONSUMO] == "S")
				aNfItem[nItem][IT_VALICM] := 0
			EndIf

			/*
			  Foi criado o parametro MV_DIFALIQ para que o usuario informe uma aliquota especifica a ser utilizada no calculo
			   do ICMS Complementar.
			  Ao aplicar esta aliquota, ira ignorar as regras utilizadas no calculo de diferenciacao entre aliquota interna e
			   aliquota interestadual.
			 */
			If aSX6[MV_DIFALIQ] <> 0
				aNfItem[nItem][IT_VALCMP] := ( nBase * aSX6[MV_DIFALIQ] ) / 100
			Endif

		Else
			If ( aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST] ) .And. aNFCab[NF_TPCLIFOR] <> "X"

				/* O diferencial de alíquotas, na aquisição interestadual de material de uso e consumo ou ativo imobilizado,
				   o contribuinte, mesmo que optante pelo Simples Nacional, estará sujeito ao recolhimento do diferencial de alíquotas
				   fora do regime simplificado*/

				//Tratamento efetuado para que o IPI NÃO seja considerado na Base de Cálculo do ICC, conforme solicitado na Portaria CAT 75 de 2008, Artigo 2 do
				//Regulamento de ICMS do Estado de São Paulo orienta sobre o assunto, na qual preve fato gerador do ICMS, quando ocorrer a entrada em estabelecimento do
				//Simples Nacional de mercadorias oriundas de outros Estados.
				nBase := IIf(aNFItem[nItem][IT_TS][TS_AGREG]<>"F",aNfItem[nItem][IT_VALMERC]-IIf(aNFItem[nItem][IT_TS][TS_AGREG]$"DR",aNfItem[nItem][IT_DEDICM],0),0)+;
				Iif(aNfCab[NF_TPCLIFOR]=="R" .And. cSimpNac $ "1" .And. aSX6[MV_ESTADO] == "SP" .And. aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST],0,IIf(aNFItem[nItem][IT_TS][TS_INCIDE]$"S",aNfItem[nItem][IT_VALIPI],0))+;
				aNfItem[nItem][IT_FRETE]+aNfItem[nItem][IT_SEGURO]+aNfItem[nItem][IT_DESPESA]

				If aNFItem[nItem][IT_TS][TS_AGREG]<>"F"
					nBase -= (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT])
				EndIf

				If aNFCab[NF_SIMPNAC] == "1" .And. aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_CLIFOR] =="F"
					nVlIcmOri := (aNfItem[nItem][IT_BASEICM]*aNfItem[nItem][IT_ALIQDIF]/100)
				EndIf

				IF aNFCab[NF_SIMPNAC] == "1" .AND. aNFCab[NF_CLIFOR] =="F"
					lBaseSimp	:= aSX6[MV_ESTADO]  $ aSX6[MV_BDSIMP] //MV_BDSIMP somente terá efeito para base dupla e compra de simples nacional
				EndIF

				//EC 87/2015 calculo para estado que aderiram DOLT/SUTRI n 002/2016
				//http://tdn.totvs.com/download/attachments/223929840/Parecer%20Consultoria%20Tribut%C3%A1ria%20Segmentos%20-%20TUESYM%20-%20Base%20de%20c%C3%A1lculo%20do%20diferencial%20de%20al%C3%ADquota%20%E2%80%93%20EC872015%20-%20MG.pdf?version=1&modificationDate=1453393192000&api=v2
				If lDifal .And. aSX6[MV_ESTADO] $ aSX6[MV_BASDENT] .And. aNfCab[NF_OPERNF] == "E" .And. ;
					(!(AllTrim(aNFCab[NF_ESPECIE])$"CTR/CTE/CTA/CA/CTF" .Or. "NFST"$AllTrim(aNFCab[NF_ESPECIE])) .Or. aNFCab[NF_UFDEST] $ aSX6[MV_BASDPUF])

					If nReduzICMS > 0 .And. Iif(lBicmcpl,Iif(aNFItem[nItem][IT_TS][TS_BICMCMP] == "1",.T.,.F.),aSX6[MV_BICMCMP])
						nBase := (nBase*nReduzICMS)/100
						aNfItem[nItem][IT_PREDCMP]	:= nReduzICMS
					EndIf

					IF aSX6[MV_ESTADO] $ aSX6[MV_BASDEGO]
						aNfItem[nItem][IT_BASEDES] := nBase/(1-(aNfItem[nItem][IT_ALIQCMP]/100)) //Base Destino
					ElseIf aSX6[MV_ESTADO] $ aSX6[MV_BASDSER] //base de calculo conforme Estado de Sergipe http://tdn.totvs.com/pages/releaseview.action?pageId=267800346 - TWFOKI
						aNfItem[nItem][IT_BASEDES] := nBase/(1-((aNfItem[nItem][IT_ALIQCMP]-aNFItem[nItem,IT_ALIQICM])/100)) //Base Destino
					Else
						aNfItem[nItem][IT_BASEDES] := (nBase- Iif( aNFItem[nItem][IT_TS][TS_COMPRED] $ " 1" .OR. lBaseSimp , aNfItem[nItem][IT_VALICM], nVlIcmOri ))/(1-(aNfItem[nItem][IT_ALIQCMP]/100)) //Base Destino
					Endif

					If nRedICMSCOM > 0
						aNfItem[nItem][IT_BASEDES] := (aNfItem[nItem][IT_BASEDES]*nRedICMSCOM)/100
						aNfItem[nItem][IT_PREDCMP] := nRedICMSCOM
					Endif
				ElseIf	lDifal .And.	nRedICMSCOM > 0
					aNfItem[nItem][IT_BASEDES] := (aNfItem[nItem][IT_VALMERC]-aNfItem[nItem][IT_VALICM])/(1-(aNfItem[nItem][IT_ALIQCMP]/100)) //Base Destino
					aNfItem[nItem][IT_BASEDES] := (aNfItem[nItem][IT_BASEDES]*nRedICMSCOM)/100
					aNfItem[nItem][IT_PREDCMP] := nRedICMSCOM
				EndIf

				If aNFCab[NF_SIMPNAC] =="1" .And. aNFItem[nItem][IT_TS][TS_COMPL] == "S" .And. aNFItem[nItem][IT_TS][TS_CONSUMO]$"S" .And. aNFCab[NF_CLIFOR] =="F" .And. aNfItem[nItem][IT_ALIQCMP] >aNfItem[nItem][IT_ALIQDIF]
					aNfItem[nItem][IT_VALCMP] := (Iif(aNfItem[nItem][IT_BASEDES] > 0,aNfItem[nItem][IT_BASEDES],aNfItem[nItem][IT_BASEICM])*((aNfItem[nItem][IT_ALIQCMP] - Iif(lBaseSimp ,nAlqIcmOri , aNfItem[nItem][IT_ALIQDIF]) ) /100))
				Else
					IF aSX6[MV_CMPALIQ] //Calcula ICMS Complementar pela diferença entre aliquotas.
						aNfItem[nItem][IT_VALCMP] := (Iif(aNfItem[nItem][IT_BASEDES] > 0,aNfItem[nItem][IT_BASEDES],Iif(Iif(lBicmcpl,Iif(aNFItem[nItem][IT_TS][TS_BICMCMP] == "1",.T.,.F.),aSX6[MV_BICMCMP]),aNfItem[nItem][IT_BASEICM],aNfItem[nItem][IT_BICMORI]))*((aNfItem[nItem][IT_ALIQCMP]- Iif(lBaseSimp ,nAlqIcmOri , aNFItem[nItem,IT_ALIQICM]) )/100))
					Else
						aNfItem[nItem][IT_VALCMP] := (Iif(aNfItem[nItem][IT_BASEDES] > 0,aNfItem[nItem][IT_BASEDES], Iif(Iif(lBicmcpl,Iif(aNFItem[nItem][IT_TS][TS_BICMCMP] == "1",.T.,.F.),aSX6[MV_BICMCMP]),aNfItem[nItem][IT_BASEICM] ,aNfItem[nItem][IT_BICMORI])   )*(aNfItem[nItem][IT_ALIQCMP]/100)) - IIf(lBaseSimp ,aNfItem[nItem][IT_BASEDES] * nAlqIcmOri / 100  , Iif( aNFItem[nItem][IT_TS][TS_COMPRED] $ " 1", aNfItem[nItem][IT_VALICM], nVlIcmOri ))
					Endif
				EndIf

				If aNfCab[NF_OPERNF] == "E" .And. aNFCab[NF_SIMPNAC] == "1" .And. aNFItem[nItem][IT_TS][TS_ICM] == "N" .And. aNFItem[nItem][IT_TS][TS_COMPL] == "S" .And. aNFItem[nItem][IT_TS][TS_CIAP] == "S"
					aNfItem[nItem][IT_BASEICM]	:= 0
					aNfItem[nItem][IT_VALICM]	:= 0
				Endif

				If Iif(lBicmcpl,Iif(aNFItem[nItem][IT_TS][TS_BICMCMP] == "1",.T.,.F.),aSX6[MV_BICMCMP])
					aNfItem[nItem][IT_PREDCMP]	:= nReduzICMS
				Else
					aNfItem[nItem][IT_PREDCMP]	:= 0
				Endif

				/* Foi criado o parametro MV_DIFALIQ para que o usuario informe uma aliquota especifica a ser utilizada no calculo
				   do ICMS Complementar.
				  Ao aplicar esta aliquota, ira ignorar as regras utilizadas no calculo de diferenciacao entre aliquota interna e
				   aliquota interestadual. */

				If aSX6[MV_DIFALIQ] <> 0
					If Iif(lBicmcpl,Iif(aNFItem[nItem][IT_TS][TS_BICMCMP] == "1",.T.,.F.),aSX6[MV_BICMCMP])
						aNfItem[nItem][IT_VALCMP] := ( aNfItem[nItem][IT_BASEICM] * aSX6[MV_DIFALIQ] ) / 100
					Else
						aNfItem[nItem][IT_VALCMP] := ( aNfItem[nItem][IT_BICMORI] * aSX6[MV_DIFALIQ] ) / 100
					Endif
				Endif
			EndIf
		EndIf

	EndIf
EndIf

//Antecipacao ICMS - Mesma Regra do ICMS Complementar
If aNFItem[nItem][IT_TS][TS_ANTICMS] == "1" .And. !aNfCab[NF_PPDIFAL]

	nBsAntIc := aNfItem[nItem][IT_BICMORI]

	//Tratamento Sutri MG 002
	If ( aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST] ) .And. aNFCab[NF_TPCLIFOR] <> "X"
		If ((aSX6[MV_ESTADO] $ aSX6[MV_BASDENT]) .And. aSX6[MV_BASDANT] ) .And. aNfCab[NF_OPERNF] == "E" .And. ;
			!(AllTrim(aNFCab[NF_ESPECIE])$"CTR/CTE/CTA/CA/CTF" .Or. "NFST"$AllTrim(aNFCab[NF_ESPECIE]))

			IF aNFCab[NF_SIMPNAC] == "1"
				nVlIcmOri := (aNfItem[nItem][IT_BICMORI] * aNfItem[nItem][IT_ALIQDIF]/100)
				nBsAntIc  := aNfItem[nItem][IT_BASEDES] := (aNfItem[nItem][IT_BICMORI]-nVlIcmOri)/(1-(aNfItem[nItem][IT_ALIQCMP]/100))
			ElseIf aSX6[MV_BSICMCM]
				nBsAntIc := aNfItem[nItem][IT_BASEDES] := aNfItem[nItem][IT_BASEICM]/(1-(aNfItem[nItem][IT_ALIQCMP]/100))
			Else
				nVlIcmOri := aNfItem[nItem][IT_BICMORI] * (aNfItem[nItem][IT_ALIQICM]/100)
				nBsAntIc := aNfItem[nItem][IT_BASEDES] := (aNfItem[nItem][IT_BICMORI]-nVlIcmOri)/(1-(aNfItem[nItem][IT_ALIQCMP]/100))
			Endif
		EndIf
	EndIf

	IF aNFCab[NF_SIMPNAC] == "1" .And. Iif(cSimpNac <> "1" .And. aSX6[MV_ESTADO] <> "MG",.T.,.F.)
		//Alteração referente a Issue MSERV-6527, tratamento feito contemplando apenas o estado de MG, conforme parecer da consultoria: http://tdn.totvs.com/x/V_yRDg
		//A Antecipação tributária para Fornecedor optante pelo Simples Nacional será calculado com alíquota interestadual normal, aplicando a
		//Alíquota que se aplicaria a operação caso o fornecedor não fosse optante pelo SN e não a que foi utiliza e destacada na nota fiscal.
		aNfItem[nItem][IT_VALANTI]:= ((nBsAntIc * IIf(nRedAntec > 0, (nRedAntec/100), 1)) * ((aNfItem[nItem][IT_ALIQCMP]-aNFitem[nItem][IT_ALIQDIF])/100))
	ElseIf aNFItem[nItem][IT_TS][TS_INCIDE] == "N" .And. aNFItem[nItem][IT_TS][TS_IPIANTE] == "1"
		aNfItem[nItem][IT_VALANTI]:= (((nBsAntIc + aNfItem[nItem][IT_VALIPI]) * IIf(nRedAntec > 0, (nRedAntec/100), 1)) * (aNfItem[nItem][IT_ALIQCMP]/100)) - (nVlIcmOri + (aNfItem[nItem][IT_VALIPI] * (aNfItem[nItem][IT_ALIQICM]/100)))
	ElseIf aNFItem[nItem][IT_TS][TS_INCIDE] == "N" .And. (aSX6[MV_ESTADO] $ "BA|MA|CE")
		// Implementação do tratametno abaixo com base na consultoria tributario.
		// http://tdn.totvs.com/pages/releaseview.action?pageId=264896731  Item 29
		// Tratamento diferenciado p/ BA - Só deduz o próprio destacado quando houver redução da antecipação. Caso contrário deduz o ICMS próprio original (s/ redução).
		aNfItem[nItem][IT_VALANTI] := (((aNfItem[nItem][IT_BICMORI] + aNfItem[nItem][IT_VALIPI]) * IIf(nRedAntec > 0, (nRedAntec/100), 1)) * (aNfItem[nItem][IT_ALIQCMP]/100)) - IIf(aSX6[MV_ESTADO] $ "BA" .And. nRedAntec > 0, aNfItem[nItem][IT_VALICM], nVlIcmOri)
	ElseIf aNfItem[nItem][IT_UFXPROD][UFP_VL_ANT] > 0
		// Antecipacao de ICMS com pauta.
		// http://tdn.totvs.com/pages/releaseview.action?pageId=271158371
		aNfItem[nItem][IT_VALANTI] := (((aNfItem[nItem][IT_QUANT] * aNfItem[nItem][IT_UFXPROD][UFP_VL_ANT]) * IIf(nRedAntec > 0, (nRedAntec/100), 1)) * (aNfItem[nItem][IT_ALIQCMP]/100)) - aNfItem[nItem][IT_VALICM]
	ElseIf aSX6[MV_CMPALIQ]
		aNfItem[nItem][IT_VALANTI]:= ((nBsAntIc * IIf(nRedAntec > 0, (nRedAntec/100), 1)) * ((aNfItem[nItem][IT_ALIQCMP]-aNfItem[nItem][IT_ALIQICM])/100))
	Else
		aNfItem[nItem][IT_VALANTI]:= ((nBsAntIc * IIf(nRedAntec > 0, (nRedAntec/100), 1)) * (aNfItem[nItem][IT_ALIQCMP]/100)) - nVlIcmOri
	Endif

	//Removido tratamento abaixo com base na consultoria
	// http://tdn.totvs.com/pages/releaseview.action?pageId=264896731  Item 29
	//Reducao Antecipação ICMS
	//Decreto  6.284 de 14/03/1997, Art. 352-A § 4. do Regulame  o do ICMS do Estado da Bahia
	/*If nRedAntec > 0
		aNfItem[nItem][IT_VALANTI]	:= aNfItem[nItem][IT_VALANTI] * nRedAntec /100
	EndIf*/

EndIf

//Tratamento EC 87 -Diferencial de aliquota parcial para estado de destino
//http://tdn.totvs.com/pages/releaseview.action?pageId=189301460 //http://tdn.totvs.com/pages/releaseview.action?pageId=192096926
If aNFItem[nItem][IT_TS][TS_COMPL] == "S" .And.( aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST] ) .And.;
 ((aNfCab[NF_OPERNF] == "S" .And. ((aNFCab[NF_TPCLIFOR]=="F" .And. aNFCab[NF_LINSCR]) .Or. aNfCab[NF_TIPONF]=="D")) .Or. aNfCab[NF_OPERNF] == "E") .And. aNfCab[NF_PPDIFAL]

	nUltimo := Len(aMVPPDIFAL)

	IF (nPos := aScan(aMVPPDIFAL,{|x| x[1]== Year(aNfCab[NF_DTEMISS])})) > 0
		aNfItem[nItem][IT_PDDES]:= aMVPPDIFAL[nPos][2]
		aNfItem[nItem][IT_PDORI]:= aMVPPDIFAL[nPos][3]
	ElseIf Year(aNfCab[NF_DTEMISS] ) > aMVPPDIFAL[nUltimo][1]
		aNfItem[nItem][IT_PDDES]:= aMVPPDIFAL[nUltimo][2]
		aNfItem[nItem][IT_PDORI]:= aMVPPDIFAL[nUltimo][3]
	Endif

	// Flags p/ facilitar a leitura do IF abaixo.
	lDevVda := (( aNFCab[NF_OPERNF] == "E" .OR. aNFCab[NF_OPERNF] == "S" ) .And. (aNfCab[NF_TIPONF]$"D|B" .Or. aNFItem[nItem][IT_TS][TS_PODER3] =="D"))
	lCompPrc := (aNfCab[NF_TIPONF] == "C" .And. (aNfCab[NF_TPCOMPL] == "1" .Or. Empty(aNfCab[NF_TPCOMPL])))
	lCompIcm := (aNfCab[NF_TIPONF] == "I")

	//EC 87 Devolucao de venda ou complemento de preco utiliza os percentuais da NF de origem.
	If (!Empty(aNFItem[nItem][IT_RECORI]) .And. aNfCab[NF_PPDIFAL] .And. (lDevVda .Or. lCompPrc .Or. lCompIcm))
		If aNFCab[NF_CLIFOR] == "C"
			dbSelectArea("SD2")		
			MsGoto( aNFItem[nItem][IT_RECORI] )			
			lDevIntegral := aNfItem[nItem][IT_QUANT] == SD2->D2_QUANT
			//Espelha os percentuais			
			aNfitem[nItem][IT_PDDES] 	:= SD2->D2_PDDES
			aNfitem[nItem][IT_PDORI] 	:= SD2->D2_PDORI			

			//Espelha os valores na devolução integral ou proporcionaliza na devolução parcial
			If lDevVda
				aNfItem[nItem][IT_BASEDES]	:= Iif( lDevIntegral , SD2->D2_BASEDES , ( aNfItem[nItem][IT_QUANT] * SD2->D2_BASEDES ) / SD2->D2_QUANT ) 
				aNfItem[nItem][IT_DIFAL]	:= Iif( lDevIntegral , SD2->D2_DIFAL   , ( aNfItem[nItem][IT_QUANT] * SD2->D2_DIFAL   ) / SD2->D2_QUANT ) 
				aNfItem[nItem][IT_VALCMP]	:= Iif( lDevIntegral , SD2->D2_ICMSCOM , ( aNfItem[nItem][IT_QUANT] * SD2->D2_ICMSCOM ) / SD2->D2_QUANT ) 	
			EndIf

		Else
			dbSelectArea("SD1")
			MsGoto( aNFItem[nItem][IT_RECORI] )
			lDevIntegral := aNfItem[nItem][IT_QUANT] == SD1->D1_QUANT
			
			//Espelha os percentuais
			aNfitem[nItem][IT_PDDES] 	:= SD1->D1_PDDES
			aNfitem[nItem][IT_PDORI] 	:= SD1->D1_PDORI			
			
			//Espelha os valores na devolução integral ou proporcionaliza na devolução parcial
			If lDevVda
				aNfItem[nItem][IT_BASEDES]	:= Iif( lDevIntegral , SD1->D1_BASEDES , ( aNfItem[nItem][IT_QUANT] * SD1->D1_BASEDES ) / SD1->D1_QUANT )  
				aNfItem[nItem][IT_DIFAL]	:= Iif( lDevIntegral , SD1->D1_DIFAL   , ( aNfItem[nItem][IT_QUANT] * SD1->D1_DIFAL   ) / SD1->D1_QUANT )  
				aNfItem[nItem][IT_VALCMP]	:= Iif( lDevIntegral , SD1->D1_ICMSCOM , ( aNfItem[nItem][IT_QUANT] * SD1->D1_ICMSCOM ) / SD1->D1_QUANT )  			
			EndIf
			
		EndIf 

		If nRedICMSCOM > 0		
			aNfItem[nItem][IT_PREDCMP]	:= nRedICMSCOM
		Endif	

		//Se o DEVPARC estiver com conteúdo 1 ou S, siginifica que proporcionalizará os valores na devolução, e não deverá recalcular.
		If lDevIntegral .OR. aNFItem[nItem][IT_TS][TS_DEVPARC] $ "1S"
			lProcEC87	:= .F.
		EndIF

	EndIF	
	
	If lProcEC87 
		//Verifica se utiliza duas bases
		If aSX6[MV_BASDUPL] .Or. aNFCab[NF_UFDEST] $aSX6[MV_UFBASDP] 
			aNfItem[nItem][IT_BASEDES] := (aNfItem[nItem][IT_VALMERC]- Iif( aNFItem[nItem][IT_TS][TS_DESCOND] == "1", 0 , aNfItem[nItem][IT_DESCONTO] )  +aNfItem[nItem][IT_FRETE]+aNfItem[nItem][IT_SEGURO]+aNfItem[nItem][IT_DESPESA]+Iif(aNFItem[nItem][IT_TS][TS_INCIDE]=="S",aNfItem[nItem][IT_VALIPI],0)-aNfItem[nItem][IT_VALICM])/(1-(aNfItem[nItem][IT_ALIQCMP]+aNfItem[nItem][IT_ALFCCMP])/100) //base Destino
		Else
			aNfItem[nItem][IT_BASEDES] := Iif(Iif(lBicmcpl,Iif(aNFItem[nItem][IT_TS][TS_BICMCMP] == "1",.T.,.F.),aSX6[MV_BICMCMP]) .Or. aNfCab[NF_TIPONF]$"D|B" .Or. aNFItem[nItem][IT_TS][TS_PODER3] =="D",Iif(Iif(lBicmcpl,Iif(aNFItem[nItem][IT_TS][TS_BICMCMP] == "1",.F.,.T.),!aSX6[MV_BICMCMP]) .and. nReduzICMS<>0 .And. nReduzICMS<>100,aNfItem[nItem][IT_BASEICM] * 100 /nReduzICMS,aNfItem[nItem][IT_BASEICM]),aNfItem[nItem][IT_BICMORI])
		EndIf

		If nRedICMSCOM > 0
			aNfItem[nItem][IT_BASEDES] := (aNfItem[nItem][IT_BASEDES]*nRedICMSCOM)/100
			aNfItem[nItem][IT_PREDCMP]	:= nRedICMSCOM
		Endif	

		nDifal := (aNfItem[nItem][IT_BASEDES]*(aNfItem[nItem][IT_ALIQCMP]/100)) - Iif( aNFItem[nItem][IT_TS][TS_COMPRED] $ " 1", Iif( aNfItem[nItem][IT_VICMBRT] > 0 , aNfItem[nItem][IT_VICMBRT] ,aNfItem[nItem][IT_VALICM] ), nVlIcmOri )		
 
		If cSimpNac $ "1" .And. aNFCab[NF_OPERNF] == "S" .And. aNfItem[nItem][IT_ALIQCMP] >aNfItem[nItem][IT_ALIQDIF]
			nDifal := (aNfItem[nItem][IT_BASEDES]*((aNfItem[nItem][IT_ALIQCMP] - aNfItem[nItem][IT_ALIQDIF]) /100))
		Endif

		If aNfCab[NF_OPERNF] == "S" // campo Difal tera valor a ser pago em outro estado
			aNfItem[nItem][IT_VALCMP] := (Iif(aNfCab[NF_TIPONF]=="D",aNfItem[nItem][IT_PDDES],aNfItem[nItem][IT_PDORI] )* nDifal)/100 //valor do estado de origem
			aNfItem[nItem][IT_DIFAL] := (Iif(aNfCab[NF_TIPONF]=="D",aNfItem[nItem][IT_PDORI],aNfItem[nItem][IT_PDDES] )* nDifal)/100 // valor estado destino
		Else
			aNfItem[nItem][IT_VALCMP] := (Iif(aNfCab[NF_TIPONF]=="D" .Or. (aNfCab[NF_TIPONF]=="B" .And. Iif(Type("cFormul")=="C",cFormul == "S", .F.)),aNfItem[nItem][IT_PDORI],aNfItem[nItem][IT_PDDES] )* nDifal)/100 // valor estado destino
			aNfItem[nItem][IT_DIFAL] := (Iif(aNfCab[NF_TIPONF]=="D" .Or. (aNfCab[NF_TIPONF]=="B" .And. Iif(Type("cFormul")=="C",cFormul == "S", .F.)),aNfItem[nItem][IT_PDDES],aNfItem[nItem][IT_PDORI])* nDifal)/100 //valor do estado de origem
		Endif	
	EndIF	
Endif


If lReproc
	aNfItem[nItem][IT_VALCMP] := nSvValComp
	aNfItem[nItem][IT_VALANTI] := nSvValAnt
Else
	aNfItem[nItem][IT_DIFAL] := Max(0, aNfItem[nItem][IT_DIFAL])
	aNfItem[nItem][IT_VALCMP] := If(aNfCab[NF_OPERNF] == "E" .Or. aNfItem[nItem][IT_DIFAL] > 0 .Or. lDevCompra, Max(0,aNfItem[nItem][IT_VALCMP]),0)
	aNfItem[nItem][IT_VALANTI]:= Max(0,aNfItem[nItem][IT_VALANTI])
	MaItArred(nItem,{"IT_VALCMP", "IT_DIFAL"})
	MaFisFECP(nItem,,,"BSE|VLR")
EndIf
Return(.T.)

/*/
MaFisIPI -Alexandre Lemes -21/11/2012
Calculo do imposto sobre produtos industrializacos ( IPI ).
*/
Static Function MaFisIPI(nItem,cExecuta,lNoProces,cRefSDesc)

Local aRastItem	 := {}
Local nQuantPed  := 0
Local nReduzIPI  := 0
Local nSalvaBase := aNfItem[nItem][IT_BASEIPI]
Local nSalvaAliq := aNfItem[nItem][IT_ALIQIPI]
Local nSalvaValor := aNfItem[nItem][IT_VALIPI]
Local lExistNF   := .F.
Local lDevolBSE  := .F.
Local lDevolALQ  := .F.
Local lDevolVLR  := .F.
Local nQuantida  :=  0
Local lRndrne    := aSX6[MV_RNDIPI]
Local lSobra 	 := aSX6[MV_RNDSOBR]
Local cCFORemFut	:= aSX6[MV_REMVFUT]
Local lRemFut		:= .F.
Local lIpiMin		:= !Empty(aNFItem[nItem][IT_TS][TS_IPIMIN]) .And. aNFItem[nItem][IT_TS][TS_IPIMIN] == "1"
Local lSegUPau := aSX6[MV_IPI2UNI] //utiliza ou nao segunda unidade quando for pauta
Local nVlOprIPI	:= 0
Local nVlPautIPI	:= 0

DEFAULT cExecuta  := "BSE|ALQ|VLR"
DEFAULT lNoProces := .F.
DEFAULT cRefSDesc := ""

/*Se for Remessa de uma entrega futura soma o IPI da NF original na base do ICMS da nota de remessa*/
lRemFut:= aNFItem[nItem][IT_TS][TS_IPI] == "N" .And. Alltrim(aNfItem[nItem][IT_CF])$cCFORemFut .And. aNFItem[nItem][IT_TS][TS_CONSUMO] == "S" .And. aPos[FP_IPIVFCF] .And. aNFItem[nItem][IT_TS][TS_IPIVFCF]$"234"

//O bloco a seguir providencia para que em operações de devolução e ou beneficiamento quando o parametro MV_DEVTOT = .T.
//o valor da BASE do IPI seja igual a  Base do Imposto do documento Original quando a devolução e ou beneficiamento for
//igual a do documento original, se houverem despesas acessorias inclusas na base do documento original (Frete, Despesas e Seguro)
//as mesmas deverão ser digitadas manualmente no documento de devolução.
If !Empty(aNFItem[nItem][IT_RECORI]) .And. ( aNFCab[NF_TIPONF] $ "DB" .Or. aNFItem[nItem][IT_TS][TS_PODER3] == "D" )

	lExistNF := RetComp( aNFCab[NF_CLIFOR] , aNFItem[nItem][IT_RECORI] )

	If aNFCab[NF_TIPONF] $ "DB"
		If aNFCab[NF_CLIFOR] == "C"
			SD2->(MsGoto(aNFItem[nItem][IT_RECORI]))
			If !lExistNF .And. (aNfItem[nItem][IT_QUANT] == SD2->D2_QUANT)  .And. (Iif(!aSX6[MV_DEVTOT] ,SD2->D2_VALFRE+SD2->D2_SEGURO+SD2->D2_DESPESA==0 , SD2->D2_BASEIPI >0) .Or. ;
				(!aNfCab[NF_CALCSUF]$"IN " .And. aSX6[MV_DESCZF] .And. aSX6[MV_DESZFPC] ))
				aNfItem[nItem][IT_BASEIPI] := SD2->D2_BASEIPI
				aNfItem[nItem][IT_PREDIPI]	:= aNFItem[nItem][IT_TS][TS_BASEIPI]
				lDevolBSE := .T.
			EndIf
			If !lExistNF .And. (aNfItem[nItem][IT_QUANT] <> SD2->D2_QUANT .And. aNFItem[nItem][IT_TS][TS_DEVPARC]$"1S")  .And. (Iif(!aSX6[MV_DEVTOT] ,SD2->D2_VALFRE+SD2->D2_SEGURO+SD2->D2_DESPESA==0 , SD2->D2_BASEIPI >0) .Or. ;
				(!aNfCab[NF_CALCSUF]$"IN " .And. aSX6[MV_DESCZF] .And. aSX6[MV_DESZFPC] ))
				aNfItem[nItem][IT_BASEIPI] := ((SD2->D2_BASEIPI / SD2->D2_QUANT) * aNfItem[nItem][IT_QUANT])
				aNfItem[nItem][IT_PREDIPI]	:= aNFItem[nItem][IT_TS][TS_BASEIPI]
				lDevolBSE := .T.
			EndIf
			aNFitem[nItem][IT_ALIQIPI] := SD2->D2_IPI
			aNFitem[nItem][IT_TIPONF ] := IIf( SD2->D2_TIPO$"IP" , SD2->D2_TIPO , aNfCab[NF_TIPONF] )
			lDevolALQ := .T.
			If (SD2->D2_VALIPI > 0 .Or. Abs( aNfItem[nItem][IT_VALIPI] - SD2->D2_VALIPI) <= 1 ) .And. aNfItem[nItem][IT_QUANT] == SD2->D2_QUANT .And. Iif(!aSX6[MV_DEVTOT] , SD2->D2_VALFRE+SD2->D2_SEGURO+SD2->D2_DESPESA == 0 , SD2->D2_VALIPI > 0)
				aNfItem[nItem][IT_VALIPI] := SD2->D2_VALIPI
				lDevolVLR := .T.
			EndIf
		Else
			SD1->(MsGoto(aNFItem[nItem][IT_RECORI]))
			If !lExistNF .And. aNfItem[nItem][IT_QUANT] == SD1->D1_QUANT .And. Iif(!aSX6[MV_DEVTOT] , SD1->D1_VALFRE+SD1->D1_SEGURO+SD1->D1_DESPESA==0 ,SD1->D1_BASEIPI > 0)
				aNfItem[nItem][IT_BASEIPI] := SD1->D1_BASEIPI
				aNfItem[nItem][IT_PREDIPI]	:= aNFItem[nItem][IT_TS][TS_BASEIPI]
				lDevolBSE := .T.
			EndIf
			aNFitem[nItem][IT_ALIQIPI] := SD1->D1_IPI
			aNFitem[nItem][IT_TIPONF ] := IIf( SD1->D1_TIPO$"IP" , SD1->D1_TIPO , aNfCab[NF_TIPONF] )
			lDevolALQ := .T.
			If (SD1->D1_VALIPI > 0 .Or. Abs( aNfItem[nItem][IT_VALIPI] - SD1->D1_VALIPI) <= 1 ) .And. aNfItem[nItem][IT_QUANT] == SD1->D1_QUANT .And. Iif(!aSX6[MV_DEVTOT] , SD1->D1_VALFRE+SD1->D1_SEGURO+SD1->D1_DESPESA == 0 , SD1->D1_VALIPI > 0)
				aNfItem[nItem][IT_VALIPI] := SD1->D1_VALIPI
				lDevolVLR := .T.
			EndIf
		EndIf
	Else
		If aNFCab[NF_CLIFOR] == "C"
			SD1->(MsGoto(aNFItem[nItem][IT_RECORI]))
			If !lExistNF .And. aNfItem[nItem][IT_QUANT] == SD1->D1_QUANT .And. Iif(!aSX6[MV_DEVTOT] , SD1->D1_VALFRE+SD1->D1_SEGURO+SD1->D1_DESPESA==0 ,SD1->D1_BASEIPI > 0)
				aNfItem[nItem][IT_BASEIPI] := SD1->D1_BASEIPI
				aNfItem[nItem][IT_PREDIPI]	:= aNFItem[nItem][IT_TS][TS_BASEIPI]
				lDevolBSE := .T.
			EndIf
			aNFitem[nItem][IT_ALIQIPI] := SD1->D1_IPI
			aNFitem[nItem][IT_TIPONF ] := IIf( SD1->D1_TIPO$"IP" , SD1->D1_TIPO , aNfCab[NF_TIPONF] )
			lDevolALQ := .T.
			If (SD1->D1_VALIPI > 0 .Or. Abs(aNfItem[nItem][IT_VALIPI] - SD1->D1_VALIPI) <= 1 ) .And. aNfItem[nItem][IT_QUANT] == SD1->D1_QUANT .And. Iif(!aSX6[MV_DEVTOT] , SD1->D1_VALFRE+SD1->D1_SEGURO+SD1->D1_DESPESA == 0 , SD1->D1_VALIPI > 0)
				aNfItem[nItem][IT_VALIPI] := SD1->D1_VALIPI
				lDevolVLR := .T.
			EndIf
		Else
			SD2->(MsGoto(aNFItem[nItem][IT_RECORI]))
			If !lExistNF .And. aNfItem[nItem][IT_QUANT] == SD2->D2_QUANT .And. Iif(!aSX6[MV_DEVTOT] ,SD2->D2_VALFRE+SD2->D2_SEGURO+SD2->D2_DESPESA==0 , SD2->D2_BASEIPI >0)
				aNfItem[nItem][IT_BASEIPI] := SD2->D2_BASEIPI
				aNfItem[nItem][IT_PREDIPI]	:= aNFItem[nItem][IT_TS][TS_BASEIPI]
				lDevolBSE := .T.
			EndIf
			aNFitem[nItem][IT_ALIQIPI] := SD2->D2_IPI
			aNFitem[nItem][IT_TIPONF ] := IIf( SD2->D2_TIPO$"IP" , SD2->D2_TIPO , aNfCab[NF_TIPONF] )
			lDevolALQ := .T.
			If (SD2->D2_VALIPI > 0 .Or. Abs(aNfItem[nItem][IT_VALIPI] - SD2->D2_VALIPI) <= 1 ) .And. aNfItem[nItem][IT_QUANT] == SD2->D2_QUANT .And. Iif(!aSX6[MV_DEVTOT] , SD2->D2_VALFRE+SD2->D2_SEGURO+SD2->D2_DESPESA == 0 , SD2->D2_VALIPI > 0)
				aNfItem[nItem][IT_VALIPI] := SD2->D2_VALIPI
				lDevolVLR := .T.
			EndIf
		EndIf
	EndIf
EndIf

//Define BASE do IPI - IT_BASEIPI
If "BSE" $ cExecuta

	If !lDevolBSE

		aNfItem[nItem][IT_BASEIPI]	:= 0

		If (aNFItem[nItem][IT_TS][TS_IPI] <> "N" .And. !aNFitem[nItem][IT_TIPONF ] $ "PI" .And. aNFCab[NF_LJCIPI]) .Or. lRemFut
		
			// Calculo da base de IPI.
			If aNFItem[nItem][IT_TS][TS_AGREG]<>"F"
				aNfItem[nItem][IT_BASEIPI]:= aNfItem[nItem][IT_VALMERC] - IIf(cRefSDesc == "1",0,(aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT]))
				If (aNFCab[NF_OPERNF] == "S" .And. aNfCab[NF_OPIRRF] == "EP" .And. cRefSDesc <> "1" ) .Or. aNfCab[NF_ROTINA] == 'LOJA701' // Somente deduz quando emitido pelo LOJA ou Saida para Orgao Publico
					aNfItem[nItem][IT_BASEIPI] -=  IIf(aNFItem[nItem][IT_TS][TS_AGREG]$"DR" , aNfItem[nItem][IT_DEDICM] , 0 )	
				Endif
			EndIf

			IF aNFItem[nItem][IT_TS][TS_TRANFIL] == "1" .And. aSX6[MV_PBIPITR] > 0  .And. aNFitem[nItem][IT_PRCCF] > 0
				aNfItem[nItem][IT_BASEIPI]:=aNFitem[nItem][IT_PRCCF] * (aSX6[MV_PBIPITR]/100)
			EndIf

			//Deduz PIS/Cofins Zona Franca de Manaus da base de calculo do IPI
			If aSX6[MV_IPIZFM] .And. ( aNfCab[NF_ROTINA] $ "MATA461|FATA701|MATA103" .Or. FunName() == "MATA920" )
				aNfItem[nItem][IT_BASEIPI] := aNfItem[nItem][IT_BASEIPI] + aNfItem[nItem][IT_DESCZFPIS] + aNfItem[nItem][IT_DESCZFCOF]
			Endif

			// Se o parâmetro está habilitado significa que não foi informado o II no valor aduaneiro então devo somar o II na base do ICMS para ficar correta.
          IF aSX6[MV_EIC0064] .And.  !( aNFItem[nItem][IT_TS][TS_AGREG] $ "B|C" ).And. aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_CLIFOR] =="F" .And. aNFCab[NF_TPCLIFOR] =="X" .And. Substr(aNfItem[nItem][IT_CF],1,1)=="3" .And. aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"
             aNfItem[nItem][IT_BASEIPI] += aNfItem[nItem][IT_VALII]
          EndIf

			//	Cálculo da base de imposto IPI, com o valor do imposto do ICMS próprio.
			If aSX6[MV_SOMAICM]
				MaFisBSICM(nItem)
				If aNFItem[nItem][IT_TS][TS_AGREG] == "I" .And. aNFCab[NF_OPERNF] == "S"
					MaFisVICMS(nItem)
					aNfItem[nItem][IT_BASEIPI] += aNfItem[nItem][IT_VALICM]
				Endif
			Endif

			If aNFItem[nItem][IT_TS][TS_DESPIPI] == "S"
				aNfItem[nItem][IT_BASEIPI] += aNfItem[nItem][IT_DESPESA]
				aNfItem[nItem][IT_BASEIPI] += aNfItem[nItem][IT_SEGURO]
			EndIf

			If aNFItem[nItem][IT_TS][TS_IPIFRET] == "S"
				aNfItem[nItem][IT_BASEIPI] += aNfItem[nItem][IT_FRETE]
			EndIf

			If aNFItem[nItem][IT_TS][TS_AGREG] <> "F"
				If aNFItem[nItem][IT_TS][TS_TPIPI] == "B" .Or. ( aSX6[MV_IPIBRUT] == "S" .And. aNFItem[nItem][IT_TS][TS_TPIPI] == " " )
					aNfItem[nItem][IT_BASEIPI] += IIf(cRefSDesc == "1",0,(aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT] + aNfItem[nItem][IT_DESCZF])) 
					IF (aNFCab[NF_OPERNF] == "S" .And. aNfCab[NF_OPIRRF] == "EP" .And. cRefSDesc <> "1") .Or. aNfCab[NF_ROTINA] == 'LOJA701' // Somente deduz quando emitido pelo LOJA ou Saida para Orgao Publico
						aNfItem[nItem][IT_BASEIPI] +=  IIf(aNFItem[nItem][IT_TS][TS_AGREG]$"DR" , aNfItem[nItem][IT_DEDICM] , 0 )
					EndIf	
				EndIf
			EndIf

			// Salva a base de IPI original e aplica a reducao.
			aNfItem[nItem][IT_BIPIORI]	:= NoRound(aNfItem[nItem][IT_BASEIPI],2)

			nReduzIPI := IIf( !Empty(aNFitem[nItem,IT_EXCECAO]) .And. aNfItem[nItem,IT_EXCECAO,15] > 0 , aNfItem[nItem,IT_EXCECAO,15] , aNFItem[nItem][IT_TS][TS_BASEIPI] )

			If nReduzIPI <> 0
				If lRndrne .Or. lSobra
					aNfItem[nItem][IT_BASEIPI] := Round(aNfItem[nItem][IT_BASEIPI] * nReduzIPI / 100 , 2 )
				Else
					aNfItem[nItem][IT_BASEIPI] := NoRound(aNfItem[nItem][IT_BASEIPI] * nReduzIPI / 100 , 2 )
				EndIf

				aNfItem[nItem][IT_PREDIPI] := nReduzIPI
			EndIf

			If aNFItem[nItem][IT_TS][TS_IPI] == "R"
				If aNFItem[nItem][IT_TS][TS_IPIPECR] > 0
					aNfItem[nItem][IT_BASEIPI] := aNfItem[nItem][IT_BASEIPI] * aNFItem[nItem][IT_TS][TS_IPIPECR] / 100
				Else
					aNfItem[nItem][IT_BASEIPI] := aNfItem[nItem][IT_BASEIPI] / 2
				Endif
			EndIf
		EndIf
	Else
		If !(aNFItem[nItem][IT_TS][TS_IPI] <> "N" .And. !aNFitem[nItem][IT_TIPONF ]$"IP")
			aNfItem[nItem][IT_BASEICM]	:= 0
			aNfItem[nItem][IT_BSFRETE]	:= 0
		EndIf
	EndIf

	If lNoProces
		aNfItem[nItem][IT_BASEIPI] := nSalvaBase
	EndIf

	// Rastro de Ativo para primeira saida, nao calcula IPI
	If aSX6[MV_RASTRO] == "S" .And. aSX6[MV_RSATIVO] .And. aNfCab[NF_OPERNF] == "S" .And. aNfItem[nItem][IT_PRD][SB_RSATIVO] == "1"
		aRastItem := RastroItem(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_LOTE],Iif(Empty(aNfItem[nItem][IT_SUBLOTE]),AllTrim(aNfItem[nItem][IT_SUBLOTE]),aNfItem[nItem][IT_SUBLOTE]))
		If Len(aRastItem) > 0
			If !aRastItem[1] .And. aRastItem[2] == 0
				aNfItem[nItem][IT_BASEIPI] := 0
			Else
				//TOTALIZA ITENS DO PEDIDO DE VENDA.
				aEval( aNfItem , {|x| nQuantPed += IIf(!x[IT_DELETED] .And. x[IT_PRODUTO] == aNfItem[nItem][IT_PRODUTO] .And. x[IT_LOTE] == aNfItem[nItem][IT_LOTE] .And. x[IT_SUBLOTE] == aNfItem[nItem][IT_SUBLOTE] , x[IT_QUANT] , 0 )} )

				If nQuantPed > aRastItem[2]
					//MENSAGEM PARA QUEBRA DOS ITENS.
					If  aRastItem[1] .And. aNfItem[nItem][IT_QUANT] > aRastItem[2] .And. lRastItem
						MsgInfo(STR0033+CRLF+;  //"Para controle correto da geração do IPI, será necessário quebrar em dois Itens:"
						STR0034+aNfItem[nItem][IT_ITEM]+; //Item:
						STR0035+aNfItem[nItem][IT_PRODUTO]+;// Produto:
						STR0036+aNfItem[nItem][IT_LOTE]+; // Lote:
						STR0037+aNfItem[nItem][IT_SUBLOTE]+CRLF+; // Sub-Lote:
						STR0038+Str(aRastItem[2])+CRLF+;//"1- Quantidade Tributada:"
						STR0039+Str(aNfItem[nItem][IT_QUANT]-aRastItem[2])+CRLF+;//"2- Quantidade Não Tributada:"
						STR0040,;//"Não houve alteração do calculo do IPI"
						STR0032) //"Quebra Item, Tributado x Não Tributado"
						If ValType(lPlanRaAtv) <> "U"
							lPlanRaAtv := .F.
							lRastItem := .F.
						EndIf
					Else
						aNfItem[nItem][IT_BASEIPI] := 0
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf

	MaItArred(nItem,{"IT_BASEIPI"})
EndIf

//Define ALIQUOTA DO IPI IT_ALIQIPI
If "ALQ" $ cExecuta .And. !lDevolALQ

	aNFitem[nItem][IT_ALIQIPI] := 0
	aNFitem[nItem][IT_TIPONF ] := aNfCab[NF_TIPONF]

	If aNFItem[nItem][IT_TS][TS_IPI] <> "N" .Or. lRemFut

		aNFitem[nItem][IT_ALIQIPI] := aNfItem[nItem][IT_PRD][SB_IPI]

		If !Empty(aNFitem[nItem,IT_EXCECAO]) .And. aNFItem[nItem,IT_EXCECAO,17] <> 0 	// Verifica as Excecoes fiscais
			aNFitem[nItem][IT_ALIQIPI] := aNFItem[nItem,IT_EXCECAO,17]
		Endif

	EndIf

EndIf

//Define VALOR do IPI    IT_VALIPI
If "VLR" $ cExecuta .And. !lDevolVLR

	aNfItem[nItem][IT_VALIPI]  := 0
	aNfItem[nItem][IT_PAUTIPI] := 0

	If (aNFItem[nItem][IT_TS][TS_IPI] <> "N" .And. aNFitem[nItem][IT_TIPONF ] <> "I") .Or. lRemFut

		If aNFitem[nItem][IT_TIPONF ] == "P"
			If aNFItem[nItem][IT_TS][TS_AGREG] <> "F"
				aNfItem[nItem][IT_VALIPI] := aNfItem[nItem][IT_VALMERC]
			EndIf
		Else

			aNfItem[nItem][IT_VALIPI] := (aNfItem[nItem][IT_BASEIPI] * (aNfItem[nItem][IT_ALIQIPI] / 100))

			// Calculo do IPI de Pauta: Verifica SB1 ou SF7
			If (!Empty(aNfItem[nItem][IT_PRD][SB_VLR_IPI]) .Or. ( !Empty(aNFitem[nItem][IT_EXCECAO]) .And. aNfItem[nItem][IT_EXCECAO][9] <> 0 ) )

				If !Empty(aNFitem[nItem][IT_EXCECAO]) .And. aNfItem[nItem][IT_EXCECAO][9] <> 0

					aNFitem[nItem][IT_ALIQIPI] := IIF(!Empty(aNfItem[nItem][IT_EXCECAO][17]),aNfItem[nItem][IT_EXCECAO][17],aNfItem[nItem][IT_PRD][SB_IPI])

					nVlOprIPI	:= (aNfItem[nItem][IT_BASEIPI] * aNfItem[nItem][IT_ALIQIPI] / 100)
					nVlPautIPI	:= IIF(lSegUPau .And. aNfItem[nItem][IT_PRD][SB_CONV] > 0, ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],0,2),aNfItem[nItem][IT_QUANT]) * aNfItem[nItem][IT_EXCECAO][9]

					If lIpiMin
						If nVlOprIPI < nVlPautIPI
							aNfItem[nItem][IT_VALIPI]  := nVlPautIPI
							aNfItem[nItem][IT_PAUTIPI] := aNfItem[nItem][IT_EXCECAO][9]
							aNFitem[nItem][IT_ALIQIPI] := 0
						Else
							aNfItem[nItem][IT_VALIPI]  := nVlOprIPI
							aNfItem[nItem][IT_PAUTIPI] := 0
						EndIf
					Else
						aNfItem[nItem][IT_VALIPI]  := nVlPautIPI
						aNfItem[nItem][IT_PAUTIPI] := aNfItem[nItem][IT_EXCECAO][9]
						aNFitem[nItem][IT_ALIQIPI] := 0
					EndIf
				Else

					aNFitem[nItem][IT_ALIQIPI] := IIF(!Empty(aNFitem[nItem][IT_EXCECAO]) .And. !Empty(aNfItem[nItem][IT_EXCECAO][17]),aNfItem[nItem][IT_EXCECAO][17],aNfItem[nItem][IT_PRD][SB_IPI])

					nVlOprIPI	:= (aNfItem[nItem][IT_BASEIPI] * aNfItem[nItem][IT_ALIQIPI] / 100 )
					nVlPautIPI	:= IIF(lSegUPau .And. aNfItem[nItem][IT_PRD][SB_CONV] > 0, ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],0,2),aNfItem[nItem][IT_QUANT]) * aNfItem[nItem][IT_PRD][SB_VLR_IPI]

					If lIpiMin
						If nVlOprIPI < nVlPautIPI
							aNfItem[nItem][IT_VALIPI]  := nVlPautIPI
							aNfItem[nItem][IT_PAUTIPI] := aNfItem[nItem][IT_PRD][SB_VLR_IPI]
							aNFitem[nItem][IT_ALIQIPI] := 0
						Else
							aNfItem[nItem][IT_VALIPI]  := nVlOprIPI
							aNfItem[nItem][IT_PAUTIPI] := 0
						EndIf
					Else
						aNfItem[nItem][IT_VALIPI]  := nVlPautIPI
						aNfItem[nItem][IT_PAUTIPI] := aNfItem[nItem][IT_PRD][SB_VLR_IPI]
						aNFitem[nItem][IT_ALIQIPI] := 0
					EndIf

				EndIf

				// Caso seja devolucao utiliza os valores da NF de origem
				If aNFCab[NF_TIPONF] $ "DB"
					If aNFCab[NF_CLIFOR] == "C"
						dbSelectArea("SD2")
						If !Empty(aNFItem[nItem][IT_RECORI])
							SD2->(MsGoto(aNFItem[nItem][IT_RECORI]) )
							If aNfItem[nItem][IT_QUANT] == SD2->D2_QUANT
								aNfItem[nItem][IT_VALIPI]  := SD2->D2_VALIPI
								aNfItem[nItem][IT_PAUTIPI] := SD2->D2_VALIPI / SD2->D2_QUANT
							ElseIf aNfItem[nItem][IT_QUANT] <> SD2->D2_QUANT .And. aNFItem[nItem][IT_TS][TS_DEVPARC]$"1S"
								aNfItem[nItem][IT_PAUTIPI] := SD2->D2_VALIPI / SD2->D2_QUANT
								aNfItem[nItem][IT_VALIPI]  := aNfItem[nItem][IT_QUANT] * aNfItem[nItem][IT_PAUTIPI]
							EndIf
						EndIf
					Else
						dbSelectArea("SD1")
						If !Empty(aNFItem[nItem][IT_RECORI])
							SD1->(MsGoto( aNFItem[nItem][IT_RECORI]) )
							If aNfItem[nItem][IT_QUANT] == SD1->D1_QUANT
								aNfItem[nItem][IT_VALIPI]  := SD1->D1_VALIPI
								aNfItem[nItem][IT_PAUTIPI] := SD1->D1_VALIPI / SD1->D1_QUANT
							ElseIf aNfItem[nItem][IT_QUANT] <> SD1->D1_QUANT .And. aNFItem[nItem][IT_TS][TS_DEVPARC]$"1S"
								aNfItem[nItem][IT_PAUTIPI] := SD1->D1_VALIPI / SD1->D1_QUANT
								aNfItem[nItem][IT_VALIPI]  := aNfItem[nItem][IT_QUANT] * aNfItem[nItem][IT_PAUTIPI]
							EndIf
						EndIf
					EndIf
				EndIf

				If !Empty(aSX6[MV_IPIPFAT])
					aNfItem[nItem][IT_VALIPI] *= aNfItem[nItem][IT_PRD][SB_IPIPFAT]
				EndIf

			EndIf
		EndIf

		MaItArred(nItem,{"IT_VALIPI"})

	EndIf

	If cRefSDesc == "1"
		aNfItem[nItem][IT_VIPIORI] := aNfItem[nItem][IT_VALIPI]
	EndIf	
EndIf

If lRemFut .And. aNfItem[nItem][IT_VALIPI] > 0
	aNfItem[nItem][IT_IPIVFCF] := aNfItem[nItem][IT_VALIPI]
	aNfItem[nItem][IT_VALIPI] :=0
	aNfItem[nItem][IT_BASEIPI]:=0
EndIf

// Restaurando aliquota e valor originais pois a base foi refeita
// acima para efetuar uma correcao na base ocasionada por uma
// implementacao incorreta.

If lNoProces
	aNfItem[nItem][IT_ALIQIPI] := nSalvaAliq
	aNfItem[nItem][IT_VALIPI] := nSalvaValor
EndIf
//Seguindo a ordem do enquadramento do IIF abaixo
If  'CST' $ cExecuta
	If Empty(aNfItem[nItem][IT_PRD][SB_GRPCST])
		aNFItem[nItem][IT_TS][TS_GRPCST]:= aNfItem[nItem][IT_GRPCST]
	Else
		aNfItem[nItem][IT_PRD][SB_GRPCST]:= aNfItem[nItem][IT_GRPCST]
	EndIf
EndIf

//codigo de enquadramento do IPI
aNfItem[nItem][IT_GRPCST]	:= IIf(!Empty(aNfItem[nItem][IT_PRD][SB_GRPCST]),aNfItem[nItem][IT_PRD][SB_GRPCST],aNFItem[nItem][IT_TS][TS_GRPCST])

Return
/*/
MaFisISS -Alexandre Lemes -05/11/2012
Calculo do ISS
/*/
Static Function MaFisISS(nItem,cExecuta)

Local aIssPrg    := {}
Local cSBCodISS  := aNfItem[nItem][IT_PRD][SB_CODISS]
Local cSBRegrISS := ""
Local cBuffer    := ""
Local cUfPresISS := ""
Local cCodMunISS := ""
Local cCdMunic	 := Iif(Len(Alltrim(SM0->M0_CODMUN))<=5,xFisCodIBGE(SM0->M0_ESTENT),"")+SM0->M0_CODMUN
Local nTotalISS  := 0
Local nItValidos := 0
Local nX         := 0
Local nY         := 0
Local nBseISS    := 0
Local nAliqISS   := 0
Local nAliqTMS   := 0
Local dLei13137	 := CtoD("22/06/2015")
Local lPostVenc := aSX6[MV_ANTVISS] == "2"
Local nDia       := 1
Local nUtil      := 0
Local cMes       := Alltrim(Str(IIf(Month(dDataBase)== 12,1,Month(dDataBase)+1)))
Local cAno       := Alltrim(Str(IIf(Month(dDataBase)== 12,Year(dDataBase)+1,Year(dDataBase))))
Local aAuxData   := {CTOD("  /  /  "),CTOD("  /  /  "),RetFeriados(),LastDay(Ctod("01/"+cMes+"/"+cAno),2)}
Local lRetISS    := .F.
Local lAchou     := .F.
Local lExcecao   := .F.
Local nAliqSN    := 0

//Abaixo é realizado o tratamento de desconto referente ao ISS
//nas operações de prestação de serviço para órgão público.
//
//Nessa situação, a TES está configurada para NÃO calcular o ISS,
//pois não deve gravar valor de ISS em lugar algum, nem em SD2.
//E o livro está configurado como Isento.
//
//Neste caso, preciso calcular o que seria o ISS, caso houvesse e
//tratá-lo como desconto, no campo IT_DEDICM.

Local lDescISS	 := (aNFItem[nItem][IT_TS][TS_ISS] == "N" .And. aNFItem[nItem][IT_TS][TS_LFISS] == "I" .And. aNfCab[NF_OPIRRF] == "EP"  .And. aNFItem[nItem][IT_TS][TS_AGREG] == "D")

DEFAULT cExecuta := "BSE|ALQ|VLR"

//Define o Codigo ISS.
If ("COD" $ cExecuta)
	aNfItem[nItem][IT_PRD][SB_CODISS] := aNfItem[nItem][IT_CODISS]
	// infelizmente deixei aqui a chamada pois é onde o CODISS é atualizado, infelizmente não há um local centralizado junto com o posicionamento das demais tabelas.
	// vide mais anotações na chamada da mesma função no final do IF da alíquota.
	MaSeekCLI(nItem)
EndIf

//Define Aliquota ISS.
If ("ALQ" $ cExecuta) .Or. (lDescISS)

	If aNfCab[NF_OPERNF] == "E" .And. cSBCodISS <> aNfItem[nItem][IT_CODISS]
		aNfItem[nItem][IT_CODISS]	:= cSBCodISS
	EndIf

	If ( aNfCab[NF_OPERNF] == "S" .And. (lDescISS .Or. aNFItem[nItem][IT_TS][TS_ISS] == "S") ) .Or.;
		(aNfCab[NF_OPERNF] == "E" .And. !Empty(aNfItem[nItem][IT_CODISS]) .And. (aNFItem[nItem][IT_TS][TS_ISS] == "S" .Or. lDescISS ) ) .Or.;
		( !Empty(aNfCab[NF_NATUREZA]) .And. aInfNat[NT_CALCISS] == "S" .And. aNFItem[nItem][IT_TS][TS_ICM] == "N" .And. aNfCab[NF_OPERNF]$aSX6[MV_TPNFISS] .And. aNFItem[nItem][IT_TS][TS_DUPLIC] == "S")

		aNfItem[nItem][IT_CALCISS] := "S"
		//A aliquota sempre sera atualizada conforme atualizacao realizada no item, seguindo o mesmo tratamento realizado para os outros impostos
		nAliqISS := IIf( aNfItem[nItem][IT_PRD][SB_ALIQISS] == 0 , aSX6[MV_ALIQISS] , aNfItem[nItem][IT_PRD][SB_ALIQISS] )

		If IntTms() .And. nModulo == 43 //TMS
			If aPE[PE_TM200ISS]
				nAliqTMS := ExecBlock("TM200ISS",.F.,.F.,{DTC->DTC_SERVIC, DTC->DTC_TIPTRA, DTC->DTC_LOTNFC, DTC->DTC_CLICAL, DTC->DTC_LOJCAL, DTC->DTC_CLIREM, DTC->DTC_LOJREM, DTC->DTC_CLIDES, DTC->DTC_LOJDES})
				If ValType(nAliqTMS) == "N"
					nAliqISS := nAliqTMS
				EndIf
			Else
				If aPos[FP_DUY_ALQISS] // Verifica se foi informada a aliquota do ISS para regiao
					DUY->(dbSetOrder(1))
					If IsInCallStack('TMSA040')
						DUY->(MsSeek(xFilial("DUY")+M->DT4_CDRORI))
					Else
						DUY->(MsSeek(xFilial("DUY")+DTC->DTC_CDRCAL))
					EndIf
					If DUY->DUY_ALQISS > 0
						nAliqISS := DUY->DUY_ALQISS
					EndIf
				EndIf
			EndIf
		EndIf

		If aNfCab[NF_USAALIQSN]
			If (nAliqSN := MaAliqSimp(nItem, "ISS")) > 0 
				nAliqISS := nAliqSN
			EndIf
		EndIf

		//Define a Aliquota do ISS por Excecao Fiscal.
		If ( !Empty(aNFitem[nItem][IT_EXCECAO]) ) .And. aNfItem[nItem][IT_EXCECAO][7] == "S"
			If aNFCab[NF_UFORIGEM] == aNFCab[NF_UFDEST]
				If aNFItem[nItem][IT_EXCECAO][1] > 0
					nAliqISS := aNfItem[nItem][IT_EXCECAO][1] //Aliquota Interna
					lExcecao := .T.
				EndIf
			Else
				If aNFItem[nItem][IT_EXCECAO][2] > 0
					nAliqISS := aNfItem[nItem][IT_EXCECAO][2] //Aliquota Externa
					lExcecao := .T.
				EndIf
			EndIf
		EndIf
	Else
		aNfItem[nItem][IT_CALCISS] := "N"
	EndIf

	aNfItem[nItem][IT_RATEIOISS]:= aNFItem[nItem][IT_TS][TS_ISS]
	aNfItem[nItem][IT_ALIQISS]  := nAliqISS

	aNfItem[nItem][IT_CNAE]	:= aNfItem[nItem][IT_PRD][SB_CNAE]
	aNfItem[nItem][IT_CFPS]	:= aNFItem[nItem][IT_TS][TS_CFPS]
	aNfItem[nItem][IT_TRIBMU] := aNfItem[nItem][IT_PRD][SB_TRIBMU]

	//Tratamento para Controle de Aliquota atraves da tabela CE1 - Aliquotas do ISS.
	If aSX6[MV_ISSXMUN] .And. aNFItem[nItem][IT_TS][TS_ISS] == "S" .And. ((aNfCab[NF_OPERNF] == "E" .And. !aNFCab[NF_TIPONF] $ "DB") .Or. (aNfCab[NF_OPERNF] == "S")) .And. aDic[AI_CE1]

		cUfPresISS := IIf( aNfItem[1][IT_PRD][SB_MEPLES] == "2" , aNFCab[NF_UFPREISS] , aNFCab[NF_UFORIGEM] )
		cCodMunISS := IIf( aNfItem[1][IT_PRD][SB_MEPLES] == "2" , aNfCab[NF_CODMUN]   , IIf( aNfCab[NF_OPERNF] == "S" , Substr(Alltrim(cCdMunic),3,5) , cMunForISS ) )

		cCodMunISS := IIf( aSX6[MV_EISSXM]=="1" .And. aNfCab[NF_OPERNF] == "E",Substr(Alltrim(cCdMunic),3,5),cCodMunISS )

		cFornCE1   := Space(Len(SA2->A2_COD))
		cLojaCE1   := Space(Len(SA2->A2_LOJA))
		cDescCE1    := CE1->CE1_MUNISS
		dVencCE1   := CTod("")
		cRecIssCE1 := Iif( aNfCab[NF_OPERNF] == "S" .And. !aNFCab[NF_TIPONF] $ "DB" , "1" , aNFCab[NF_RECISS] )

		CE1->(dbSetOrder(1)) //Cod.Prest.Servico sempre segue o Municipio do cadastro da filial sigamat.emp no caso de operacoes de saida.

		If aNfCab[NF_OPERNF] == "S" .And. CE1->(msSeek(xFilial("CE1")+cSBCodISS+SM0->M0_ESTENT+Substr(Alltrim(cCdMunic),3,5)+aNfItem[nItem][IT_PRODUTO]))
			aNfItem[nItem][IT_CODISS]:= CE1->CE1_CPRISS
		ElseIf aNfCab[NF_OPERNF] == "S" .And. CE1->(MsSeek(xFilial("CE1")+aNfItem[nItem][IT_PRD][SB_CODISS]+SM0->M0_ESTENT+Substr(Alltrim(cCdMunic),3,5)))
			aNfItem[nItem][IT_CODISS]:= CE1->CE1_CPRISS
		EndIf

		If aNfCab[NF_OPERNF] == "E" .And. aSX6[MV_EISSXM]=="1"
			If CE1->(MsSeek(xFilial("CE1")+cSBCodISS+SM0->M0_ESTENT+cCodMunISS+aNfItem[nItem][IT_PRODUTO]))
				lAchou := .T.
			ElseIf CE1->(MsSeek(xFilial("CE1")+aNfItem[nItem][IT_PRD][SB_CODISS]+SM0->M0_ESTENT+cCodMunISS))
				lAchou := .T.
			Endif
		Else
			If CE1->(MsSeek(xFilial("CE1")+cSBCodISS+cUfPresISS+cCodMunISS+aNfItem[nItem][IT_PRODUTO]))
				lAchou := .T.
			ElseIf CE1->(MsSeek(xFilial("CE1")+aNfItem[nItem][IT_PRD][SB_CODISS]+cUfPresISS+cCodMunISS))
				lAchou := .T.
			Endif
		EndIf

		If lAchou
			//ALTERACAO DO MUNICIPIO
			If aNfCab[NF_OPERNF] == "E"
				aNfItem[nItem][IT_CODISS]:= CE1->CE1_CTOISS
			EndIf

			aNfItem[nItem][IT_ALIQISS]:= IIf(!Empty(CE1->CE1_ALQISS) .And. !lExcecao,CE1->CE1_ALQISS,nAliqISS)

			//Grava campo Cnae e Tribmun SFT
			If aPos[FP_CE1_TRIBMU]
				aNfItem[nItem][IT_TRIBMU] := PadR(CE1->CE1_TRIBMU, TamSX3("CE1_TRIBMU")[1])
			EndIf

			If aPos[FP_CE1_CNAE]
				aNfItem[nItem][IT_CNAE] := CE1->CE1_CNAE
			EndIf

			If CE1->CE1_RETISS == "1" //Retem ISS 1=SIM / 2=NAO

				If	aSX6[MV_EISSXM] =="1" .And. aPos[FP_CE1_RMUISE]
					If aNfCab[NF_OPERNF] == "S" .And. aNFCab[NF_RECISS] $ "S|1|" .And.;
						((CE1->CE1_RMUISS == "1" .And. Substr(Alltrim(cCdMunic),3,5) == cMunForISS ) .Or.;
						(CE1->CE1_RMUISS == "2" .And. Substr(Alltrim(cCdMunic),3,5) <> cMunForISS ) .Or.;
						(CE1->CE1_RMUISS == "3" ))

						lRetISS := .T.
					ElseIf aNfCab[NF_OPERNF] == "E" .And. aNFCab[NF_RECISS] $ "N|2| " .And.;
						((CE1->CE1_RMUISE == "1" .And. Substr(Alltrim(cCdMunic),3,5) == cMunForISS ) .Or.;
						(CE1->CE1_RMUISE == "2" .And. Substr(Alltrim(cCdMunic),3,5) <> cMunForISS ) .Or.;
						(CE1->CE1_RMUISE == "3" ))

						lRetISS := .T.
					Else
						cRecIssCE1 := '1' // nao gera titulo de ISS
					EndIF
				ElseIf ((CE1->CE1_RMUISS == "1" .And. Substr(Alltrim(cCdMunic),3,5) == cMunForISS ) .Or.; //cMunForIss e o Municipio Original do Fornecedor
						  (CE1->CE1_RMUISS == "2" .And. Substr(Alltrim(cCdMunic),3,5) <> cMunForISS ) .Or.;
						  (CE1->CE1_RMUISS == "3" ))

					lRetISS := .T.
				EndIf

				If lRetISS
					cFornCE1    := CE1->CE1_FORISS
					cLojaCE1    := CE1->CE1_LOJISS
					cDescCE1    := CE1->CE1_MUNISS

					If cPaisLoc == "BRA"
						dbSelectArea("CC2")
						CC2->(dbSetOrder(1))
						CC2->(dbSeek(xFilial("CC2")+CE1->CE1_ESTISS+CE1->CE1_CMUISS))
						If aPos[FP_CC2_TPDIA] .and. CC2->CC2_TPDIA == "2" .And. CC2->CC2_DTRECO <> 0
							If cMes == "2" .And. CC2->CC2_DTRECO > Day(LastDay(Ctod("01"+"/"+"2"+"/"+cAno)))
								cDia 		:= Alltrim(Str(Day(LastDay(Ctod("01"+"/"+"2"+"/"+cAno)))))
								dVencCE1	:= DataValida(Ctod(cDia+"/"+cMes+"/"+cAno), lPostVenc)
							Else
								cDia 		:= Alltrim(Str(CC2->CC2_DTRECO))
								dVencCE1	:= DataValida(Ctod(cDia+"/"+cMes+"/"+cAno), lPostVenc)
							EndIf
						Else
							While nUtil < CC2->CC2_DTRECO .And. nDia <= Day(aAuxData[4])
								aAuxData[1]:=CTOD((Str(nDia))+"/"+cMes+"/"+cAno)
								If LastDay(aAuxData[1],3) == aAuxData[1] .And. ;
									Ascan(aAuxData[3],Dtos(aAuxData[1])) == 0
									aAuxData[2] := aAuxData[1]
									nUtil++
								EndIf
								nDia++
							EndDo
							dVencCE1    := IIF(nUtil < CC2->CC2_DTRECO,LastDay(aAuxData[2],2),aAuxData[2])
						Endif
					Endif

						cRecIssCE1  := "2"
				EndIf

				dVencISS := dVencCE1
				cFornISS := cFornCE1
				cLojaISS := cLojaCE1

			Endif

			aNFCab[NF_RECISS] := Iif( aNfCab[NF_OPERNF] == "S" .And. !aNFCab[NF_TIPONF] $ "DB" , aNFCab[NF_RECISS] , cRecISSCE1 )
		Else
			If !lExcecao .And. (aNfItem[nItem][IT_ALIQISS] <= 0 .OR. aNfItem[nItem][IT_ALIQISS] == aSX6[MV_ALIQISS])
				nAliqISS := IIf( aNfItem[nItem][IT_PRD][SB_ALIQISS] == 0 , aSX6[MV_ALIQISS] , aNfItem[nItem][IT_PRD][SB_ALIQISS] )
				aNfItem[nItem][IT_ALIQISS]:= nAliqISS
			EndIf
		EndIf
	EndIf
	// Chamando o posicionamento da CLI pois infelizmente o CODISS é atualizado na função de cálculo do ISS :/ 
	// Poderia estar na função que carrega o produto se não fosse a CE1
	// Retirar daqui quando reescrever o ISS :D
	MaSeekCLI(nItem) 

EndIf

//Define a Base do ISS.
If ("BSE" $ cExecuta) .Or. (lDescISS)

	aNfItem[nItem][IT_BASEISS]:= 0

	If (aNfItem[nItem][IT_CALCISS] == "S" .Or. lDescISS ) .And. (aNfCab[NF_OPERNF] == "E" .Or. ;
		((aNfCab[NF_RECISS] == "1" .And. aNfCab[NF_OPERNF] == "S" .And. aSX6[MV_DESCISS] ) .Or. (aNfCab[NF_RECISS] <> "1" .And. aNfCab[NF_OPERNF] == "S") ) )

		//-- Se descontos incondicionais subtraidos antes de aplicar % de reducao da base
		nBseISS := aNfItem[nItem][IT_VALMERC] - IIf( aNFItem[nItem][IT_TS][TS_DESCOND] == "2" .And. (!aPos[FP_F4_DESCISS] .Or. aNFItem[nItem][IT_TS][TS_DESCISS] <> "2") , (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT]) , 0 ) //Caso o desconto INCONDICIONAL aNFItem[nItem][IT_TS][TS_DESCOND] == "2" abater o desconto da base de ISS.

		If aNFItem[nItem][IT_TS][TS_BASEISS] > 0 // Reducao padrao da base do ISS ( TES )
			nBseISS := ( nBseISS * aNFItem[nItem][IT_TS][TS_BASEISS] ) / 100
			aNfItem[nItem][IT_PREDISS] := aNFItem[nItem][IT_TS][TS_BASEISS]
		EndIf

		If aNfItem[nItem,IT_REDISS] > 0 // Reducao opcional da base do ISS ( TES )
			nBseISS := ( nBseISS * aNfItem[nItem,IT_REDISS] ) / 100
			aNfItem[nItem][IT_PREDISS] := aNfItem[nItem,IT_REDISS]
		EndIf

		//-- Se descontos incondicionais subtraidos apos de aplicar % de reducao da base
		nBseISS := nBseISS - IIf( aNFItem[nItem][IT_TS][TS_DESCOND] == "2" .And. (aPos[FP_F4_DESCISS] .And. aNFItem[nItem][IT_TS][TS_DESCISS] == "2") , (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT]) , 0 ) //Caso o desconto INCONDICIONAL aNFItem[nItem][IT_TS][TS_DESCOND] == "2" abater o desconto da base de ISS.

		If aTes[TS_AGRISS] == "1"
			nBseISS := nBseISS/(1-(aNfItem[nItem][IT_ALIQISS]/100))
		Endif

		//Tratamento de Controle de Deducoes atraves do cadastro CC2 - Municipios.
		If cPaisLoc == "BRA" .And. aSX6[MV_ISSXMUN] .And. aPos[FP_CC2_PERMAT] .And. aPos[FP_CC2_PERSER] .And. aPos[FP_CC2_MDEDMA] .And. aPos[FP_CC2_MDEDSR]
			If aNFItem[nItem][IT_TS][TS_ISS] == "S" .And. ( (aNfCab[NF_OPERNF] == "E" .And. !aNFCab[NF_TIPONF] $ "DB") .Or. (aNfCab[NF_OPERNF] == "S" .And. aNFCab[NF_TIPONF] $ "DB") )
				//Muncio Arbitra o Valor da Deducao 1=SIM e 2=NAO e foi Informado o percentual a Arbitrar.
				CC2->(dbSetOrder(1))
				If CC2->(MsSeek(xFilial("CC2") + aNFCab[NF_UFORIGEM] + aNfCab[NF_CODMUN]))
					If CC2->CC2_PERMAT > 0 //Municipio Arbitra Deducoes de Materiais.
						aNfItem[nItem,IT_ABMATISS]	:=	nBseISS * (CC2->CC2_PERMAT/100)
					EndIf
					If CC2->CC2_PERSER > 0  //Municipio Arbitra Deducoes de Servicos.
						aNfItem[nItem,IT_ABVLISS]	:=  nBseISS * (CC2->CC2_PERSER/100)
					EndIf
					If CC2->CC2_MDEDMA == "2"
						aNfItem[nItem,IT_ABMATISS]	:= 0
					EndIf
					If CC2->CC2_MDEDSR == "2"
						aNfItem[nItem,IT_ABVLISS]	:= 0
					EndIf
				EndIf
			EndIf
		EndIf

		//Utilizada condicao de FunName() para o If abaixo (tabela SC6) pois eh necessario mapear a real necessidade deste calculo
		//no preenchimento da referencia IT_ABMATISS. Foram levantadas as possibilidades de utilizar MaFisLoad ou MaFisAlt nos fontes
		//MATA410 e MATA461 para que este If nao exista mais.
		If FunName()=="MATA410" .Or. aNfCab[NF_ROTINA] == "MATA461"
			If cPaisLoc == "BRA" .And. SC6->C6_ABATMAT > 0 //Incluido tratamento para que o Valor a ser descontado seja proporcional a quantidade faturada
				aNfItem[nItem,IT_ABMATISS] := ((aNfItem[nItem][IT_QUANT] * SC6->C6_ABATMAT) / SC6->C6_QTDVEN)
			EndIf
		Endif

		nBseISS -= aNfItem[nItem,IT_ABVLISS]
		nBseISS -= aNfItem[nItem,IT_ABMATISS]

		//Alteracao da base de calculo do ISS para o municipio conforme campo Base ISS, conforme Lei Complementar 185 de 25 de julho de 2007 (Barueri).
		If aPos[FP_CC2_BASISS]
			//-- Verificar campo Exe.Servico (B1_MEPLES), 1=EP ou 2=LES
			cUfPresISS := IIf( aNfItem[1][IT_PRD][SB_MEPLES] == "2" , aNFCab[NF_UFPREISS] , aNFCab[NF_UFORIGEM] )
			cCodMunISS := IIf( aNfItem[1][IT_PRD][SB_MEPLES] == "2" , aNfCab[NF_CODMUN]   , IIf( aNfCab[NF_OPERNF] == "S" , Substr(Alltrim(cCdMunic),3,5) , cMunForISS ) )
			//-- Verificar campo Ded.Base ISS (CC2_BASISS), 1=Sim ou 2=Nao
			CC2->(dbSetOrder(1)) //CC2_FILIAL+CC2_EST+CC2_MUN
			If CC2->(MsSeek(xFilial("CC2") + cUfPresISS + cCodMunISS) .And. CC2_BASISS == "1")
				//-- Somente se acima do valor informado no parametro MV_VL10925.
				nBseISS := nBseISS - aNfItem[nItem][IT_VALIRR]
				If dDataBase >= dLei13137 .Or. aNfItem[nItem][IT_VALMERC] >= aSX6[MV_VL10925]
					nBseISS := nBseISS - aNfItem[nItem][IT_VALPIS] - aNfItem[nItem][IT_VALCOF] - aNfItem[nItem][IT_VALCSL]
				EndIf
			EndIf
		//Versao anterior a criacao do campo Base ISS no Cadastro de Municipios.
		ElseIf cCdMunic == '3505708' .And. aNfCab[NF_OPERNF] == "S" .And. aNfItem[1][IT_PRD][SB_MEPLES] == "1"

			If AllTrim(SubStr(cCdMunic, 3, 5)) == aNfCab[NF_CODMUN]
				nBseISS := nBseISS - aNfItem[nItem][IT_VALPIS] - aNfItem[nItem][IT_VALCOF] - aNfItem[nItem][IT_VALCSL] - aNfItem[nItem][IT_VALIRR]
			EndIf

		EndIf
		
		//Eeftua o Gross Up do Imposto de renda na base de cálculo do ISS
		IF xFisGrossIR(nItem, aNFItem, aNfCab,"ISS") //Verifica se deverá considerar GrossUp do IRRF na base do ISS
			nBseISS	:= nBseISS / ( 1 - ( aNfItem[nItem][IT_ALIQIRR] / 100 ) )			
		EndIF		
		aNfItem[nItem][IT_BASEISS] := nBseISS

	EndIf

EndIf

//Define o Valor do ISS.
If ("VLR" $ cExecuta) .Or. (lDescISS)

	aNfItem[nItem][IT_VALISS] := 0

	If aNfItem[nItem][IT_CALCISS] == "S" .Or. lDescISS

		aNfItem[nItem][IT_VALISS] := aNfItem[nItem][IT_BASEISS] * aNfItem[nItem][IT_ALIQISS] / 100

		If aNFItem[nItem][IT_TS][TS_AGREG] == "D" .Or. aNFItem[nItem][IT_TS][TS_AGREG] == "R"
			If lDescISS
				aNfItem[nItem][IT_DEDICM] := aNfItem[nItem][IT_VALISS]
			Else
				If aNFItem[nItem][IT_TS][TS_BASEISS] > 0
					If aSX6[MV_DBRDIF]
						aNfItem[nItem][IT_DEDICM] := Round(aNfItem[nItem][IT_BICMORI] * aNfItem[nItem][IT_ALIQISS] / 100 * (1-(aNFItem[nItem][IT_TS][TS_BASEISS]/100)),2)
					Else
						aNfItem[nItem][IT_DEDICM] := Round(aNfItem[nItem][IT_BICMORI] * aNfItem[nItem][IT_ALIQISS] / 100 * (aNFItem[nItem][IT_TS][TS_BASEISS]/100),2)
					EndIf
				Else
					aNfItem[nItem][IT_DEDICM] := aNfItem [nItem][IT_BICMORI] - Round(aNfItem[nItem][IT_BICMORI] * (1-(aNfItem[nItem][IT_ALIQISS]/100*IIf(aNFItem[nItem][IT_TS][TS_BASEISS]==0,1,aNFItem[nItem][IT_TS][TS_BASEISS]/100))),2)
				EndIf
			EndIf
		EndIf

		If aNFCab[NF_TIPONF] $ "DB"
			If !Empty(aNFItem[nItem][IT_RECORI])
				If ( aNFCab[NF_CLIFOR] == "C")
					SD2->(MsGoto(aNFItem[nItem][IT_RECORI]))
					If (SD2->D2_VALISS > 0 .Or. Abs(aNfItem[nItem][IT_VALISS]-SD2->D2_VALISS)<=1) .And. aNfItem[nItem][IT_QUANT] == SD2->D2_QUANT .And. SD2->D2_VALFRE + SD2->D2_SEGURO + SD2->D2_DESPESA == 0
						aNfItem[nItem][IT_VALISS] := SD2->D2_VALISS
						aNfItem[nItem][IT_DEDICM] := IIf(cPaisLoc == "BRA" .And. (aNFItem[nItem][IT_TS][TS_AGREG] == "D" .Or. aNFItem[nItem][IT_TS][TS_AGREG] == "R") , SD2->D2_DESCICM , 0 )
					EndIf
				Else
					SD1->(MsGoto(aNFItem[nItem][IT_RECORI]))
					If (SD1->D1_VALISS > 0 .Or. Abs(aNfItem[nItem][IT_VALISS]-SD1->D1_VALISS)<=1) .And. aNfItem[nItem][IT_QUANT] == SD1->D1_QUANT .And. SD1->D1_VALFRE + SD1->D1_SEGURO + SD1->D1_DESPESA == 0
						aNfItem[nItem][IT_VALISS] := SD1->D1_VALISS
						aNfItem[nItem][IT_DEDICM] := IIf(aNFItem[nItem][IT_TS][TS_AGREG] == "D" .Or. aNFItem[nItem][IT_TS][TS_AGREG] == "R" , SD1->D1_DESCICM , 0 )
					EndIf
				EndIf
			EndIf
		Else
			MaItArred(nItem,{"IT_VALISS"})
		EndIf
	EndIf
	//Abaixo é realizado o tratamento de desconto referente ao ISS
	//nas operações de prestação de serviço para órgão público.
	//Acima já utilizei o que seria o ISS como um desconto, no IT_DEDICM
	//portanto abaixo, volto a zerar o ISS, pois não há ISS no documento
	If lDescISS
		aNfItem[nItem][IT_VALISS] 	:= 0
		aNfItem[nItem][IT_ALIQISS]	:= 0
		aNfItem[nItem][IT_BASEISS]	:= 0
	EndIf

EndIf

//ISS PROGRESSIVO -  Aplica a Aliquota e o Valor do ISS conforme arquivo Texto
//CALCPROG.ISS localizado no \SYSTEM, sobrepondo o calculo Normal feito acima.
If aNfItem[nItem][IT_CALCISS] == "S" .And. aSX6[MV_ISSPRG] == "S" .And. aPos[FP_B1_REGRISS]

	If File("calcprog.iss")
		cSBRegrISS := aNfItem[nItem][IT_PRD][SB_REGRISS]
		FT_FUse("calcprog.iss")
		FT_FGotop()
		While ( !FT_FEof() )
			cBuffer := FT_FReadLn()

			If ( (AllTrim(SubStr(cBuffer,01,05)) == Substr(Alltrim(SM0->M0_CODMUN),3,5)  ) ;
				.Or.  (AllTrim(SubStr(cBuffer,01,05)) == Alltrim(aNfCab[NF_CODMUN]) ));
				.And.  AllTrim(SubStr(cBuffer,06,02)) == cSBRegrISS

				aadd(aIssPrg,{SubStr(cBuffer,01 ,05 )  ,; // 01 Codigo do Municipio
				SubStr(cBuffer,06 ,02 )  ,; // 02 Codigo da regra referente ao B1_REGRISS
				Val(SubStr(cBuffer,08 ,17 )) ,; // 03 Valor inicial da faixa
				Val(SubStr(cBuffer,25 ,17 )) ,; // 04 Valor final da faixa
				Val(SubStr(cBuffer,42 ,06 )) ,; // 05 Aliquota
				Val(SubStr(cBuffer,48 ,09 )) }) // 06 Valor de desconto
			EndIf
			FT_FSkip()
		EndDo
		FT_FUse()
	Else
		Alert("Tabela de configuração não encontrada!")
	EndIf

	If !Empty(aIssPrg)  ;
		.And. (( aIssPrg[1][1] == Substr(Alltrim(SM0->M0_CODMUN),3,5) .And. aIssPrg[1][1] == Alltrim(aNfCab[NF_CODMUN]) .And. aNFCab[NF_OPERNF] == "S" ) ; //Se for Saida e Cod Mun Estiver no Sigamat
		.Or. ( aIssPrg[1][1] == Alltrim(aNfCab[NF_CODMUN]) .And. aNFCab[NF_OPERNF] == "E" ) )

		For nY:= 1 to Len(aNfItem)
			If !aNfItem[nY][IT_DELETED]
				nTotalISS += aNfItem[nY][IT_VALMERC] - (aNfItem[nY][IT_DESCONTO]+aNfItem[nY][IT_DESCTOT])
				nItValidos += 1
			EndIf
		Next nY

		For nX := 1 to Len(aIssPrg)
			If 	( nTotalISS >= aIssPrg[nX][3] .And. nTotalISS <= aIssPrg[nX][4] )
				nAliqISS := aIssPrg[nX][5]
				If "ALQ" $ cExecuta
					For nY:= 1 to Len(aNfItem)
						aNfItem[nItem][IT_ALIQISS] := nAliqISS
						If nY <> nItem
							MaFisAlt("IT_ALIQISS",nAliqISS,nY)
						EndIf
					Next nY
				EndIf
				aNfItem[nItem][IT_VALISS] := ( aNfItem[nItem][IT_BASEISS] * ( nAliqISS / 100 ) ) - ( aIssPrg[nX][6] / nItValidos )
				aNfCab[NF_DESCISS] := aIssPrg[nX][6]
				MaItArred(nItem,{"IT_VALISS"})
				Exit
			EndIf
		Next nX

	EndIf
EndIf

Return

/*/
MaAliqISS- Alexandre Lemes-05/11/2012
A funcao MaAliqISS foi mantida apenas por motivo de compati
bilidade, pois devido a mesma nao ser STATIC ela foi utiliza
da em varios programas do PROTHEUS para obter a aliquota ISS*/

Function MaAliqISS(nItem)
MaExcecao(nItem)
MaFisISS(nItem,"ALQ")
Return(aNfItem[nItem][IT_ALIQISS])

/*/
MaFisINSS - Alexandre Lemes - 29/10/2012
Calcula o INSS.
/*/
Static Function MaFisINSS(nItem,cExecuta)

Local nInssAcum  := 0
Local nValMaxIns := 0
Local nI		 := 0
Local nCont      := 0
Local nTotInss	 := 0
Local nValInss	 := 0
Local nInssAnt	 := 0
Local aAliqCPEsp := {}
Local cAliqCPEsp := aSX6[MV_ALCPESP]
Local nQtdAliq   := 0
Local lLegadoEsp := .F.

DEFAULT cExecuta := "BSE|ALQ|VLR|RED"

If "RED" $ cExecuta

	aNfItem[nItem][IT_REDINSS] := aNfItem[nItem][IT_PRD][SB_REDINSS]
	//O parametro MV_CTRAUTO define se para notas fiscais de complemento de frete deve ser considerado as informacoes de IRRF e INSS
	//(calculo e reducao) da natureza financeira ou do cadastro de produtos. .T. = Natureza  .F. = Produto  (DEFAULT .F.)
	If Empty(aNfItem[nItem][IT_REDINSS]) .Or. ( aSX6[MV_CTRAUTO] .And. aNfCab[NF_TIPONF]=="C" .And. aNfCab[NF_TPCOMP] == "F" )
		If !Empty(aNfCab[NF_NATUREZA])
			aNfItem[nItem][IT_REDINSS] := aInfNat[NT_BASEINS]
		EndIf
	EndIf

EndIf

If "ALQ" $ cExecuta

	aNfItem[nItem][IT_ALIQINS] := IIf( !Empty(aNfCab[NF_NATUREZA]) , aInfNat[NT_PERCINS] , 0 )
	// Manteremos duas formas de calcular o INSS especial, pode ser considerado que o valor total do item 
	// se refere a aposentadoria especial, nesse caso ele pode configurar a alíquota adicional via campo definido no 
	// parâmetro MV_ALINSB1.
	// A outra forma seria considerar que em apenas 1 item ele tem valor de aposentadoria especial, mas não com a mesma alíquota.
	// Exemplo: valor do item: 100,00 valor especial a 15 anos: 40,00 e valor especial a 20 anos: 30,00 
 
	If	aNfItem[nItem][IT_SECP15]	>	0	.or.  ;
		aNfItem[nItem][IT_SECP20]	>	0	.or.  ;
		aNfItem[nItem][IT_SECP25]	>	0

		If !Empty(cAliqCPEsp)

			aAliqCPEsp := StrTokArr(cAliqCPEsp,'|')

			nQtdAliq  := 03
			For nCont := 01 To nQtdAliq
	
				If !Empty(aAliqCPEsp[nCont])
					aAliqCPEsp[nCont] := Val(aAliqCPEsp[nCont])
				Else
					aAliqCPEsp[nCont] := 0
				EndIf
			Next nCont
		
		Else	
		
			aAliqCPEsp := {0,0,0}
			
		EndIf
		
		aNfItem[nItem][IT_ALCP15] := aAliqCPEsp[01]
		aNfItem[nItem][IT_ALCP20] := aAliqCPEsp[02]
		aNfItem[nItem][IT_ALCP25] := aAliqCPEsp[03]
	 
	Else

		If !Empty(aSX6[MV_ALINSB1])
			dbSelectArea(cAliasPROD)
			If &(aSX6[MV_ALINSB1]) > 0
		
				If &(aSX6[MV_TPAPSB1]) 		== '1'
					aNfItem[nItem][IT_ALCP15] := &(aSX6[MV_ALINSB1])
				ElseIf &(aSX6[MV_TPAPSB1]) 	== '2'
					aNfItem[nItem][IT_ALCP20] := &(aSX6[MV_ALINSB1])
				ElseIf &(aSX6[MV_TPAPSB1]) 	== '3'
					aNfItem[nItem][IT_ALCP25] := &(aSX6[MV_ALINSB1])
				EndIf

			EndIf

				aNfItem[nItem][IT_ALIQINA]	:=	aNfItem[nItem][IT_ALIQINS] + &(aSX6[MV_ALINSB1])
		
		EndIf

	EndIf
EndIf

If "BSE" $ cExecuta

	aNfItem[nItem][IT_BASEINS] := 0

	If aNfItem[nItem][IT_PRD][SB_INSS] == "S" .Or. ( aSX6[MV_CTRAUTO] .And. aNfCab[NF_TIPONF] == "C" .And. aNfCab[NF_TPCOMP] == "F" .And. !Empty(aNfCab[NF_NATUREZA]) .And. aInfNat[NT_CALCINS] == "S" )
		If aNfItem[nItem][IT_PRD][SB_INSS] == "S" .And. (aNFItem[nItem][IT_TS][TS_DUPLIC] == "S" .Or. lINSSSemDu .Or. aNFItem[nItem][IT_TS][TS_CINSS]=="1")

			If aNfCab[NF_RECINSS] == "S" .Or.;
				(aNfCab[NF_RECINSS]=="N" .And. aNFCab[NF_OPERNF]=="S" .And. aInfNat[NT_DEDINSS] == "2")

				If aNfItem[nItem][IT_ALIQINS] > 0

					aNfItem[nItem][IT_BASEINS] := (aNfItem[nItem][IT_TOTAL] + ;
					IIf( aTes[TS_AGREG]		$	"D", aNfItem[nItem][IT_DEDICM] , 0 ) + ;
					IIf( aSX6[MV_INSSDES]	==	"1", aNfItem[nItem,IT_DESCONTO], 0 ) ) * ;
					IIf(aNfItem[nItem][IT_REDINSS] > 0 , aNfItem[nItem][IT_REDINSS]/100 , 1 )

					aNfItem[nItem][IT_BASEINS] -= aNfItem[nItem,IT_ABVLINSS] // Abatimento da base de calculo do INSS

					If aNfItem[nItem][IT_BASEINS] >0
						If	aNfItem[nItem][IT_SECP15]	>	0	.or.  ;
							aNfItem[nItem][IT_SECP20]	>	0	.or.  ;
							aNfItem[nItem][IT_SECP25]	>	0

						aNfItem[nItem][IT_BSCP15] := aNfItem[nItem][IT_SECP15]
						aNfItem[nItem][IT_BSCP20] := aNfItem[nItem][IT_SECP20]
						aNfItem[nItem][IT_BSCP25] := aNfItem[nItem][IT_SECP25]

						Else 
							If !Empty(aSX6[MV_ALINSB1])
								dbSelectArea(cAliasPROD)
								If &(aSX6[MV_ALINSB1]) > 0
									If &(aSX6[MV_TPAPSB1]) == '1'
										aNfItem[nItem][IT_BSCP15] := aNfItem[nItem][IT_BASEINS]
									ElseIf &(aSX6[MV_TPAPSB1]) == '2'
										aNfItem[nItem][IT_BSCP20] := aNfItem[nItem][IT_BASEINS]
									ElseIf &(aSX6[MV_TPAPSB1]) == '3'
										aNfItem[nItem][IT_BSCP25] := aNfItem[nItem][IT_BASEINS]
									EndIf 
									aNfItem[nItem][IT_BASEINA]    := aNfItem[nItem][IT_BASEINS]
								EndIf 		
							EndIf
						EndIf 
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf

EndIf

If "VLR" $ cExecuta


			aNfItem[nItem][IT_VLCP15] := aNfItem[nItem][IT_BSCP15] * aNfItem[nItem][IT_ALCP15] /100
			aNfItem[nItem][IT_VLCP20] := aNfItem[nItem][IT_BSCP20] * aNfItem[nItem][IT_ALCP20] /100
			aNfItem[nItem][IT_VLCP25] := aNfItem[nItem][IT_BSCP25] * aNfItem[nItem][IT_ALCP25] /100
			
			aNfItem[nItem][IT_VALINS] := aNfItem[nItem][IT_BASEINS] * aNfItem[nItem][IT_ALIQINS] /100
			aNfItem[nItem][IT_VALINS] += aNfItem[nItem][IT_VLCP15] + aNfItem[nItem][IT_VLCP20] + aNfItem[nItem][IT_VLCP25]
			
	If aSX6[MV_LIMINSS] > 0 .And. aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_CLIFOR] == "F" .And. Len(AllTrim(aNFCab[NF_CNPJ])) < 14 .And. Len(AllTrim(aNFCab[NF_CNPJ])) > 1

		aNfItem[nItem][IT_ACINSS] := 0

		nTotInss := 0
		nInssAnt := 0

		For nI := 1 to nItem
			If aNfItem[nItem][IT_ACINSS] == 0
				aNfItem[nItem][IT_ACINSS] := aNfItem[nItem][IT_VALINS]
			EndIf
			If !aNfItem[nI][IT_DELETED]
				nTotInss += aNfItem[nI][IT_ACINSS]
				If nItem <> nI
					nInssAnt += aNfItem[nI][IT_ACINSS]
				Endif
			Endif
		Next nI

		nInssAcum  	:= VerInssAcm(aNfCab[NF_CODCLIFOR],aNfCab[NF_LOJA],aNfCab[NF_NREDUZ],dDataBase,dDataBase,.T.)
		nValMaxIns 	:= ( aSX6[MV_LIMINSS] - nInssAcum )
		nValInss    := ( nValMaxIns - nInssAnt )

		Do Case
			Case nValMaxIns <= 0
				aNfItem[nItem][IT_VALINS] := 0
				lLimInss := .T.
			Case ( nValMaxIns < nTotInss )
				aNfItem[nItem][IT_VALINS] := Iif( nValInss < 0 , 0 , nValInss )
				lLimInss := .T.
		EndCase

		If lLimInss
			MaFisToCols(aHeader,aCols,,"MT100")
		Endif
	Endif

	// Abatimento da valor do INSS em valor - Subcontratada
	//Faturamento
	If aNfItem[nItem][IT_VALINS] >= aNfItem[nItem][IT_ABSCINS] .And. aNfItem[nItem][IT_ABSCINS] > 0
		aNfItem[nItem][IT_VALINS] -= aNfItem[nItem][IT_ABSCINS]
	Endif
	//Movimento de entrada
	If aNfItem[nItem][IT_VALINS] >= aNfItem[nItem][IT_AVLINSS] .And. aNfItem[nItem][IT_AVLINSS] > 0
		aNfItem[nItem][IT_VALINS] -= aNfItem[nItem][IT_AVLINSS]
	Endif

EndIf

Return

/*/
MaFisIR -Alexandre Lemes -06/11/2012
Calculo do IR pessoa Fisica e Juridica
*/
Static Function MaFisIR(nItem,cExecuta,dVencReal,lVisual)

Local aArea     := {}
Local aIRprg    := {}
Local cPessoa	:= Iif(Len(Alltrim(aNfCab[NF_CNPJ]))< 14,"F","J")
Local cWhere    := ""
Local cCliFor   := aNfCab[NF_CODCLIFOR]
Local cLoja     := aNfCab[NF_LOJA]
Local nAliquota	:= aNfCab[NF_ALIQIR]
Local nSomaIRF  := 0
Local nX        := 0
Local nDebDep   := 0
Local nSldDep   := 0
Local lUsaTbPrg := .F.
Local lVldBseIR := .T.
Local lCtrAuto  := aSX6[MV_CTRAUTO] .And. aNfCab[NF_TIPONF] == "C" .And. aNfCab[NF_TPCOMP] == "F" .And. !Empty(aNfCab[NF_NATUREZA])

#IFNDEF TOP
	Local dDtSeek
	Local bDataImp
#ENDIF

DEFAULT dVencReal := dDataBase
DEFAULT cExecuta  := "BSE|ALQ|VLR"
DEFAULT lVisual	  := .F.

//Define BASE do IRRF - IT_BASEIRR
If "BSE" $ cExecuta

	aNfItem[nItem][IT_BASEIRR] := 0

	If aPE[PE_MAFISBIR]
		lVldBseIR := ExecBlock( "MAFISBIR",.F.,.F.,{aNfItem[nItem,IT_TES],aNfItem[nItem,IT_PRODUTO],aNfCab[NF_CLIFOR],aNfCab[NF_OPERNF],aNfCab[NF_CODCLIFOR],aNfCab[NF_LOJA]})
	EndIf

	If lVldBseIR .And. (aNFItem[nItem][IT_TS][TS_DUPLIC] == "S" .Or. lIRRFSemDu) .And. !Empty(aInfNat[NT_CODIGO]) .And. ( aInfNat[NT_CALCIRF] == "S" .Or. aSX6[MV_IRSEMNT] )

		If aNfItem[nItem][IT_PRD][SB_IRRF] == "S" .Or. lCtrAuto .Or. (aNfCab[NF_OPIRRF] == "EP" .And. aNfCab[NF_RECIRRF] == "1")
			//O parametro MV_CTRAUTO define se para notas fiscais de complemento de frete deve ser considerado as informacoes
			//de IRRF e INSS (calculo e reducao) da natureza ou do cad de produtos. .T.= Natureza - .F.= Produto (DEFAULT)
			aNfItem[nItem][IT_REDIR] := aNfItem[nItem][IT_PRD][SB_REDIRRF]

			If (Empty(aNfItem[nItem][IT_REDIR]) .And. !Empty(aNfCab[NF_NATUREZA]))
				If aInfNat[NT_BASEIRF] > 0
					aNfItem[nItem][IT_REDIR] := aInfNat[NT_BASEIRF]
				ElseIf aInfNat[NT_IRRFCAR] == "S" .And. aInfNat[NT_BASEIRC] > 0
					aNfItem[nItem][IT_REDIR] := aInfNat[NT_BASEIRC]
				EndIf
			EndIf

			If lCtrAuto .Or. ( Empty(aNfItem[nItem][IT_REDIR]) .And. !Empty(aNfCab[NF_NATUREZA]) )
				aNfItem[nItem][IT_REDIR] := aInfNat[NT_BASEIRF]
			EndIf

			aNfItem[nItem][IT_BASEIRR] := aNfItem[nItem][IT_TOTAL]

			If aNFItem[nItem][IT_TS][TS_DESCOND] == "1"	//Incluir o valor do desconto na base de IRRF
				aNfItem[nItem][IT_BASEIRR] := aNfItem[nItem][IT_BASEIRR] +aNfItem[nItem][IT_DESCONTO]
			EndIf

			//Indica se o valor do IPI deve compor a base de calculo do PIS/COFINS de ST.
			//1=Sim (Compoe) e 2=Nao(Nao Compoe)
			If aNFItem[nItem][IT_TS][TS_IPIPC]=="2"
				aNfItem[nItem][IT_BASEIRR] -= aNfItem[nItem][IT_VALIPI]
			Endif

			//Verifica se o valor do ICMS Solidario esta agregado ao valor total
			If !(aNFItem[nItem][IT_TS][TS_INCSOL]$"A,N,D")
				aNfItem[nItem][IT_BASEIRR] -= aNfItem[nItem][IT_VALSOL]
			Endif

			//Agrega o Valor do ICMS Retido - Somente para Empresa Publica
			If aNFItem[nItem][IT_TS][TS_DBSTIRR] == "1" .And. aNFCab[NF_OPIRRF] == "EP"
				aNfItem[nItem][IT_BASEIRR] += aNfItem[nItem][IT_VALSOL]
			Endif

			//O INSS devera ser deduzido da base do IR e nao do valor dos
			//servicos. Portanto, quando ha reducao na base de calculo, primeiro
			//efetua-se a reducao e depois a deducao do INSS.
			aNfItem[nItem][IT_BASEIRR] := aNfItem[nItem][IT_BASEIRR] * IIf( aNfItem[nItem][IT_REDIR] > 0 , aNfItem[nItem][IT_REDIR] / 100 , 1 )
			If !Len(AllTrim(aNFCAB[NF_CNPJ])) == 14
				aNfItem[nItem][IT_BASEIRR] := IIf(( aSX6[MV_INSIRF]=="1"),aNfItem[nItem][IT_BASEIRR]-aNfItem[nItem][IT_VALINS],aNfItem[nItem][IT_BASEIRR])
			Endif

			// Verificar se Fornecedor eh Pessoa Fisica
			// - Se Nao possui tratamento de base redutora IRPF
			// 	* Para este caso, nao calcular ou gravar o IRPF
			// - Se possui tratamento de base redutora IRPF
			// 	* Para este caso, nao zero a base de IRPF
			//Se nao possui tratamento de base redutora de IRRF

			// Chamado TQMMO9 - Comentado trecho abaixo para que a base do IR nao seja zerada quando o calculo for na baixa (aNfCab[NF_MODIRF] == "2").
			// Se a base for zerada neste ponto, o calculo da retenção na baixa do titulo no financeiro sera feito pelo valor total da nota/titulo
			// e se houver itens que não calculam IR na NF o valor sera calculado incorretamente, pois o valor destes itens nao deve compor a base.


			//Calculo da Base do IR com desconto de DEPENDENTES por item Chamado SCHLLN 29/12/2009
			If  aNfCab[NF_TPCLIFOR] == "F" .And. aNfItem[nItem][IT_BASEIRR] > 0 .And. cPessoa == "F"  .And. aNfCab[NF_NUMDEP] > 0 .And. aPos[FP_D1_SLDDEP]

				dbSelectArea("SD1")
				nSldDep  := ( aSX6[MV_TMSVDEP] * aNfCab[NF_NUMDEP])
				#IFDEF TOP
					cWhere := ""
					If aSX6[MV_ACMIRPF] == "2" //1 = Emissao 2= Vencimento Real 3=Data Contabilizacao
						cWhere += "%SE2.E2_VENCREA  BETWEEN '"+Dtos(FirstDay(dDataBase))+"' AND '"+Dtos(LastDay(dDataBase))+"' AND%"
					ElseIf aSX6[MV_ACMIRPF] == "1"
						cWhere += "%SE2.E2_EMISSAO  BETWEEN '"+Dtos(FirstDay(dDataBase))+"' AND '"+Dtos(LastDay(dDataBase))+"' AND%"
					Else
						cWhere += "%SE2.E2_EMIS1  BETWEEN '"+Dtos(FirstDay(dDataBase))+"' AND '"+Dtos(LastDay(dDataBase))+"' AND%"
					EndIf

					BeginSql Alias "MaTbDepPF"
						SELECT	SUM(D1_SLDDEP) SLDDEP
						FROM %Table:SE2% SE2,%Table:SF1% SF1,%Table:SD1% SD1
						WHERE
						SE2.E2_FILIAL  = %xFilial:SE2% AND
						SE2.E2_FORNECE = %Exp:cCliFor% AND
						SE2.E2_LOJA    = %Exp:cLoja% AND
						SF1.F1_FILIAL  = %xFilial:SF1% AND
						SE2.E2_PREFIXO = SF1.F1_PREFIXO AND
						SE2.E2_NUM     = SF1.F1_DOC AND
						SE2.E2_FORNECE = SF1.F1_FORNECE AND
						SE2.E2_LOJA    = SF1.F1_LOJA AND
						SE2.E2_EMISSAO = SF1.F1_EMISSAO AND
						SF1.F1_FILIAL  = SD1.D1_FILIAL AND
						SF1.F1_SERIE   = SD1.D1_SERIE AND
						SF1.F1_DOC     = SD1.D1_DOC AND
						SF1.F1_FORNECE = SD1.D1_FORNECE AND
						SF1.F1_LOJA    = SD1.D1_LOJA AND
						%exp:cWhere%
						SD1.D1_FILIAL = %xFilial:SD1% AND
						SD1.D1_SLDDEP > 0  AND
						SE2.%notdel% AND
						SF1.%notdel% AND
						SD1.%notdel%
					EndSql

					dbSelectArea("MaTbDepPF")
					While !(MaTbDepPF->(Eof()))
						nDebDep  += SLDDEP
						MaTbDepPF->(dbSkip())
					EndDo
					MaTbDepPF->(dbCloseArea())
				#ELSE
					aArea := GetArea()
					For nX := 1 to Day(LastDay(dDataBase))
						dbSelectArea("SE2")
						If aSX6[MV_ACMIRPF] == "2"
							dDtSeek  := Dtos(Ctod(StrZero(nX)+"/"+SubStr(Dtoc(dVencReal),4,Iif(Len(Dtoc(dVencReal)) == 10, 7, 5))))
							bDataImp := {||SE2->E2_VENCREA}
							SE2->(dbSetOrder(3))
						Else
							dDtSeek := Dtos(Ctod(StrZero(nX)+"/"+SubStr(Dtoc(dDataBase),4,Iif(Len(Dtoc(dDataBase)) == 10, 7, 5))))
							bDataImp := Iif( aSX6[MV_ACMIRPF] == "1"  ,  {||SE2->E2_EMISSAO} , {||SE2->E2_EMIS1} )
							SE2->(dbSetOrder(5))
						EndIf
						If SE2->( MsSeek(xFilial("SE2") + dDtSeek + aNfCab[NF_NREDUZ] , .T. ) )
							Do While SE2->(!Eof()) .And. xFilial("SE2") == SE2->E2_FILIAL .And. Dtos(Eval(bDataImp))==dDtSeek .And. SE2->E2_NOMFOR == aNfCab[NF_NREDUZ]
								DbSelectArea("SD1")
								SD1->(dbSetOrder(1))//D1_FILIAL+D1_DOC+D1_SERIE+D1_FORNECE+D1_LOJA+D1_COD+D1_ITEM
								If SD1->(MsSeek(xFilial("SD1")+SE2->E2_NUM+SE2->E2_PREFIXO+SE2->E2_FORNECE+SE2->E2_LOJA))
									Do While SD1->(!Eof())
										If SD1->D1_SLDDEP > 0
											nDebDep  += SD1->D1_SLDDEP
										Endif
										SD1->(dbSkip())
									EndDo
								Endif
								SE2->(dbSkip())
							EndDo
						EndIf
					Next nX
					RestArea(aArea)
				#ENDIF

				If GdFieldPos("D1_SLDDEP") > 0  // Alemes refazer, retirar acols Chamado SCHLLN 29/12/2009
					nSldDep:=nSldDep-nDebDep
					aCols[nItem][GdFieldPos("D1_SLDDEP")]:= 0
					If aNfItem[nItem][IT_BASEIRR]>0
						For nX :=1 To Len(aCols)
							If !aCols[nX][Len(aCols[nX])]//Somente linhas nao deletadas
								nSldDep -= aCols[nX][GdFieldPos("D1_SLDDEP")]
							Endif
						Next nX
						If nSldDep > 0
							If aNfItem[nItem][IT_BASEIRR] > nSldDep
								aNfItem[nItem][IT_BASEIRR] -= nSldDep
								If GdFieldPos("D1_SLDDEP") > 0
									aCols[nItem][GdFieldPos("D1_SLDDEP")]:= nSldDep
								EndIf
							Else
								aCols[nItem][GdFieldPos("D1_SLDDEP")]:= aNfItem[nItem][IT_BASEIRR]
								aNfItem[nItem][IT_BASEIRR] := 0
							Endif
						Endif
					Endif
				EndIf

			Endif
		EndIf
	EndIf
EndIf

//Define ALIQUOTA IRRF - IT_ALIQIRR
If "ALQ" $ cExecuta
	If !Empty(aNfCab[NF_NATUREZA]) .And. aNfCab[NF_MODIRF] <> "3"
		If aNfCab[NF_CLIFOR] == "C"
			Do Case
				Case aNfCab[NF_ALIQIR] > 0
					If aSX6[MV_IRSEMNT] // Parametro = .T. deixa gerar o IR mesmo que a natureza esteja para NAO calcular
						nAliquota := aNfCab[NF_ALIQIR]
					Else
						If aInfNat[NT_CALCIRF] == "S"
							nAliquota := aNfCab[NF_ALIQIR]
						EndIf
					EndIf
				Case aInfNat[NT_CALCIRF] == "S" .And. (Len(AllTrim(aNFCAB[NF_CNPJ])) == 14 .Or. aNfCab[NF_MODIRF] == "2" )
					nAliquota := IIf( aInfNat[NT_PERCIRF] > 0 , aInfNat[NT_PERCIRF] , aSX6[MV_ALIQIRF] )
				Case aInfNat[NT_CALCIRF] == "S" .And. Len(AllTrim(aNFCAB[NF_CNPJ])) <> 14
					If aNfCab[NF_MODIRF] == "4" .Or. ( aNFCab[NF_TPCLIFOR] == "X" .And. aNFCab[NF_PESSOA] == "J" )   //aNfCab[NF_MODIRF] == "4" --> Empresa Individual
						nAliquota := IIf( aInfNat[NT_PERCIRF] > 0 , aInfNat[NT_PERCIRF] , aSX6[MV_ALIQIRF] )
					Else
						lUsaTbPrg := .T.
					EndIf
			EndCase
		Else
			If aInfNat[NT_CALCIRF] == "S" .And. aNfItem[nItem][IT_BASEIRR] > 0
				If aNfCab[NF_TPCLIFOR] == "F" .And. aNfCab[NF_MODIRF] <> "2" .And. aNfCab[NF_IRPROG] <> "1"
					If aNfCab[NF_MODIRF] == "4" //--Empresa Individual
						nAliquota := IIf( aInfNat[NT_PERCIRF] > 0 , aInfNat[NT_PERCIRF] , aSX6[MV_ALIQIRF] )
					Else
						lUsaTbPrg := .T.
					EndIf
				ElseIf aNfCab[NF_IRPROG] == "1" .And. cPessoa == "J"
					lUsaTbPrg := .T.
				Else
					// Verificar se Fornecedor utiliza MP232
					// Para este caso, nao calcular ou gravar o IRPF
					If aPos[FP_A2_CALCIRF] .And. aPos[FP_E2_VRETIRF] .And. aPos[FP_E2_PRETIRF] .And. aPos[FP_E5_VRETIRF] .And. ;
						aPos[FP_E5_PRETIRF] .And. aNfCab[NF_MODIRF] == "2"
						nAliquota := 0
					Else
						nAliquota := IIf( aInfNat[NT_PERCIRF] > 0 , aInfNat[NT_PERCIRF] , aSX6[MV_ALIQIRF] )
					EndIf
				EndIf
			EndIf
		EndIf

		If lUsaTbPrg
			aEval(aNfItem,{|x| nSomaIRF += IIf(!x[IT_DELETED],x[IT_BASEIRR],0)})
			aIRprg := MaTbIrfPF(aNfItem[nItem][IT_BASEIRR],nSomaIRF-aNfItem[nItem][IT_BASEIRR],Iif(lVisual,.F.,.T.),aNfCab[NF_CODCLIFOR],aNfCab[NF_LOJA],dVencReal,cPessoa)
			nAliquota := aIRprg[2]
		EndIf

		// Verificar se Fornecedor pessoa juridica realiza calculo do IRR no momento da baixa.
		If aInfNat[NT_CALCIRF] == "S" .And. cPessoa == "J" .And. aNfCab[NF_MODIRF] == "2"
			nAliquota := IIf( aInfNat[NT_PERCIRF] > 0 , aInfNat[NT_PERCIRF] , aSX6[MV_ALIQIRF] )
		EndIf
	EndIf

	aNfItem[nItem][IT_ALIQIRR]	:= nAliquota

EndIf

//Estou verificando novamente cExecuta, pois preciso da alíquota do IR pronta para que eu possa incluir na base de cálculo, ao invés de fazer uma chamada recursiva, adicionei este complemento da base de cálculo
If "BSE" $ cExecuta .AND.  aNfItem[nItem][IT_BASEIRR] > 0 .AND. xFisGrossIR(nItem, aNFItem, aNfCab, "IRRF") //Verifica se deverá considerar GrossUp do IRRF
	//Esta opção significa que deverá incluir o valor do IR na base de cálculo 	
	aNfItem[nItem][IT_BASEIRR]	:= aNfItem[nItem][IT_BASEIRR] / ( 1 - ( aNfItem[nItem][IT_ALIQIRR] / 100 ) )
EndIF
//Define VALOR do IRRF - IT_VALIRR
If "VLR" $ cExecuta

	aNfItem[nItem][IT_VALIRR] := 0

	If aNfItem[nItem][IT_ALIQIRR] <> 0 .And. aNfItem[nItem][IT_BASEIRR] > 0 .And. ( cPessoa == "F" .Or. aNfCab[NF_IRPROG] == "1" ) .And. ;
		(aNfCab[NF_CLIFOR] == "F" .Or. ( aNfCab[NF_CLIFOR] == "C" .And. aNfCab[NF_ALIQIR] == 0 ) .Or. aNfCab[NF_IRPROG] == "1" )
		lUsaTbPrg := .T.
	EndIf

	If (aNfCab[NF_CLIFOR] == "C" .And. aNFCab[NF_TPCLIFOR] == "X" .And. aNFCab[NF_PESSOA] == "J" ) .Or. ;
		(aNfCab[NF_CLIFOR] == "F" .And. aNfCab[NF_IRPROG] <> "1" .And.   aNFCab[NF_TPCLIFOR] == "X" ) //retenção de IR para operação de importação [artigos  706 e 719 do Decreto n3000, de março de 1999 (http://www.receita.fazenda.gov.br/Legislacao/rir/Livro3.htm)
		lUsaTbPrg := .F.
	EndIf

	If lUsaTbPrg
		If nSomaIRF == 0
			aEval(aNfItem,{|x| nSomaIRF += IIf(!x[IT_DELETED],x[IT_BASEIRR],0)})
			aIRprg := MaTbIrfPF(aNfItem[nItem][IT_BASEIRR],nSomaIRF-aNfItem[nItem][IT_BASEIRR],.T.,aNfCab[NF_CODCLIFOR],aNfCab[NF_LOJA],dVencReal,cPessoa)
		EndIf
		If aNfCab[NF_MODIRF] <> "2"
			For nX := 1 To Len(aNFItem)
				aNFItem[nX][IT_ALIQIRR] := aIRprg[2]
			Next nX
			If aIRprg[1] > 0
				MaFisRatRes("IT_VALIRR",aIRprg[1],aIRprg[2],"IT_ALIQIRR","IT_BASEIRR",nItem)
				MaIt2Cab(nItem)
			EndIf
		Else
			If aNfItem[nItem][IT_BASEIRR]- aIRprg[4] > 0
				If aPos[FP_A2_CALCIRF] .And. aPos[FP_E2_VRETIRF] .And. aPos[FP_E2_PRETIRF] .And. aPos[FP_E5_VRETIRF] .And. ;
					aPos[FP_E5_PRETIRF] .And. aNfCab[NF_MODIRF] == "2" // Se Fornecedor utiliza MP232 NAO calcular ou gravar IRPF
					aNfItem[nItem][IT_VALIRR] := 0
				Else
					aNfItem[nItem][IT_VALIRR] := aNfItem[nItem][IT_BASEIRR] * aNfItem[nItem][IT_ALIQIRR] /100
				Endif
			Else
				aNfItem[nItem][IT_VALIRR] := 0
			EndIf
		EndIf
	Else
		aNfItem[nItem][IT_VALIRR] := aNfItem[nItem][IT_BASEIRR] * aNfItem[nItem][IT_ALIQIRR] / 100
	EndIf

	MaItArred(nItem, {"IT_VALIRR"})

EndIf

Return

/*/
MaTbIrfPF-Eduardo/Edson   -31.01.2004
Inicializa o Calculo das operacoes Fiscais
Retorno   ExpA: [1] Valor do IRPF
[2] Aliquota do IRPF
[3] Dedução  do IRPF
Parametros ExpN1 : Valor do IRPF
ExpN2 : Valor acumulado do IRPF
*/
Function MaTbIrfPF(nBaseIRF,nTotIrf,lSE2,cFornece,cLoja,dVencReal,cPessoa)

Local aArea     := GetArea()
Local aTabela   := {}
Local cQrySE2 	:= "'"+ xFilial("SE2") + "'"
Local cQrySD1 	:= "'"+ xFilial("SD1") + "'"
Local cQrySED 	:= "'"+ xFilial("SED") + "'"
Local aFilial	:= Iif(cPessoa == "F", {"%%","%%","%%"},{"%SE2.E2_FILIAL = "+cQrySE2+" AND%","%SD1.D1_FILIAL = "+cQrySD1+" AND%","%SED.ED_FILIAL = "+cQrySED+" AND%"})
Local aFilCnpj	:= Iif(cPessoa == "F",MatFilCalc(.F.),{})
Local cAddWhere := ""
Local cBuffer   := ""
Local nX        := 0
Local nBase     := 0
Local nAliq     := 0
Local nValor    := 0
Local nDed      := 0
Local nIsento   := 0
Local nTotTit 	:= 0
Local nTotInss	:= 0
Local nTotIrrf	:= 0
Local nVenctoPF := aSX6[MV_ACMIRPF]
Local nVenctoPJ := aSX6[MV_ACMIRPJ]   //1 = Emissao    2= Vencimento Real	3=Data Contabilizacao
Local lContrRet := aPos[FP_E2_VRETPIS] .And. aPos[FP_E2_VRETCOF] .And. aPos[FP_E2_VRETCSL] .And. aPos[FP_E2_PRETPIS] .And. aPos[FP_E2_PRETCOF] .And. aPos[FP_E2_PRETCSL]
Local lPCCBaixa := aSX6[MV_BX10925]== "1" .And. aPos[FP_E5_VRETPIS] .And. aPos[FP_E5_VRETCOF] .And. aPos[FP_E5_VRETCSL] .And. aPos[FP_E5_PRETPIS] .And. aPos[FP_E5_PRETCOF] .And. aPos[FP_E5_PRETCSL] .And. aPos[FP_E2_SEQBX] .And. aPos[FP_FQ_SEQDES]
Local dDataEmi	:=	dDataBase
Local cFilQrySE2 := ""
Local aNfProc := {}

#IFNDEF TOP
	Local nLastDay:= Day(LastDay(dDataBase))
	Local dDtSeek
	Local bDataImp
#ELSE
	Local cWhere    := ""
	Local cSepNeg   := If("|"$MV_CPNEG,"|",",")
	Local cSepProv  := If("|"$MVPROVIS,"|",",")
	Local cSepRec   := If("|"$MVPAGANT,"|",",")
#ENDIF

DEFAULT nTotIrf   := 0
DEFAULT lSE2      := .F.
DEFAULT dVencReal := dDataBase

//dDataEmi para respeitar os parametros MV_ACMIRPF e  MV_ACMIRPJ
If Type("dDEmissao") == "D" .And. !Empty(dDEmissao)
	dDataEmi	:=	dDEmissao
Endif

If aUltPesq == Nil
	STATIC aUltPesq := {ctod(""),"","",0,0}
EndIf

If FWModeAccess( "SE2" , 3 ) == "C"
	cFilOri := "E2_FILORIG"
Else
	cFilOri := "E2_FILIAL"
EndIf

// Calcula o valor do IRF ocorrido no mes
If lSE2 .And. ( !(aUltPesq[1] == dDataBase .And. aUltPesq[2] == cFornece .And. aUltPesq[3] == cLoja))
	#IFDEF TOP
		cWhere := ""
		If cPessoa == "F" .Or. aNfCab[NF_IRPROG] == "1"
			If nVenctoPF == "2"
				//Se for no mesmo mês uso a DataBase senão uso a Data do Vencimento Real
				If Dtos(FirstDay(dVencReal))<= Dtos(dDataBase) .And. Dtos(LastDay(dVencReal))>= Dtos(dDataBase)
					cWhere += "%SE2.E2_VENCREA  BETWEEN '"+Dtos(FirstDay(dDataBase))+"' AND '"+Dtos(LastDay(dDataBase))+"' AND "
				Else
					cWhere += "%SE2.E2_VENCREA  BETWEEN '"+Dtos(FirstDay(dVencReal))+"' AND '"+Dtos(LastDay(dVencReal))+"' AND "
				EndIf
			ElseIf nVenctoPF == "1"
				cWhere += "%SE2.E2_EMISSAO  BETWEEN '"+Dtos(FirstDay(dDataEmi))+"' AND '"+Dtos(LastDay(dDataEmi))+"' AND "
			Else
				cWhere += "%SE2.E2_EMIS1  BETWEEN '"+Dtos(FirstDay(dDataBase))+"' AND '"+Dtos(LastDay(dDataBase))+"' AND "
			EndIf
		Else
			If nVenctoPJ == "2"
				If Dtos(dDataBase)==Dtos(dVencReal)
					cWhere += "%SE2.E2_VENCREA  = '" + Dtos(dDataBase) + "' AND "
				Else
					cWhere += "%SE2.E2_VENCREA  = '" + Dtos(dVencReal) + "' AND "	//Totaliza pelo vencimento real
				EndIf
			ElseIf nVenctoPJ == "1"
				cWhere += "%SE2.E2_EMISSAO  = '" + Dtos(dDataEmi) + "' AND "
			Else
				cWhere += "%SE2.E2_EMIS1  = '" + Dtos(dDataBase) + "' AND "
			EndIf
		EndIf
		cWhere += "SE2.E2_TIPO NOT IN "+FormatIn(MVABATIM,"|")+" AND "
		cWhere += "SE2.E2_TIPO NOT IN "+FormatIn(MV_CPNEG,cSepNeg)+" AND "
		cWhere += "SE2.E2_TIPO NOT IN "+FormatIn(MVPROVIS,cSepProv)+" AND "
		cWhere += "SE2.E2_TIPO NOT IN "+FormatIn(MVPAGANT,cSepRec)+" AND "
		cWhere += "SE2.E2_FATURA NOT IN ('NOTFAT') "
		If aPE[PE_MACALIRRF]
			cAddWhere := ExecBlock("MACALIRRF",.F.,.F., {cWhere} )
			If ValType(cAddWhere) == "C" .And. !Empty(cAddWhere)
				cWhere += " AND " + cAddWhere
			EndIf
		EndIf
		cWhere += " AND %"
		BeginSql Alias "MaTbIrfPF"
			SELECT E2_FILIAL,E2_VALOR,E2_IRRF,E2_BASEIRF,E2_INSS,E2_ISS,E2_SEST,E2_PRETPIS,E2_PRETCOF,E2_PRETCSL,E2_VRETPIS,E2_VRETCOF,E2_VRETCSL,
			E2_TIPO,E2_NUM,E2_PREFIXO,E2_FORNECE,E2_LOJA,E2_ORIGEM,E2_FATURA,E2_FILORIG
			FROM %Table:SE2% SE2
			WHERE
			%exp:aFilial[1]%
			SE2.E2_FORNECE = %Exp:cFornece% AND
			SE2.E2_LOJA = %Exp:cLoja% AND
			SE2.%notdel% AND
			%exp:cWhere%
			EXISTS (
			SELECT SED.ED_CODIGO
			FROM %Table:SED% SED
			WHERE
			%exp:aFilial[3]%
			SED.ED_CALCIRF = 'S' AND
			SED.ED_CODIGO = SE2.E2_NATUREZ AND
			SE2.%notdel% AND
			SED.%notdel%)
		EndSql

		dbSelectArea("MaTbIrfPF")

		While !(MaTbIrfPF->(Eof()))
			If 	MaTbIrfPF->(E2_TIPO) == MVNOTAFIS .And. Alltrim(MaTbIrfPF->(E2_ORIGEM)) == "MATA100"

				cFilQrySE2 := Iif(cFilOri == "E2_FILIAL",MaTbIrfPF->E2_FILIAL,MaTbIrfPF->E2_FILORIG)

				If cPessoa == "F"
					aFilial[2] := "%SF1.F1_FILIAL = '" + cFilQrySE2 + "' AND%"
					If (nX := aScan(aFilCnpj,{|x| x[2] == cFilQrySE2})) == 0 .Or. ;
						Substr(aFilCnpj[nX,4],1,8) <> Substr(SM0->M0_CGC,1,8)
						dbSkip()
						Loop
					EndIf
				EndIf

				// Validacao para que os valores de uma NF que tenha mais de uma parcela nao sejam acumulados indevidamente.
				// Nestes casos a query na SE2 retorna mais de uma linha, porem soh preciso dos dados da SD1 uma vez...então
				// soh executo a query na SD1 uma vez.
				If aScan(aNfProc, {|x| x[1]+x[2]+x[3]+x[4]+x[5] == cFilQrySE2 + MaTbIrfPF->(E2_NUM + E2_PREFIXO + E2_FORNECE + E2_LOJA)}) == 0

					BeginSql Alias "TMPSD1"
						SELECT SUM(D1_BASEIRR) BASEIRR, SUM(D1_VALINS) VALINS
						FROM %Table:SD1% SD1, %Table:SF1% SF1
						WHERE
						%Exp:aFilial[2]%
						SF1.F1_DOC = %Exp:MaTbIrfPF->(E2_NUM)% AND
						SF1.F1_PREFIXO = %Exp:MaTbIrfPF->(E2_PREFIXO)% AND
						SF1.F1_FORNECE = %Exp:MaTbIrfPF->(E2_FORNECE)% AND
						SF1.F1_LOJA = %Exp:MaTbIrfPF->(E2_LOJA)% AND
						SF1.%notdel% AND
						SD1.D1_FILIAL = SF1.F1_FILIAL AND
						SD1.D1_DOC = SF1.F1_DOC AND
						SD1.D1_SERIE = SF1.F1_SERIE AND
						SD1.D1_FORNECE = SF1.F1_FORNECE AND
						SD1.D1_LOJA = SF1.F1_LOJA AND
						SD1.%notdel%
					EndSql

					nTotTit	+= BASEIRR
					dbCloseArea()

					aAdd(aNfProc, {cFilQrySE2, MaTbIrfPF->(E2_NUM), MaTbIrfPF->(E2_PREFIXO), MaTbIrfPF->(E2_FORNECE), MaTbIrfPF->(E2_LOJA)})

				EndIf

			Else
				nTotTit	+= E2_VALOR+E2_IRRF+E2_ISS+E2_SEST
			EndIf
			dbSelectArea("MaTbIrfPF")
			If lContrRet .And. !lPccBaixa .And. (E2_PRETPIS == " " .And. E2_PRETCOF == " " .And. E2_PRETCSL == " ")
				nTotTit	+= E2_VRETPIS+E2_VRETCOF+E2_VRETCSL
			Endif
			nTotInss += E2_INSS
			nTotIrrf += E2_IRRF
			dbSkip()
		EndDo
		MaTbIrfPF->(dbCloseArea())
		dbSelectArea("SA2")
	#ELSE
		dbSelectArea("SA2")
		dbSetOrder(1)
		MsSeek(xFilial("SA2")+cFornece+cLoja)
		dbSelectArea("SE2")
		If cPessoa == "F" .Or. aNfCab[NF_IRPROG]=="1"
			If nVenctoPF == "2"
				//Se for no mesmo mês uso a DataBase senão uso a Data do Vencimento Real
				If Dtos(FirstDay(dVencReal))<= Dtos(dDataBase) .And. Dtos(LastDay(dVencReal))>= Dtos(dDataBase)
					nLastDay := Day(LastDay(dDataBase))
				Else
					nLastDay := Day(LastDay(dVencReal))
				EndIf
				bDataImp := {||SE2->E2_VENCREA}
				dbSetOrder(3)
			ElseIf nVenctoPF == "1"
				bDataImp := {||SE2->E2_EMISSAO}
				dbSetOrder(5)
			Else// nVenctoPF == "3"
				bDataImp := {||SE2->E2_EMIS1}
				dbSetOrder(5)
			EndIf
			nStart:= 1
		Else
			If nVenctoPJ == "2"
				//Se for no mesmo dia uso a DataBase senão uso a Data do Vencimento Real
				If Dtos(dDataBase)==Dtos(dVencReal)
					nLastDay := Day(dDataBase)
				Else
					nLastDay := Day(dVencReal)
				EndIf
				nStart	:= nLastDay
				bDataImp := {||SE2->E2_VENCREA}
				dbSetOrder(3)
			ElseIf nVenctoPJ == "1"
				bDataImp := {||SE2->E2_EMISSAO}
				nLastDay := Day(dDataBase)
				nStart	:= nLastDay
				dbSetOrder(5)
			Else// nVenctoPJ == "3"
				bDataImp := {||SE2->E2_EMIS1}
				nLastDay := Day(dDataBase)
				nStart	:= nLastDay
				dbSetOrder(5)
			EndIf
		EndIf
		For nX := nStart to nLastDay
			If nVenctoPF == "2" .Or. nVenctoPJ == "2"
				dDtSeek := Dtos(Ctod(StrZero(nX)+"/"+SubStr(Dtoc(dVencReal),4,Iif(Len(Dtoc(dVencReal)) == 10, 7, 5))))
			Else
				dDtSeek := Dtos(Ctod(StrZero(nX)+"/"+SubStr(Dtoc(dDataBase),4,Iif(Len(Dtoc(dDataBase)) == 10, 7, 5))))
			EndIf
			If MsSeek(xFilial("SE2")+dDtSeek+SA2->A2_NREDUZ,.T.)
				While !Eof() .And. xFilial("SE2") == E2_FILIAL .And. Dtos(Eval(bDataImp))==dDtSeek .And. E2_NOMFOR == SA2->A2_NREDUZ
					SED->(MsSeek(xFilial("SED")+SE2->E2_NATUREZ))
					If E2_FORNECE+E2_LOJA == SA2->A2_COD+SA2->A2_LOJA .And. !(E2_TIPO $ MVABATIM+"/"+MV_CPNEG+"/"+MVPAGANT+"/"+MVPROVIS) .And. SED->ED_CALCIRF=="S" .And. !(E2_FATURA == "NOTFAT")
						nTotTit	+= E2_BASEIRF+E2_IRRF+E2_ISS+E2_SEST
						If lContrRet .And. !lPccBaixa .And. (E2_PRETPIS == " " .And. E2_PRETCOF == " " .And. E2_PRETCSL == " ")
							nTotTit	+= E2_VRETPIS+E2_VRETCOF+E2_VRETCSL
						Endif
						nTotInss += E2_INSS
						nTotIrrf += E2_IRRF
					Endif
					dbSkip()
				EndDo
			EndIf
		Next nX
	#ENDIF

	//MV_INSIRF == "1" Ja grava o valor da BASE do IRFF no E2_BSEIRF/D1_BASEIRR descontando o valor do INSS nao sendo necessario tratar o parametro nesta funcao para somar ou subtrair o INSS da base do IR
	aUltPesq:= {dDataBase,cFornece,cLoja, nTotTit ,nTotIRRF}

EndIf
nBaseIRF += aUltPesq[4]
// Aplica a tabela progressiva
If File("SIGAADV.IRF")
	FT_FUse("SIGAADV.IRF")
	FT_FGotop()
	While ( !FT_FEof() )
		cBuffer := FT_FReadLn()
		aadd(aTabela,{Val(SubStr(cBuffer,1,15)),Val(SubStr(cBuffer,17,6)),Val(SubStr(cBuffer,24,15))})
		FT_FSkip()
	EndDo
	FT_FUse()

	For nX := 1 To Len(aTabela)
		nBase := aTabela[nX,1]
		nAliq := aTabela[nX,2]
		nDed  := aTabela[nX,3]
		If nAliq == 0
			nIsento := nBase
		EndIf
		If nBaseIRF+nTotIrf <= aTabela[nX][1]
			Exit
		EndIf
	Next nX
	nValor := NoRound(((nBaseIRF+nTotIrf)*nAliq/100),3)-nDed-aUltPesq[5]
	nValor := Max(nValor,0)
EndIf

RestArea(aArea)

Return({nValor,nAliq,nDed,nIsento})

/*MaRecIR - Cleber Stenio   -07.01.2009
  DescrioRecalcula o Valor do IR qdo alterado a condicao de Pagamento
   do Titulo no MATA103X.*/
Function MaRecIR(dVencReal)

Local nX  := 0
Local nAliquota := 0
Local lTabProg := .F.
Local cPessoa	:= Iif(Len(Alltrim(aNfCab[NF_CNPJ]))< 14,"F","J")

DEFAULT dVencReal := dDataBase

aUltPesq := {ctod(""),"","",0,0}

aEval(aNfItem,{|x| nAliquota += IIf(!x[IT_DELETED],x[IT_ALIQIRR],0)}) // Para impedir o recalculo o IRRF quando o mesmo for informado Manualmente na NFE

IF ( cPessoa == "F" .Or. aNfCab[NF_IRPROG] == "1" ) .And. (aNfCab[NF_CLIFOR] == "F" .Or. ( aNfCab[NF_CLIFOR] == "C" .And. aNfCab[NF_ALIQIR] == 0 ) .Or. aNfCab[NF_IRPROG] == "1" )
		lTabProg := .T.
EndIf

If nAliquota > 0

	For nX := 1 To Len(aNFItem)
		MaFisIR(nX,"VLR",dVencReal)
		MaItArred(nX)
	Next nX

	MaIt2Cab()

ElseIf lTabProg

	For nX := 1 To Len(aNFItem)
		MaFisIR(nX,"ALQ|VLR",dVencReal)
		MaItArred(nX)
	Next nX

	MaIt2Cab()

EndIf

Return

/*/
MaFisPIS - Alexandre Lemes - 28/09/2012
Calculo do PIS - Apuracao / Retencao e ST
*/
Static Function MaFisPIS(nItem,cTipo,cExecuta,lReproc,lAgregICM)

Local aExcecao	 := {}
Local aAreaSA1   := {}
Local aAreaSC6   := {}
Local aMaPISVeic := {}
Local aMaPISDif  := {}
Local aMaCalcPIS := IIf( aPE[PE_MACALCPIS] , ExecBlock("MaCalcPIS") , Array(2) )
Local cNatureza  := ""
Local nDescISS	 := 0
Local nVlUnitCig := 0
Local nFatRedPIS := 1
Local nAliqAgr	 := 0
Local nBasePIS   := 0
Local nBasePS2	 := 0
Local nBasePS3	 := 0
Local nPautaSB1  := aNfItem[nItem][IT_PRD][SB_VLR_PIS]
Local nRedBsPIS	 := aNfItem[nItem][IT_PRD][SB_REDPIS]
Local nAliqSB1   := aNfItem[nItem][IT_PRD][SB_PPIS]
Local nAliqBase  := IIf( !Empty(aNFitem[nItem,IT_EXCECAO]) .And. aNFItem[nItem,IT_EXCECAO,12] <> 0 , aNFItem[nItem,IT_EXCECAO,12] , IIf(Empty(nAliqSB1) , aSX6[MV_TXPIS] , nAliqSB1) )
Local nAliqPIS   := nAliqBase // Retencao
Local nAliqPS2   := nAliqBase // Apuracao
Local nAliqPS3   := nAliqBase // Substituicao Tributaria ST
Local lRecalPS2  := .T.
Local lAgreg     := .F.
Local lDc5602	 := .F.
Local lZFMAlqZ	 := .F.
Local lSegUndPau := aSX6[MV_PISCOFP] //utiliza ou nao segunda unidade quando for pauta
Local lPisMin		:= aNfItem[nItem][IT_TS][TS_PISMIN] == "1"
Local nVlOprPis	:= 0
Local nVlPautPis	:= 0

Local nBaseOri := aNfItem[nItem][IT_BASEPS2]
Local nAliqOri := aNfItem[nItem][IT_ALIQPS2]
Local nValOri  := aNfItem[nItem][IT_VALPS2]
Local nMajOri  := aNfItem[nItem][IT_VALPMAJ]

//Reducao de BASE PIS pesquisa pelo PRODUTO / TES ou EXCECAO
DEFAULT nRedBsPIS := 0
DEFAULT cExecuta  := "BSE|ALQ|VLR"
DEFAULT lReproc := .F.
DEFAULT lAgregICM := .T.

If aSX6[MV_PCFATPC] .And. aNfCab[NF_OPERNF] == "S" .And. !Empty(aNfCab[NF_CLIEFAT])
	aExcecao	:= aNFitem[nItem][IT_EXCECAO]
	aNFitem[nItem][IT_EXCECAO] := aNFitem[nItem][IT_EXCEFAT]
	cNatureza	:= aNfCab[NF_NATUREZA]
	aNfCab[NF_NATUREZA]	:= aNfCab[NF_NATUFAT]
EndIf

nRedBsPIS := IIf( aNFItem[nItem][IT_TS][TS_BASEPIS] > 0 , aNFItem[nItem][IT_TS][TS_BASEPIS] , nRedBsPIS )
nRedBsPIS := IIf( !Empty(aNFitem[nItem][IT_EXCECAO]) .And. aNfItem[nItem,IT_EXCECAO,18] > 0 , aNfItem[nItem,IT_EXCECAO,18] , nRedBsPIS )

If nRedBsPIS <> 0
	nFatRedPIS	:= IIf( nRedBsPIS>0,1-nRedBsPIS/100,1)
EndIf

//PIS APURACAO - IT_BASEPS2 / IT_ALIQPS2 / IT_VALPS2
If "PS2" $ cTipo
	lDc5602:=.F.
	If aNfItem[nItem][IT_TABNTRE] == "4313" .AND. aNfCab[NF_OPERNF]=="S"
		lDc5602:=Decret5602((aNfItem[nItem][IT_VALMERC]/ aNfItem[nItem][IT_QUANT]),aNfItem[nItem][IT_POSIPI],aNfItem[nItem][IT_CODNTRE])
	EndIF
	aNfItem[nItem][IT_ALQPMAJ] := aNFItem[nItem][IT_TS][TS_ALQPMAJ] //Alimenta a referencia de aliquota majorada do PIS APURACAO
	aNfItem[nItem][IT_VALPMAJ] := 0 						// garante a limpeza da referencia caso o produto seja trocado na edicao da NF.
	//Devolucao de importacao, mantem os valores do PIS APURACAO do documento Original
	//If aNFCab[NF_TPCLIFOR]=="X" .And. Substr(aNfItem[nItem][IT_CF],1,1)$"37"
	If ( aNFCab[NF_TIPONF] $"DB" .Or. aNFItem[nItem][IT_TS][TS_PODER3] == "D" ) .And. !Empty(aNFItem[nItem][IT_RECORI]) .And. aNFItem[nItem][IT_TS][TS_OPERGAR] <> '1'
		If aNFCab[NF_TIPONF] $ "DB"
			If aNFCab[NF_CLIFOR] == "C"
				SD2->(MsGoto(aNFItem[nItem][IT_RECORI]) )
				If aNfItem[nItem][IT_QUANT] == SD2->D2_QUANT
					aNfItem[nItem][IT_ALIQPS2] := SD2->D2_ALQIMP6
					aNfItem[nItem][IT_BASEPS2] := SD2->D2_BASIMP6
					aNfItem[nItem][IT_VALPS2]  := SD2->D2_VALIMP6
					lRecalPS2 := .F.
				ElseIf aNfItem[nItem][IT_QUANT] <> SD2->D2_QUANT .And. aNFItem[nItem][IT_TS][TS_DEVPARC]$"1S"
					aNfItem[nItem][IT_ALIQPS2] := SD2->D2_ALQIMP6
					aNfItem[nItem][IT_BASEPS2] := (aNfItem[nItem][IT_QUANT] * SD2->D2_BASIMP6)/SD2->D2_QUANT
					aNfItem[nItem][IT_VALPS2]  := (aNfItem[nItem][IT_QUANT] * SD2->D2_VALIMP6)/SD2->D2_QUANT
					lRecalPS2 := .F.
				EndIf
			Else
				SD1->(MsGoto( aNFItem[nItem][IT_RECORI]) )
				If aNfItem[nItem][IT_QUANT] == SD1->D1_QUANT
					aNfItem[nItem][IT_ALIQPS2] := SD1->D1_ALQIMP6
					aNfItem[nItem][IT_BASEPS2] := SD1->D1_BASIMP6
					aNfItem[nItem][IT_VALPS2]  := SD1->D1_VALIMP6
					If aNFItem[nItem][IT_TS][TS_ALQPMAJ] > 0
						aNfItem[nItem][IT_VALPMAJ] := aNfItem[nItem][IT_BASEPS2] * (aNFItem[nItem][IT_TS][TS_ALQPMAJ]/100)
					EndIf
					lRecalPS2 := .F.
				ElseIf aNfItem[nItem][IT_QUANT] <> SD1->D1_QUANT .And. aNFItem[nItem][IT_TS][TS_DEVPARC]$"1S"
					aNfItem[nItem][IT_ALIQPS2] := SD1->D1_ALQIMP6
					aNfItem[nItem][IT_BASEPS2] := (aNfItem[nItem][IT_QUANT] * SD1->D1_BASIMP6)/SD1->D1_QUANT
					aNfItem[nItem][IT_VALPS2]  := (aNfItem[nItem][IT_QUANT] * SD1->D1_VALIMP6)/SD1->D1_QUANT
					lRecalPS2 := .F.
				EndIf
			EndIf
		Else
			If aNFCab[NF_CLIFOR] == "C"
				SD1->(MsGoto( aNFItem[nItem][IT_RECORI]) )
				If aNfItem[nItem][IT_QUANT] == SD1->D1_QUANT
					aNfItem[nItem][IT_ALIQPS2] := SD1->D1_ALQIMP6
					aNfItem[nItem][IT_BASEPS2] := SD1->D1_BASIMP6
					aNfItem[nItem][IT_VALPS2]  := SD1->D1_VALIMP6
					lRecalPS2 := .F.
				EndIf
			Else
				SD2->(MsGoto(aNFItem[nItem][IT_RECORI]) )
				If aNfItem[nItem][IT_QUANT] == SD2->D2_QUANT
					aNfItem[nItem][IT_ALIQPS2] := SD2->D2_ALQIMP6
					aNfItem[nItem][IT_BASEPS2] := SD2->D2_BASIMP6
					aNfItem[nItem][IT_VALPS2]  := SD2->D2_VALIMP6
					lRecalPS2 := .F.
				ElseIf aNfItem[nItem][IT_QUANT] <> SD2->D2_QUANT .And. aNFItem[nItem][IT_TS][TS_DEVPARC]$"1S"
					aNfItem[nItem][IT_ALIQPS2] := SD2->D2_ALQIMP6
					aNfItem[nItem][IT_BASEPS2] := (aNfItem[nItem][IT_QUANT] * SD2->D2_BASIMP6)/SD2->D2_QUANT
					aNfItem[nItem][IT_VALPS2]  := (aNfItem[nItem][IT_QUANT] * SD2->D2_VALIMP6)/SD2->D2_QUANT
					lRecalPS2 := .F.
				EndIf
			EndIf
		EndIf
	EndIf

	//PIS APURACAO - CALCULO
	If lRecalPS2

		lZFMAlqZ := aNFItem[nItem][IT_TS][TS_PISCOF]=="4" .And. aNFItem[nItem][IT_TS][TS_PISCRED]=="3" .And. ;
		aNfCab[NF_CLIFOR]=="C" .And. !aNfCab[NF_CALCSUF]$"IN " .And. !aNFitem[nItem][IT_TIPONF ]$"BD" .And. ;
		aNFItem[nItem][IT_TS][TS_ISS] <> "S" .And. aSX6[MV_DESCZF] .And. aSX6[MV_DESZFPC] .And. ( aNFItem[nItem][IT_TS][TS_PISCRED]$"134" ) .And. ;
		Empty(aNfItem[nItem][IT_ALIQPS2]) .And. ((aPE[PE_MACSTPICO] .And. !ExecBlock("MaCstPiCo",.F.,.F.,{nItem,aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_TES],aNfCab[NF_CLIFOR],aNfCab[NF_CODCLIFOR],aNfCab[NF_LOJA],aNfCab[NF_OPERNF]})[2]$"04#06#73") .Or. (!aPE[PE_MACSTPICO] .And. aNFItem[nItem][IT_TS][TS_CSTPIS] $"04#06#73")) .AND. !lDc5602

		If (aNFItem[nItem][IT_TS][TS_PISCOF]$"1|3" .And. !aNFItem[nItem][IT_TS][TS_PISCRED]$"3") .Or. lZFMAlqZ
			//Define a Aliquota do PIS APURACAO - IT_ALIQPS2
			If "ALQ" $ cExecuta
				If ( aNFItem[nItem][IT_TS][TS_PISCRED] == "3" .Or. Empty(aNFItem[nItem][IT_TS][TS_PISCRED]) ) .And. aNfItem[nItem][IT_PRD][SB_PIS] == "2"
					nAliqPS2 := 0
				Endif

				If ( aPE[PE_MACSTPICO] .And. ExecBlock("MaCstPiCo",.F.,.F.,{nItem,aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_TES],aNfCab[NF_CLIFOR],aNfCab[NF_CODCLIFOR],aNfCab[NF_LOJA],aNfCab[NF_OPERNF]})[2]$"04#06#73") .Or. (!aPE[PE_MACSTPICO] .And. (aNFItem[nItem][IT_TS][TS_CSTPIS] $"04#06#73" .Or. aNFItem[nItem][IT_TS][TS_PSCFST]== "3"))
					nAliqPS2:=0
				EndIF

				aNfItem[nItem][IT_ALIQPS2]	:= IIf( aSX6[MV_APURPIS] , aSX6[MV_TXPIS] , nAliqPS2 )// MV_APURPIS = .T. pegar aliquota do MV_TXPIS

				If aPE[PE_MAPISDIF] // //Ponto de Entrada para calculo de PIS Apuracao com Aliquota Diferenciada
					aMaPISDif := ExecBlock("MAPISDIF",.F.,.F.,{nItem,nAliqPS2})
					If aMaPISDif[1] == "S"
						aNfItem[nItem][IT_ALIQPS2] := aMaPISDif[2]
					EndIf
				EndIf
				
				//Aliquota Majorada do PIS, Majora a Aliquota do PIS APURACAO qunado for Importacao. MaFisII
				If aNFItem[nItem][IT_TS][TS_ALQPMAJ] > 0 .And. aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_CLIFOR] =="F" .And. ((aNFCab[NF_TPCLIFOR] =="X" .And. Substr(aNfItem[nItem][IT_CF],1,1)=="3") .Or. aNFItem[nItem][IT_TS][TS_IMPIND] == "1") .And. aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"
					aNfitem[nItem][IT_ALIQPS2] := aNFitem[nItem][IT_ALIQPS2] + aNFItem[nItem][IT_TS][TS_ALQPMAJ]
				EndIf

				IF lDc5602
					aNfitem[nItem][IT_ALIQPS2]:= 0
				EndIF
			EndIf

			//PIS APURACAO - BASE - IT_BASEPS2
			If "BSE" $ cExecuta
				If !aNFItem[nItem][IT_TS][TS_PISCRED] $ "5" .AND. !aNfItem[nItem][IT_TIPONF]$"I|P"

					If ( nPautaSB1 == 0 .And. (Empty(aNFitem[nItem][IT_EXCECAO]) .Or. (!Empty(aNFitem[nItem][IT_EXCECAO]) .And. Empty(aNfItem[nItem][IT_EXCECAO][10])))) .Or.;
						(!Empty(aNFitem[nItem][IT_EXCECAO]) .And. Empty(aNfItem[nItem][IT_EXCECAO][10])) .Or.;
						aNfItem[nItem,IT_QUANT]==0 .Or. aSX6[MV_PISPAUT]

						If (( nPautaSB1 == 0 .And. (Empty(aNFitem[nItem][IT_EXCECAO]) .Or. (!Empty(aNFitem[nItem][IT_EXCECAO]) .And. Empty(aNfItem[nItem][IT_EXCECAO][10])))) .Or.;
							(!Empty(aNFitem[nItem][IT_EXCECAO]) .And. Empty(aNfItem[nItem][IT_EXCECAO][10]) .And. nPautaSB1 == 0) .Or.;
							(!Empty(aNFitem[nItem][IT_EXCECAO]) .And. Empty(aNfItem[nItem][IT_EXCECAO][12])) .Or.;
							aNfItem[nItem,IT_QUANT]==0) .Or. (lPisMin)
							nBasePS2 := aNfItem[nItem][IT_VALMERC]-IIf(aNFItem[nItem][IT_TS][TS_AGREG]$"DR",aNfItem[nItem][IT_DEDICM],0)

							//Tratamento do Agrega Valor - PIS / COF / ICMS
							nAliqAgr := 0

							If lAgregICM .And. aNFItem[nItem][IT_TS][TS_AGREG]=="I"
								If aNFItem[nItem][IT_TS][TS_ICM] == "N"
									nAliqAgr += aNfItem[nItem][IT_ALIQSOL]
									lAgreg	 := .T.
								Else
									If aNfCab[NF_PPDIFAL]
										nAliqAgr += aNfItem[nItem][IT_ALIQCMP]+aNfItem[nItem][IT_ALFCCMP]
									Else
										nAliqAgr += aNfItem[nItem][IT_ALIQICM]
									Endif
									lAgreg	 := .T.
								EndIf
							EndIf

							If aNFItem[nItem][IT_TS][TS_AGRPIS]=="P"
								nAliqAgr += aNfItem[nItem][IT_ALIQPS2]
								lAgreg	 := .T.
								If aNFItem[nItem][IT_TS][TS_AGRCOF]=="C"
									nAliqAgr += aNfItem[nItem][IT_ALIQCF2]
								Endif
							Endif

							If lAgreg

								If aSX6[MV_RNDICM]
									nBasePS2 := Round(nBasePS2 / ( 1 - (nAliqAgr/100)) , 2 )
								Else
									nBasePS2 := nBasePS2 / ( 1 - (nAliqAgr/100))
								EndIf

							Endif

							If aNFItem[nItem][IT_TS][TS_AGREG] == "I" .And. !lAgreg
								nBasePS2 += If(aNFitem[nItem][IT_TIPONF ]<>"I",aNfItem[nItem][IT_VALICM],0)
							EndIf

							If !(aNFItem[nItem][IT_TS][TS_AGREG]=="I" .AND. lAgreg .AND. aSX6[MV_DBSTPIS]$"1|6" .AND. IntTms()) //Tratamento para não duplicar o valor do icms na base de pis
								nBasePS2 := ( nBasePS2 - IIf( aNFItem[nItem][IT_TS][TS_PISBRUT] == "1" , 0 , (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT]+aNfItem[nItem][IT_DS43080]) ) + aNfItem[nItem][IT_DESCZFCOF] + aNfItem[nItem][IT_DESCZFPIS] + IIf(aNfItem[nItem][IT_DESCZFPIS]<>0,0,IIF(aNFItem[nItem][IT_TS][TS_CRPRST]<>0 .And. IntTms(),aNfItem[nitem][IT_VLCSOL],aNfItem[nitem][IT_VALSOL])) )
							EndIf

							If ( !(aNfCab[NF_CLIFOR]=="C" .And. aNfCab[NF_CALCSUF]$"SI" .And. !aNFitem[nItem][IT_TIPONF ]$"BD" .And. ;
								aNFItem[nItem][IT_TS][TS_ISS] <> "S" .And. aSX6[MV_DESCZF] .And. aSX6[MV_DESZFPC] ) .And. aSX6[MV_FRTBASE] ) .Or. aSX6[MV_FRTBASE]
								nBasePS2 += IIf(aNFItem[nItem][IT_TS][TS_DESPPIS] <> "2",aNfItem[nItem][IT_DESPESA],0) + IIF(aNFItem[nItem][IT_TS][TS_DESPPIS] <> "2",aNfItem[nItem][IT_SEGURO],0) + IIF(aNFItem[nItem][IT_TS][TS_DESPPIS] <> "2",aNfItem[nItem][IT_FRETE],0)
							EndIf

							// Campo A2_DEDBSPC em branco ou "1": segue a regra antiga (Parametro MV_DEDBPIS)
							// Processa sempre legado quando Saídas diferente de Devolucao/Benef
							If aNFCab[NF_DEDBSPC] $ " 1" .Or. (aNfCab[NF_OPERNF] == "S" .And. !aNFitem[nItem][IT_TIPONF ] $ "BD" )
							
								If aNFItem[nItem][IT_TS][TS_CREDIPI] == "N" .AND. aSX6[MV_DEDBPIS]$"S,P" .AND. aNFItem[nItem][IT_TS][TS_IPI]<>"R"
									nBasePS2 += aNfItem[nItem][IT_VALIPI]
								EndIf
								If !(aNFItem[nItem][IT_TS][TS_AGREG]$"DR")
									If aSX6[MV_DEDBPIS]$"S,I"
										nBasePS2 -= aNfItem[nItem][IT_VALICM]
									EndIf
								EndIf
								// Caso seja comerciante atacadista, o valor do IPI deve ser retirado da base de calculo do PIS pois esta embutido no valor da mercadoria
								If aNFItem[nItem][IT_TS][TS_CREDIPI] == "S" .And. aSX6[MV_DEDBPIS]$"S,P" .And. aNFItem[nItem][IT_TS][TS_IPI] == "R"
									nBasePS2 -= aNfItem[nItem][IT_VALIPI]
								EndIf

							Else
								// Opcoes do aNFCab[NF_DEDBSPC]:
								// 1 - Legado - Considera as regras dos parâmetros MV_DEDBPIS e MV_DEDBCOF.
								// 2 - Deduz ICMS e IPI.
								// 3 - Deduz Apenas ICMS.
								// 4 - Deduz Apenas IPI.
								// 5 - Não Deduz Nenhum.
								// 6 - Soma IPI
								Do Case
									Case aNFCab[NF_DEDBSPC] == "2"
										nBasePS2 -= aNfItem[nItem][IT_VALICM]
										nBasePS2 -= aNfItem[nItem][IT_VALIPI]
									Case aNFCab[NF_DEDBSPC] == "3"
										nBasePS2 -= aNfItem[nItem][IT_VALICM]
									Case aNFCab[NF_DEDBSPC] == "4"
										nBasePS2 -= aNfItem[nItem][IT_VALIPI]
									Case aNFCab[NF_DEDBSPC] == "6" .And. aNfItem[nItem][IT_TS][TS_LFIPI] <> "T" .AND. aNFItem[nItem][IT_TS][TS_IPI] <> "R"
										nBasePS2 += aNfItem[nItem][IT_VALIPI]
								EndCase

							EndIf

							//Exclui valor do Difal (EC/15) da base de cálculo de PIS
							IF aNfItem[nItem][IT_TS][TS_DIFALPC] == '1'
								nBasePS2 -= (aNfItem[nItem][IT_DIFAL]+aNfItem[nItem][IT_VALCMP]+aNfItem[nItem][IT_VFCPDIF])
							EndIF

							If aSX6[MV_CRDBPIS] $ "S" .And. Substr(aNfItem[nItem][IT_CF],1,1)=="3"
								nBasePS2 += aNfItem[nItem][IT_VALICM]
							EndIf

							If aNFItem[nItem][IT_TS][TS_PISDSZF] == "2"
								nBasePS2 += aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFCOF] + aNfItem[nItem][IT_DESCZFPIS])
							Endif

							// Tratamento para retirada do valor do ICMS solidario da base do PIS Apuracao
							If ((MaFisDbST("PS2",nItem) .Or. (aSX6[MV_RPCBIZF] .And. aNfCab[NF_SUFRAMA])) .And. aNfItem[nItem][IT_DESCZFPIS] == 0)
								nBasePS2 -= IIF(aNFItem[nItem][IT_TS][TS_CRPRST]<>0 .And. IntTms(),aNfItem[nItem][IT_VLCSOL],aNfItem[nItem][IT_VALSOL])
							Endif

						Else
							nBasePS2 := IIF(lSegUndPau,ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],0,2),aNfItem[nItem,IT_QUANT])
						EndIf

						nBasePS2 *= nFatRedPIS

						aNfItem[nItem][IT_BASEPS2] := nBasePS2

						If !aSX6[MV_RNDICM] .And. lAgreg
							MaItArred(nItem,{"IT_BASEPS2"})
						EndIf

						If aNFItem[nItem][IT_TS][TS_OPERSUC]=="1" .And. aNfCab[NF_SIMPSC]<>"1" .And. aNFCab[NF_SIMPNAC]<>"1" // Operacoes com Sucata
							nBasePS2 := (aNFitem[nItem][IT_VALICM] / ( (100-(aNFitem[nItem][IT_ALIQICM]+aNFitem[nItem][IT_ALIQPS2]+aNFitem[nItem][IT_ALIQCF2]))/100 ) )
							aNfItem[nItem][IT_BASEPS2] := nBasePS2
						Endif
					Else
						//Calculo da BASE PIS APURACAO pela PAUTA do SB1 ou EXCECAO
						If (Empty(aNFitem[nItem,IT_EXCECAO]) .Or. Empty(aNFItem[nItem,IT_EXCECAO,10]))
							nBasePS2 := IIF(lSegUndPau,ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],0,2),aNfItem[nItem,IT_QUANT]) * nPautaSB1
							aNfItem[nItem][IT_PAUTPIS]	:= nPautaSB1
						Else
							nBasePS2 := aNfItem[nItem,IT_QUANT] * aNFItem[nItem,IT_EXCECAO,10]
							aNfItem[nItem][IT_PAUTPIS]	:= aNFItem[nItem,IT_EXCECAO,10]
						EndIf
						aNfItem[nItem][IT_BASEPS2] := nBasePS2
					EndIf

					//Zera a BASE do PIS APURACAO somente quando a aliquota for = 0 e o CSTPIS  NAO for = "04#06#73"
					If Empty( aNfItem[nItem][IT_ALIQPS2] ) .And. ((aPE[PE_MACSTPICO] .And. !ExecBlock("MaCstPiCo",.F.,.F.,{nItem,aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_TES],aNfCab[NF_CLIFOR],aNfCab[NF_CODCLIFOR],aNfCab[NF_LOJA],aNfCab[NF_OPERNF]})[2]$"04#06#73") .Or. (!aPE[PE_MACSTPICO] .And. !aNFItem[nItem][IT_TS][TS_CSTPIS] $"04#06#73")) .AND. !lDc5602 .And. !lZFMAlqZ
						aNfItem[nItem][IT_BASEPS2] := 0
					EndIf

				Else
					aNfItem[nItem][IT_BASEPS2] := 0
				EndIf

				//Especifico para VEICULOS
				If cPaisLoc == "BRA" .And. aSX6[MV_CALCVEI] .And. "PS2" $ cTipo .And. aNfCab[NF_OPERNF] == "S" .And. aPos[FP_B1_CHASSI] .And. !Empty( aNfItem[nItem][IT_PRD][SB_CHASSI] ) // Alteracao de base para veiculos usados
					If aNfItem[nItem][IT_BASVEIC] == 0
						aAreaSC6 := SC6->(GetArea())
						SC6->(dbSetOrder(1))
						If SC6->( MsSeek(xFilial("SC6")+aNfCab[NF_PEDIDO]+aNfItem[nItem][IT_ITEM]+aNfItem[nItem][IT_PRODUTO]) )
							aNfItem[nItem][IT_BASVEIC] := SC6->C6_BASVEIC
						EndIf
						RestArea(aAreaSC6)
					EndIf
					aNfItem[nItem][IT_BASEPS2] -= aNfItem[nItem][IT_BASVEIC]
					If aNfItem[nItem][IT_BASEPS2] < 0
						aNfItem[nItem][IT_BASEPS2] := 0
					EndIF
				EndIf

			EndIf

			//Define o Valor do PIS MAJORADO conforme aliquota informada na TES.
			If aNFItem[nItem][IT_TS][TS_ALQPMAJ] > 0
				aNfItem[nItem][IT_VALPMAJ] := aNfItem[nItem][IT_BASEPS2] * (aNFItem[nItem][IT_TS][TS_ALQPMAJ]/100)
			EndIf

			//PIS APURACAO - VALOR - IT_VALPS2
			If "VLR" $ cExecuta

				If (nPautaSB1 == 0 .And. (Empty(aNFitem[nItem][IT_EXCECAO]) .Or. (!Empty(aNFitem[nItem][IT_EXCECAO]) .And. Empty(aNfItem[nItem][IT_EXCECAO][10])))) .Or.;
					aNfItem[nItem,IT_QUANT]==0 .Or. !aSX6[MV_PISPAUT]

					aNfItem[nItem][IT_VALPS2] := aNfItem[nItem][IT_BASEPS2]*aNfItem[nItem][IT_ALIQPS2]/100

				Else
					//PIS APURACAO - Aplica PAUTA SB1 ou Excecao
					If aNfItem[nItem][IT_BASEPS2] <> 0
						If Empty(aNFitem[nItem,IT_EXCECAO]) .Or. (Empty(aNFItem[nItem,IT_EXCECAO,10]) .And. Empty(aNFItem[nItem,IT_EXCECAO,12]))
							IF lPisMin

								nVlOprPis	:= aNfItem[nItem][IT_BASEPS2]*aNfItem[nItem][IT_ALIQPS2]/100
								nVlPautPis	:= IIF(lSegUndPau .And. aNfItem[nItem][IT_PRD][SB_CONV] > 0,ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],0,2),aNfItem[nItem,IT_QUANT]) * nPautaSB1

								IF  nVlOprPis <  nVlPautPis
									aNfItem[nItem][IT_BASEPS2] := IIF(lSegUndPau .And. aNfItem[nItem][IT_PRD][SB_CONV] > 0,ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],0,2),aNfItem[nItem,IT_QUANT])
									aNfitem[nItem][IT_ALIQPS2] := nPautaSB1
									aNfItem[nItem][IT_VALPS2]  := aNfItem[nItem][IT_BASEPS2] * aNfitem[nItem][IT_ALIQPS2]
									aNfItem[nItem][IT_PAUTPIS] := nPautaSB1

									/*Se efetuou o cálculo por pauta e o CST não for 03, forço o 03*/
									IF aNFItem[nItem][IT_TS][TS_CSTPIS] <> '03' .And. aNfCab[NF_OPERNF] == "S"
										aNFItem[nItem][IT_TS][TS_CSTPIS] := '03'
									ENDIF

									aNFItem[nItem][IT_PAUTAPS] := .T.
								ELSE
									aNfItem[nItem][IT_VALPS2]  := nVlOprPis
									aNfItem[nItem][IT_PAUTPIS] := 0
									aNFItem[nItem][IT_PAUTAPS] := .F.
									// Quando CST não mudar para 03 não ira gravar tabela da receita
									aNfItem[nItem][IT_TABNTRE] := ""
									aNfItem[nItem][IT_CODNTRE] := ""
									aNfItem[nItem][IT_GRPNTRE] := ""
									aNfItem[nItem][IT_DATNTRE] := cTod("//")
								ENDIF
							ELSE
								aNfItem[nItem][IT_BASEPS2] := IIF(lSegUndPau,ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],0,2),aNfItem[nItem,IT_QUANT])
								aNfitem[nItem][IT_ALIQPS2] := nPautaSB1
								aNfItem[nItem][IT_VALPS2]  := aNfItem[nItem][IT_BASEPS2] * aNfitem[nItem][IT_ALIQPS2]
								aNfItem[nItem][IT_PAUTPIS] := nPautaSB1
								aNFItem[nItem][IT_PAUTAPS] := .T.
							ENDIF
						Else
							IF lPisMin
								nVlOprPis	:= aNfItem[nItem][IT_BASEPS2]*aNfItem[nItem][IT_ALIQPS2]/100
								nVlPautPis	:= IIF(lSegUndPau .And. aNfItem[nItem][IT_PRD][SB_CONV] > 0,ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],0,2),aNfItem[nItem,IT_QUANT]) * aNFItem[nItem,IT_EXCECAO,10]

								IF  nVlOprPis < nVlPautPis
									aNfItem[nItem][IT_BASEPS2] := IIF(lSegUndPau .And. aNfItem[nItem][IT_PRD][SB_CONV] > 0,ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],0,2),aNfItem[nItem,IT_QUANT])
									aNfitem[nItem][IT_ALIQPS2] := aNFItem[nItem,IT_EXCECAO,10]
									aNfItem[nItem][IT_VALPS2]  := aNfItem[nItem][IT_BASEPS2]* aNfitem[nItem][IT_ALIQPS2]
									aNfItem[nItem][IT_PAUTPIS] := aNFItem[nItem,IT_EXCECAO,10]

									/*Se efetuou o cálculo por pauta e o CST não for 03, forço o 03*/
									IF aNFItem[nItem][IT_TS][TS_CSTPIS] <> '03' .And. aNfCab[NF_OPERNF] == "S"
										aNFItem[nItem][IT_TS][TS_CSTPIS] := '03'
									ENDIF

									aNFItem[nItem][IT_PAUTAPS] := .T.
								ELSE
									aNfItem[nItem][IT_VALPS2]  := nVlOprPis
									aNfItem[nItem][IT_PAUTPIS] := 0
									aNFItem[nItem][IT_PAUTAPS] := .F.
									// Quando CST não mudar para 03 não ira gravar tabela da receita
									aNfItem[nItem][IT_TABNTRE] := ""
									aNfItem[nItem][IT_CODNTRE] := ""
									aNfItem[nItem][IT_GRPNTRE] := ""
									aNfItem[nItem][IT_DATNTRE] := cTod("//")
								ENDIF
							ElseIf !Empty(aNFitem[nItem,IT_EXCECAO]) .And. !Empty(aNFItem[nItem,IT_EXCECAO,12])
								aNfItem[nItem][IT_BASEPS2] := aNfItem[nItem][IT_VALMERC]-IIf(aNFItem[nItem][IT_TS][TS_AGREG]$"DR",aNfItem[nItem][IT_DEDICM],0)
								aNfitem[nItem][IT_ALIQPS2] := aNFItem[nItem,IT_EXCECAO,12]
								aNfItem[nItem][IT_VALPS2]  := aNfItem[nItem][IT_BASEPS2] * aNfitem[nItem][IT_ALIQPS2] /100
								aNfItem[nItem][IT_PAUTPIS] := aNFItem[nItem,IT_EXCECAO,10]
								aNFItem[nItem][IT_PAUTAPS] := .F.
							ELSE
								aNfItem[nItem][IT_BASEPS2] := IIF(lSegUndPau,ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],0,2),aNfItem[nItem,IT_QUANT])
								aNfitem[nItem][IT_ALIQPS2] := aNFItem[nItem,IT_EXCECAO,10]
								aNfItem[nItem][IT_VALPS2]  := aNfItem[nItem][IT_BASEPS2] * aNfitem[nItem][IT_ALIQPS2]
								aNfItem[nItem][IT_PAUTPIS] := aNFItem[nItem,IT_EXCECAO,10]
								aNFItem[nItem][IT_PAUTAPS] := .T.
							ENDIF
						EndIf
					EndIf
				EndIf

				If aNFItem[nItem][IT_TS][TS_AGRPIS]=="P"
					aNfItem[nItem][IT_VALPS2] := Round(aNfItem[nItem][IT_VALPS2],2)
				EndIf

				//DESCONTO SUFRAMA - PIS APURACAO
				If !lZFMAlqZ .And. aNfCab[NF_CLIFOR]=="C" .And. !aNfCab[NF_CALCSUF]$"IN " .And. !aNFitem[nItem][IT_TIPONF ]$"BD" .And. ;
					aNFItem[nItem][IT_TS][TS_ISS] <> "S" .And. aSX6[MV_DESCZF] .And. aSX6[MV_DESZFPC] .And. ( aNFItem[nItem][IT_TS][TS_PISCRED]$"134" )

					If ( aPE[PE_MACSTPICO] .And. ExecBlock("MaCstPiCo",.f.,.f.,{nItem,aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_TES],aNfCab[NF_CLIFOR],aNfCab[NF_CODCLIFOR],aNfCab[NF_LOJA],aNfCab[NF_OPERNF]})[2]$"04#06#73") .Or. ( !aPE[PE_MACSTPICO] .And. aNFItem[nItem][IT_TS][TS_CSTPIS] $"04#06#73")
						If aNfItem[nItem][IT_PAUTPIS] == 0
							If aNfItem[nItem][IT_DESCZFPIS] == 0
								aNfItem[nItem][IT_VALPS2]:= aNfItem[nItem][IT_BASEPS2] * nAliqBase / 100
							Else
								aNfItem[nItem][IT_VALPS2]:= aNfItem[nItem][IT_DESCZFPIS]
							Endif
						Else
							aNfItem[nItem][IT_VALPS2] := aNfItem[nItem][IT_BASEPS2]
						EndIf
					Endif

					MaItArred(nItem,{"IT_DESCZFPIS"})
					aNfItem[nItem][IT_DESCZF] -= aNfItem[nItem][IT_DESCZFPIS]

					If aNfCab[NF_ROTINA] $ "MATA461|FATA701" .Or. FunName()=="MATA920"
						MaItArred(nItem,{"IT_VALPS2"})
						aNfItem[nItem][IT_VALMERC]+= aNfItem[nItem][IT_DESCZFPIS]
						aNfItem[nItem][IT_VALMERC]-= aNfItem[nItem][IT_VALPS2]
						If FunName()=="MATA920"
							aNfItem[nItem][IT_PRCUNI] := aNfItem[nItem][IT_VALMERC]/aNfItem[nItem][IT_QUANT]
						Elseif FunName() $ "MATA461|MATA460A|FATA701"
							aNfItem[nItem][IT_PRCUNI] := (aNfItem[nItem][IT_VALMERC]- (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT]) + aNfItem[nItem][IT_ACRESCI] )/aNfItem[nItem][IT_QUANT]
						EndIf
					EndIf
					aNfItem[nItem][IT_DESCZFPIS]:= aNfItem[nItem][IT_VALPS2]
					MaItArred(nItem,{"IT_DESCZFPIS"})
					aNfItem[nItem][IT_DESCZF]   += aNfItem[nItem][IT_DESCZFPIS]
					aNfItem[nItem][IT_VALPS2]   := 0
					If aNFItem[nItem][IT_TS][TS_PSCFST] == "1" .And. !aNFItem[nItem][IT_TS][TS_CSTPIS] $"04#06#73"
						aNfItem[nItem][IT_BASEPS2]  := 0
					EndIf
				EndIf

				MaItArred(nItem,{"IT_VALPS2"})
			Endif
			If "PS2" $ cTipo
				If aPE[PE_MAPISVEIC] // ATENCAO!!! Ponto de entrada para uso exclusivo da TOTVS, nao sugerir o uso do mesmo a clientes - GDP FISCAL
					aMaPISVeic := ExecBlock("MaPISVeic",.F.,.F.,{nItem,aNfItem[nItem][IT_BASEPS2],aNfItem[nItem][IT_ALIQPS2],aNfItem[nItem][IT_VALPS2]})
					aNfItem[nItem][IT_BASEPS2] := aMaPISVeic[1]
					aNfItem[nItem][IT_ALIQPS2] := aMaPISVeic[2]
					aNfItem[nItem][IT_VALPS2]  := aMaPISVeic[3]
				EndIf
			Endif
		Else
			If "BSE" $ cExecuta
				aNfItem[nItem][IT_BASEPS2]:= 0
			EndIf
			If "VLR" $ cExecuta
				aNfItem[nItem][IT_VALPS2] := 0
			EndIf
			If "ALQ" $ cExecuta
				aNfItem[nItem][IT_ALIQPS2]:= 0
			EndIf
		EndIf
	EndIf

	// Se for reprocessamento restauro a base, aliquota e valor originais.
	If lReproc
		aNfItem[nItem][IT_BASEPS2] := nBaseOri
		aNfItem[nItem][IT_ALIQPS2] := nAliqOri
		aNfItem[nItem][IT_VALPS2]  := nValOri
		aNfItem[nItem][IT_VALPMAJ] := nMajOri
	EndIf
EndIf

//PIS RETENCAO - IT_BASEPIS / IT_ALIQPIS / IT_VALPIS
If "PIS" $ cTipo
	//Define a Aliquota do PIS RETENCAO - IT_ALIQPIS
	If "ALQ" $ cExecuta
		If Empty(nAliqSB1) .Or. aSX6[MV_TPALPIS] == "1"
			If !Empty(aNfCab[NF_NATUREZA]) .And. aInfNat[NT_CALCPIS] == "S" .And. !Empty(aInfNat[NT_PERCPIS])

				nAliqPIS :=  aInfNat[NT_PERCPIS]

				If nModulo == 43 .And. SA1->A1_TPESSOA == "EP" // Para o Tipo de Cliente 'Empresa Publica',quando transporte for Internacional,nao gerar a retencao de PIS/COFINS -- BOPS 153148
					aAreaSA1 := SA1->(GetArea())
					SA1->(dbSetOrder(1))
					If SA1->(msSeek(xFilial("SA1")+SF2->F2_CLIENT+SF2->F2_LOJENT)) .And. SA1->A1_EST == "EX"
						nAliqPIS := 0
					EndIf
					RestArea(aAreaSA1)
				EndIf

			EndIf

			If aPE[PE_MACALCPIS]
				If aMaCalcPIS[1] == "S" .And. !Empty(aMaCalcPIS[2])
					nAliqPIS := aMaCalcPIS[2]
				EndIf
			EndIf

		EndIf


		aNfItem[nItem][IT_ALIQPIS]	:= nAliqPIS
	Endif
	//Calculo de BASE e VALOR do PIS RETENCAO - IT_BASEPIS e IT_VALPIS

	If "BSE" $ cExecuta .Or. "VLR" $ cExecuta
		If ( aPE[PE_MACALCPIS] .And. aMaCalcPIS[1]=="S" ) .Or. ( !Empty(aNfCab[NF_NATUREZA]) .And. aInfNat[NT_CALCPIS]=="S" ;
			.And. aNfCab[NF_RECPIS] $ "S|P" .And. ( aNfItem[nItem][IT_PRD][SB_PIS] == "1" .Or. aNfCab[NF_RECPIS] == "P" ) )
			// A base de calculo da retencao eh o valor da duplicata
			// porem de acordo com a Cons. Trib. Liz, o valor do ISS nao
			// devera ser deduzido da base do PIS/COF/CSL retencao. Para
			// isso foi criado o parametro MV_DEISSBS que se estiver como
			// .T. nao sera descontado e se estiver como .F. - default sera
			nDescISS := Iif( aSX6[MV_DEISSBS] .And. aNfCab[NF_RECISS]=="1" .And. aSX6[MV_DESCISS] .And. aNfCab[NF_OPERNF]=="S" .And. aSX6[MV_TPABISS]=="1",aNfItem[nItem][IT_VALISS],0)
			nBasePIS := aNfItem[nItem,IT_BASEDUP] + IIf( aSX6[MV_PISBRU] == "1" , (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT]) , 0 ) + nDescISS

			// Retirado:
			// 		Inciso II, paragrafo 2º, artigo 1º da Lei 10845/02
			//		Issue - DSERFIS2-386
			If aNfItem[nItem][IT_TS][TS_APLREPC]$"13"
				nBasePIS *= nFatRedPIS
			EndIf

			//Tratamento extraido da funcao MaFisVTot para saber se foi contemplado o VALOR DE IPI na base da duplicata para que eu possa subtrair
			If (aNFItem[nItem][IT_TS][TS_IPIPC]=="2") .And. (aNFitem[nItem][IT_TIPONF]=="P" .Or. aNFItem[nItem][IT_TS][TS_IPI]<>'R')
				nBasePIS -= aNfItem[nItem][IT_VALIPI]
			EndIf
			If aSX6[MV_CRDBPIS] $ "S" .And. Substr(aNfItem[nItem][IT_CF],1,1)=="3"
				nBasePIS += aNfItem[nItem][IT_VALICM]
			EndIf

			// Tratamento para retirada do valor do ICMS solidario da base do PIS Retencao
			If MaFisDbST("PIS",nItem) .And. aNfItem[nItem][IT_DESCZFPIS] == 0
				nBasePIS -= aNfItem[nitem][IT_VALSOL]
			Endif

			//Quando operação com diferimento para orgão Publico, base de retenção deve ser sobre total da nota.
			If aTes[TS_PICMDIF]<>0 .And. aTes[TS_ICMSDIF]$" ,1,2" .And. aTes[TS_ICM] == "S"
				nBasePIS += aNfItem[nItem][IT_ICMSDIF]
			EndIf

			If "BSE" $ cExecuta
				aNfItem[nItem][IT_BASEPIS]:= nBasePIS
			Endif

			If "VLR" $ cExecuta
				aNfItem[nItem][IT_VALPIS] := aNfItem[nItem][IT_BASEPIS] * aNfItem[nItem][IT_ALIQPIS] / 100
			Endif

			If aNfItem[nItem][IT_PRD][SB_RETOPER] == "1" .And. !aNfCab[NF_RECPIS] == "N" //Item classificado na Medida Provisoria 252 Junho/2005 e nao aguardar o limite imposto pela Lei 10.925 (R$ 5.000,00) autopecas
				aNfItem[nItem][IT_PIS252] := aNfItem[nItem][IT_VALPIS]
			Endif
		Else
			If "BSE" $ cExecuta
				aNfItem[nItem][IT_BASEPIS]:= 0
			EndIf
			If "VLR" $ cExecuta
				aNfItem[nItem][IT_VALPIS] := 0
			EndIf
		EndIf
	EndIf

	MaItArred(nItem,{"IT_VALPIS"})
EndIf

//Calcula PIS-ST   Base  Aliquota e Valor - IT_BASEPS3 - IT_ALIQPS3 - IT_VALPS3
If "PS3" $ cTipo
	If aNFItem[nItem][IT_TS][TS_PSCFST] $ "1/3"
		//Conforme IN SRF 594 de 2005, nao devem integrar a base de calculo do PIS/COFINS ST:
		//- Receitas isentas e as decorrentes de vendas a aliquota 0
		//- Vendas canceladas
		//- Descontos incondicionais
		//- IPI
		//- ICMS ST
		If aNFItem[nItem][IT_TS][TS_IPIPC] == "2" //Somente retiro aqui o valor do PS3 e CF3 caso o campo IPIPC estiver como 2, pois se estiver como 1 já estou retirando os valores no momento de compor o IT_TOTAL
			nBasePS3 := aNfItem[nItem][IT_TOTAL] //- ((aNfItem[nItem][IT_VALPS3]) + aNfItem[nItem][IT_VALCF3])
			nBasePS3 -= aNfItem[nItem][IT_VALIPI] //Conforme IN SRF546/2005 o valor do IPI deve integrar a base calculo PIS/COFINS ST-Zona Franca de Manaus

			If !(aNFItem[nItem][IT_TS][TS_INCSOL]$"A,N,D") // Verifica se o valor do ICMS Solidario esta agregado ao valor total
				nBasePS3 -= aNfItem[nItem][IT_VALSOL]
			Endif

		Else
			nBasePS3 := aNfItem[nItem][IT_VALMERC] + aNfItem[nItem][IT_VALIPI]
		Endif

		If ( !(aNfCab[NF_CLIFOR]=="C" .And. aNfCab[NF_CALCSUF]$"SI" .And. !aNFitem[nItem][IT_TIPONF ]$"BD" .And. ;
				aNFItem[nItem][IT_TS][TS_ISS] <> "S" .And. aSX6[MV_DESCZF] .And. aSX6[MV_DESZFPC] ) .And. aSX6[MV_FRTBASE] ) .Or. aSX6[MV_FRTBASE]
				nBasePS3 += IIf(aNFItem[nItem][IT_TS][TS_DESPPIS] <> "2",aNfItem[nItem][IT_DESPESA],0) + IIF(aNFItem[nItem][IT_TS][TS_DESPPIS] <> "2",aNfItem[nItem][IT_SEGURO],0) + IIF(aNFItem[nItem][IT_TS][TS_DESPPIS] <> "2",aNfItem[nItem][IT_FRETE],0)
		EndIf

		If aNFCab[NF_CLIFOR] == "C" .And. aNFCab[NF_TIPONF] $ "DB" .And. !aNfItem[nItem][IT_TIPONF]$"I|P" .And. aSX6[MV_DESCZF] .And. aSX6[MV_DESZFPC]
			If aNFItem[nItem][IT_TS][TS_PISCRED] <> "3" .And. aNFItem[nItem][IT_TS][TS_PISCOF]$"13" .And. !aNfCab[NF_CALCSUF]$"IN "
				nBasePS3 -= (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT])
			ElseIf aNFItem[nItem][IT_TS][TS_PISCRED] == "3" .And. aNFItem[nItem][IT_TS][TS_PISCOF]$"4" .And. aNfCab[NF_CALCSUF]$"I"
				nBasePS3 -= (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT])
			EndIf
		Else
			If aNFItem[nItem][IT_TS][TS_PISCRED] <> "3" .And. aNFItem[nItem][IT_TS][TS_PISCOF]$"13" .And. aNFItem[nItem][IT_TS][TS_PISBRUT] == '2' .And. aNFItem[nItem][IT_TS][TS_IPIPC] <> '2'
				nBasePS3 -= (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT]+aNfItem[nItem][IT_DS43080])
			EndIf
		EndIf

		If aNFItem[nItem][IT_TS][TS_PISDSZF] == "2"
			nBasePS3 += aNfItem[nItem][IT_DESCZF]
		EndIf

		nBasePS3 *= nFatRedPIS
		//Se usuario informou percentual de Substituicao Tributaria de cigarro, ira multiplicar a base de calculo pelo percentual
		If Len(Alltrim(aSX6[MV_PUPCCST])) > 0 .And. aPos[FP_B1_PUPCCST]
			nVlUnitCig := aNfItem[nItem][IT_PRD][SB_PUPCCST] // Campo onde e informado o valor unitario para calcular valor de PIS ST.
		EndIF

		If !Empty(aNFitem[nItem][IT_EXCECAO])
			If aNfItem[nItem,IT_EXCECAO,25] > 0
				nVlUnitCig	:= aNfItem[nItem,IT_EXCECAO,25]
				aNfItem[nItem][IT_PRCUNIC] := nVlUnitCig
			Endif
		Endif

		If Len(AllTrim(aSX6[MV_B1CPSST])) > 0 .And. aPos[FP_B1_B1CPSST]
			aNfItem[nItem][IT_COEPSST] := aNfItem[nItem][IT_PRD][SB_B1CPSST] // Campo onde e informado o % de Substituição tributaria do PIS para fabrincante de cigarros.
		EndIf

		If nVlUnitCig > 0
			If aNfItem[nItem][IT_COEPSST] > 0
				nBasePS3 := ( aNfItem[nItem][IT_QUANT] * nVlUnitCig ) * aNfItem[nItem][IT_COEPSST]
			Else
				nBasePS3 := aNfItem[nItem][IT_QUANT] * nVlUnitCig
			EndIf
		EndIF

		If aNFCab[NF_TIPONF]$"D" .And. !Empty(aNFItem[nItem][IT_RECORI]) .And. aNFCab[NF_CLIFOR] == "C" .And. cPaisLoc == "BRA"
			SD2->( MsGoto( aNFItem[nItem][IT_RECORI] ) )
			nBasePS3 := aNfItem[nItem][IT_QUANT] * SD2->D2_BASEPS3 / SD2->D2_QUANT
		EndIF

		If "BSE" $ cExecuta
			aNfItem[nItem][IT_BASEPS3] := nBasePS3
		Endif
		If "ALQ" $ cExecuta
			IF aNFItem[nItem][IT_TS][TS_PSCFST] == "3" // 3= Aliq. Zero
				nAliqPS3 := 0
			Elseif Len(Alltrim(aSX6[MV_B1PISST])) > 0 .And. aNfItem[nItem][IT_PRD][SB_B1PISST] > 0 	//Verifica Campo criado na SB1
				nAliqPS3 := aNfItem[nItem][IT_PRD][SB_B1PISST]
			ElseIF aSX6[MV_TXPISST] > 0
				nAliqPS3 := aSX6[MV_TXPISST] // Verifica aliquota parametro
			Endif
			aNfItem[nItem][IT_ALIQPS3] := nAliqPS3
		Endif
		If "VLR" $ cExecuta
			aNfItem[nItem][IT_VALPS3]  := aNfItem[nItem][IT_BASEPS3]*aNfItem[nItem][IT_ALIQPS3]/100
		Endif
	Else
		If "BSE" $ cExecuta
			aNfItem[nItem][IT_BASEPS3] := 0
		EndIf
		If "ALQ" $ cExecuta
			aNfItem[nItem][IT_ALIQPS3] := 0
		EndIf
		If "VLR" $ cExecuta
			aNfItem[nItem][IT_VALPS3]  := 0
		EndIf
	EndIf
	MaItArred(nItem,{"IT_VALPS3"})
EndIf

If aSX6[MV_PCFATPC] .And. aNfCab[NF_OPERNF] == "S" .And. !Empty(aNfCab[NF_CLIEFAT])
	aNFitem[nItem][IT_EXCECAO] 	:= aExcecao
	aNfCab[NF_NATUREZA] 		:= cNatureza
EndIf

Return

/*/
MaFisCOFINS -Alexandre Lemes -28/09/2012
Calculo do COFINS - Apuracao / Retencao e ST
*/
Static Function MaFisCOFINS(nItem,cTipo,cExecuta,lReproc,lAgregICM)

Local aExcecao	 := {}
Local aAreaSA1   := {}
Local aAreaSC6   := {}
Local aMaCOFVeic := {}
Local aMaCOFDif  := {}
Local aMaCalcCOF := IIf( aPE[PE_MACALCCOF] , ExecBlock("MaCalcCOF") , Array(2) )

Local cNatureza	 := ""

Local nDescISS	 := 0
Local nVlUnitCig := 0
Local nFatRedCOF := 1
Local nAliqAgr	 := 0
Local nBaseCOF   := 0
Local nBaseCF2	 := 0
Local nBaseCF3	 := 0
Local nPautaSB1  := aNfItem[nItem][IT_PRD][SB_VLR_COF]
Local nRedBsCOF	 := aNfItem[nItem][IT_PRD][SB_REDCOF]
Local nAliqSB1   := aNfItem[nItem][IT_PRD][SB_PCOFINS]
Local nAliqBase  := IIf( !Empty(aNFitem[nItem,IT_EXCECAO]) .And. aNFItem[nItem,IT_EXCECAO,13] <> 0 , aNFItem[nItem,IT_EXCECAO,13] , IIf(Empty(nAliqSB1) , aSX6[MV_TXCOFIN] , nAliqSB1) )
Local nAliqCOF   := nAliqBase // Retencao
Local nAliqCF2   := nAliqBase // Apuracao
Local nAliqCF3   := nAliqBase // Substituicao Tributaria ST
Local lRecalCF2  := .T.
Local lAgreg     := .F.
Local lDc5602	 := .F.
Local lZFMAlqZ	 := .F.
Local lSegUndPau := aSX6[MV_PISCOFP] //utiliza ou nao segunda unidade quando for pauta
Local lCofMin		:= aNfItem[nItem][IT_TS][TS_COFMIN] == "1"
Local nVlOprCof	:= 0
Local nVlPautCof	:= 0

Local nBaseOri := aNfItem[nItem][IT_BASECF2]
Local nAliqOri := aNfItem[nItem][IT_ALIQCF2]
Local nValOri  := aNfItem[nItem][IT_VALCF2]
Local nMajOri  := aNfItem[nItem][IT_VALCMAJ]

//Reducao de BASE COFINS pesquisa pelo PRODUTO / TES ou EXCECAO
DEFAULT nRedBsCOF := 0
DEFAULT cExecuta  := "BSE|ALQ|VLR"
DEFAULT lReproc := .F.
DEFAULT lAgregICM := .T.

If aSX6[MV_PCFATPC] .And. aNfCab[NF_OPERNF] == "S" .And. !Empty(aNfCab[NF_CLIEFAT])
	aExcecao	:= aNFitem[nItem][IT_EXCECAO]
	aNFitem[nItem][IT_EXCECAO] := aNFitem[nItem][IT_EXCEFAT]
	cNatureza	:= aNfCab[NF_NATUREZA]
	aNfCab[NF_NATUREZA]	:= aNfCab[NF_NATUFAT]
EndIf

nRedBsCOF := IIf( aNFItem[nItem][IT_TS][TS_BASECOF] > 0 , aNFItem[nItem][IT_TS][TS_BASECOF] , nRedBsCOF )
nRedBsCOF := IIf( !Empty(aNFitem[nItem][IT_EXCECAO]) .And. aNfItem[nItem,IT_EXCECAO,19] > 0 , aNfItem[nItem,IT_EXCECAO,19] , nRedBsCOF )
If nRedBsCOF <> 0
	nFatRedCOF	:= IIf( nRedBsCOF>0,1-nRedBsCOF/100,1)
EndIf

//COFINS APURACAO - IT_BASECF2 / IT_ALIQCF2 / IT_VALCF2
If "CF2" $ cTipo

	lDc5602:=.F.
	If aNfItem[nItem][IT_TABNTRE] == "4313" .AND. aNfCab[NF_OPERNF]=="S"
		lDc5602:=Decret5602((aNfItem[nItem][IT_VALMERC]/ aNfItem[nItem][IT_QUANT]),aNfItem[nItem][IT_POSIPI],aNfItem[nItem][IT_CODNTRE])
	EndIF
	aNfItem[nItem][IT_ALQCMAJ] := aNFItem[nItem][IT_TS][TS_ALQCMAJ] //Alimenta a referencia de aliquota majorada do COFINS APURACAO
	aNfItem[nItem][IT_VALCMAJ] := 0 // garante a limpeza da referencia caso o produto seja trocado na edicao da NF.

	//Devolucao de importacao, mantem os valores do COFINS APURACAO do documento Original
	//If aNFCab[NF_TPCLIFOR]=="X" .And. Substr(aNfItem[nItem][IT_CF],1,1)$"37"
	If ( aNFCab[NF_TIPONF] $"DB" .Or. aNFItem[nItem][IT_TS][TS_PODER3] == "D" ) .And. !Empty(aNFItem[nItem][IT_RECORI]) .And. aNFItem[nItem][IT_TS][TS_OPERGAR] <> '1'
		If aNFCab[NF_TIPONF] $ "DB"
			If aNFCab[NF_CLIFOR] == "C"
				SD2->(MsGoto(aNFItem[nItem][IT_RECORI]) )
				If aNfItem[nItem][IT_QUANT] == SD2->D2_QUANT
					aNfItem[nItem][IT_ALIQCF2] := SD2->D2_ALQIMP5
					aNfItem[nItem][IT_BASECF2] := SD2->D2_BASIMP5
					aNfItem[nItem][IT_VALCF2]  := SD2->D2_VALIMP5
					lRecalCF2 := .F.
				ElseIf aNfItem[nItem][IT_QUANT] <> SD2->D2_QUANT .And. aNFItem[nItem][IT_TS][TS_DEVPARC]$"1S"
					aNfItem[nItem][IT_ALIQCF2] := SD2->D2_ALQIMP5
					aNfItem[nItem][IT_BASECF2] := (aNfItem[nItem][IT_QUANT] * SD2->D2_BASIMP5)/SD2->D2_QUANT
					aNfItem[nItem][IT_VALCF2]  := (aNfItem[nItem][IT_QUANT] * SD2->D2_VALIMP5)/SD2->D2_QUANT
					lRecalCF2 := .F.
				EndIf
			Else
				SD1->(MsGoto( aNFItem[nItem][IT_RECORI]) )
				If aNfItem[nItem][IT_QUANT] == SD1->D1_QUANT
					aNfItem[nItem][IT_ALIQCF2] := SD1->D1_ALQIMP5
					aNfItem[nItem][IT_BASECF2] := SD1->D1_BASIMP5
					aNfItem[nItem][IT_VALCF2]  := SD1->D1_VALIMP5
					If aNFItem[nItem][IT_TS][TS_ALQCMAJ] > 0
						aNfItem[nItem][IT_VALCMAJ] := aNfItem[nItem][IT_BASECF2] * (aNFItem[nItem][IT_TS][TS_ALQCMAJ]/100)
					EndIf
					lRecalCF2 := .F.
				ElseIf aNfItem[nItem][IT_QUANT] <> SD1->D1_QUANT .And. aNFItem[nItem][IT_TS][TS_DEVPARC]$"1S"
					aNfItem[nItem][IT_ALIQCF2] := SD1->D1_ALQIMP5
					aNfItem[nItem][IT_BASECF2] := (aNfItem[nItem][IT_QUANT] * SD1->D1_BASIMP5)/SD1->D1_QUANT
					aNfItem[nItem][IT_VALCF2]  := (aNfItem[nItem][IT_QUANT] * SD1->D1_VALIMP5)/SD1->D1_QUANT
					lRecalCF2 := .F.
				EndIf
			EndIf
		Else
			If aNFCab[NF_CLIFOR] == "C"
				SD1->(MsGoto( aNFItem[nItem][IT_RECORI]) )
				If aNfItem[nItem][IT_QUANT] == SD1->D1_QUANT
					aNfItem[nItem][IT_ALIQCF2] := SD1->D1_ALQIMP5
					aNfItem[nItem][IT_BASECF2] := SD1->D1_BASIMP5
					aNfItem[nItem][IT_VALCF2]  := SD1->D1_VALIMP5
					lRecalCF2 := .F.
				EndIf
			Else
				SD2->(MsGoto(aNFItem[nItem][IT_RECORI]) )
				If aNfItem[nItem][IT_QUANT] == SD2->D2_QUANT
					aNfItem[nItem][IT_ALIQCF2] := SD2->D2_ALQIMP5
					aNfItem[nItem][IT_BASECF2] := SD2->D2_BASIMP5
					aNfItem[nItem][IT_VALCF2]  := SD2->D2_VALIMP5
					lRecalCF2 := .F.
				ElseIf aNfItem[nItem][IT_QUANT] <> SD2->D2_QUANT .And. aNFItem[nItem][IT_TS][TS_DEVPARC]$"1S"
					aNfItem[nItem][IT_ALIQCF2] := SD2->D2_ALQIMP5
					aNfItem[nItem][IT_BASECF2] := (aNfItem[nItem][IT_QUANT] * SD2->D2_BASIMP5)/SD2->D2_QUANT
					aNfItem[nItem][IT_VALCF2]  := (aNfItem[nItem][IT_QUANT] * SD2->D2_VALIMP5)/SD2->D2_QUANT
					lRecalCF2 := .F.
				EndIf
			EndIf
		EndIf
	EndIf

	//COFINS APURACAO - CALCULO
	If lRecalCF2

		lZFMAlqZ := aNFItem[nItem][IT_TS][TS_PISCOF]=="4" .And. aNFItem[nItem][IT_TS][TS_PISCRED]=="3" .And. ;
		aNfCab[NF_CLIFOR]=="C" .And. !aNfCab[NF_CALCSUF]$"IN " .And. !aNFitem[nItem][IT_TIPONF ]$"BD" .And. ;
		aNFItem[nItem][IT_TS][TS_ISS] <> "S" .And. aSX6[MV_DESCZF] .And. aSX6[MV_DESZFPC] .And. ( aNFItem[nItem][IT_TS][TS_PISCRED]$"134" ) .And. ;
		Empty(aNfItem[nItem][IT_ALIQCF2]) .And. ((aPE[PE_MACSTPICO] .And. !ExecBlock("MaCstPiCo",.F.,.F.,{nItem,aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_TES],aNfCab[NF_CLIFOR],aNfCab[NF_CODCLIFOR],aNfCab[NF_LOJA],aNfCab[NF_OPERNF]})[2]$"04#06#73") .Or. (!aPE[PE_MACSTPICO] .And. aNFItem[nItem][IT_TS][TS_CSTCOF] $"04#06#73")) .AND. !lDc5602

		If (aNFItem[nItem][IT_TS][TS_PISCOF]$"2|3" .And. !aNFItem[nItem][IT_TS][TS_PISCRED]$"3") .Or. lZFMAlqZ

			//Define a Aliquota do COFINS APURACAO - IT_ALIQCF2
			If "ALQ" $ cExecuta
				If ( aNFItem[nItem][IT_TS][TS_PISCRED] == "3" .Or. Empty(aNFItem[nItem][IT_TS][TS_PISCRED]) ) .And. aNfItem[nItem][IT_PRD][SB_COFINS] == "2"
					nAliqCF2 := 0
				Endif

				If ( aPE[PE_MACSTPICO] .And. ExecBlock("MaCstPiCo",.F.,.F.,{nItem,aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_TES],aNfCab[NF_CLIFOR],aNfCab[NF_CODCLIFOR],aNfCab[NF_LOJA],aNfCab[NF_OPERNF]})[2]$"04#06#73") .Or. (!aPE[PE_MACSTPICO] .And. (aNFItem[nItem][IT_TS][TS_CSTCOF] $"04#06#73" .Or. aNFItem[nItem][IT_TS][TS_PSCFST]== "3"))
					nAliqCF2:=0
				EndIF

				aNfItem[nItem][IT_ALIQCF2]	:= IIf( aSX6[MV_APURCOF] , aSX6[MV_TXCOFIN] , nAliqCF2 ) // MV_APURCOF = .T. pegar aliquota do MV_TXCOFIN

				If aPE[PE_MaCofDif] // //Ponto de Entrada para calculo de Cofins Apuracao com Aliquota Diferenciada
					aMaCOFDif := ExecBlock("MaCofDif",.F.,.F.,{nItem,nAliqCF2})
					If aMaCOFDif[1] == "S"
						aNfItem[nItem][IT_ALIQCF2] := aMaCOFDif[2]
					EndIf
				EndIf

				//Aliquota Majorada do COFINS, Majora a Aliquota do COFINS APURACAO qunado for Importacao. MaFisII
				If aNFItem[nItem][IT_TS][TS_ALQCMAJ] > 0 .And. aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_CLIFOR] =="F" .And. ((aNFCab[NF_TPCLIFOR] =="X" .And. Substr(aNfItem[nItem][IT_CF],1,1)=="3") .Or. aNFItem[nItem][IT_TS][TS_IMPIND] == "1") .And. aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"
					aNfitem[nItem][IT_ALIQCF2] := aNFitem[nItem][IT_ALIQCF2] + aNFItem[nItem][IT_TS][TS_ALQCMAJ]
				EndIf

				IF lDc5602
					aNfitem[nItem][IT_ALIQCF2]:= 0
				EndIF
			EndIf

			//COFINS APURACAO - BASE - IT_BASECF2
			If "BSE" $ cExecuta
				If !aNFItem[nItem][IT_TS][TS_PISCRED] $ "5" .AND. !aNfItem[nItem][IT_TIPONF]$"I|P"

					If ( nPautaSB1 == 0 .And. (Empty(aNFitem[nItem][IT_EXCECAO]) .Or. (!Empty(aNFitem[nItem][IT_EXCECAO]) .And. Empty(aNfItem[nItem][IT_EXCECAO][11])))) .Or.;
						(!Empty(aNFitem[nItem][IT_EXCECAO]) .And. Empty(aNfItem[nItem][IT_EXCECAO][11])) .Or.;
						aNfItem[nItem,IT_QUANT]==0 .Or. aSX6[MV_COFPAUT]

						If (( nPautaSB1 == 0 .And. (Empty(aNFitem[nItem][IT_EXCECAO]) .Or. (!Empty(aNFitem[nItem][IT_EXCECAO]) .And. Empty(aNfItem[nItem][IT_EXCECAO][11])))) .Or.;
							(!Empty(aNFitem[nItem][IT_EXCECAO]) .And. Empty(aNfItem[nItem][IT_EXCECAO][11]) .And. nPautaSB1 == 0) .Or.;
							(!Empty(aNFitem[nItem][IT_EXCECAO]) .And. Empty(aNfItem[nItem][IT_EXCECAO][13])) .Or. ;
							aNfItem[nItem,IT_QUANT]==0) .Or. (lCofMin)

							nBaseCF2 := aNfItem[nItem][IT_VALMERC]-IIf(aNFItem[nItem][IT_TS][TS_AGREG]$"DR",aNfItem[nItem][IT_DEDICM],0)

							//Tratamento do Agrega Valor - PIS / COF / ICMS
							nAliqAgr := 0

							If lAgregICM .And. aNFItem[nItem][IT_TS][TS_AGREG]=="I"
								If aNFItem[nItem][IT_TS][TS_ICM] == "N"
									nAliqAgr += aNfItem[nItem][IT_ALIQSOL]
									lAgreg	 := .T.
								Else
									If aNfCab[NF_PPDIFAL]
										nAliqAgr += aNfItem[nItem][IT_ALIQCMP]+aNfItem[nItem][IT_ALFCCMP]
									Else
										nAliqAgr += aNfItem[nItem][IT_ALIQICM]
									Endif
									lAgreg	 := .T.
								EndIf
							EndIf

							If aNFItem[nItem][IT_TS][TS_AGRCOF]=="C"
								nAliqAgr += aNfItem[nItem][IT_ALIQCF2]
								lAgreg	 := .T.
								If aNFItem[nItem][IT_TS][TS_AGRPIS]=="P"
									nAliqAgr += aNfItem[nItem][IT_ALIQPS2]
								Endif
							Endif

							If lAgreg

								If aSX6[MV_RNDICM]
									nBaseCF2 := Round(nBaseCF2 / ( 1 - (nAliqAgr/100)) , 2 )
								Else
									nBaseCF2 := nBaseCF2 / ( 1 - (nAliqAgr/100))
								EndIf

							Endif

							If aNFItem[nItem][IT_TS][TS_AGREG] == "I" .And. !lAgreg
								nBaseCF2 += If(aNFitem[nItem][IT_TIPONF ]<>"I",aNfItem[nItem][IT_VALICM],0)
							EndIf

							If !(aNFItem[nItem][IT_TS][TS_AGREG]=="I" .AND. lAgreg .AND. aSX6[MV_DBSTCOF]$"1|6" .AND. IntTms()) //Tratamento para não duplicar o valor do icms na base de cof
								nBaseCF2 := ( nBaseCF2 - IIf( aNFItem[nItem][IT_TS][TS_COFBRUT] == "1" , 0 , (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT]+aNfItem[nItem][IT_DS43080]) ) + aNfItem[nItem][IT_DESCZFCOF] + aNfItem[nItem][IT_DESCZFPIS] + IIf(aNfItem[nItem][IT_DESCZFCOF]<>0,0,IIF(aNFItem[nItem][IT_TS][TS_CRPRST]<>0 .And. IntTms(),aNfItem[nitem][IT_VLCSOL],aNfItem[nitem][IT_VALSOL])) )
							EndIf

							If ( !(aNfCab[NF_CLIFOR]=="C" .And. aNfCab[NF_CALCSUF]$"SI" .And. !aNFitem[nItem][IT_TIPONF ]$"BD" .And. ;
								aNFItem[nItem][IT_TS][TS_ISS] <> "S" .And. aSX6[MV_DESCZF] .And. aSX6[MV_DESZFPC] ) .And. aSX6[MV_FRTBASE] ) .Or. aSX6[MV_FRTBASE]
								nBaseCF2 += IIf(aNFItem[nItem][IT_TS][TS_DESPCOF] <> "2",aNfItem[nItem][IT_DESPESA],0) + IIF(aNFItem[nItem][IT_TS][TS_DESPCOF] <> "2",aNfItem[nItem][IT_SEGURO],0) + IIF(aNFItem[nItem][IT_TS][TS_DESPCOF] <> "2",aNfItem[nItem][IT_FRETE],0)
							EndIf

							// Campo A2_DEDBSPC em branco ou "1": segue a regra antiga (Parametro MV_DEDBCOF)
							// Processa sempre legado quando Saídas diferente de Devolucao/Benef
							If aNFCab[NF_DEDBSPC] $ " 1" .Or. (aNfCab[NF_OPERNF] == "S" .And. !aNFitem[nItem][IT_TIPONF ] $ "BD" )
							
								If aNFItem[nItem][IT_TS][TS_CREDIPI] == "N" .And. aSX6[MV_DEDBCOF]$"S,P" .AND. aNFItem[nItem][IT_TS][TS_IPI] <> "R"
									nBaseCF2 += aNfItem[nItem][IT_VALIPI]
								EndIf
								If !(aNFItem[nItem][IT_TS][TS_AGREG]$"DR")
									If aSX6[MV_DEDBCOF]$"S,I"
										nBaseCF2 -= aNfItem[nItem][IT_VALICM]
									EndIf
								EndIf
								// Caso seja comerciante atacadista, o valor do IPI deve ser retirado da base de calculo do COFINS pois esta embutido no valor da mercadoria
								If aNFItem[nItem][IT_TS][TS_CREDIPI] == "S" .And. aSX6[MV_DEDBCOF]$"S,P" .And. aNFItem[nItem][IT_TS][TS_IPI] == "R"
									nBaseCF2 -= aNfItem[nItem][IT_VALIPI]
								EndIf

							Else
								// Opcoes do aNFCab[NF_DEDBSPC]:
								// 1 - Legado - Considera as regras dos parâmetros MV_DEDBPIS e MV_DEDBCOF.
								// 2 - Deduz ICMS e IPI.
								// 3 - Deduz Apenas ICMS.
								// 4 - Deduz Apenas IPI.
								// 5 - Não Deduz Nenhum.
								// 6 - Soma IPI
								Do Case
									Case aNFCab[NF_DEDBSPC] == "2"
										nBaseCF2 -= aNfItem[nItem][IT_VALICM]
										nBaseCF2 -= aNfItem[nItem][IT_VALIPI]
									Case aNFCab[NF_DEDBSPC] == "3"
										nBaseCF2 -= aNfItem[nItem][IT_VALICM]
									Case aNFCab[NF_DEDBSPC] == "4"
										nBaseCF2 -= aNfItem[nItem][IT_VALIPI]
									Case aNFCab[NF_DEDBSPC] == "6" .And. aNfItem[nItem][IT_TS][TS_LFIPI] <> "T" .AND. aNFItem[nItem][IT_TS][TS_IPI] <> "R"
										nBaseCF2 += aNfItem[nItem][IT_VALIPI]
								EndCase
							EndIf

							//Exclui valor do Difal (EC/15) da base de cálculo de COFINS
							IF aNfItem[nItem][IT_TS][TS_DIFALPC] == '1'
								nBaseCF2 -= (aNfItem[nItem][IT_DIFAL]+aNfItem[nItem][IT_VALCMP]+aNfItem[nItem][IT_VFCPDIF])
							EndIF

							If aSX6[MV_CRDBCOF] $ "S" .And. Substr(aNfItem[nItem][IT_CF],1,1)=="3"
								nBaseCF2 += aNfItem[nItem][IT_VALICM]
							EndIf

							If aNFItem[nItem][IT_TS][TS_COFDSZF] == "2"
								nBaseCF2 += aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFCOF] + aNfItem[nItem][IT_DESCZFPIS])
							Endif

							//Tratamento para retirada do valor do ICMS solidario da base do COFINS Apuracao
							If ((MaFisDbST("CF2",nItem) .Or. (aSX6[MV_RPCBIZF] .And. aNfCab[NF_SUFRAMA])) .And. aNfItem[nItem][IT_DESCZFCOF] == 0)
								nBaseCF2 -= IIF(aNFItem[nItem][IT_TS][TS_CRPRST]<>0 .And. IntTms(),aNfItem[nitem][IT_VLCSOL],aNfItem[nitem][IT_VALSOL])
							Endif
						Else
							nBaseCF2 := IIF(lSegUndPau,ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],0,2),aNfItem[nItem,IT_QUANT])
						EndIf

						nBaseCF2 *= nFatRedCOF

						aNfItem[nItem][IT_BASECF2] := nBaseCF2

						If !aSX6[MV_RNDICM] .And. lAgreg
							MaItArred(nItem,{"IT_BASECF2"})
						EndIf

						If aNFItem[nItem][IT_TS][TS_OPERSUC]=="1" .And. aNfCab[NF_SIMPSC]<>"1" .And. aNFCab[NF_SIMPNAC]<>"1" // Operacoes com Sucata
							nBaseCF2 := (aNFitem[nItem][IT_VALICM] / ( (100-(aNFitem[nItem][IT_ALIQICM]+aNFitem[nItem][IT_ALIQPS2]+aNFitem[nItem][IT_ALIQCF2]))/100 ) )
							aNfItem[nItem][IT_BASECF2] := nBaseCF2
						Endif
					Else
						//Calculo da BASE COFINS APURACAO pela PAUTA do SB1 ou EXCECAO
						If (Empty(aNFitem[nItem,IT_EXCECAO]) .Or. Empty(aNFItem[nItem,IT_EXCECAO,11]))
							nBaseCF2 := IIF(lSegUndPau,ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],0,2),aNfItem[nItem,IT_QUANT]) * nPautaSB1
							aNfItem[nItem][IT_PAUTCOF]	:= nPautaSB1
						Else
							nBaseCF2 := aNfItem[nItem,IT_QUANT] * aNFItem[nItem,IT_EXCECAO,11]
							aNfItem[nItem][IT_PAUTCOF]	:= aNFItem[nItem,IT_EXCECAO,11]
						EndIf
						aNfItem[nItem][IT_BASECF2] := nBaseCF2
					EndIf
					//Zera a BASE do COFINS APURACAO somente quando a aliquota for = 0 e o CSTCOF  NAO for = "04#06#73"
					If Empty( aNfItem[nItem][IT_ALIQCF2] ) .And. ((aPE[PE_MACSTPICO] .And. !ExecBlock("MaCstPiCo",.F.,.F.,{nItem,aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_TES],aNfCab[NF_CLIFOR],aNfCab[NF_CODCLIFOR],aNfCab[NF_LOJA],aNfCab[NF_OPERNF]})[2]$"04#06#73") .Or. (!aPE[PE_MACSTPICO] .And. !aNFItem[nItem][IT_TS][TS_CSTCOF] $"04#06#73")) .AND. !lDc5602 .And. !lZFMAlqZ
						aNfItem[nItem][IT_BASECF2] := 0
					EndIf

				Else
					aNfItem[nItem][IT_BASECF2] := 0
				EndIf

				//Especifico para VEICULOS
				If cPaisLoc == "BRA" .And. aSX6[MV_CALCVEI] .And. "CF2" $ cTipo .And. aNfCab[NF_OPERNF] == "S" .And. aPos[FP_B1_CHASSI] .And. !Empty( aNfItem[nItem][IT_PRD][SB_CHASSI] ) // Alteracao de base para veiculos usados
					If aNfItem[nItem][IT_BASVEIC] == 0
						aAreaSC6 := SC6->(GetArea())
						SC6->(dbSetOrder(1))
						If SC6->( MsSeek(xFilial("SC6")+aNfCab[NF_PEDIDO]+aNfItem[nItem][IT_ITEM]+aNfItem[nItem][IT_PRODUTO]) )
							aNfItem[nItem][IT_BASVEIC] := SC6->C6_BASVEIC
						EndIf
						RestArea(aAreaSC6)
					EndIf
					aNfItem[nItem][IT_BASECF2] -= aNfItem[nItem][IT_BASVEIC]
					If aNfItem[nItem][IT_BASECF2] < 0
						aNfItem[nItem][IT_BASECF2] := 0
					EndIF
				EndIf

			EndIf

			//Define o Valor do COFINS MAJORADO conforme aliquota informada na TES.
			If aNFItem[nItem][IT_TS][TS_ALQCMAJ] > 0
				aNfItem[nItem][IT_VALCMAJ] := aNfItem[nItem][IT_BASECF2] * (aNFItem[nItem][IT_TS][TS_ALQCMAJ]/100)
			EndIf

			//COFINS APURACAO - VALOR - IT_VALCF2
			If "VLR" $ cExecuta
				If (nPautaSB1 == 0 .And. (Empty(aNFitem[nItem][IT_EXCECAO]) .Or. (!Empty(aNFitem[nItem][IT_EXCECAO]) .And. Empty(aNfItem[nItem][IT_EXCECAO][11])))) .Or.;
					aNfItem[nItem,IT_QUANT]==0 .Or. !aSX6[MV_PISPAUT]
					aNfItem[nItem][IT_VALCF2] := aNfItem[nItem][IT_BASECF2]*aNfItem[nItem][IT_ALIQCF2]/100
				Else
					//COFINS APURACAO - Aplica PAUTA SB1 ou Excecao
					If aNfItem[nItem][IT_BASECF2] <> 0
						If Empty(aNFitem[nItem,IT_EXCECAO]) .Or. (Empty(aNFItem[nItem,IT_EXCECAO,11]) .And. Empty(aNFItem[nItem,IT_EXCECAO,13]))
							IF lCofMin

								nVlOprCof	:= aNfItem[nItem][IT_BASECF2]*aNfItem[nItem][IT_ALIQCF2]/100
								nVlPautCof	:= IIF(lSegUndPau .And. aNfItem[nItem][IT_PRD][SB_CONV] > 0,ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],0,2),aNfItem[nItem,IT_QUANT]) * nPautaSB1

								IF nVlOprCof < nVlPautCof
									aNfItem[nItem][IT_BASECF2] := IIF(lSegUndPau .And. aNfItem[nItem][IT_PRD][SB_CONV] > 0,ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],0,2),aNfItem[nItem,IT_QUANT])
									aNfItem[nItem][IT_ALIQCF2] := nPautaSB1
									aNfItem[nItem][IT_VALCF2]  := aNfItem[nItem][IT_BASECF2] * aNfItem[nItem][IT_ALIQCF2]
									aNfItem[nItem][IT_PAUTCOF] := nPautaSB1

									/*Se efetuou o cálculo por pauta e o CST não for 03, forço o 03*/
									IF aNFItem[nItem][IT_TS][TS_CSTCOF] <> '03' .And. aNfCab[NF_OPERNF] == "S"
										aNFItem[nItem][IT_TS][TS_CSTCOF] := '03'
									ENDIF
									aNFItem[nItem][IT_PAUTACF] := .T.
								ELSE
									aNfItem[nItem][IT_VALCF2]  := 	nVlOprCof
									aNfItem[nItem][IT_PAUTCOF] := 0
									aNFItem[nItem][IT_PAUTACF] := .F.
									// Quando CST não mudar para 03 não ira gravar tabela da receita
									aNfItem[nItem][IT_TABNTRE] := ""
									aNfItem[nItem][IT_CODNTRE] := ""
									aNfItem[nItem][IT_GRPNTRE] := ""
									aNfItem[nItem][IT_DATNTRE] := cTod("//")
								ENDIF
							ELSE
								aNfItem[nItem][IT_BASECF2] := IIF(lSegUndPau,ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],0,2),aNfItem[nItem,IT_QUANT])
								aNfItem[nItem][IT_ALIQCF2] := nPautaSB1
								aNfItem[nItem][IT_VALCF2]  := aNfItem[nItem][IT_BASECF2] * aNfItem[nItem][IT_ALIQCF2]
								aNfItem[nItem][IT_PAUTCOF] := nPautaSB1
								aNFItem[nItem][IT_PAUTACF] := .T.
							ENDIF
						Else
							IF lCofMin

								nVlOprCof	:= aNfItem[nItem][IT_BASECF2]*aNfItem[nItem][IT_ALIQCF2]/100
								nVlPautCof	:= IIF(lSegUndPau .And. aNfItem[nItem][IT_PRD][SB_CONV] > 0,ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],0,2),aNfItem[nItem,IT_QUANT]) * aNFItem[nItem,IT_EXCECAO,11]

								IF nVlOprCof < nVlPautCof
									aNfItem[nItem][IT_BASECF2] := IIF(lSegUndPau .And. aNfItem[nItem][IT_PRD][SB_CONV] > 0,ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],0,2),aNfItem[nItem,IT_QUANT])
									aNfItem[nItem][IT_ALIQCF2] := aNFItem[nItem,IT_EXCECAO,11]
									aNfItem[nItem][IT_VALCF2]  := aNfItem[nItem][IT_BASECF2] * aNfItem[nItem][IT_ALIQCF2]
									aNfItem[nItem][IT_PAUTCOF] := aNFItem[nItem,IT_EXCECAO,11]

									/*Se efetuou o cálculo por pauta e o CST não for 03, forço o 03 - OPERACAO TRIBUTAVEL (ALIQUOTA POR UNIDADE DE PRODUTO)  */
									IF aNFItem[nItem][IT_TS][TS_CSTCOF] <> '03' .And. aNfCab[NF_OPERNF] == "S"
										aNFItem[nItem][IT_TS][TS_CSTCOF] := '03'
									ENDIF
									aNFItem[nItem][IT_PAUTACF] := .T.
								ELSE
									aNfItem[nItem][IT_VALCF2]  := aNfItem[nItem][IT_BASECF2]*aNfItem[nItem][IT_ALIQCF2]/100
									aNfItem[nItem][IT_PAUTCOF] := 0
									aNFItem[nItem][IT_PAUTACF] := .F.
									// Quando CST não mudar para 03 não ira gravar tabela da receita
									aNfItem[nItem][IT_TABNTRE] := ""
									aNfItem[nItem][IT_CODNTRE] := ""
									aNfItem[nItem][IT_GRPNTRE] := ""
									aNfItem[nItem][IT_DATNTRE] := cTod("//")
								ENDIF
							ElseIf !Empty(aNFitem[nItem,IT_EXCECAO]) .And. !Empty(aNFItem[nItem,IT_EXCECAO,13])
								aNfItem[nItem][IT_BASECF2] := aNfItem[nItem][IT_VALMERC]-IIf(aNFItem[nItem][IT_TS][TS_AGREG]$"DR",aNfItem[nItem][IT_DEDICM],0)
								aNfItem[nItem][IT_ALIQCF2] := aNFItem[nItem,IT_EXCECAO,13]
								aNfItem[nItem][IT_VALCF2]  := aNfItem[nItem][IT_BASECF2] * aNfItem[nItem][IT_ALIQCF2] /100
								aNfItem[nItem][IT_PAUTCOF] := aNFItem[nItem,IT_EXCECAO,11]
								aNFItem[nItem][IT_PAUTACF] := .F.
							ELSE
								aNfItem[nItem][IT_BASECF2] := IIF(lSegUndPau,ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],0,2),aNfItem[nItem,IT_QUANT])
								aNfItem[nItem][IT_ALIQCF2] := aNFItem[nItem,IT_EXCECAO,11]
								aNfItem[nItem][IT_VALCF2]  := aNfItem[nItem][IT_BASECF2] * aNfItem[nItem][IT_ALIQCF2]
								aNfItem[nItem][IT_PAUTCOF] := aNFItem[nItem,IT_EXCECAO,11]
								aNFItem[nItem][IT_PAUTACF] := .T.
							ENDIF
						EndIf
					EndIf
				EndIf

				If aNFItem[nItem][IT_TS][TS_AGRCOF]=="C"
					aNfItem[nItem][IT_VALCF2] := Round(aNfItem[nItem][IT_VALCF2],2)
				EndIf

				//DESCONTO SUFRAMA - COFINS APURACAO
				If !lZFMAlqZ .And. aNfCab[NF_CLIFOR]=="C" .And. !aNfCab[NF_CALCSUF]$"IN " .And. !aNFitem[nItem][IT_TIPONF ]$"BD" .And. ;
					aNFItem[nItem][IT_TS][TS_ISS] <> "S" .And. aSX6[MV_DESCZF] .And. aSX6[MV_DESZFPC] .And. ( aNFItem[nItem][IT_TS][TS_PISCRED]$"134" )

					If ( aPE[PE_MACSTPICO] .And. ExecBlock("MaCstPiCo",.f.,.f.,{nItem,aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_TES],aNfCab[NF_CLIFOR],aNfCab[NF_CODCLIFOR],aNfCab[NF_LOJA],aNfCab[NF_OPERNF]})[2]$"04#06#73") .Or. ( !aPE[PE_MACSTPICO] .And. aNFItem[nItem][IT_TS][TS_CSTCOF] $"04#06#73")
						If aNfItem[nItem][IT_PAUTCOF] == 0
							If aNfItem[nItem][IT_DESCZFCOF] == 0
								aNfItem[nItem][IT_VALCF2]:= aNfItem[nItem][IT_BASECF2] * nAliqBase / 100
							Else
								aNfItem[nItem][IT_VALCF2]:= aNfItem[nItem][IT_DESCZFCOF]
							Endif
						Else
							aNfItem[nItem][IT_VALCF2] := aNfItem[nItem][IT_BASECF2]
						EndIf
					Endif

					MaItArred(nItem,{"IT_DESCZFCOF"})
					aNfItem[nItem][IT_DESCZF] -= aNfItem[nItem][IT_DESCZFCOF]

					If aNfCab[NF_ROTINA] $ "MATA461|FATA701" .Or. FunName()=="MATA920"
						MaItArred(nItem,{"IT_VALCF2"})
						aNfItem[nItem][IT_VALMERC]+= aNfItem[nItem][IT_DESCZFCOF]
						aNfItem[nItem][IT_VALMERC]-= aNfItem[nItem][IT_VALCF2]
						If FunName()=="MATA920"
							aNfItem[nItem][IT_PRCUNI] := aNfItem[nItem][IT_VALMERC]/aNfItem[nItem][IT_QUANT]
						Elseif FunName() $ "MATA461|MATA460A|FATA701"
							aNfItem[nItem][IT_PRCUNI] := (aNfItem[nItem][IT_VALMERC]- (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT]) + aNfItem[nItem][IT_ACRESCI] )/aNfItem[nItem][IT_QUANT]
						EndIf
					EndIf
					aNfItem[nItem][IT_DESCZFCOF]:= aNfItem[nItem][IT_VALCF2]
					MaItArred(nItem,{"IT_DESCZFCOF"})
					aNfItem[nItem][IT_DESCZF]   += aNfItem[nItem][IT_DESCZFCOF]
					aNfItem[nItem][IT_VALCF2]   := 0
					If aNFItem[nItem][IT_TS][TS_PSCFST] == "1" .And. !aNFItem[nItem][IT_TS][TS_CSTCOF] $"04#06#73"
						aNfItem[nItem][IT_BASECF2]  := 0
					EndIf
				EndIf

				MaItArred(nItem,{"IT_VALCF2"})
			Endif
			If "CF2" $ cTipo
				If aPE[PE_MACOFVEIC] // ATENCAO!!! Ponto de entrada para uso exclusivo da TOTVS, nao sugerir o uso do mesmo a clientes - GDP FISCAL
					aMaCOFVeic := ExecBlock("MaCOFVeic",.F.,.F.,{nItem,aNfItem[nItem][IT_BASECF2],aNfItem[nItem][IT_ALIQCF2],aNfItem[nItem][IT_VALCF2]})
					aNfItem[nItem][IT_BASECF2] := aMaCOFVeic[1]
					aNfItem[nItem][IT_ALIQCF2] := aMaCOFVeic[2]
					aNfItem[nItem][IT_VALCF2]  := aMaCOFVeic[3]
				EndIf
			Endif
		Else
			If "BSE" $ cExecuta
				aNfItem[nItem][IT_BASECF2]:= 0
			EndIf
			If "VLR" $ cExecuta
				aNfItem[nItem][IT_VALCF2] := 0
			EndIf
			If "ALQ" $ cExecuta
				aNfItem[nItem][IT_ALIQCF2]:= 0
			EndIf
		EndIf
	EndIf

	// Se for reprocessamento restauro a base, aliquota e valor originais.
	If lReproc
		aNfItem[nItem][IT_BASECF2] := nBaseOri
		aNfItem[nItem][IT_ALIQCF2] := nAliqOri
		aNfItem[nItem][IT_VALCF2] := nValOri
		aNfItem[nItem][IT_VALCMAJ] := nMajOri
	EndIf

EndIf

//COFINS RETENCAO - IT_BASECOF / IT_ALIQCOF / IT_VALCOF
If "COF" $ cTipo
	//Define a Aliquota do COFINS RETENCAO - IT_ALIQCOF
	If "ALQ" $ cExecuta
		If Empty(nAliqSB1) .Or. aSX6[MV_TPALCOF] == "1"
			If !Empty(aNfCab[NF_NATUREZA]) .And. aInfNat[NT_CALCCOF] == "S" .And. !Empty(aInfNat[NT_PERCCOF])

				nAliqCOF :=  aInfNat[NT_PERCCOF]

				If nModulo == 43 .And. SA1->A1_TPESSOA == "EP" // Para o Tipo de Cliente 'Empresa Publica',quando transporte for Internacional,nao gerar a retencao de PIS/COFINS -- BOPS 153148
					aAreaSA1 := SA1->(GetArea())
					SA1->(dbSetOrder(1))
					If SA1->(msSeek(xFilial("SA1")+SF2->F2_CLIENT+SF2->F2_LOJENT)) .And. SA1->A1_EST == "EX"
						nAliqCOF := 0
					EndIf
					RestArea(aAreaSA1)
				EndIf

			EndIf
			If aPE[PE_MACALCCOF]
				If aMaCalcCOF[1] == "S" .And. !Empty(aMaCalcCOF[2])
					nAliqCOF := aMaCalcCOF[2]
				EndIf
			EndIf
		EndIf
		aNfItem[nItem][IT_ALIQCOF]	:= nAliqCOF
	Endif

	//Calculo de BASE e VALOR do COFINS RETENCAO - IT_BASECOF e IT_VALCOF
	If "BSE" $ cExecuta .Or. "VLR" $ cExecuta
		If ( aPE[PE_MACALCCOF] .And. aMaCalcCOF[1]=="S" ) .Or. ( !Empty(aNfCab[NF_NATUREZA]) .And. aInfNat[NT_CALCCOF]=="S" ;
			.And. aNfCab[NF_RECCOFI] $ "S|P" .And. ( aNfItem[nItem][IT_PRD][SB_COFINS] == "1" .Or. aNfCab[NF_RECCOFI] == "P" ) )
			// A base de calculo da retencao eh o valor da duplicata
			// porem de acordo com a Cons. Trib. Liz, o valor do ISS nao
			// devera ser deduzido da base do PIS/COF/CSL retencao. Para
			// isso foi criado o parametro MV_DEISSBS que se estiver como
			// .T. nao sera descontado e se estiver como .F. - default sera
			nDescISS := Iif( aSX6[MV_DEISSBS] .And. aNfCab[NF_RECISS]=="1" .And. aSX6[MV_DESCISS] .And. aNfCab[NF_OPERNF]=="S" .And. aSX6[MV_TPABISS]=="1",aNfItem[nItem][IT_VALISS],0)
			nBaseCOF := aNfItem[nItem,IT_BASEDUP] + IIf( aSX6[MV_COFBRU] == "1" , (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT]) , 0 ) + nDescISS

			// Retirado:
			// 		Inciso II, paragrafo 2º, artigo 1º da Lei 10845/02
			//		Issue - DSERFIS2-386
			If aNfItem[nItem][IT_TS][TS_APLREPC]$"23"
				nBaseCOF *= nFatRedCOF
			EndIf

			//Tratamento extraido da funcao MaFisVTot para saber se foi contemplado o VALOR DE IPI na base da duplicata para que eu possa subtrair
			If (aNFItem[nItem][IT_TS][TS_IPIPC]=="2") .And. (aNFitem[nItem][IT_TIPONF]=="P" .Or. aNFItem[nItem][IT_TS][TS_IPI]<>'R')
				nBaseCOF -= aNfItem[nItem][IT_VALIPI]
			EndIf
			If aSX6[MV_CRDBCOF] $ "S" .And. Substr(aNfItem[nItem][IT_CF],1,1)=="3"
				nBaseCOF += aNfItem[nItem][IT_VALICM]
			EndIf

			// Tratamento para retirada do valor do ICMS solidario da base do COFINS Retencao
			If MaFisDbST("COF",nItem).And. aNfItem[nItem][IT_DESCZFCOF] == 0
				nBaseCOF -= aNfItem[nitem][IT_VALSOL]
			Endif

			//Quando operação de entrada com diferimento para orgão Publico, base de retenção deve ser sobre total da nota.
			If aTes[TS_PICMDIF]<>0 .And. aTes[TS_ICMSDIF]$" ,1,2" .And. aTes[TS_ICM] == "S"
				nBaseCOF += aNfItem[nItem][IT_ICMSDIF]
			EndIf

			If "BSE" $ cExecuta
				aNfItem[nItem][IT_BASECOF]:= nBaseCOF
			Endif
			If  "VLR" $ cExecuta
				aNfItem[nItem][IT_VALCOF] := aNfItem[nItem][IT_BASECOF] * aNfItem[nItem][IT_ALIQCOF] / 100
			Endif
			If aNfItem[nItem][IT_PRD][SB_RETOPER] == "1" .And. !aNfCab[NF_RECCOFI] == "N" //Item classificado na Medida Provisoria 252 Junho/2005 e nao aguardar o limite imposto pela Lei 10.925 (R$ 5.000,00) autopecas
				aNfItem[nItem][IT_COF252] := aNfItem[nItem][IT_VALCOF]
			Endif

		Else
			If "BSE" $ cExecuta
				aNfItem[nItem][IT_BASECOF]:= 0
			EndIf
			If "VLR" $ cExecuta
				aNfItem[nItem][IT_VALCOF] := 0
			EndIf
		EndIf
	EndIf
	MaItArred(nItem,{"IT_VALCOF"})
EndIf
//Calcula COFINS-ST   Base  Aliquota e Valor - IT_BASECF3 - IT_ALIQCF3 - IT_VALCF3
If "CF3" $ cTipo
	If aNFItem[nItem][IT_TS][TS_PSCFST] $ "1/3"
		//Conforme IN SRF 594 de 2005, nao devem integrar a base de calculo do PIS/COFINS ST:
		//- Receitas isentas e as decorrentes de vendas a aliquota 0
		//- Vendas canceladas
		//- Descontos incondicionais
		//- IPI
		//- ICMS ST
		If aNFItem[nItem][IT_TS][TS_IPIPC] == "2" //Somente retiro aqui o valor do PS3 e CF3 caso o campo IPIPC estiver como 2, pois se estiver como 1 já estou retirando os valores no momento de compor o IT_TOTAL
			nBaseCF3 := aNfItem[nItem][IT_TOTAL] //- ((aNfItem[nItem][IT_VALPS3]) + aNfItem[nItem][IT_VALCF3])
			nBaseCF3 -= aNfItem[nItem][IT_VALIPI] //Conforme IN SRF546/2005 o valor do IPI deve integrar a base calculo PIS/COFINS ST-Zona Franca de Manaus

			If !(aNFItem[nItem][IT_TS][TS_INCSOL]$"A,N,D") // Verifica se o valor do ICMS Solidario esta agregado ao valor total
				nBaseCF3 -= aNfItem[nItem][IT_VALSOL]
			Endif
		Else
			nBaseCF3 := aNfItem[nItem][IT_VALMERC] + aNfItem[nItem][IT_VALIPI]
		Endif
		If ( !(aNfCab[NF_CLIFOR]=="C" .And. aNfCab[NF_CALCSUF]$"SI" .And. !aNFitem[nItem][IT_TIPONF ]$"BD" .And. ;
				aNFItem[nItem][IT_TS][TS_ISS] <> "S" .And. aSX6[MV_DESCZF] .And. aSX6[MV_DESZFPC] ) .And. aSX6[MV_FRTBASE] ) .Or. aSX6[MV_FRTBASE]
				nBaseCF3 += IIf(aNFItem[nItem][IT_TS][TS_DESPCOF] <> "2",aNfItem[nItem][IT_DESPESA],0) + IIF(aNFItem[nItem][IT_TS][TS_DESPCOF] <> "2",aNfItem[nItem][IT_SEGURO],0) + IIF(aNFItem[nItem][IT_TS][TS_DESPCOF] <> "2",aNfItem[nItem][IT_FRETE],0)
		EndIf
		If aNFCab[NF_CLIFOR] == "C" .And. aNFCab[NF_TIPONF] $ "DB" .And. !aNfItem[nItem][IT_TIPONF]$"I|P" .And. aSX6[MV_DESCZF] .And. aSX6[MV_DESZFPC]
			If aNFItem[nItem][IT_TS][TS_PISCRED] <> "3" .And. aNFItem[nItem][IT_TS][TS_PISCOF]$"13" .And. !aNfCab[NF_CALCSUF]$"IN "
				nBaseCF3 -= (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT])
			ElseIf aNFItem[nItem][IT_TS][TS_PISCRED] == "3" .And. aNFItem[nItem][IT_TS][TS_PISCOF]$"4" .And. aNfCab[NF_CALCSUF]$"I"
				nBaseCF3 -= (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT])
			EndIf
		Else
			If aNFItem[nItem][IT_TS][TS_PISCRED] <> "3" .And. aNFItem[nItem][IT_TS][TS_PISCOF]$"13" .And. aNFItem[nItem][IT_TS][TS_COFBRUT] == '2' .And. aNFItem[nItem][IT_TS][TS_IPIPC] <> '2'
				nBaseCF3 -= (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT]+aNfItem[nItem][IT_DS43080])
			EndIf
		EndIf

		If aNFItem[nItem][IT_TS][TS_COFDSZF] == "2"
			nBaseCF3 += aNfItem[nItem][IT_DESCZF]
		EndIf

		nBaseCF3 *= nFatRedCOF
		//Se usuario informou percentual de Substituicao Tributaria de cigarro, ira multiplicar a base de calculo pelo percentual
		If Len(Alltrim(aSX6[MV_PUPCCST])) > 0 .And. aPos[FP_B1_PUPCCST]
			nVlUnitCig := aNfItem[nItem][IT_PRD][SB_PUPCCST] // Campo onde e informado o valor unitario para calcular valor de PIS ST.
		EndIF
		If !Empty(aNFitem[nItem][IT_EXCECAO])
			If aNfItem[nItem,IT_EXCECAO,25] > 0
				nVlUnitCig	:= aNfItem[nItem,IT_EXCECAO,25]
				aNfItem[nItem][IT_PRCUNIC] := nVlUnitCig
			Endif
		Endif
		If Len(AllTrim(aSX6[MV_B1CCFST])) > 0 .And. aPos[FP_B1_B1CCFST]
			aNfItem[nItem][IT_COECFST] := aNfItem[nItem][IT_PRD][SB_B1CCFST] // Campo onde e informado o % de Substituição tributaria da COFINS para fabrincante de cigarros.
		EndIf
		If nVlUnitCig > 0
			If aNfItem[nItem][IT_COECFST] > 0
				nBaseCF3 := ( aNfItem[nItem][IT_QUANT] * nVlUnitCig ) * aNfItem[nItem][IT_COECFST]
			Else
				nBaseCF3 := aNfItem[nItem][IT_QUANT] * nVlUnitCig
			EndIf
		EndIF
		If aNFCab[NF_TIPONF]$"D" .And. !Empty(aNFItem[nItem][IT_RECORI]) .And. aNFCab[NF_CLIFOR] == "C"
			SD2->( MsGoto( aNFItem[nItem][IT_RECORI] ) )
			nBaseCF3 := aNfItem[nItem][IT_QUANT] * SD2->D2_BASECF3 / SD2->D2_QUANT
		EndIF
		If "BSE" $ cExecuta
			aNfItem[nItem][IT_BASECF3] := nBaseCF3
		Endif
		If "ALQ" $ cExecuta
			IF aNFItem[nItem][IT_TS][TS_PSCFST] == "3" // 3= Aliq. Zero
				nAliqCF3 := 0
			Elseif Len(Alltrim(aSX6[MV_B1COFST])) > 0 .And. aNfItem[nItem][IT_PRD][SB_B1COFST] > 0 	//Verifica Campo criado na SB1
				nAliqCF3 := aNfItem[nItem][IT_PRD][SB_B1COFST]
			ElseIF aSX6[MV_TXCOFST] > 0  // Verifica aliquota parametro
				nAliqCF3 := aSX6[MV_TXCOFST]
			Endif
			aNfItem[nItem][IT_ALIQCF3] := nAliqCF3
		Endif
		If "VLR" $ cExecuta
			aNfItem[nItem][IT_VALCF3]  := aNfItem[nItem][IT_BASECF3]*aNfItem[nItem][IT_ALIQCF3]/100
		Endif
	Else
		If "BSE" $ cExecuta
			aNfItem[nItem][IT_BASECF3] := 0
		EndIf
		If "ALQ" $ cExecuta
			aNfItem[nItem][IT_ALIQCF3] := 0
		EndIf
		If "VLR" $ cExecuta
			aNfItem[nItem][IT_VALCF3]  := 0
		EndIf
	EndIf
	MaItArred(nItem,{"IT_VALCF3"})
EndIf

If aSX6[MV_PCFATPC] .And. aNfCab[NF_OPERNF] == "S" .And. !Empty(aNfCab[NF_CLIEFAT])
	aNFitem[nItem][IT_EXCECAO] 	:= aExcecao
	aNfCab[NF_NATUREZA] 		:= cNatureza
EndIf

Return

/*MaFisCSLL-Alexandre Lemes -01/10/2012
Calculo do CSLL
*/
Static Function MaFisCSLL(nItem,cExecuta)

Local aMaCalcCSL := IIf( aPE[PE_MACALCCSL] , ExecBlock("MaCalcCSL") , Array(2) )
Local nAliqSB1   := aNfItem[nItem][IT_PRD][SB_PCSLL]
Local nAliquota  := IIf(Empty(nAliqSB1),aSX6[MV_TXCSLL],nAliqSB1)
Local nDesconto  := 0
Local nDescISS	 := 0

DEFAULT cExecuta  := "BSE|ALQ|VLR"
//Define Base CSLL
If "BSE" $ cExecuta
	If (( aPE[PE_MACALCCSL] .And. aMaCalcCSL[1]=="S" ) .Or. ( !Empty(aNfCab[NF_NATUREZA]) .And. aInfNat[NT_CALCCSL]=="S" )) .And.;
		( aNfCab[NF_RECCSLL] $ "S|P" ) .And. ( aNfItem[nItem][IT_PRD][SB_CSLL] == " " .Or. aNfItem[nItem][IT_PRD][SB_CSLL] == "1" .Or. aNfCab[NF_RECCSLL] == "P" )
		// A base de calculo da retencao eh o valor da duplicata
		// porem de acordo com a Cons. Trib. Liz, o valor do ISS nao
		// devera ser deduzido da base do PIS/COF/CSL retencao. Para
		// isso foi criado o parametro MV_DEISSBS que se estiver como
		// .T. nao sera descontado e se estiver como .F. - default sera
		nDescISS := IIf(aSX6[MV_DEISSBS] .And. aNfCab[NF_RECISS]=="1" .And. aSX6[MV_DESCISS] .And. aNfCab[NF_OPERNF]=="S" .And. aSX6[MV_TPABISS]=="1", aNfItem[nItem][IT_VALISS] , 0 )
		nDesconto:= IIf(aSX6[MV_CSLLBRU] == "1" , (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT]) , 0) // Caso o parametro indique a base de calculo pelo valor bruto da nota fiscal somar o valor do desconto concedido ao total da duplicata.

		aNfItem[nItem][IT_BASECSL] := aNfItem[nItem,IT_BASEDUP] + IIf( aNfItem[nItem,IT_BASEDUP] > 0 , nDesconto , 0 ) + nDescISS

		If aNFItem[nItem][IT_TS][TS_IPIPC]=="2" 	// Indica se o valor do IPI deve compor a base de calculo. 1=Sim (Compoe) e 2=Nao(Nao Compoe)
			aNfItem[nItem][IT_BASECSL] -= aNfItem[nItem][IT_VALIPI]
		Endif

		// Tratamento para retirada do valor do ICMS solidario da base do CSLL
		// Verifica se o valor do ICMS Solidario esta agregado ao valor total
		If !(aNFItem[nItem][IT_TS][TS_INCSOL]$"A,N,D") .And. MaFisDbST("CSL",nItem)
			aNfItem[nItem][IT_BASECSL] -= aNfItem[nItem][IT_VALSOL]
		Endif

		If aNFItem[nItem][IT_TS][TS_DBSTCSL] == "1" .And. aNFCab[NF_OPIRRF] == "EP" // Agrega o Valor do ICMS Retido - Somente para Empresa Publica
			aNfItem[nItem][IT_BASECSL] += aNfItem[nItem][IT_VALSOL]
		Endif

		//Quando operação de entrada com diferimento para orgão Publico, base de retenção deve ser sobre total da nota.
		If aTes[TS_PICMDIF]<>0 .And. aTes[TS_ICMSDIF]$" ,1,2" .And. aTes[TS_ICM] == "S"
			aNfItem[nItem][IT_BASECSL] += aNfItem[nItem][IT_ICMSDIF]
		EndIf

	Else
		aNfItem[nItem][IT_BASECSL] := 0
	EndIf
EndIf
//Define Aliquota CSLL
If "ALQ" $ cExecuta
	If Empty(nAliqSB1) .Or. aSX6[MV_TPALCSL]== "1"
		If !Empty(aNfCab[NF_NATUREZA]) .And. aInfNat[NT_CALCCSL]=="S" .And. !Empty(aInfNat[NT_PERCCSL])
			nAliquota :=  aInfNat[NT_PERCCSL]
		EndIf

		If aPE[PE_MACALCCSL]
			If aMaCalcCSL[1]=="S" .And. !Empty(aMaCalcCSL[2])
				nAliquota := aMaCalcCSL[2]
			EndIf
		EndIf
	EndIf
	aNfItem[nItem][IT_ALIQCSL]	:= nAliquota
EndIf

//Define Valor CSLL
If "VLR" $ cExecuta
	If ( aPE[PE_MACALCCSL] .And. aMaCalcCSL[1] == "S" ) .Or. ( !Empty(aNfCab[NF_NATUREZA]) .And. aInfNat[NT_CALCCSL] == "S" )
		aNfItem[nItem][IT_VALCSL] := aNfItem[nItem][IT_BASECSL]*aNfItem[nItem][IT_ALIQCSL]/100
	Else
		aNfItem[nItem][IT_VALCSL] := 0
	EndIf

	MaItArred(nItem,{"IT_VALCSL"})
EndIf

Return

/*
MaFisII  - Cleber Stenio Santos - 23.03.2009
Calcula PIS/COFINS Importação conforme fórmula IN SRF 572/05
*/
Static Function MaFisII(nItem,cCampo)
Local nBsICMFic := 0 //Base ICMS Ficticio para calculo do PIS/COFINS
Local nVlICMFic := 0 //ICMS Ficticio para calculo do PIS/COFINS
Local nIN572x   := 0 //Fórmula x para o cálculo da IN572 considerando IPI Percentual
Local nAliqII   := 0 //Aliquota Imposto Importacao
Local nAliqIPI  := 0 //Aliquota IPI
Local nAliqPIS  := 0 //Aliquota PIS
Local nAliqCOF  := 0 //Aliquota Cofins
Local nAliqICM  := 0 //Aliquota ICMS
Local nBsPISImp := 0 //Base PIS Importacao
Local nBsCOFImp := 0 //Base COFINS Importacao
Local nVlPISImp := 0 //Valor PIS Importacao
Local nVlCOFImp := 0 //Valor COFINS Importacao
Local nVlAduan  := 0 //Valor Aduaneiro
Local nIN572y   := 0 //Fórmula y para o cálculo da IN572 considerando IPI Pauta
Local nIN572w   := 0 //Fórmula w para o cálculo da IN572 considerando IPI Pauta
Local nIN572s   := 0 // Formula de Calculo de Importação de servico
Local nAliqICMNF:= 0 //Aliquota original do ICMS da NF
Local cImpServ	:= "N"
Local nValMaj   := 0
Local nDifVal   := 0
Local nRedPis   := 0
Local nRedCof   := 0

DEFAULT cCampo := ""

If aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_CLIFOR] =="F" .And. aNFCab[NF_TPCLIFOR] =="X" .And. Substr(aNfItem[nItem][IT_CF],1,1)=="3" .And. aNFItem[nItem][IT_TS][TS_INTBSIC]$"123"
	IF !Empty(aNfItem[nItem][IT_CODISS]) .And. (aNFItem[nItem][IT_TS][TS_ICM]=="N") .And. (aNFItem[nItem][IT_TS][TS_LFICM] == "N") .And. (aNFItem[nItem][IT_TS][TS_IPI]=="N") .And. (aNFItem[nItem][IT_TS][TS_LFIPI]=="N")  .And. (aNFItem[nItem][IT_TS][TS_ISS] == "S")
		cImpServ := "S"
 	EndIf

   //Redução de Pis
   //Produto
   nRedPis := IIf( aNfItem[nItem][IT_PRD][SB_REDPIS] > 0 , aNfItem[nItem][IT_PRD][SB_REDPIS] , nRedPis )
   //Tes. Caso não tenha mantém da variável nRedPis já preenchida anteriormente
   nRedPis :=  IIf( aNFItem[nItem][IT_TS][TS_BASEPIS] > 0 , aNFItem[nItem][IT_TS][TS_BASEPIS] , nRedPis )
   //Exceção Fiscal. Caso não tenha mantém da variável nRedPis já preenchida anteriormente
   nRedPis :=  IIf( !Empty(aNFitem[nItem][IT_EXCECAO]) .And. aNfItem[nItem,IT_EXCECAO,18] > 0 , aNfItem[nItem,IT_EXCECAO,18] , nRedPis )

   nRedPis  := IIf( nRedPis == 0, 1, (1 - (nRedPis/100)) )

   //Redução de Cofins
   //Produto
   nRedCof := IIf( aNfItem[nItem][IT_PRD][SB_REDCOF] > 0 , aNfItem[nItem][IT_PRD][SB_REDCOF] , nRedCof )
   //Tes. Caso não tenha mantém da variável nRedCof já preenchida anteriormente
   nRedCof :=  IIf( aNFItem[nItem][IT_TS][TS_BASECOF] > 0 , aNFItem[nItem][IT_TS][TS_BASECOF] , nRedCof )
   //Exceção Fiscal. Caso não tenha mantém da variável nRedCof já preenchida anteriormente
   nRedCof :=  IIf( !Empty(aNFitem[nItem][IT_EXCECAO]) .And. aNfItem[nItem,IT_EXCECAO,19] > 0 , aNfItem[nItem,IT_EXCECAO,19] , nRedCof )

   nRedCof  := IIf( nRedCof == 0, 1, (1 - (nRedCof/100)) )

	nAliqII   := aNfItem[nItem][IT_ALIQII]/100
	nAliqIPI  := aNFitem[nItem][IT_ALIQIPI]/100

	If aNFItem[nItem][IT_TS][TS_PISCOF] == "1"
		nAliqPIS  := aNFitem[nItem][IT_ALIQPS2]/100
	ElseIf aNFItem[nItem][IT_TS][TS_PISCOF] == "2"
		nAliqCOF  := aNFitem[nItem][IT_ALIQCF2]/100
	ElseIf aNFItem[nItem][IT_TS][TS_PISCOF] == "3"
		nAliqPIS  := aNFitem[nItem][IT_ALIQPS2]/100
		nAliqCOF  := aNFitem[nItem][IT_ALIQCF2]/100
	EndIf

	nAliqICMNF	:= aNFitem[nItem][IT_ALIQICM]/100 							//Salvo para usar no recalculo do ICMS

	IF aSX6[MV_EIC0064]// Define que o valor aduaneiro informado em notas de importação esteja sem o Valor do II
      // Desta forma não preciso tirar o II do val Merc, uma vez que já foi informado sem o II na NF de importação
      nVlAduan    := aNfItem[nItem][IT_VALMERC]
	Else
       //Desta forma retira o II do Val Merc pois ele informou junto
       nVlAduan    := aNfItem[nItem][IT_VALMERC] - aNfItem[nItem][IT_VALII]    //Valor da Mercadoria - Valor do II
	EndIf

	nVlAduan	+= Iif(aNFItem[nItem][IT_TS][TS_DESPPIS] <> "2" .And. aNFItem[nItem][IT_TS][TS_DESPCOF] <> "2", aNfItem[nItem][IT_DESPESA]+aNfItem[nItem][IT_SEGURO]+aNfItem[nItem][IT_FRETE]+aNfItem[nItem][IT_AFRMIMP], 0 )

	//Se Reducao na base de ICMS (aNFItem[nItem][IT_TS][TS_BASEICM]>0)
	//Aliquota ICMS * Aliquota de reducao TES
	//Aplicar a redução na aliquota e calcular PIS/COFINS com a aliquota reduzida
	nAliqICM := IIf( aNFItem[nItem][IT_TS][TS_BASEICM] > 0 , ((aNFitem[nItem][IT_ALIQICM] * aNFItem[nItem][IT_TS][TS_BASEICM]) / 100) / 100 , aNFitem[nItem][IT_ALIQICM] / 100 )

	If !Empty(aNFItem[nItem][IT_EXCECAO]) .And. aNFItem[nItem][IT_EXCECAO][14] > 0
		nAliqICM := ((aNFitem[nItem][IT_ALIQICM] * aNfItem[nItem,IT_EXCECAO,14]) / 100) / 100 //Reducao na base de ICMS
	EndIf

	nAliqICM := Round(nAliqICM*100,2)/100

	//Se não tiver IPI Pauta mas tiver Valor IPI calculado faço o cálculo considerando IPI Percentual
	If Empty(aNfItem[nItem][IT_PAUTIPI]) .And. !Empty(aNfItem[nItem][IT_VALIPI])
		//Fórmula x para o cálculo da IN572 considerando IPI Percentual

		nIN572x :=(1+nAliqICM * (nAliqII+nAliqIPI * (1+nAliqII))) / ((1-nAliqPIS-nAliqCOF)*(1-nAliqICM)) //Não é mais utilizado no cálculo de PIS/Cofins Importaçção, conforme a lei 12.865 de 09/10/2013.

		//Se tiver valor da COFINS já calculado conforme as regras já existentes para a COFINS e
		//Tiver que calcular COFINS Importação eu cálculo considerando o valor da COFINS
		If !Empty(aNfItem[nItem][IT_VALCF2]) .And. aNFItem[nItem][IT_TS][TS_INTBSIC]$"23"
			//Valor do COFINS Importação
			nVlCOFImp:= nAliqCOF * (nVlAduan)
		EndIf
		//Se tiver valor do PIS já calculado conforme as regras já existentes para o PIS e
		//Tiver que calcular PIS Importação eu cálculo considerando o valor de PIS
		If !Empty(aNfItem[nItem][IT_VALPS2]) .And. aNFItem[nItem][IT_TS][TS_INTBSIC]$"13"
			//Valor do PIS Importação
			nVlPISImp:= nAliqPIS * (nVlAduan)
		EndIf
	Else //Se houver IPI Pauta ou Não tiver IPI faço o cálculo considerando IPI Pauta
		//Fórmula y para o cálculo da IN572 considerando IPI Pauta
		nIN572y :=(1+nAliqICM * nAliqII)/((1-nAliqPIS-nAliqCOF)*(1-nAliqICM)) //Não é mais utilizado no cálculo de PIS/Cofins Importaçção, conforme a lei 12.865 de 09/10/2013.
		//Fórmula w para o cálculo da IN572 considerando IPI Pauta
		nIN572w :=(nAliqICM * aNfItem[nItem][IT_PAUTIPI]) / ((1-nAliqPIS-nAliqCOF)*(1-nAliqICM)) //Não é mais utilizado no cálculo de PIS/Cofins Importaçção, conforme a lei 12.865 de 09/10/2013.
		//Se tiver valor da COFINS já calculado conforme as regras já existentes para a COFINS e
		//Tiver que calcular COFINS Importação eu cálculo considerando o valor da COFINS
		If !Empty(aNfItem[nItem][IT_VALCF2]) .And. aNFItem[nItem][IT_TS][TS_INTBSIC]$"23"
			//Valor do COFINS Importação
			nVlCOFImp:= nAliqCOF * (nVlAduan*aNfItem[nItem][IT_QUANT])
		EndIf
		//Se tiver valor do PIS já calculado conforme as regras já existentes para o PIS e
		//Tiver que calcular PIS Importação eu cálculo considerando o valor de PIS
		If !Empty(aNfItem[nItem][IT_VALPS2]) .And. aNFItem[nItem][IT_TS][TS_INTBSIC]$"13"
			//Valor do PIS Importação
			nVlPISImp:= nAliqPIS * (nVlAduan*aNfItem[nItem][IT_QUANT])
		EndIf
	EndIf

	//Base de cálculo ICMS Fictício = (Valor Aduaneiro+imposto importação+IPI)/(1-%ICMS)
	nBsICMFic:= ((nVlAduan+aNfItem[nItem][IT_VALII]) + aNfItem[nItem][IT_VALIPI])/(1-nAliqICM)
	//Valor do ICMS Fictício = Base de cálculo do ICMS * %ICMS
	nVlICMFic:= nBsICMFic * nAliqICM

	If cImpServ == "N"
		//Conforme a lei 12.865 de 09/10/2013, a base de Calculo de PIS/Cofins será comporta apenas no Valor Aduaneiro
		//Base de Cálculo COFINS Importação
		nBsCOFImp := nVlAduan
       nBsCOFImp *= nRedCof

		//Base de Cálculo COFINS Importação
		nBsPISImp := nVlAduan
		nBsPISImp *= nRedPis
	Else
		/* Formula para calculo de Pis Cofins Importaçãp de Serviço
		V = o valor pago, creditado, entregue, empregado ou remetido para o exterior, antes da retenção do imposto de renda
		C = alíquota da Contribuição para o Pis/Pasep-Importação
		D = alíquota da Cofins-Importação
		F = alíquota do Imposto sobre Serviços de qualquer Natureza
		Cofins Importação = D*V*Z
		Pis Importação	  = C*V*Z
		Z = (1+F)/(1-C-D)
		Base de Cálculo COFINS/PIS Importação Serviço */

		//Inclui o valor do Imposto de Renda na base de cálculo do PIS e COFINS Importação
		IF xFisGrossIR(nItem, aNFItem, aNfCab, "PISCOFIMP") //Verifica se deverá considerar GrossUp do IRRF na base do PIS e COFINS Importação
			nBsICMFic	:= nBsICMFic / ( 1 - ( aNfItem[nItem][IT_ALIQIRR] / 100 ) )
		EndIF
		nIN572s :=(1+(aNfItem[nItem][IT_ALIQISS]/100))/((1-nAliqPIS-nAliqCOF))
		nBsCOFImp := nBsICMFic * nIN572s
		nBsCOFImp *= nRedCof
		nBsPISImp := nBsICMFic * nIN572s
		nBsPISImp *= nRedPis
	EndIf
	//Atualiza Valores
	If (!Empty(aNfItem[nItem][IT_VALCF2]) .Or. aNFItem[nItem][IT_TS][TS_CSTCOF] $"73") .And. aNFItem[nItem][IT_TS][TS_INTBSIC]$"23"
		aNfItem[nItem][IT_BASECF2] := nBsCOFImp

		//Nessa situacao, atualizo valor da contribuicao
		/* Se o campo do valor do COFINS majorado (IT_VALCMAJ) for alterado, obtenho o valor original
		   do cálculo (nValMaj) e somo a diferença entre o valor digitado e o valor obtido (nDifVal) no
		   valor do COFINS importacao (nVlCOFImp) */

		If AllTrim(cCampo) == "IT_VALCMAJ"
			nValMaj := (aNfItem[nItem][IT_BASECF2] * (aNFItem[nItem][IT_TS][TS_ALQCMAJ]/100))
			nDifVal := aNfItem[nItem][IT_VALCMAJ] - nValMaj

			nVlCOFImp	:=	((nBsCOFImp * nAliqCOF) + nDifVal)
		Else
			nVlCOFImp	:=	nBsCOFImp * nAliqCOF
		Endif

		aNfItem[nItem][IT_VALCF2]  := nVlCOFImp

		MaItArred(nItem, { "IT_BASECF2","IT_VALCF2" } )   // Ajusta os arredondamentos do item
	EndIf

	If (!Empty(aNfItem[nItem][IT_VALPS2]) .Or. aNFItem[nItem][IT_TS][TS_CSTCOF] $"73") .And. aNFItem[nItem][IT_TS][TS_INTBSIC]$"13"
		aNfItem[nItem][IT_BASEPS2] := nBsPISImp

		//Nessa situacao, atualizo valor da contribuicao
		nVlPISImp	:=	nBsPISImp * nAliqPIS

		aNfItem[nItem][IT_VALPS2]  := nVlPISImp

		MaItArred(nItem, { "IT_BASEPS2","IT_VALPS2" } )   // Ajusta os arredondamentos do item
	EndIf

	If aNFItem[nItem][IT_TS][TS_ALQCMAJ] > 0 .And. cCampo <> "IT_VALCMAJ"
		aNfItem[nItem][IT_VALCMAJ] := aNfItem[nItem][IT_BASECF2] * (aNFItem[nItem][IT_TS][TS_ALQCMAJ]/100)
	EndIf

	If aNFItem[nItem][IT_TS][TS_ALQPMAJ] > 0
		aNfItem[nItem][IT_VALPMAJ] := aNfItem[nItem][IT_BASEPS2] * (aNFItem[nItem][IT_TS][TS_ALQPMAJ]/100)
	EndIf

	MaFisBSICM(nItem,,,,cCampo)
	If (aNFItem[nItem][IT_TS][TS_AGRPIS] == "P" .Or. aNFItem[nItem][IT_TS][TS_AGRPIS] == "C") .And. aSX6[MV_REDIMPO]
		aNfItem[nItem][IT_BASEICM]:= aNfItem[nItem][IT_BASEICM]/(1-nAliqICM)
	Else
		aNfItem[nItem][IT_BASEICM]:= aNfItem[nItem][IT_BASEICM]/(1-nAliqICMNF)
	Endif
	MaFisVICMS(nItem) //Recalcula o valor do ICMS

	//Necessário processar a base de ICMS ST e valor de ICMS ST para que seja calculado considerando os valores atualizados de ICMS
	//e PIS COFINS împortação que foram calculados acima, pois o ICMS ST deverá considerar estes valores atualizados.
	MaFisBSSol(nItem, cCampo)
	MaFisVSol(nItem, cCampo)
EndIf

Return

/*
MaFisRURAL -Alexandre Lemes -04/10/2012
Executa o calculo do FUNRURAL.
*/
Static Function MaFisRURAL(nItem,cExecuta)

Local aPFunRur  := {}
Local npRural   := aSX6[MV_CONTSOC]
Local nY 		:= Len(npRural)
Local nAliquota	:= 0
Local nNewAlqRur:= 0
Local nPosAlqFun:= 1
DEFAULT cExecuta := "BSE|ALQ|VLR|"

If aNfItem[nItem][IT_PRD][SB_CONTSOC] == "S" .And. aNFItem[nItem][IT_TS][TS_CONTSOC]=="1" .And. aNfCab[NF_TPCLIFOR] <> "X"
	IF  "ALQ" $ cExecuta
		//Define Aliquota FUNRURAL
		//aPFunRur[1]  == "F"
		//aPFunRur[2]  == "L"
		//aPFunRur[3]  == "J"
		Do While nY > 0
			nY:=AT("/",npRural)
			AADD(aPFunRur,IIf(nY > 0,Substr(npRural,1,nY-1),npRural))
			npRural:=Substr(npRural,nY+1,Len(npRural))
		EndDo
		//Retidado o "J" passado na função AT, pois de acordo com o que foi visto pela nossa consultora tributária, na entrada não
		// deve haver a retenção quando o fornecedor for pessoa jurídica
		If aNfCab[NF_CLIFOR] == "F"
			nAliquota := IIf( AT(SA2->A2_TIPORUR,"FL") > 0 , Val(aPFunRur[ AT(SA2->A2_TIPORUR,"FL") ]) , 0 )
		Else // Este ajuste e necessario pois este campo grava FLJ no MP10 e 123 no MP11 e ainda no MP11 a ordem de FJL e invertida ao prametro que le FLJ
			If SM0->M0_PRODRUR $ "F|1"
				nPosAlqFun := 1
			ElseIf SM0->M0_PRODRUR $ "L|3"
				nPosAlqFun := 2
			ElseIf SM0->M0_PRODRUR $ "J|2"
				nPosAlqFun := 3
			EndIf
			nAliquota := IIf( Val(SM0->M0_PRODRUR) > 0 , Val(aPFunRur[nPosAlqFun]) , 0 )
		EndIf
		//Ponto de Entrada para alterar a aliquota de Funrural de 2.3% para 0,02% conforme acoes
		//judiciarias movidas por alguns produtores e empregadores rurais cuja causa tem sido aceita
		//por inconstitucionalidade do art. 25 da Lei n 8.212/91.
		If aPE[PE_MAFISRUR]
			nNewAlqRur := ExecBlock( "MAFISRUR",.F.,.F.,{aNfItem[nItem,IT_TES],aNfItem[nItem,IT_PRODUTO],aNfCab[NF_CLIFOR],aNfCab[NF_OPERNF],aNfCab[NF_CODCLIFOR],aNfCab[NF_LOJA],IIf(aNfCab[NF_CLIFOR] == "F", SA2->A2_TIPORUR , SM0->M0_PRODRUR ) , nAliquota})
			If ValType(nNewAlqRur) == "N"
				nAliquota := nNewAlqRur
			EndIf
		EndIf

		aNfItem[nItem][IT_PERFUN] := nAliquota

	EndIF

	IF "BSE" $ cExecuta
		//Define a Base FUNRURAL
		IF aNfItem[nItem][IT_PERFUN] > 0
			If (aNFItem[nItem][IT_TS][TS_BSRURAL] == "1")
				aNfItem[nItem][IT_BASEFUN] := IIF(aNFItem[nItem][IT_TS][TS_DICMFUN] =="1" .And. aNFItem[nItem][IT_TS][TS_AGREG] == "D" .And. aNfItem[nItem][IT_DEDICM]>0 , (aNfItem[nItem][IT_VALMERC]-aNfItem[nItem][IT_DEDICM]) - aNfItem[nItem][IT_DESCONTO],;
				aNfItem[nItem][IT_VALMERC] - aNfItem[nItem][IT_DESCONTO])
			Else
				aNfItem[nItem][IT_BASEFUN] := IIF(aNFItem[nItem][IT_TS][TS_DICMFUN] =="1" .And. aNFItem[nItem][IT_TS][TS_AGREG] == "D" .And. aNfItem[nItem][IT_DEDICM]>0 ,(aNfItem[nItem][IT_VALMERC]-aNfItem[nItem][IT_DEDICM]) - aNfItem[nItem][IT_DESCONTO] + aNfItem[nItem][IT_FRETE] + aNfItem[nItem][IT_DESPESA] + aNfItem[nItem][IT_SEGURO],;
				aNfItem[nItem][IT_VALMERC] - aNfItem[nItem][IT_DESCONTO] + aNfItem[nItem][IT_FRETE] + aNfItem[nItem][IT_DESPESA] + aNfItem[nItem][IT_SEGURO])
			EndIf
		Else
			aNfItem[nItem][IT_BASEFUN] := 0
		EndIF

	EndIF

	IF "VLR" $ cExecuta
		//Define o Valor FUNRURAL
		IF aNfItem[nItem][IT_PERFUN] > 0
			aNfItem[nItem][IT_FUNRURAL] := ( aNfItem[nItem][IT_BASEFUN] * aNfItem[nItem][IT_PERFUN] ) / 100
		Else
			aNfItem[nItem][IT_FUNRURAL]:= 0
		EndIf
	EndIF
Else
	aNfItem[nItem][IT_BASEFUN] := 0
	aNfItem[nItem][IT_PERFUN]  := 0
	aNfItem[nItem][IT_FUNRURAL]:= 0

EndIf

Return

/*
MaFisFFF- Alexandre Lemes-28/09/2012
Efetua calculo FETHAB, FACS, FABOV para o estado do Mato Grosso.
*/
Static Function MaFisFFF(nItem)

Local cPrUm     := ""
Local cSgUm     := ""
Local nIndUpf	:= 0
Local nAliq     := 0
Local nQtd2Um   := 0

aNfItem[nItem][IT_BASEFAB] := 0
aNfItem[nItem][IT_ALIQFAB] := 0
aNfItem[nItem][IT_VALFAB]  := 0
aNfItem[nItem][IT_BASEFAC] := 0
aNfItem[nItem][IT_ALIQFAC] := 0
aNfItem[nItem][IT_VALFAC]  := 0
aNfItem[nItem][IT_BASEFET] := 0
aNfItem[nItem][IT_ALIQFET] := 0
aNfItem[nItem][IT_VALFET]  := 0
aNfItem[nItem][IT_BASEFMD] := 0
aNfItem[nItem][IT_VALFMD]  := 0
aNfItem[nItem][IT_BASIMA]	:= 0
aNfItem[nItem][IT_ALIIMA]	:= 0
aNfItem[nItem][IT_VALIMA]	:= 0
aNfItem[nItem][IT_BASFASE]  := 0
aNfItem[nItem][IT_ALIFASE]	:= 0
aNfItem[nItem][IT_VALFASE]	:= 0
aNfItem[nItem][IT_BASFUND]  := 0
aNfItem[nItem][IT_ALIFUND]	:= 0
aNfItem[nItem][IT_VALFUND]	:= 0

nIndUpf:= aNfCab[NF_INDUFP]

If nIndUpf > 0 .And. cPaisLoc == "BRA"
	cPrUm     := If(!Empty(aNfItem[nItem][IT_B1UM]),aNfItem[nItem][IT_B1UM],"")
	cSgUm     := If(!Empty(aNfItem[nItem][IT_B1SEGUM]),aNfItem[nItem][IT_B1SEGUM],"")
	//FABOV - BASE / ALIQUOTA e VALOR
	If (aPos[FP_B1_AFABOV] .And. aPos[FP_A2_RFABOV] .And. aPos[FP_A1_RFABOV] .And. aPos[FP_F4_CFABOV] )
		If aNfItem[nItem][IT_AFABOV] > 0 .And. aNFItem[nItem][IT_TS][TS_CALCFAB] == "1"
			nAliq	  := aNfItem[nItem][IT_AFABOV]
			If Alltrim(cPrUm) == "UN" // E obrigatorio que a primeira ou a segunda unidade de medida seja "UN"
				aNfItem[nItem][IT_BASEFAB] := Round((nIndUpf * nAliq /100),2)
				aNfItem[nItem][IT_ALIQFAB] := nAliq
				aNfItem[nItem][IT_VALFAB]  := Round(((nIndUpf * nAliq /100) * aNfItem[nItem][IT_QUANT]),2)
			ElseIf Alltrim(cSgUm) == "UN"
				nQtd2Um:= ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],0,2)
				If nQtd2Um > 0
					aNfItem[nItem][IT_BASEFAB] := Round((nIndUpf * nAliq /100),2)
					aNfItem[nItem][IT_ALIQFAB] := nAliq
					aNfItem[nItem][IT_VALFAB]  := Round(((nIndUpf * nAliq /100) * nQtd2Um),2)
				EndIf
			EndIf
		EndIf
	EndIf
	//FACS  - BASE / ALIQUOTA e VALOR
	If  (aPos[FP_B1_AFACS] .And. aPos[FP_A2_RFACS] .And. aPos[FP_A1_RFACS] .And. aPos[FP_F4_CFACS] )
		If aNfItem[nItem][IT_AFACS] > 0 .And. aNFItem[nItem][IT_TS][TS_CALCFAC] == "1"
			nAliq	  := aNfItem[nItem][IT_AFACS]
			If Alltrim(cPrUm) $ "TL|TON" // E obrigatorio que a primeira ou a segunda unidade de medida seja "TL"
				aNfItem[nItem][IT_BASEFAC] := Round((nIndUpf * nAliq /100),2)
				aNfItem[nItem][IT_ALIQFAC] := nAliq
				aNfItem[nItem][IT_VALFAC]  := Round(((nIndUpf * nAliq /100) * aNfItem[nItem][IT_QUANT]),2)
			ElseIf Alltrim(cSgUm) $ "TL|TON"
				nQtd2Um:= ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],0,2)
				If nQtd2Um > 0
					aNfItem[nItem][IT_BASEFAC] := Round((nIndUpf * nAliq /100),2)
					aNfItem[nItem][IT_ALIQFAC] := nAliq
					aNfItem[nItem][IT_VALFAC]  := Round(((nIndUpf * nAliq /100) * nQtd2Um),2)
				EndIf
			EndIf
		EndIf
	EndIf

	//FETHAB - BASE / ALIQUOTA e VALOR
	If  (aPos[FP_B1_AFETHAB]  .And. aPos[FP_A2_RECFET]  .And. aPos[FP_A1_RECFET] .And. aPos[FP_F4_CALCFET] )
		If aNfItem[nItem][IT_AFETHAB]  > 0  .And. !Empty(aNfItem[nItem][IT_TFETHAB]) .And. aNFItem[nItem][IT_TS][TS_CALCFET] == "1"
			nAliq	  := aNfItem[nItem][IT_AFETHAB]
			If aNfItem[nItem][IT_TFETHAB] $ "12"  // 1 - Soja ou 2 - Algodao
				If Alltrim(cPrUm) $ "TL|TON" // E obrigatorio que a primeira ou a segunda unidade de medida seja "TL"
					aNfItem[nItem][IT_BASEFET] := Round((nIndUpf * nAliq /100),2)
					aNfItem[nItem][IT_ALIQFET] := nAliq
					aNfItem[nItem][IT_VALFET]  := Round(((nIndUpf * nAliq /100) * aNfItem[nItem][IT_QUANT]),2)
				ElseIf Alltrim(cSgUm) $ "TL|TON"
					nQtd2Um:= ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],1,2)
					If nQtd2Um > 0
						aNfItem[nItem][IT_BASEFET] := Round((nIndUpf	 * nAliq /100),2)
						aNfItem[nItem][IT_ALIQFET] := nAliq
						aNfItem[nItem][IT_VALFET]  := Round(((nIndUpf * nAliq /100) * nQtd2Um),2)
					EndIf
				EndIf

				IF aNfCab[NF_RECFET] == "1"
					aNfItem[nItem][IT_VALFETR]	:= aNfItem[nItem][IT_VALFET]
				EndIF

				IF aNfItem[nItem][IT_TFETHAB] == "2"
				 	IF aPos[FP_F4_RFETALG] .AND. aNFItem[nItem][IT_TS][TS_RFETALG] == "2"// Algodão irá verificar retenção no cadastro de TES
						aNfItem[nItem][IT_VALFETR]:= 0 //Se no cadastro do TES estiver igual a SIM então não irá reter FETHAB, se estiver diferente irá considerar o padrão
					ElseIF aNfCab[NF_RECFET] == "1"
						aNfItem[nItem][IT_VALFETR]	:= aNfItem[nItem][IT_VALFET]
					EndIF

				EndIF

			ElseIf aNfItem[nItem][IT_TFETHAB] == "3" //  3 - Gado
				If Alltrim(cPrUm) == "UN" // E obrigatorio que a primeira ou a segunda unidade de medida seja "UN"
					aNfItem[nItem][IT_BASEFET] := Round((nIndUpf * nAliq /100),2)
					aNfItem[nItem][IT_ALIQFET] := nAliq
					aNfItem[nItem][IT_VALFET]  := Round(((nIndUpf * nAliq /100) * aNfItem[nItem][IT_QUANT]),2)
				ElseIf Alltrim(cSgUm) == "UN"
					nQtd2Um:= ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],0,2)
					If nQtd2Um > 0
						aNfItem[nItem][IT_BASEFET] := Round((nIndUpf * nAliq /100),2)
						aNfItem[nItem][IT_ALIQFET] := nAliq
						aNfItem[nItem][IT_VALFET]  := Round(((nIndUpf * nAliq /100) * nQtd2Um),2)
					EndIf
				EndIf

				IF aNfCab[NF_RECFET] == "1"
					aNfItem[nItem][IT_VALFETR]	:= aNfItem[nItem][IT_VALFET]
				EndIF
			ElseIf aNfItem[nItem][IT_TFETHAB] == "4" //Madeira
				If Alltrim(cPrUm) == "M3" // E obrigatorio que a primeira ou a segunda unidade de medida seja "M3"
					aNfItem[nItem][IT_BASEFET] := Round((nIndUpf * nAliq /100),2)
					aNfItem[nItem][IT_ALIQFET] := nAliq
					aNfItem[nItem][IT_VALFET]  := Round(((nIndUpf * nAliq /100) * aNfItem[nItem][IT_QUANT]),2)
				ElseIf Alltrim(cSgUm) == "M3"
					nQtd2Um:= ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],0,2)
					If nQtd2Um > 0
						aNfItem[nItem][IT_BASEFET] := Round((nIndUpf * nAliq /100),2)
						aNfItem[nItem][IT_ALIQFET] := nAliq
						aNfItem[nItem][IT_VALFET]  := Round(((nIndUpf * nAliq /100) * nQtd2Um),2)
					EndIf
				EndIf
				IF aNfCab[NF_RECFET] == "1"
					aNfItem[nItem][IT_VALFETR]	:= aNfItem[nItem][IT_VALFET]
				EndIF
			EndIf
		EndIf
	EndIf
	//FAMAD - BASE / ALIQUOTA e VALOR
	If (aPos[FP_AFAMAD] .And. aPos[FP_A2_RECFMD] .And. aPos[FP_A1_RECFMD] .And. aPos[FP_CFAMAD] )
		If aNfItem[nItem][IT_ALQFMD] > 0 .And. aNFItem[nItem][IT_TS][TS_CFAMAD] == "1"
			nAliq	  := aNfItem[nItem][IT_ALQFMD]
			If Alltrim(cPrUm) == "M3" // E obrigatorio que a primeira ou a segunda unidade de medida seja "M3"
				aNfItem[nItem][IT_BASEFMD] := Round((nIndUpf * nAliq /100),2)
				aNfItem[nItem][IT_ALQFMD] := nAliq
				aNfItem[nItem][IT_VALFMD]  := Round(((nIndUpf * nAliq /100) * aNfItem[nItem][IT_QUANT]),2)
			ElseIf Alltrim(cSgUm) == "M3"
				nQtd2Um:= ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],0,2)
				If nQtd2Um > 0
					aNfItem[nItem][IT_BASEFMD] := Round((nIndUpf * nAliq /100),2)
					aNfItem[nItem][IT_ALQFMD] := nAliq
					aNfItem[nItem][IT_VALFMD] := Round(((nIndUpf * nAliq /100) * nQtd2Um),2)
				EndIf
			EndIf
		EndIf
	EndIf
	//IMA-MT
	If  (aPos[FP_B1_AIMAMT] .And. aPos[FP_A2_RIMAMT] .And. aPos[FP_A1_RIMAMT] .And. aPos[FP_F4_CIMAMT])
		If aNfItem[nItem][IT_AIMAMT] > 0 .And. aNFItem[nItem][IT_TS][TS_CIMAMT] == "1"
			nAliq	  := aNfItem[nItem][IT_AIMAMT]
			If Alltrim(cPrUm) $ "TL|TON"
				aNfItem[nItem][IT_BASIMA]	:= Round((nIndUpf * nAliq /100),2)
				aNfItem[nItem][IT_ALIIMA]	:= nAliq
				aNfItem[nItem][IT_VALIMA]	:= Round(aNfItem[nItem][IT_BASIMA] * aNfItem[nItem][IT_QUANT],2)
			ElseIf Alltrim(cSgUm) $ "TL|TON"
				nQtd2Um:= ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],0,2)
				If nQtd2Um > 0
					aNfItem[nItem][IT_BASIMA]	:= Round((nIndUpf * nAliq /100),2)
					aNfItem[nItem][IT_ALIIMA]	:= nAliq
					aNfItem[nItem][IT_VALIMA]	:= Round(aNfItem[nItem][IT_BASIMA] * nQtd2Um,2)
				EndIf
			EndIf
			IF aNfCab[NF_RECIMA] == "1"
				aNfItem[nItem][IT_VLIMAR]	:= aNfItem[nItem][IT_VALIMA]
			EndIF
		EndIf
	EndIf
	//FASE-MT
	If  (aPos[FP_B1_AFASEMT] .And. aPos[FP_A2_RFASEMT] .And. aPos[FP_A1_RFASEMT] .And. aPos[FP_F4_CFASE])
		If aNfItem[nItem][IT_AFASEMT] > 0 .And. aNFItem[nItem][IT_TS][TS_CFASE] == "1"
			nAliq	  := aNfItem[nItem][IT_AFASEMT]
			If Alltrim(cPrUm) == "KG"
				aNfItem[nItem][IT_BASFASE]	:= Round((nIndUpf * nAliq /100),2)
				aNfItem[nItem][IT_ALIFASE]	:= nAliq
				aNfItem[nItem][IT_VALFASE]	:= Round(aNfItem[nItem][IT_BASFASE] * aNfItem[nItem][IT_QUANT],2)
			ElseIf Alltrim(cSgUm) == "KG"
				nQtd2Um:= ConvUm(aNfItem[nItem][IT_PRODUTO],aNfItem[nItem][IT_QUANT],0,2)
				If nQtd2Um > 0
					aNfItem[nItem][IT_BASFASE]	:= Round((nIndUpf * nAliq /100),2)
					aNfItem[nItem][IT_ALIFASE]	:= nAliq
					aNfItem[nItem][IT_VALFASE]	:= Round(aNfItem[nItem][IT_BASFASE] * nQtd2Um,2)
				EndIf
			EndIf
			IF aNfCab[NF_RECFASE] == "1"
				aNfItem[nItem][IT_VLFASER]	:= aNfItem[nItem][IT_VALFASE]
			EndIF
		EndIf
	EndIf
	//FUNDESA-RS
	If (aPos[FP_B1_AFUNDES] .And. aPos[FP_F4_CFUNDES])
        If aNfItem[nItem][IT_PRD][SB_AFUNDES] > 0 .And. aNFItem[nItem][IT_TS][TS_CFUNDES] == "1"
            aNfItem[nItem][IT_BASFUND] := nIndUpf * aNfItem[nItem][IT_PRD][SB_AFUNDES]
            aNfItem[nItem][IT_ALIFUND] := aNfItem[nItem][IT_PRD][SB_AFUNDES]
            aNfItem[nItem][IT_VALFUND] := aNfItem[nItem][IT_BASFUND] * aNfItem[nItem][IT_QUANT]
        EndIf
    EndIf
Endif

Return

/*
MaFisSEST - Alexandre Lemes - 01/10/2012
Calculo do SEST
*/
Static Function MaFisSEST(nItem)

If !Empty(aNfCab[NF_NATUREZA]) .And. aNfCab[NF_RECSEST]=="1" .And. aNFItem[nItem][IT_TS][TS_DUPLIC]=="S" .And. aPos[FP_ED_BASESES] .And. aPos[FP_ED_PERCSES]
	aNfItem[nItem][IT_BASESES] := IIf( aInfNat[NT_BASESES] > 0,((aNfItem[nItem][IT_TOTAL]*aInfNat[NT_BASESES])/100) , aNfItem[nItem][IT_TOTAL] )
	aNfItem[nItem][IT_ALIQSES] := aInfNat[NT_PERCSES]
	aNfItem[nItem][IT_VALSES]  := aNfItem[nItem][IT_BASESES]*(aNfItem[nItem][IT_ALIQSES]/100)
	MaItArred(nItem,{"IT_VALSES"})
Else
	aNfItem[nItem][IT_BASESES] := 0
	aNfItem[nItem][IT_ALIQSES] := 0
	aNfItem[nItem][IT_VALSES]  := 0
Endif

Return

/*MaFisSENAR - Alexandre Lemes - 28/09/2012
Descricao  Calculo do SENAR Lei 8.205, de 22 de dezembro de 2004
*/
Static Function MaFisSENAR(nItem)

Local lDev := Iif(Alltrim(aNfCab[NF_TIPONF]) $ "DB",.T.,.F.)

If aNFItem[nItem][IT_TS][TS_ALSENAR] > 0 .And. (aNFItem[nItem][IT_TS][TS_DUPLIC] == "S" .Or. aNFItem[nItem][IT_TS][TS_CSENAR]=="1")
	If ((SubStr(aNfItem[nItem][IT_CF],1,1) $ "5|6|7" .And. !lDev) .Or.(SubStr(aNfItem[nItem][IT_CF],1,1) $ "1|2" .And. lDev))
		aNfItem[nItem][IT_BSSENAR]:= aNfItem[nItem][IT_TOTAL]
		aNfItem[nItem][IT_ALSENAR]:= aNFItem[nItem][IT_TS][TS_ALSENAR]
		aNfItem[nItem][IT_VLSENAR]:= aNfItem[nItem][IT_BSSENAR]*(aNFItem[nItem][IT_TS][TS_ALSENAR]/100)
		MaItArred(nItem,{"IT_VLSENAR"})
	ElseIf (((SubStr(aNfItem[nItem][IT_CF],1,1) $ "1|2") .Or.(SubStr(aNfItem[nItem][IT_CF],1,1) $ "5|6" .And. lDev)) .And. (aNfCab[NF_TPCLIFOR] == "F" .Or. aNfCab[NF_TIPORUR] == "F"))
		aNfItem[nItem][IT_BSSENAR]:= aNfItem[nItem][IT_TOTAL]
		aNfItem[nItem][IT_ALSENAR]:= aNFItem[nItem][IT_TS][TS_ALSENAR]
		aNfItem[nItem][IT_VLSENAR]:= aNfItem[nItem][IT_BSSENAR]*(aNFItem[nItem][IT_TS][TS_ALSENAR]/100)
		MaItArred(nItem,{"IT_VLSENAR"})
	Else
		aNfItem[nItem][IT_BSSENAR]:= 0
		aNfItem[nItem][IT_ALSENAR]:= 0
		aNfItem[nItem][IT_VLSENAR]:= 0
	Endif
Else
	aNfItem[nItem][IT_BSSENAR]:= 0
	aNfItem[nItem][IT_ALSENAR]:= 0
	aNfItem[nItem][IT_VLSENAR]:= 0
Endif

Return

/*MaFisAFRMM - Alexandre Lemes - 01/10/2012
Calculo do AFRMM
*/
Static Function MaFisAFRMM(nItem)

If aNFItem[nItem][IT_TS][TS_AFRMM] == "S"
	aNfItem[nItem][IT_BASEAFRMM] := IIf( aNfItem[nItem][IT_VALMERC] > 0 , aNfItem[nItem][IT_VALMERC] , 0 )
	aNfItem[nItem][IT_ALIQAFRMM] := IIf( !Empty( aSX6[MV_TXAFRMM] )  , aSX6[MV_TXAFRMM] , 0 )
	aNfItem[nItem][IT_VALAFRMM]  := (( aNfItem[nItem][IT_BASEAFRMM] * aNfItem[nItem][IT_ALIQAFRMM] ) / 100 )

	If aPE[PE_MAAFRMM]
		aNfItem[nItem][IT_VALAFRMM] := ExecBlock("MAAFRMM",.F.,.F.,{ aNfItem[nItem][IT_VALAFRMM] })
	Endif
Else
	aNfItem[nItem][IT_BASEAFRMM] := 0
	aNfItem[nItem][IT_ALIQAFRMM] := 0
	aNfItem[nItem][IT_VALAFRMM]  := 0
EndIf

Return

/*
MaFisVsul - Alexandre Lemes - 28/09/2012
Calcula o valor do Fundersul do item - Mato Grosso do Sul
Este valor sera calculado apenas nas entradas do estado,
sendo que o resultado sera deduzido da duplicata a pagar.
*/
Static Function MaFisVSul(nItem)

Local nUferms := 0

If aNfItem[nItem][IT_PRD][SB_PRFDSUL] > 0 .And. (aNFItem[nItem][IT_TS][TS_DUPLIC] == "S" .Or. (aSX6[MV_EASY] == "S" .And. aNFItem[nItem][IT_TS][TS_AGREG]$"BC")) .And.;
	aNFItem[nItem][IT_TS][TS_CLFDSUL] == "1" .And. (SubStr(aNfItem[nItem][IT_CF],1,1) $ "13" .Or. ;
	(SubStr(aNfItem[nItem][IT_CF],1,1)$"56")) //.And. aNFitem[nItem][IT_TIPONF] == "D"))

	If SM2->(FieldPos("M2_MOEDA"+Alltrim(aSX6[MV_UFERMS]))) > 0
		SM2->(dbSetOrder(1))
		If SM2->(MsSeek(dDataBase))
			nUferms := SM2->&("M2_MOEDA"+Alltrim(aSX6[MV_UFERMS]))
		Endif
		If nUferms > 0
			aNfItem[nItem][IT_VALFDS]  := aNfItem[nItem][IT_QUANT] * (nUferms * aNfItem[nItem][IT_PRD][SB_PRFDSUL] / 100)
			aNfItem[nItem][IT_PRFDSUL] := aNfItem[nItem][IT_PRD][SB_PRFDSUL]
			aNfItem[nItem][IT_UFERMS]  := nUferms
		Endif
	Endif
Else
	aNfItem[nItem][IT_VALFDS]  := 0
	aNfItem[nItem][IT_PRFDSUL] := 0
	aNfItem[nItem][IT_UFERMS]  := 0
Endif

Return

/*/
MaFisBSICA - Alexandre Lemes - 24/09/2012
Executa o calculo da Base do ICMS do frete Autonomo
*/
Static Function MaFisICA(nItem)

aNfItem[nItem][IT_BASEICA]:= IIf( aNFItem[nItem][IT_TS][TS_LFICM] <> "N" .And. aNFItem[nItem][IT_TS][TS_FRETAUT] <> "2" .And. aNFItem[nItem][IT_TS][TS_FRETAUT] <> "3", aNfItem[nItem][IT_AUTONOMO] , 0 )
aNfItem[nItem][IT_VALICA] := IIf( aNFItem[nItem][IT_TS][TS_LFICM] <> "N" , aNfItem[nItem][IT_BASEICA] * aNfItem[nItem][IT_ALIQICM] / 100 , 0 )

Return

/*/
MaFisTST - Alexandre Lemes - 24/09/2012
Verifica a base para calculo do ICMS sobre o frete quando o calculo e feito a parte do calculo do ICMS
*/
Static Function MaFisTST(nItem,cExecuta)

DEFAULT cExecuta  := "BSE|ALQ|VLR"

//Calcula o ICMS do frete embarcador quando:
//- a transportadora for do mesmo estado;
//- a transportadora for um autonomo;
//- a transportadora for de outro estado, mas nao inscrita no estado do contribuinte.
If aNFItem[nItem][IT_TS][TS_FRETAUT] == "3" .And. ( aNfCab[NF_TRANSUF] == aSX6[MV_ESTADO] .Or. aNfCab[NF_TRANSIN] == "3" .Or.(aNfCab[NF_TRANSIN] == "2" .And. aNfCab[NF_TRANSUF] <> aSX6[MV_ESTADO] ) )
	//Define BASE do TST - IT_BASETST
	If "BSE" $ cExecuta
		aNfItem[nItem][IT_BASETST]:= aNfItem[nItem][IT_AUTONOMO]
	EndIf
	//Define Aliquota do TST - IT_ALIQTST
	If "ALQ" $ cExecuta
		aNfItem[nItem][IT_ALIQTST]:= Val(Substr(aSX6[MV_ALIQFRE],AT(aNFCab[NF_UFDEST],aSX6[MV_ALIQFRE])+2,2))
	EndIf
	//Define VLR  do TST - IT_VALTST
	If "VLR" $ cExecuta
		aNfItem[nItem][IT_VALTST] := aNfItem[nItem][IT_BASETST]*aNfItem[nItem][IT_ALIQTST]/100
	EndIf
Else
	aNfItem[nItem][IT_BASETST]:= 0
	aNfItem[nItem][IT_ALIQTST]:= 0
	aNfItem[nItem][IT_VALTST] := 0
Endif

Return

/*
MaFisCIDE - Graziele Paro - 20/12/2013
Efetua o cálculo do CIDE, para que seja definido no titulo campo E2_CIDE
*/
Static Function MaFisCIDE(nItem,cExecuta)
DEFAULT cExecuta := "BSE|ALQ|VLR"
//zero ao trocar natureza/tes/vlmerc e outros que impactam
IF cExecuta == "BSE|ALQ|VLR"
	aNfItem[nItem][IT_ALQCIDE]:=0
	aNfItem[nItem][IT_BASECID]:=0
	aNfItem[nItem][IT_VALCIDE]:=0
	//se tiver pauta no item dou preferencia a pauta,coforme DT TVNADZ_DT_Calculo_do_CIDE_por_Pauta
	If aNfItem[nItem][IT_VLRCID] == 0
		aNfItem[nItem][IT_ALQCIDE] := aInfNat[20]
	EndIF
ENDIF

//aInfNat[19] == "S" .And. .And. aNfCab[NF_RECCIDE] == "1"
IF aNfCab[NF_OPERNF] == "E"

	If aInfNat[19] == "S" .And. aNfCab[NF_RECCIDE] == "1" .AND. aNfItem[nItem][IT_ALQCIDE] > 0 .AND. aNfItem[nItem][IT_BASECID] == 0
		aNfItem[nItem][IT_BASECID] := (aNfItem[nItem][IT_BASEDUP] * ( Iif(!Empty(aInfNat[21]),aInfNat[21]/100,1)))
		//calculo a base se tiver aliquota, pois pode ser considerado como PAUTA
		//Adiciona o valor do Imposto de renda na base de cálculo da CIDE
		If xFisGrossIR(nItem, aNFItem, aNfCab, "CIDE") //Verifica se deverá considerar GrossUp do IRRF na Base da Cide			
			aNfItem[nItem][IT_BASECID]	:= aNfItem[nItem][IT_BASECID] / ( 1 - ( aNfItem[nItem][IT_ALIQIRR] / 100 ) )
		EndIf
	EndIf

	//se for valor, ele já efetua o mafisalt
	IF "BSE" $ cExecuta .OR. "ALQ" $ cExecuta
		//quando não houver aliquota, calculo como pauta.
		If aNfItem[nItem][IT_VLRCID] > 0 .AND. aNfItem[nItem][IT_ALQCIDE] == 0
			aNfItem[nItem][IT_BASECID] := 0
			aNfItem[nItem][IT_ALQCIDE] := 0
			aNfItem[nItem][IT_VALCIDE] := aNfItem[nItem][IT_QUANT] * aNfItem[nItem][IT_VLRCID]
		Else
			aNfItem[nItem][IT_VALCIDE] := aNfItem[nItem][IT_BASECID] * (aNfItem[nItem][IT_ALQCIDE]/100)
		Endif
	EndIf
EndIf

Return

/*
MaFisFMPEQ - Graziele Paro - 01/12/2014
Efetua o cálculo do FUMIPEQ
*/
Static Function MaFisFMPEQ(nItem)
aNfItem[nItem][IT_VALFMP] := 0
aNfItem[nItem][IT_BASEFMP]:= 0
aNfItem[nItem][IT_ALQFMP] := aInfNat[25]
IF ((aNfCab[NF_OPERNF] == "S" .And. aNfCab[NF_UFDEST] == "AM") .Or. aNfCab[NF_TIPONF]=="D") .And. aInfNat[24] == "1" .And. aNfItem[nItem][IT_ALQFMP] > 0
	aNfItem[nItem][IT_BASEFMP]:= aNfItem[nItem][IT_TOTAL]
	aNfItem[nItem][IT_VALFMP] := aNfItem[nItem][IT_BASEFMP] * (aNfItem[nItem][IT_ALQFMP]/100)
EndIf
Return

/* MaFisTPDP - Alexandre Lemes - 22/11/2012
Executa calculo do TPDP - Paraiba Taxa de Processamento de Despesas Publicas.
*/
Static Function MaFisTPDP(nItem)

aNfItem[nItem][IT_BASTPDP]	:= 0
aNfItem[nItem][IT_ALITPDP]	:= 0
aNfItem[nItem][IT_VALTPDP]	:= 0

If aPos[FP_A1_TPDP] .And. aPos[FP_B1_TPDP] .And. aNfCab[NF_OPERNF] == "S" .And. SA1->A1_TPDP == "1" .And. ;
	aNfItem[nItem][IT_PRD][SB_TPDP] == "1" .And. aNfCab[NF_UFDEST]=="PB" .And. aNFItem[nItem][IT_TS][TS_DUPLIC] == "S" .And. aNfItem[nItem][IT_VALMERC] > 0

	aNfItem[nItem][IT_BASTPDP]	:= aNfItem[nItem][IT_VALMERC]
	aNfItem[nItem][IT_ALITPDP]	:= aSX6[MV_ALITPDP]

	If ( aNfItem[nItem][IT_BASTPDP] * ( aSX6[MV_ALITPDP] / 100 ) ) >= 30000
		aNfItem[nItem][IT_VALTPDP]	:= 30000
	Else
		aNfItem[nItem][IT_VALTPDP] := ( aNfItem[nItem][IT_BASTPDP] * ( aSX6[MV_ALITPDP] / 100 ) )
	Endif
	MaItArred(nItem,{"IT_VALTPDP"})
EndIf

Return

/*
MaFisFECP - ALexandre Lemes - 19/10/2012
Calcula  FECP de Todos os Estados e grava a aliquota a ser
Majorada na aliquota do ICMS na referencia de Aliquota do
FECP de cada estado no array aNFItem
*/
Static Function MaFisFECP( nItem , cCampo, lReproc, cExecuta, lZera )

Local cCfComTele	:= "1301/1302/1303/1304/1305/1306/2300/2301/2302/2303/2304/2305/2306/3301/5301/5302/5303/5304/5305/5306/5307/6302/6303/6304/6305/6306/6307/7301"
Local nAlqFecpRJ	:= aNfItem[nItem][IT_PRD][SB_FECP]
Local nAlqFecpBA	:= Iif( aPos[FP_B1_FECPBA] , aNfItem[nItem][IT_PRD][SB_FECPBA] , 0 )
Local nAlqFecpMT	:= Iif( aPos[FP_B1_FECPMT]  , aNfItem[nItem][IT_PRD][SB_FECPMT]  , 0 )
Local nAlqFecpRN	:= Iif( aPos[FP_B1_ALFECRN] , aNfItem[nItem][IT_PRD][SB_ALFECRN] , 0 )
Local nAlqFecpMG := Iif( aPos[FP_B1_ALFECMG] , aNfItem[nItem][IT_PRD][SB_ALFECMG] , 0 )
Local nAlqFecpMA	:= Iif( aPos[FP_B1_ALFUMAC] , aNfItem[nItem][IT_PRD][SB_ALFUMAC] , 0 )
Local nAlqAdicMT	:= Iif( aPos[FP_B1_ADIFECP] , aNfItem[nItem][IT_PRD][SB_ADIFECP] , 0 )
Local nBsFumacop	:= 0
Local cCSTICMS  := SubStr(aNfitem[nItem][IT_CLASFIS], 2)
Local lFecp		:= .T.
Local lFecpST		:= cCSTICMS $ "10|30|70" .Or. aNfItem[nItem][IT_BASESOL] > 0
Local lFecpOut	:= (((aNfCab[NF_OPERNF] == "E" .And. (aNFItem[nItem][IT_TS][TS_CONSUMO]$"SO" .Or. aNFItem[nItem][IT_TS][TS_CIAP]=="S" .Or. aNFItem[nItem][IT_TS][TS_ANTICMS] == "1" )) .Or. (((aNfCab[NF_TIPONF] == "D" .Or. aNfCab[NF_OPERNF] == "S" ) .And. aNfCab[NF_PPDIFAL] .And. aNFCab[NF_LINSCR]))) .And. aNfCab[NF_UFDEST] <> aNfCab[NF_UFORIGEM])
Local aMVPPDIFAL := &(aSX6[MV_PPDIFAL])
Local lDifal 		:= Iif(valType(aMVPPDIFAL)== "A", Len(aMVPPDIFAL)>0 .And. Year(aNfCab[NF_DTEMISS]) >= aMVPPDIFAL[1][1],.F.)
Local lVenPreslj := .F.
Local lCalcVlr := .T.
Local aBaseAnt := {0,0,0}
Local aAliqAnt := {0,0,0,0}
Local aVlrAnt  := {0,0,0}

Default cCampo		:=	""
Default lReproc     := .F.
Default cExecuta := "BSE|ALQ|VLR"

If lReproc

	aBaseAnt := {aNfItem[nItem][IT_BASFECP], aNfItem[nItem][IT_BSFCPST], aNfItem[nItem][IT_BSFCCMP]}
	aAliqAnt := {aNfItem[nItem][IT_ALIQFECP], aNfItem[nItem][IT_ALFCST], aNfItem[nItem][IT_ALFCCMP], aNfItem[nItem][IT_FCPAUX]}
	aVlrAnt  := {aNfItem[nItem][IT_VALFECP], aNfItem[nItem][IT_VFECPST], aNfItem[nItem][IT_VFCPDIF]}

Else

	If aNfCab[NF_TIPONF] $ "D" .And. !Empty(aNFItem[nItem][IT_RECORI])

		If ( aNFCab[NF_CLIFOR] == "C" )
			dbSelectArea("SD2")
			MsGoto( aNFItem[nItem][IT_RECORI] )

			// Valores - Soh copio se for dev. total.

			If aNfItem[nItem][IT_QUANT] == SD2->D2_QUANT

				aNfItem[nItem][IT_VALFECP] := 0
				aNfItem[nItem][IT_VFECPST] := 0
				aNfItem[nItem][IT_VFCPDIF] := 0

				If aPos[FP_D2_VALFECP] .And. SD2->D2_VALFECP > 0
					aNfItem[nItem][IT_VALFECP] := SD2->D2_VALFECP
					lCalcVlr := .F.
				EndIf
				If aPos[FP_D2_VFECPST] .And. SD2->D2_VFECPST > 0
					aNfItem[nItem][IT_VFECPST] := SD2->D2_VFECPST
					lCalcVlr := .F.
				EndIf
				If aPos[FP_D2_VFCPDIF] .And. SD2->D2_VFCPDIF > 0
					aNfItem[nItem][IT_VFCPDIF] := SD2->D2_VFCPDIF
					lCalcVlr := .F.
				EndIf

			EndIf

		Else
			dbSelectArea("SD1")
			MsGoto( aNFItem[nItem][IT_RECORI] )

			// Valores - soh copio se for dev. total.

			If aNfItem[nItem][IT_QUANT] == SD1->D1_QUANT

				aNfItem[nItem][IT_VALFECP] := 0
				aNfItem[nItem][IT_VFECPST] := 0
				aNfItem[nItem][IT_VFCPDIF] := 0

				If aPos[FP_D1_VALFECP] .And. SD1->D1_VALFECP > 0
					aNfItem[nItem][IT_VALFECP] := SD1->D1_VALFECP
					lCalcVlr := .F.
				EndIf
				If aPos[FP_D1_VFECPST] .And. SD1->D1_VFECPST > 0
					aNfItem[nItem][IT_VFECPST] := SD1->D1_VFECPST
					lCalcVlr := .F.
				EndIf
				If aPos[FP_D1_VFCPDIF] .And. SD1->D1_VFCPDIF > 0
					aNfItem[nItem][IT_VFCPDIF] := SD1->D1_VFCPDIF
					lCalcVlr := .F.
				EndIf

			EndIf

		EndIf
	EndIf

	// Quando for aliquota tomo todas as decisoes p/ calculo/majoracao do FECP.
	If "ALQ" $ cExecuta

		aNfItem[nItem][IT_ALIQFECP]:= 0
		aNfItem[nItem][IT_ALFCST]  := 0
		aNfItem[nItem][IT_ALFCCMP] := 0	

		// Se UFP_AFCPST for igual a "2" (Aliquota do cadastro de clientes) nao precisa preencher na CFC.
		If ((aNfItem[nItem][IT_UFXPROD][UFP_ALIQFECP] > 0 .Or. aNfItem[nItem][IT_UFXPROD][UFP_AFCPST] == '2') .And. aNFItem[nItem][IT_TS][TS_ISEFECP] <> "1")

			// Validacoes para ICMS Complementar/Antecipacao:
			// Nao majorar em Operacoes Interestaduais de Entrada para Consumo quando o campo CFC_FCPXDA = Nao
			If aNfItem[nItem][IT_UFXPROD][UFP_FECPDIF] $ "2"
				lFecpOut	:=	.F.
			Endif

			//-> Nao majorar em Operacoes Internas quanto For Venda Interna para um cliente Interestadual / Consumidor Final.
			If (aNfCab[NF_UFDEST] == aNfCab[NF_UFORIGEM] .And. aNfItem[nItem][IT_UFXPROD][UFP_FECPINT] $ "2" .And. aNfCab[NF_TPCLIFOR] == "F" .And. (aNfCab[NF_ROTINA] $ "LOJA701|FATA701" .OR. lReproc)  .And. aNfItem[nItem][IT_TS][TS_VENPRES] == "1") .OR. ;
		  		(aNfCab[NF_TIPONF] ==  "D" .And. aNfCab[NF_UFDEST] == aNfCab[NF_UFORIGEM] .And. aNfItem[nItem][IT_UFXPROD][UFP_FECPINT] $ "2" .And. aNfCab[NF_TPCLIFOR] == "F" .And.  aNfItem[nItem][IT_TS][TS_VENPRES] == "1")
				lVenPreslj := .T.
			EndIf

			// Validacoes para ICMS Proprio:
			//-> Nao majorar em Operacoes Internas quando o campo CFC_FCPINT = Nao
			//-> Nao majorar em Importacoes quando o campo CFC_FCPINT = Nao
			//-> Nao majorar em Devolucoes, pois a MATXFIS busca a aliquota do documento original
			//-> Nao majorar em Operacoes Interestaduais de Entrada
			//-> Nao majorar em Operacoes Interestaduais de Saida, exceto destinadas a Consumidor Final.
			If lFecp .And.	(;
								( aNfCab[NF_UFDEST] == aNfCab[NF_UFORIGEM] .And. aNfItem[nItem][IT_UFXPROD][UFP_FECPINT] $ "2" .And. aNfCab[NF_TPCLIFOR] <> "F") .Or.;
								( aNfCab[NF_UFORIGEM] == "EX" .And. aNfItem[nItem][IT_UFXPROD][UFP_FECPINT] $ "2") .Or.;
								( aNfCab[NF_UFDEST] <> aNfCab[NF_UFORIGEM] .And. aNfCab[NF_OPERNF] == "E" .And. aNfCab[NF_UFORIGEM] <> "EX"  ) .Or.;
								( aNfCab[NF_UFDEST] <> aNfCab[NF_UFORIGEM] .And. aNfCab[NF_OPERNF] == "S" .And. aNfCab[NF_TPCLIFOR] <> "F" ) .Or.;
								( aNfCab[NF_UFDEST] <> aNfCab[NF_UFORIGEM] .And. aNfCab[NF_OPERNF] == "S" .And. aNfCab[NF_TPCLIFOR] == "F"  .And. lDifal) .Or. lVenPreslj ;
							)
				lFecp	:=	.F.
			Endif

			//Validacoes para ICMS ST: Nao majorar em Devolucoes, pois a MATXFIS busca a aliquota do documento original
			If (lFecpST .And. ( aNfCab[NF_TIPONF] $ "D" )) .Or. lVenPreslj
				lFecpST := .F.
			Endif

			//ICMS Proprio: Nas operacoes interestaduais destinadas a nao contribuintes, devo utilizar a majoracao com aliquota do estado de origem.
			If lFecp
				If aNfCab[NF_OPERNF] == "S" .And. aNfCab[NF_UFDEST] <> aNfCab[NF_UFORIGEM] .And. aNfCab[NF_LINSCR]
					aNfItem[nItem][IT_ALIQFECP]	:= aNfItem[nItem][IT_UFXPROD][UFP_ALQFCPO]
				Else
					aNfItem[nItem][IT_ALIQFECP]	:= aNfItem[nItem][IT_UFXPROD][UFP_ALIQFECP]
				Endif

				// Se utilizar Indice Auxiliar para calculo do FECP gravo na referencia separada.
				If aNfItem[nItem][IT_UFXPROD][UFP_FECPAUX] > 0
					aNfItem[nItem][IT_FCPAUX] := aNfItem[nItem][IT_UFXPROD][UFP_FECPAUX]
				Endif
			Endif

			//	ICMS Substituicao Tributaria
			If lFecpST
				// Configuração de aliquota do FCP-ST por CNAE.
				If aNfItem[nItem][IT_UFXPROD][UFP_AFCPST] == '2'
					aNfItem[nItem][IT_ALFCST] := aNfCab[NF_PERFECP]
				Else
					aNfItem[nItem][IT_ALFCST] := aNfItem[nItem][IT_UFXPROD][UFP_ALIQFECP]
				EndIf

				// Se utilizar Indice Auxiliar para calculo do FECP gravo na referencia separada.
				If aNfItem[nItem][IT_UFXPROD][UFP_FECPAUX] > 0
					aNfItem[nItem][IT_FCPAUX] := aNfItem[nItem][IT_UFXPROD][UFP_FECPAUX]
				Endif
			Endif

			// ICMS Diferencial de Aliquotas ou Antecipacao de ICMS
			If lFecpOut
				If aNFItem[nItem][IT_TS][TS_COMPL] == "S" .Or. aNFItem[nItem][IT_TS][TS_ANTICMS] == "1"
					aNfItem[nItem][IT_ALFCCMP]	:= aNfItem[nItem][IT_UFXPROD][UFP_ALIQFECP]

					// Se utilizar Indice Auxiliar para calculo do FECP gravo na referencia separada.
					If aNfItem[nItem][IT_UFXPROD][UFP_FECPAUX] > 0
						aNfItem[nItem][IT_FCPAUX] := aNfItem[nItem][IT_UFXPROD][UFP_FECPAUX]
					Endif
				Endif
			Endif

		Else
			//FECP - RIO DE JANEIRO - Lei 14.264/07 - Decreto 1036 de 28/01/08
			If !aNFItem[nItem][IT_TS][TS_ISEFECP] == "1" .And. aNfItem[nItem][IT_PRD][SB_FECP] > 0

				If (( aSX6[MV_ESTADO] == "RJ" .And. aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_UFDEST] <> aNFCab[NF_UFORIGEM] .And. aNFItem[nItem][IT_TS][TS_COMPL] == "S" .And. !(aNfCab[NF_PPDIFAL] .And. aNfCab[NF_TIPONF] =="D")) .Or. ;
					( aSX6[MV_ESTADO] == "RJ" .And. aNFCab[NF_UFDEST] == "RJ" .And. (aNFCab[NF_UFORIGEM] == "RJ" .Or. aNFCab[NF_UFORIGEM] == "EX") ) .Or. ;
					( aSX6[MV_ESTADO] == "RJ" .And. aNFCab[NF_OPERNF] == "S" .And. aNFCab[NF_UFDEST] <> aNFCab[NF_UFORIGEM] .And. aNFCab[NF_LINSCR] .And. !lDifal) .Or. ;
					( aSX6[MV_ESTADO] == "RJ" .And. aNFCab[NF_OPERNF] == "S" .And. aNFCab[NF_UFDEST] <> aNFCab[NF_UFORIGEM] .And. aNfCab[NF_TIPONF] =="D" ) .Or.;
					( aSX6[MV_ESTADO] <> "RJ" .And. aNFCab[NF_OPERNF] == "S" .And. aNFCab[NF_UFDEST] <> aNFCab[NF_UFORIGEM] .And. aNFCab[NF_UFDEST] == "RJ" .And. aNFCab[NF_LINSCR] .And. aNfCab[NF_PPDIFAL] .And. ((aNfItem[nItem][IT_ALIQCMP] + aNfItem[nItem][IT_PRD][SB_FECP]) > aNFitem[nItem][IT_ALIQICM])) .Or. ;
					( aSX6[MV_ESTADO] <> "RJ" .And. aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_UFDEST] <> aNFCab[NF_UFORIGEM] .And. aNFCab[NF_UFDEST] <> "RJ" .And. aNFCab[NF_UFORIGEM] =='RJ' .And. aNfCab[NF_TIPONF] =="D" .And. aNfCab[NF_PPDIFAL]))

					If lFecpOut .And. aNFItem[nItem][IT_TS][TS_COMPL] == "S"
						aNfItem[nItem][IT_ALFCCMP]	:= nAlqFecpRJ
					Else
						aNfItem[nItem][IT_ALIQFECP] := nAlqFecpRJ
					Endif
				EndIf

				// Se o CST for de ICMS-ST farei a majoracao do ST.
				If lFecpST

					If ( aSX6[MV_ESTADO] == "RJ" .And. aNFCab[NF_UFDEST] == "RJ" .And. aNFCab[NF_UFORIGEM] == "RJ" ) .Or. ;
						( aSX6[MV_ESTADO] <> "RJ" .And. aNFCab[NF_OPERNF] == "S" .And.  aNFCab[NF_UFDEST] == "RJ"  ) .Or. ;
						( aSX6[MV_ESTADO] == "RJ" .And. aNFCab[NF_UFDEST] == "RJ" )

						aNfItem[nItem][IT_ALFCST]  := nAlqFecpRJ
					EndIf
				EndIf
			EndIf

			//FECP - BAHIA
			If !aNFItem[nItem][IT_TS][TS_ISEFECP] == "1"

				If nAlqFecpBA > 0

					If ( aSX6[MV_ESTADO] == "BA" .And. aNFCab[NF_UFDEST] == "BA" .And. aNFCab[NF_UFORIGEM] == "BA" ) .Or. ;
						( aSX6[MV_ESTADO] == "BA" .And. aNFCab[NF_OPERNF] == "S"  .And. aNFCab[NF_UFDEST] <> aNFCab[NF_UFORIGEM] .And. aNFCab[NF_LINSCR] .And. !lDifal) .Or.;
						( aSX6[MV_ESTADO] <> "BA" .And. aNFCab[NF_OPERNF] == "S" .And. aNFCab[NF_UFDEST] <> aNFCab[NF_UFORIGEM] .And. aNFCab[NF_UFDEST] == "BA" .And. aNfCab[NF_PPDIFAL]).Or.;
						( aSX6[MV_ESTADO] <> "BA" .And. aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_UFDEST] <> aNFCab[NF_UFORIGEM] .And. aNFCab[NF_UFDEST] <> "BA" .And. aNFCab[NF_UFORIGEM]=='BA' .And. aNfCab[NF_TIPONF] =="D" .And. aNfCab[NF_PPDIFAL])

						If lFecpOut .And. aNFItem[nItem][IT_TS][TS_COMPL] == "S"
							aNfItem[nItem][IT_ALFCCMP]	:= nAlqFecpBA
						Else
							aNfItem[nItem][IT_ALIQFECP]  := nAlqFecpBA
						Endif
					EndIf

					// Se o CST for de ICMS-ST farei a majoracao do ST.
					If lFecpST
						If ( aSX6[MV_ESTADO] == "BA" .And. aNFCab[NF_UFDEST] == "BA" .And. aNFCab[NF_UFORIGEM] == "BA" ) .Or. ;
							( aSX6[MV_ESTADO] <> "BA" .And. aNFCab[NF_OPERNF] == "S" .And. aNFCab[NF_UFDEST] == "BA" ) .Or. ;
							( aSX6[MV_ESTADO] == "BA" .And. aNFCab[NF_UFDEST] == "BA" )

							aNfItem[nItem][IT_ALFCST]  := nAlqFecpBA
						EndIf
					EndIf
				EndIf
			EndIf

			//FECP - MATO GROSSO
			If aNFItem[nItem][IT_TS][TS_ISEFEMT] == "2" .And. !Empty( Alltrim(aSX6[MV_FECPMT]) )

				If aSX6[MV_ESTADO] == "MT" .And. aNFItem[nItem][IT_TS][TS_ICM] == "S"  .Or.;
					( aSX6[MV_ESTADO] <> "MT" .And. aNFCab[NF_OPERNF] == "S" .And. aNFCab[NF_UFDEST] <> aNFCab[NF_UFORIGEM] .And. aNFCab[NF_UFDEST] == "MT" .And. aNfCab[NF_PPDIFAL]) .Or.;
					( aSX6[MV_ESTADO] <> "MT" .And. aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_UFDEST] <> aNFCab[NF_UFORIGEM] .And. aNFCab[NF_UFDEST] <> "MT" .And. aNFCab[NF_UFORIGEM]='MT' .And. aNfCab[NF_TIPONF] =="D" .And. aNfCab[NF_PPDIFAL])

					If ( aNFCab[NF_OPERNF]$"E/S" .And. Alltrim(aNfItem[nItem][IT_CF])$cCfComTele .And. aNFCab[NF_UFORIGEM] == "MT" ) .Or. ;
						( aNFCab[NF_OPERNF] == "S" .And. aNFCab[NF_LINSCR] .And. aNFCab[NF_UFDEST] <> aNFCab[NF_UFORIGEM] .And. !lDifal ) .Or. ;
						( aNFCab[NF_OPERNF]$"E/S" .And. !Alltrim(aNfItem[nItem][IT_CF])$cCfComTele .And. aNFCab[NF_UFORIGEM] == "MT" .And. aNFCab[NF_UFDEST] == "MT" ) .Or. ;
						( aNFCab[NF_OPERNF] == "E" .And. Substr(aNfItem[nItem][IT_CF],1,1) == "3" .And. !Alltrim(aNfItem[nItem][IT_CF])$cCfComTele ) .Or. ;
						( aNFCab[NF_OPERNF] == "E" .And. aNFItem[nItem][IT_TS][TS_ANTICMS] == "1" .And. aNFCab[NF_UFORIGEM] <> "MT" .And. aNFCab[NF_UFDEST] == "MT" ).OR.;
						( aNFCab[NF_OPERNF] == "E" .And. aNfCab[NF_TIPONF] =="D" .And. aNFCab[NF_UFORIGEM] == "MT" .And. aNFCab[NF_UFDEST] <> "MT" .And. aNfCab[NF_PPDIFAL])

						If lFecpOut .And. aNFItem[nItem][IT_TS][TS_COMPL] == "S"
							aNfItem[nItem][IT_ALFCCMP]	:= nAlqFecpMT + nAlqAdicMT
						Else
							aNfItem[nItem][IT_ALIQFECP] := nAlqFecpMT + nAlqAdicMT
						EndIf
					EndIf
				EndIf

				// Atencao nas alteracoes: Este IF eh repetido no bloco de calculo do VALOR.
				If lFecpST .And. aNFCab[NF_UFDEST] == "MT" .And. aNfCab[NF_REGESIM] == "1" .And. aNfItem[nItem][IT_PRD][SB_REGESIM] == "1" .And. !aNFCab[NF_TIPONF] $ "DB"
					aNfItem[nItem][IT_ALFCST] := aNFCab[NF_PERFECP]
				EndIf
			EndIf

			//FECP - RIO GRANDE DO NORTE (FECOP)
			If aNFItem[nItem][IT_TS][TS_ISEFERN] == "2" .And. aSX6[MV_ESTADO] == "RN" .And. aNFItem[nItem][IT_TS][TS_ICM] == "S" .OR.;
				( aSX6[MV_ESTADO] <> "RN" .And. aNFCab[NF_OPERNF] == "S" .And. aNFCab[NF_UFDEST] <> aNFCab[NF_UFORIGEM] .And. aNFCab[NF_UFDEST] == "RN" .And. aNfCab[NF_PPDIFAL]) .Or.;
				( aSX6[MV_ESTADO] <> "RN" .And. aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_UFDEST] <> aNFCab[NF_UFORIGEM] .And. aNFCab[NF_UFDEST] <> "RN" .And. aNFCab[NF_UFORIGEM] == "RN" .And. aNfCab[NF_TIPONF] == "D" .And. aNfCab[NF_PPDIFAL])

				If nAlqFECPRN > 0
					If ( aNFCab[NF_OPERNF] == "S" .And. aNFItem[nItem][IT_TS][TS_CONSUMO] == "S" .And. aNFCab[NF_UFORIGEM] == "RN" ) .Or. ;
						( aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_UFORIGEM] == "RN" .And. aNFItem[nItem][IT_TS][TS_ANTICMS] <> "1" .And. (aNFItem[nItem][IT_TS][TS_CONSUMO] $ "SO" .Or. aNFItem[nItem][IT_TS][TS_CIAP] == "S") ) .Or. ;
						( aNFCab[NF_OPERNF] == "E" .And. aNFItem[nItem][IT_TS][TS_ANTICMS] == "1" .And. aNFCab[NF_UFORIGEM] <> "RN" .And. aNFCab[NF_UFDEST] == "RN" ) .Or. ;
						( aNFCab[NF_OPERNF] == "E" .And. Substr(aNfItem[nItem][IT_CF],1,1) == "3" ) .Or.;
						( aNFCab[NF_OPERNF] == "S" .And. aNFCab[NF_UFDEST] <> aNFCab[NF_UFORIGEM] .And. aNFCab[NF_UFDEST] == "RN" .And. aNfCab[NF_PPDIFAL])

						If lFecpOut .And. aNFItem[nItem][IT_TS][TS_COMPL] == "S"
							aNfItem[nItem][IT_ALFCCMP]	:= nAlqFECPRN
						Else
							aNfItem[nItem][IT_ALIQFECP] := nAlqFECPRN
						Endif
					EndIf

					// Se o CST for de ICMS-ST farei a majoracao do ST.
					If lFecpST
						If ( aNFCab[NF_OPERNF] == "S" .And. aNFCab[NF_UFDEST] == "RN" .And. aNFCab[NF_UFORIGEM] == "RN" ) .Or. ;
							( aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_UFDEST] == "RN" .And. aNFCab[NF_UFORIGEM] == "RN" .And. aNFItem[nItem][IT_TS][TS_ANTICMS] <> "1" ) .Or. ;
							( aNFCab[NF_OPERNF] == "E" .And. aNFItem[nItem][IT_TS][TS_ANTICMS] == "1" .And. aNFCab[NF_UFORIGEM] <> "RN" .And. aNFCab[NF_UFDEST] == "RN" )

							aNfItem[nItem][IT_ALFCST] := nAlqFECPRN
						EndIf
					EndIf
				EndIf
			EndIf

			//FECP - MINAS GERAIS
			If aNFItem[nItem][IT_TS][TS_ISEFEMG] == "2" .And. !Empty( Alltrim(aSX6[MV_ALFECMG]) )

				If nAlqFecpMG > 0

					If	((aSX6[MV_ESTADO] <> "MG" .And. aNFCab[NF_OPERNF] == "S" .And. aNFCab[NF_UFDEST] <> aNFCab[NF_UFORIGEM] .And. aNFCab[NF_UFDEST] == "MG" .And. (aNfCab[NF_PPDIFAL] .Or. lFecpST)) .Or.;
			   			 (aSX6[MV_ESTADO] <> "MG" .And. aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_UFDEST] <> aNFCab[NF_UFORIGEM] .And. aNFCab[NF_UFORIGEM] == "MG" .And. aNfCab[NF_TIPONF] == "D" .And. aNfCab[NF_PPDIFAL]) .Or.;
						 (aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_TIPONF] == "D" .And. aNFCab[NF_UFDEST] == "MG" .And. aNFCab[NF_UFORIGEM] == "MG" .And. aNFItem[nItem][IT_TS][TS_ICM] == "S") .Or.;
						 (aSX6[MV_ESTADO] == "MG" .And. aNFCab[NF_UFDEST] == "MG" .And. (aNFCab[NF_UFORIGEM] == "MG" .Or. aNFCab[NF_UFORIGEM] == "EX") .And. aNFItem[nItem][IT_TS][TS_ICM] == "S") .Or.;
						 (aSX6[MV_ESTADO] == "MG" .And. aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_UFDEST] <> aNFCab[NF_UFORIGEM] .And. aNFItem[nItem][IT_TS][TS_COMPL] == "S" .And. !(aNfCab[NF_PPDIFAL] .And. aNfCab[NF_TIPONF] =="D")) .Or.;
						 (aSX6[MV_ESTADO] == "MG" .And. aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_UFDEST] <> aNFCab[NF_UFORIGEM] .And. aNFCab[NF_UFDEST] == "MG" .And. lFecpST))

						// Se o CST for de ICMS-ST farei a majoracao do ST.
						If lFecpST
							aNfItem[nItem][IT_ALFCST] := nAlqFecpMG
						Else
							If lFecpOut .And. aNFItem[nItem][IT_TS][TS_COMPL] == "S"
								aNfItem[nItem][IT_ALFCCMP]	:= nAlqFecpMG
							Else
								aNfItem[nItem][IT_ALIQFECP] := nAlqFecpMG
							Endif
						EndIf
					EndIf
				EndIf
			EndIf

			//FECP - MARANHAO - Lei 8.205, de 22 de dezembro de 2004  (FUMACOP)
			If nAlqFecpMA > 0
				If aSX6[MV_ESTADO] == "MA" .And. aNfCab[NF_OPERNF] == "S" .And. ( SA1->A1_CONTRIB == "2" .Or. aNFCab[NF_TPCLIFOR] == "F" ) .Or.;
					( aSX6[MV_ESTADO] <> "MA" .And. aNFCab[NF_OPERNF] == "S" .And. aNFCab[NF_UFDEST] <> aNFCab[NF_UFORIGEM] .And. aNFCab[NF_UFDEST] == "MA" .And. aNfCab[NF_PPDIFAL]).Or.;
					( aSX6[MV_ESTADO] <> "MA" .And. aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_UFDEST] <> aNFCab[NF_UFORIGEM] .And. aNFCab[NF_UFDEST] <> "MA" .And. aNFCab[NF_UFORIGEM]=='MA' .And. aNfCab[NF_TIPONF] =="D" .And. aNfCab[NF_PPDIFAL])

					If lFecpOut .And. aNFItem[nItem][IT_TS][TS_COMPL] == "S"
						aNfItem[nItem][IT_ALFCCMP]	:= nAlqFecpMA
					Else
						aNfItem[nItem][IT_ALIQFECP]	:= nAlqFecpMA
					Endif
				EndIf

				If lFecpST
					If ((aSX6[MV_ESTADO] == "MA" .And. aNFCab[NF_UFDEST] == "MA" .And. aNFCab[NF_UFORIGEM] == "MA" ) .Or. ;
						( aSX6[MV_ESTADO] <> "MA" .And. aNFCab[NF_OPERNF] == "S" .And.  aNFCab[NF_UFDEST] == "MA"  ) .Or. ;
						( aSX6[MV_ESTADO] == "MA" .And. aNFCab[NF_UFDEST] == "MA" ))
						aNfItem[nItem][IT_ALFCST]  := nAlqFecpMA
					EndIf
				EndIf
			EndIf
		EndIF

		// Para NF's de devolucao, utilizar a aliquota do doc. de origem.
		// Fiz este trecho no final para que caso o cliente nao possua
		// algum dos campos na base, ou esteja devolvendo uma NF emitida
		// antes da criacao dos mesmos, o sistema copie apenas o que
		// foi gravado e calcule as demais aliquotas.

		If aNfCab[NF_TIPONF] $ "D" .And. !Empty(aNFItem[nItem][IT_RECORI])

			If ( aNFCab[NF_CLIFOR] == "C" )

				dbSelectArea("SD2")
				MsGoto( aNFItem[nItem][IT_RECORI] )

				If aPos[FP_D2_ALQFECP] .And. SD2->D2_ALQFECP > 0
					aNfItem[nItem][IT_ALIQFECP] := SD2->D2_ALQFECP
				EndIf
				If aPos[FP_D2_ALFCPST] .And. SD2->D2_ALFCPST > 0
					aNfItem[nItem][IT_ALFCST] := SD2->D2_ALFCPST
				EndIf
				If aPos[FP_D2_ALIQCMP] .And. SD2->D2_ALFCCMP > 0
					aNfItem[nItem][IT_ALFCCMP] := SD2->D2_ALFCCMP
				EndIf
				If aPos[FP_D2_FCPAUX] .And. SD2->D2_FCPAUX > 0
					aNfItem[nItem][IT_FCPAUX] := SD2->D2_FCPAUX
				EndIf

			Else

				dbSelectArea("SD1")
				MsGoto( aNFItem[nItem][IT_RECORI] )

				If aPos[FP_D1_ALQFECP] .And. SD1->D1_ALQFECP > 0
					aNfItem[nItem][IT_ALIQFECP] := SD1->D1_ALQFECP
				EndIf
				If aPos[FP_D1_ALFCPST] .And. SD1->D1_ALFCPST > 0
					aNfItem[nItem][IT_ALFCST] := SD1->D1_ALFCPST
				EndIf
				If aPos[FP_D1_ALIQCMP] .And. SD1->D1_ALFCCMP > 0
					aNfItem[nItem][IT_ALFCCMP] := SD1->D1_ALFCCMP
				EndIf
				If aPos[FP_D1_FCPAUX] .And. SD1->D1_FCPAUX > 0
					aNfItem[nItem][IT_FCPAUX] := SD1->D1_FCPAUX
				EndIf
			EndIf
		EndIf
	EndIf

	If "BSE" $ cExecuta

		aNfItem[nItem][IT_BASFECP] := 0
		aNfItem[nItem][IT_BSFCPST] := 0
		aNfItem[nItem][IT_BSFCCMP] := 0

		If aNfItem[nItem][IT_ALIQFECP] > 0

			aNfItem[nItem][IT_BASFECP] := aNfItem[nItem][IT_BASEICM]

			// Configuracao da base via CFC.
			If aNfItem[nItem][IT_UFXPROD][UFP_ALIQFECP] > 0 .And. aNfItem[nItem][IT_UFXPROD][UFP_BS_FCPPR] == "1"
				aNfItem[nItem][IT_BASFECP] := aNfItem[nItem][IT_BASEICM]
			EndIf

			// Utiliza Indice Auxiliar para calculo do FECP. Neste caso a base eh sempre o valor.
			If aNfItem[nItem][IT_UFXPROD][UFP_FECPAUX] > 0
				aNfItem[nItem][IT_BASFECP] := aNfItem[nItem][IT_VALICM]
			Endif

		EndIf

		// ICMS-ST
		If aNfItem[nItem][IT_ALFCST] > 0

			aNfItem[nItem][IT_BSFCPST] := aNfItem[nItem][IT_BASESOL]

			If ((aSX6[MV_ESTADO] == "RJ" .And. aNFCab[NF_UFDEST] == "RJ" .And. aNFCab[NF_UFORIGEM] == "RJ") .Or. (aSX6[MV_ESTADO] == "BA" .And. aNFCab[NF_UFDEST] == "BA" .And. aNFCab[NF_UFORIGEM] == "BA"))
				aNfItem[nItem][IT_BSFCPST] := ( aNfItem[nItem][IT_BASESOL] - aNfItem[nItem][IT_BASEICM] )
			EndIf

			If lFecpST .And. aNFCab[NF_UFDEST] == "MT" .And. aNfCab[NF_REGESIM] == "1" .And. aNfItem[nItem][IT_PRD][SB_REGESIM] == "1" .And. !aNFCab[NF_TIPONF] $ "DB"
				aNfItem[nItem][IT_BSFCPST] := Iif(aNFItem[nItem][IT_TS][TS_INCIDE] == "N", aNfItem[nItem][IT_VALIPI], 0) + aNfItem[nItem][IT_BASEICM] + aNfItem[nItem][IT_DESPESA]
			EndIf

			// Configuracao da base via CFC.
			If aNfItem[nItem][IT_UFXPROD][UFP_ALIQFECP] > 0
				Do Case
					// Base do ICMS-ST.
					Case aNfItem[nItem][IT_UFXPROD][UFP_BS_FCPST] == "1"
						aNfItem[nItem][IT_BSFCPST] := aNfItem[nItem][IT_BASESOL]
					// Diferenca entre as bases do ST e Proprio.
					Case aNfItem[nItem][IT_UFXPROD][UFP_BS_FCPST] == "2"
						aNfItem[nItem][IT_BSFCPST] := ( aNfItem[nItem][IT_BASESOL] - aNfItem[nItem][IT_BASEICM] )
					// ICMS Proprio + IPI (Quando ja nao estiver na Base) + Seguro e Despesas (Quando nao estiverem na base).
					// O frete sempre estará na base entao nao preciso somar novamente.
					Case aNfItem[nItem][IT_UFXPROD][UFP_BS_FCPST] == "3"
						aNfItem[nItem][IT_BSFCPST] := aNfItem[nItem][IT_BASEICM] + ;
													  Iif(aNFItem[nItem][IT_TS][TS_INCIDE] == "N", aNfItem[nItem][IT_VALIPI], 0) + ;
													  Iif(aNFItem[nItem][IT_TS][TS_DESPICM] $ "2|3", aNfItem[nItem][IT_DESPESA] + aNfItem[nItem][IT_SEGURO], 0)
				EndCase

			EndIf

			// Utiliza Indice Auxiliar para calculo do FECP. Neste caso a base eh sempre o valor.
			If aNfItem[nItem][IT_UFXPROD][UFP_FECPAUX] > 0
				aNfItem[nItem][IT_BSFCPST] := aNfItem[nItem][IT_VALSOL]
			Endif
		EndIf

		If aNfItem[nItem][IT_ALFCCMP] > 0

			If (aNfCab[NF_PPDIFAL] .Or. (lDifal .And. aSX6[MV_ESTADO] $ aSX6[MV_BASDENT] .And. aNfCab[NF_OPERNF] == "E"))
				aNfItem[nItem][IT_BSFCCMP]	:= aNfItem[nItem][IT_BASEDES]
			Else
				aNfItem[nItem][IT_BSFCCMP]	:= aNfItem[nItem][IT_BASEICM]
			Endif

			If aNfItem[nItem][IT_UFXPROD][UFP_ALIQFECP] > 0
				// Configuracao da base via CFC.
				Do Case
					Case aNfItem[nItem][IT_UFXPROD][UFP_BS_FCPCM] == "1"
						aNfItem[nItem][IT_BSFCCMP]	:= aNfItem[nItem][IT_BASEDES]
					Case aNfItem[nItem][IT_UFXPROD][UFP_BS_FCPCM] == "2"
						aNfItem[nItem][IT_BSFCCMP]	:= aNfItem[nItem][IT_BASEICM]
				EndCase
			EndIf

			// Utiliza Indice Auxiliar para calculo do FECP. Neste caso a base eh sempre o valor.
			If aNfItem[nItem][IT_UFXPROD][UFP_FECPAUX] > 0
				aNfItem[nItem][IT_BSFCCMP] := aNfItem[nItem][IT_VALCMP]
			Endif
		EndIf

		// Tratamento para devolucoes - Mesmo conceito das aliquotas: Se o cliente
		// não possuir todos os campos ou estiver devolvendo um documento lancado
		// antes da implementacao da base de calculo do FCP, ou seja, ele tem o campo
		// mas esta zerado, entao nao posso copiar da origem e devo deixar o sistema
		// efetuar os calculos.

		If aNfCab[NF_TIPONF] $ "D" .And. !Empty(aNFItem[nItem][IT_RECORI])

			If ( aNFCab[NF_CLIFOR] == "C" )
				dbSelectArea("SD2")
				MsGoto( aNFItem[nItem][IT_RECORI] )

				// Bases - Soh copio se for dev. total.

				If aNfItem[nItem][IT_QUANT] == SD2->D2_QUANT

					aNfItem[nItem][IT_BASFECP] := 0
					aNfItem[nItem][IT_BSFCPST] := 0
					aNfItem[nItem][IT_BSFCCMP] := 0

					If aPos[FP_D2_BASFECP] .And. SD2->D2_BASFECP > 0
						aNfItem[nItem][IT_BASFECP] := SD2->D2_BASFECP
					EndIf
					If aPos[FP_D2_BSFCPST] .And. SD2->D2_BSFCPST > 0
						aNfItem[nItem][IT_BSFCPST] := SD2->D2_BSFCPST
					EndIf
					If aPos[FP_D2_BSFCCMP] .And. SD2->D2_BSFCCMP > 0
						aNfItem[nItem][IT_BSFCCMP] := SD2->D2_BSFCCMP
					EndIf
				EndIf
			Else
				dbSelectArea("SD1")
				MsGoto( aNFItem[nItem][IT_RECORI] )

				// Bases - soh copio se for dev. total.
				If aNfItem[nItem][IT_QUANT] == SD1->D1_QUANT

					aNfItem[nItem][IT_BASFECP] := 0
					aNfItem[nItem][IT_BSFCPST] := 0
					aNfItem[nItem][IT_BSFCCMP] := 0

					If aPos[FP_D1_BASFECP] .And. SD1->D1_BASFECP > 0
						aNfItem[nItem][IT_BASFECP] := SD1->D1_BASFECP
					EndIf
					If aPos[FP_D1_BSFCPST] .And. SD1->D1_BSFCPST > 0
						aNfItem[nItem][IT_BSFCPST] := SD1->D1_BSFCPST
					EndIf
					If aPos[FP_D1_BSFCCMP] .And. SD1->D1_BSFCCMP > 0
						aNfItem[nItem][IT_BSFCCMP] := SD1->D1_BSFCCMP
					EndIf

				EndIf

			EndIf
		EndIf

	EndIf

	If "VLR" $ cExecuta .And. lCalcVlr

		aNfItem[nItem][IT_VALFECP] := 0
		aNfItem[nItem][IT_VFECPST] := 0
		aNfItem[nItem][IT_VFCPDIF] := 0

		//--------------------------------------------------------------------------------------------
		// Regra Geral: Se utilizar o indice p/ calcular o FCP nao posso dividir a aliquota por 100
		// pois o indice nao eh um percentual.
		//--------------------------------------------------------------------------------------------

		// ICMS Proprio
		If aNfItem[nItem][IT_BASFECP] > 0 .And. aNfItem[nItem][IT_ALIQFECP] > 0
			aNfItem[nItem][IT_VALFECP] := aNfItem[nItem][IT_BASFECP] * Iif(aNfItem[nItem][IT_FCPAUX] > 0, aNfItem[nItem][IT_FCPAUX], ( aNfItem[nItem][IT_ALIQFECP] / 100 ))
		EndIf

		// ICMS ST
		If aNfItem[nItem][IT_BSFCPST] > 0 .And. aNfItem[nItem][IT_ALFCST] > 0
			aNfItem[nItem][IT_VFECPST] := aNfItem[nItem][IT_BSFCPST] * IIf(aNfItem[nItem][IT_FCPAUX] > 0, aNfItem[nItem][IT_FCPAUX], ( aNfItem[nItem][IT_ALFCST] / 100 ))
		EndIf

		// ICMS Complementar
		If aNfItem[nItem][IT_BSFCCMP] > 0 .And. aNfItem[nItem][IT_ALFCCMP] > 0
			If aNfCab[NF_PPDIFAL]
				aNfItem[nItem][IT_VFCPDIF] := aNfItem[nItem][IT_BSFCCMP] * Iif(aNfItem[nItem][IT_FCPAUX] > 0, aNfItem[nItem][IT_FCPAUX], ( aNfItem[nItem][IT_ALFCCMP] / 100))
			Else
				aNfItem[nItem][IT_VALFECP] := aNfItem[nItem][IT_BSFCCMP] * Iif(aNfItem[nItem][IT_FCPAUX] > 0, aNfItem[nItem][IT_FCPAUX], ( aNfItem[nItem][IT_ALFCCMP] / 100))
			EndIf
		EndIf
	EndIf

	// Quando trocar o TES preciso recalcular
	// as aliquotas para que, caso seja alterado por
	// um TES que nao calcula FECP, seja retirada a majoracao.
	If cCampo == "IT_TES" .And. !lReproc
		// Não recalcular as alíquota caso tenham sido alteradas por MaFisAlt ou MaFisLoad.
		// Esta proteção impede que, caso tenha havido uma alteração intencional na referência,
		// como por exemplo na carga do pedido de compras, esta alteração não seja desfeita.
		If !aRefAlt[nItem][IT_ALIQICM]
			MaAliqIcms(nItem)
		EndIf
		If !aRefAlt[nItem][IT_ALIQSOL]
			MaAliqSoli(nItem)
		EndIf
		If !aRefAlt[nItem][IT_ALIQCMP]
			MaAliqCmp(nItem)
		EndIf
	EndIf

EndIf

// Se for reprocessamento mantenho os valores previamente calculados.
If lReproc
	aNfItem[nItem][IT_BASFECP]  := aBaseAnt[1]
	aNfItem[nItem][IT_BSFCPST]  := aBaseAnt[2]
	aNfItem[nItem][IT_BSFCCMP]  := aBaseAnt[3]

	aNfItem[nItem][IT_ALIQFECP] := aAliqAnt[1]
	aNfItem[nItem][IT_ALFCST]	:= aAliqAnt[2]
	aNfItem[nItem][IT_ALFCCMP]	:= aAliqAnt[3]
	aNfItem[nItem][IT_FCPAUX]	:= aAliqAnt[4]

	aNfItem[nItem][IT_VALFECP]	:= aVlrAnt[1]
	aNfItem[nItem][IT_VFECPST]	:= aVlrAnt[2]
	aNfItem[nItem][IT_VFCPDIF]	:= aVlrAnt[3]
EndIf

Return
/* FUNCOES PARA FINS ESPECIFICOS E OU QUE PODEM SER MOVIDAS DA MATXFIS */

/*CpyFieldSB   -            -
   Copia estrutura de campo do SB1 para criar no SBZ          */
Function CpyFieldSB(aSx3,lRetCp)

Local aAreaSX3	:= {}
Local aHelp		:= {}
Local nX		:= 0
Local nY		:= 0
Local cOrdem	:= ""
Local cMensagem	:= ""
Local cRet		:= ""
//Os campos agregados neste array serao considerados na execução do UPDFIS para replicar os campos     |
// do SB1 para o SBZ. E na leitura na funcao MaSBCampo, na MATXFIS, que direciona a leitura de
// informacoes fiscais do produto para o SB1 ou SBZ dependendo da configuracao do parametro MV_ARQPROD
Local aCpoSBZ	:= {"B1_PICM"	,;
"B1_VLR_ICM",;
"B1_INT_ICM",;
"B1_PICMRET",;
"B1_PICMENT",;
"B1_IPI"	,;
"B1_VLR_IPI",;
"B1_REDPIS"	,;
"B1_REDCOF"	,;
"B1_IRRF"	,;
"B1_ORIGEM"	,;
"B1_GRTRIB"	,;
"B1_CODISS" ,;
"B1_FECP"	,;
"B1_ALIQISS",;
"B1_PIS",;
"B1_COFINS",;
"B1_CSLL",;
"B1_PCSLL",;
"B1_ALFUMAC",;
"B1_FECPBA",;
"B1_ALFECRN",;
"B1_CNAE",;
"B1_CLASFIS",;
"B1_PPIS",;
"B1_PCOFINS",;
"B1_AFUNDES",;
"B1_TRIBMUN"}

DEFAULT lRetCp	:= .F.
DEFAULT aSx3	:= {}

If lRetCp
	For nX := 1 to len(aCpoSBZ)
		cRet += aCpoSBZ[nX] + "/"
	Next nX
	Return cRet
EndIf

aAreaSX3 := SX3->(GetArea())

dbSelectArea("SX3")
dbSetOrder(2)
For nX := 1 to len(aCpoSBZ)
	If SX3->(MsSeek(PadR(aCpoSBZ[nX],10)))
		AADD(aSX3,{	"SBZ"			,cOrdem			,StrTran(aCpoSBZ[nX],"B1","BZ"),;
		SX3->X3_TIPO	,SX3->X3_TAMANHO,SX3->X3_DECIMAL,;
		SX3->X3_TITULO 	,SX3->X3_TITSPA ,SX3->X3_TITENG ,;
		SX3->X3_DESCRIC	,SX3->X3_DESCSPA,SX3->X3_DESCENG,;
		SX3->X3_PICTURE	,StrTran(SX3->X3_VALID,"B1_","BZ_"),SX3->X3_USADO,;
		StrTran(SX3->X3_RELACAO,"B1_","BZ_"),SX3->X3_F3     ,SX3->X3_NIVEL,;
		SX3->X3_RESERV ,SX3->X3_CHECK  	,SX3->X3_TRIGGER,;
		SX3->X3_PROPRI ,SX3->X3_BROWSE	,SX3->X3_VISUAL,;
		SX3->X3_CONTEXT,SX3->X3_OBRIGAT	,StrTran(SX3->X3_VLDUSER,"B1_","BZ_"),;
		SX3->X3_CBOX   ,SX3->X3_CBOXSPA	,SX3->X3_CBOXENG,;
		SX3->X3_PICTVAR,SX3->X3_WHEN	,SX3->X3_INIBRW,;
		SX3->X3_GRPSXG ,"2"				,SX3->X3_PYME	}	)
		aHelp := {}
		cMensagem := Ap5GetHelp(aCpoSBZ[nX])
		For nY := 1 to MlCount(cMensagem)
			AADD(aHelp,MemoLine(cMensagem,,nY))
		Next nY
		PutHelp("P"+StrTran(aCpoSBZ[nX],"B1","BZ"),aHelp,aHelp,aHelp,.T.)
	EndIf
Next nX

RestArea(aAreaSX3)

Return Nil


/*/
MaFisOrdem - Edson Maricate - 01.02.99
Retorna a ordem utilizada pela rotina de calculo de impostos da referencia solicitada.
Uso: MATA461, Esta ordem e utilizada na rotina de Geracao de NF de Saida permitindo que os impostos informados no
SC6 atraves da Funcao MaFisGet() nao sejam recalculados pela Funcao Fiscal
*/
Function MaFisOrdem(cReferencia)

Local nOrdem := 10000
Local nPos   := 0

If aItemRef == Nil
	MaIniRef()
EndIf
If Substr(cReferencia,1,2) == "IT"
	nPos := aScan( aItemRef , {|x|x[1] == cReferencia } )
	If nPos > 0 .And. aItemRef[nPos][3] <> Nil
		nOrdem := aItemRef[nPos][3]
	EndIf
EndIf

Return nOrdem

/*
MaFisReprocess - Edson Maricate - 20.05.2000
Efetua o reprocessamento e gera o livro da Nota Fiscal.
*/
Function MaFisReprocess(nOpc)

Local nItem := 	0
DEFAULT nOpc:= 1

If MaFisFound("NF")
	For nItem := 1 to Len(aNfItem)
		If nOpc == 1
			MaFisTes(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
			MaNewFisTES(aNfItem[nItem][IT_TES],aNfItem[nItem][IT_RECNOSF4],nItem)
			MaFisIPI(nItem,"BSE",.T.)
			MaFisBSICM(nItem,.T.)
			MaFisLF(nItem)
		Else
			MaFisRecal(,nItem)
		EndIf
	Next nItem
	MaIt2Cab()
EndIf

Return

/*
MaFisGet - Edson Maricate - 01.02.99
Funcao utilizada no Pedido de Vendas ( Exclusivamente ) para
criar a referencia do campo no tratamento fiscal.
Obs.: nao executa o calculo do imposto, apenas utiliza o valor informado na preparacao da Nota Fiscal.
*/
Function MaFisGet(cReferencia)
Return .T.

/*AS FUNCOES ABAIXO FORAM REDIRECIONADAS PARA O FONTE IMPXFIS.PRW - 10/02/2015
  As chamadas originais foram mantidas para que nao fosse necessario alterar todos os
  fontes que as utilizam, gerando muitas dependencias desnecessarias. Desta forma, as
  funcoes foram transcritas para o IMPXFIS, com o prefixo "xFis" no lugar de "Ma" e as
  chamadas foram redirecionadas. Algumas funcoes sofreram pequenas alteracoes nos nomes
  devido ao nro. de caracteres
*/
/*/
MaFisAtuSF3 - Edson Maricate-21.02.2000
Esta rotina tem como objetivo atualizar os livros fiscais com base em uma nota fiscal de entrada ou saida.
/*/
Function MaFisAtuSF3(nCaso, cTpOper, nRecNF, cAlias, cPDV, cCNAE, cFunOrig, nCD2, cCodSef, cSerSat, cNfisCanc)

If FindFunction("xFisAtuSF3")
	Return xFisAtuSF3(nCaso, cTpOper, nRecNF, cAlias, cPDV, cCNAE, cFunOrig, nCD2, cCodSef, cSerSat, cNfisCanc, aNFCab, aNFItem, cAliasPROD, aPE, aSX6, aDic, aPos )
Else
	If IsBlind()
		UserException(STR0045)
	Else
		MsgAlert(STR0045)
		Final(STR0045)
	EndIf
EndIf

Return NIL

Function MaFisGetRF(cValid)
If FindFunction("xFisGetRF")
	Return xFisGetRF(cValid)
Else
	If IsBlind()
		UserException(STR0045)
	Else
		MsgAlert(STR0045)
		Final(STR0045)
	EndIf
EndIf

Return NIL

Function MaSBCampo(cNome)

If FindFunction("xFisSBCpo")
	Return xFisSBCpo(cNome,aSX6,cAliasProd,cCpoSBZ)
Else
	If IsBlind()
		UserException(STR0045)
	Else
		MsgAlert(STR0045)
		Final(STR0045)
	EndIf
EndIf

Return NIL

//** MaAvalTes **
Function MaAvalTes(cOperacao,cTes)

If FindFunction("xFisAvTes")
	Return xFisAvTes(cOperacao,cTes)
Else
	If IsBlind()
		UserException(STR0045)
	Else
		MsgAlert(STR0045)
		Final(STR0045)
	EndIf
EndIf

Return NIL

//** CodSitTri **
Function CodSitTri()

If FindFunction("xFisSitTri")
	Return xFisSitTri(aSX6,aPos)
Else
	If IsBlind()
		UserException(STR0045)
	Else
		MsgAlert(STR0045)
		Final(STR0045)
	EndIf
EndIf

Return NIL

//** RetComp **
Function RetComp(cAlOri,nRecOri)

If FindFunction("xFisRtComp")
	Return xFisRtComp(cAlOri,nRecOri,aSX6)
Else
	If IsBlind()
		UserException(STR0045)
	Else
		MsgAlert(STR0045)
		Final(STR0045)
	EndIf
EndIf

Return NIL

//** MaFisRefLd **
Function MaFisRefLd(cAlias,cTipo)

If FindFunction("xFisRefLd")
	Return xFisRefLd(cAlias,cTipo)
Else
	If IsBlind()
		UserException(STR0045)
	Else
		MsgAlert(STR0045)
		Final(STR0045)
	EndIf
EndIf

Return NIL

//** MaFisLdImp **
Function MaFisLdImp()

If FindFunction("xFisLdImp")
	Return xFisLdImp()
Else
	If IsBlind()
		UserException(STR0045)
	Else
		MsgAlert(STR0045)
		Final(STR0045)
	EndIf
EndIf

Return NIL

//** MaFisImpLd **
Function MaFisImpLd(cAlias,cTipo,cCursor)

If FindFunction("xFisImpLd")
	Return xFisImpLd(cAlias,cTipo,cCursor)
Else
	If IsBlind()
		UserException(STR0045)
	Else
		MsgAlert(STR0045)
		Final(STR0045)
	EndIf
EndIf

Return NIL

//** MaFisCDA **
Function MaFisCDA(nItem,nTipo,lExclui,cChaveSF,cFormul,cAlias,lReproc)

Default lReproc := .F.

If FindFunction("xFisCDA")
	Return xFisCDA(nItem,nTipo,lExclui,cChaveSF,cFormul,cAlias,aDic,aPos,aNfItem,lReproc)
Else
	If IsBlind()
		UserException(STR0045)
	Else
		MsgAlert(STR0045)
		Final(STR0045)
	EndIf
EndIf

Return NIL

//** Decret5602 **
Function Decret5602(nVlItem,cNCM,cCodNat)

If FindFunction("xFisDc5602")
	Return xFisDc5602(nVlItem,cNCM,cCodNat,aSX6)
Else
	If IsBlind()
		UserException(STR0045)
	Else
		MsgAlert(STR0045)
		Final(STR0045)
	EndIf
EndIf

Return NIL

//** MaFisRelImp **
Function MaFisRelImp(cProg,aAlias)

If FindFunction("xFisRelImp")
	Return xFisRelImp(cProg,aAlias,aSX6,aRefSX3)
Else
	If IsBlind()
		UserException(STR0045)
	Else
		MsgAlert(STR0045)
		Final(STR0045)
	EndIf
EndIf

Return NIL

//** MaIniRef **
Function MaIniRef()

If FindFunction("xFisIniRef")
	Return xFisIniRef(@aItemRef,@aCabRef,@aLFIs,@aResRef,aSX6,aPos,@aTGITRef,@aTGNFRef)
Else
	If IsBlind()
		UserException(STR0045)
	Else
		MsgAlert(STR0045)
		Final(STR0045)
	EndIf
EndIf

Return NIL

// DECLARACAO MANTIDA APENAS PARA EVITAR ERRO DE CHAMADA.
/*
MaFisAddIT - Marcelo Alexandre-01.03.2009
Carrega os valores de impostos de bases e item
*/
Function MaFisAddIT(cCampo,xValor,nItem,lZer)
Return .T.

/*/
MaNewFisTes - Joao Pellegrini-18/08/2015±±
Inicializa o codigo da TES utilizada no item
*/
Function MaNewFisTES(cTes,nRecnoSF4,nItem,lSeek)

Local aArea		:= {}
Local cHistSF4  := ""
Local lSS0 := .F.
Local aMVPPDIFAL := &(aSX6[MV_PPDIFAL])
DEFAULT cTes 	   := ""
DEFAULT nRecnoSF4  := 0
DEFAULT lSeek := !Empty(cTes) .Or. nRecnoSF4 <> 0

If lSeek
	aArea := GetArea()
	//aAreaSFC := SFC->(GetArea())
	dbSelectArea("SF4")
	If nRecnoSF4 == 0
		SF4->(dbSetOrder(1))
		SF4->(MsSeek(xFilial("SF4") + cTes))
		If lHistorico .And. !Empty(cAlsItem)
			//Se for reprocessamento,  e tiver habilitado para buscar os Historico Fiscais,
			//verifico se o ID do historico da TES  eh  igual ao que foi gravado na Nota. Se for
			//igual é porque nao teve alterações na TES após a emissão. Se for diferente,
			//é porque teve alterações no cadastro, e entao os dados são carregados da tabela de
			//Historico(SS0).
			If( aNfCab[NF_CLIFOR]=="C" .And. aNfCab[NF_TIPONF]<>"D") .Or.( aNfCab[NF_CLIFOR]=="F" .And. aNfCab[NF_TIPONF]$"D|B")
				cHistSF4 := (cAlsItem)->D2_IDSF4
			Else
				cHistSF4 := (cAlsItem)->D1_IDSF4
			EndIf
			If  cPaisLoc == "BRA" .And. Alltrim(SF4->F4_IDHIST)<>Alltrim(cHistSF4)
				dbSelectArea("SS0")
				SS0->(dbSetOrder(1))
				SS0->(MsSeek(xFilial("SS0")+cHistSF4+cTes))
				lSS0 := .T.
			EndIf
		EndIf
	Else
		MsGoto(nRecnoSF4)
	EndIf
EndIf

If lSeek .And. !lSS0
	aNfItem[nItem][IT_RECNOSF4]	:= SF4->(Recno())
EndIf

aNfItem[nItem][IT_TS][TS_SFC]	 := {}
aNfItem[nItem][IT_TS][TS_LANCFIS] := {}
aNfItem[nItem][IT_TS][TS_CODIGO]  := IIf(lSeek, IIf(!lSS0, SF4->F4_CODIGO, SS0->S0_CODIGO), CriaVar("F4_CODIGO",.F.) )
aNfItem[nItem][IT_TS][TS_TIPO]	 := IIf(lSeek, IIf(!lSS0, SF4->F4_TIPO, SS0->S0_TIPO), aNfCab[NF_OPERNF] )
aNfItem[nItem][IT_TS][TS_ICM]	 := IIf(lSeek .And. cPaisLoc == "BRA", IIf(!lSS0, SF4->F4_ICM, SS0->S0_ICM), IIf( cPaisLoc=="BRA",IIf(aSX6[MV_INITES]==.T.,"N","S"),"N")  )
aNfItem[nItem][IT_TS][TS_IPI]	 := IIf(lSeek .And. cPaisLoc == "BRA", IIf(!lSS0, SF4->F4_IPI, SS0->S0_IPI), IIf( cPaisLoc=="BRA",IIf(aSX6[MV_INITES]==.T.,"N","S"),"N")  )
aNfItem[nItem][IT_TS][TS_CREDICM] := IIf(lSeek , IIf(!lSS0, SF4->F4_CREDICM, SS0->S0_CREDICM), "S")
aNfItem[nItem][IT_TS][TS_CREDIPI] := IIf(lSeek , IIf(!lSS0, SF4->F4_CREDIPI,SS0->S0_CREDIPI), "N")
aNfItem[nItem][IT_TS][TS_DUPLIC]	 := IIf(lSeek , IIf(!lSS0, SF4->F4_DUPLIC, SS0->S0_DUPLIC), "S")
aNfItem[nItem][IT_TS][TS_ESTOQUE] := IIf(lSeek, IIf(!lSS0, SF4->F4_ESTOQUE, SS0->S0_ESTOQUE), "S")
aNfItem[nItem][IT_TS][TS_CF]		 := IIf(lSeek , IIf(!lSS0, SF4->F4_CF, SS0->S0_CF), IIf(aNfCab[NF_OPERNF] == "E","111","511") )
aNfItem[nItem][IT_TS][TS_TEXTO]	 := IIf(lSeek, IIf(!lSS0, SF4->F4_TEXTO, SS0->S0_TEXTO), CriaVar("F4_TEXTO",.F.) )
aNfItem[nItem][IT_TS][TS_BASEICM] := IIf(lSeek, IIf(!lSS0, SF4->F4_BASEICM, SS0->S0_BASEICM), 0)
aNfItem[nItem][IT_TS][TS_BASEIPI] := IIf(lSeek , IIf(!lSS0, SF4->F4_BASEIPI, SS0->S0_BASEIPI), 0)
aNfItem[nItem][IT_TS][TS_PODER3]	 := IIf(lSeek , IIf(!lSS0, SF4->F4_PODER3, SS0->S0_PODER3), "N")
aNfItem[nItem][IT_TS][TS_LFICM]   := IIf(lSeek, IIf(!lSS0, SF4->F4_LFICM, SS0->S0_LFICM), IIf(aSX6[MV_INITES]==.T.,"N","T") )
aNfItem[nItem][IT_TS][TS_LFIPI]	 := IIf(lSeek, IIf(!lSS0, SF4->F4_LFIPI, SS0->S0_LFIPI), IIf(aSX6[MV_INITES]==.T.,"N","T") )
aNfItem[nItem][IT_TS][TS_DESTACA] := IIf(lSeek, IIf(!lSS0, SF4->F4_DESTACA, SS0->S0_DESTACA), "N")
aNfItem[nItem][IT_TS][TS_INCIDE]	 := IIf(lSeek, IIf(!lSS0, SF4->F4_INCIDE, SS0->S0_INCIDE), "N")
aNfItem[nItem][IT_TS][TS_COMPL]	 := IIf(lSeek, IIf(!lSS0, SF4->F4_COMPL, SS0->S0_COMPL), "N")
aNfItem[nItem][IT_TS][TS_IPIFRET] := IIf(lSeek, IIf(!lSS0, SF4->F4_IPIFRET, SS0->S0_IPIFRET), "N")
aNfItem[nItem][IT_TS][TS_ISS]	 := IIf(lSeek, IIf(!lSS0, SF4->F4_ISS, SS0->S0_ISS), " ")
aNfItem[nItem][IT_TS][TS_LFISS]	 := IIF(lSeek .And. aPos[FP_F4_LFISS], IIf(!lSS0, SF4->F4_LFISS, SS0->S0_LFISS)," ")
aNfItem[nItem][IT_TS][TS_NRLIVRO] := IIf(lSeek , IIf(!lSS0, SF4->F4_NRLIVRO, SS0->S0_NRLIVRO), " ")
aNfItem[nItem][IT_TS][TS_UPRC]	 := IIf(lSeek, IIf(!lSS0, SF4->F4_UPRC, SS0->S0_UPRC), " ")
aNfItem[nItem][IT_TS][TS_CONSUMO] := IIf(lSeek, IIf(!lSS0, SF4->F4_CONSUMO, SS0->S0_CONSUMO), " ")
aNfItem[nItem][IT_TS][TS_FORMULA] := IIf(lSeek, IIf(!lSS0, SF4->F4_FORMULA, SS0->S0_FORMULA), " ")
aNfItem[nItem][IT_TS][TS_AGREG]	 := IIf(lSeek, IIf(!lSS0, SF4->F4_AGREG, SS0->S0_AGREG), " ")
aNfItem[nItem][IT_TS][TS_AGRDRED] := IIf(lSeek .And. aPos[FP_F4_AGRDRED] .And. !Empty(IIf(!lSS0, SF4->F4_AGRDRED, SS0->S0_AGRDRED)), IIf(!lSS0, SF4->F4_AGRDRED, SS0->S0_AGRDRED), "2")
aNfItem[nItem][IT_TS][TS_INCSOL]	 := IIf(lSeek .And. aPos[FP_F4_INCSOL], IIf(!lSS0, SF4->F4_INCSOL , SS0->S0_INCSOL), " ")
aNfItem[nItem][IT_TS][TS_CIAP]	 := IIf(lSeek, IIf(!lSS0, SF4->F4_CIAP, SS0->S0_CIAP), " ")
aNfItem[nItem][IT_TS][TS_DESPIPI] := IIf(lSeek, IIf(!lSS0, SF4->F4_DESPIPI, SS0->S0_DESPIPI), "N")
aNfItem[nItem][IT_TS][TS_ATUTEC]	 := IIf(lSeek, IIf(!lSS0, SF4->F4_ATUTEC, SS0->S0_ATUTEC), " ")
aNfItem[nItem][IT_TS][TS_ATUATF]	 := IIf(lSeek, IIf(!lSS0, SF4->F4_ATUATF, SS0->S0_ATUATF), " ")
aNfItem[nItem][IT_TS][TS_TPIPI]	 := IIf(lSeek, IIf(!lSS0, SF4->F4_TPIPI, SS0->S0_TPIPI), "B")
aNfItem[nItem][IT_TS][TS_LIVRO]	 := IIf(lSeek, IIf(!lSS0, SF4->F4_LIVRO, SS0->S0_LIVRO), "")
aNfItem[nItem][IT_TS][TS_STDESC]	 := IIf(lSeek, IIf(!lSS0, SF4->F4_STDESC , SS0->S0_STDESC), " ")
aNfItem[nItem][IT_TS][TS_DESPICM] := IIf(lSeek, IIf(!lSS0, SF4->F4_DESPICM, SS0->S0_DESPICM), "2")
aNfItem[nItem][IT_TS][TS_DESPPIS] := IIf(lSeek .And. aPos[FP_F4_DESPPIS], IIf(!lSS0, SF4->F4_DESPPIS, SS0->S0_DESPPIS), "1")
aNfItem[nItem][IT_TS][TS_DESPCOF] := IIf(lSeek .And. aPos[FP_F4_DESPCOF], IIf(!lSS0, SF4->F4_DESPCOF, SS0->S0_DESPCOF), "1")
aNfItem[nItem][IT_TS][TS_BSICMST] := IIf(lSeek .And. aPos[FP_F4_BSICMST], IIf(!lSS0, SF4->F4_BSICMST, SS0->S0_BSICMST), 0)
aNfItem[nItem][IT_TS][TS_BASEISS] := IIf(lSeek .And. aPos[FP_F4_BASEISS], IIf(!lSS0, SF4->F4_BASEISS, SS0->S0_BASEISS), 0)
aNfItem[nItem][IT_TS][TS_IPILICM] := IIf(lSeek, IIf(!lSS0, SF4->F4_IPILICM, SS0->S0_IPILICM), "2")
aNfItem[nItem][IT_TS][TS_ICMSDIF] := IIf(lSeek, IIf(!lSS0, SF4->F4_ICMSDIF, SS0->S0_ICMSDIF), "2")
aNfItem[nItem][IT_TS][TS_QTDZERO] := IIf(lSeek, IIf(!lSS0, SF4->F4_QTDZERO, SS0->S0_QTDZERO), "2")
aNfItem[nItem][IT_TS][TS_TRFICM]  := IIf(lSeek .And. aPos[FP_F4_TRFICM], IIf(!lSS0, SF4->F4_TRFICM , SS0->S0_TRFICM), "2")
aNfItem[nItem][IT_TS][TS_OBSICM]  := IIf(lSeek .And. aPos[FP_F4_OBSICM], IIf(!lSS0, SF4->F4_OBSICM , SS0->S0_OBSICM), "2")
aNfItem[nItem][IT_TS][TS_OBSSOL]  := IIf(lSeek .And. aPos[FP_F4_OBSSOL], IIf(!lSS0, SF4->F4_OBSSOL , SS0->S0_OBSSOL), "2")
aNfItem[nItem][IT_TS][TS_PICMDIF] := IIf(lSeek .And. aPos[FP_F4_PICMDIF], IIf(!lSS0, SF4->F4_PICMDIF, SS0->S0_PICMDIF), 0)
aNfItem[nItem][IT_TS][TS_PISCRED] := IIf(lSeek .And. aPos[FP_F4_PISCRED], IIf(!lSS0, SF4->F4_PISCRED, SS0->S0_PISCRED), "3")
aNfItem[nItem][IT_TS][TS_PISCOF]  := IIf(lSeek .And. aPos[FP_F4_PISCOF], IIf(!lSS0, SF4->F4_PISCOF , SS0->S0_PISCOF), "4")
aNfItem[nItem][IT_TS][TS_CREDST]  := IIf(lSeek .And. aPos[FP_F4_CREDST], IIf(!lSS0, SF4->F4_CREDST , SS0->S0_CREDST), "2")
aNfItem[nItem][IT_TS][TS_BASEPIS] := IIf(lSeek .And. aPos[FP_F4_BASEPIS], IIf(!lSS0, SF4->F4_BASEPIS, SS0->S0_BASEPIS), 0)
aNfItem[nItem][IT_TS][TS_BASECOF] := IIf(lSeek .And. aPos[FP_F4_BASECOF], IIf(!lSS0, SF4->F4_BASECOF, SS0->S0_BASECOF), 0)
aNfItem[nItem][IT_TS][TS_ICMSST]  := IIf(lSeek .And. aPos[FP_F4_ICMSST], IIf(!lSS0, SF4->F4_ICMSST , SS0->S0_ICMSST), "1")
aNfItem[nItem][IT_TS][TS_ISSST]   := IIf(lSeek .And. aPos[FP_F4_ISSST], IIf(!lSS0, SF4->F4_ISSST  , SS0->S0_ISSST), "1")
aNfItem[nItem][IT_TS][TS_AGRPIS]  := IIf(lSeek .And. aPos[FP_F4_AGRPIS], IIf(!lSS0, SF4->F4_AGRPIS , SS0->S0_AGRPIS), "2")
aNfItem[nItem][IT_TS][TS_AGRCOF]  := IIf(lSeek .And. aPos[FP_F4_AGRCOF], IIf(!lSS0, SF4->F4_AGRCOF , SS0->S0_AGRCOF), "2")
aNfItem[nItem][IT_TS][TS_AGRRETC] := IIf(lSeek .And. aPos[FP_F4_AGRRETC], IIf(!lSS0, SF4->F4_AGRRETC, SS0->S0_AGRRETC), "2")
aNfItem[nItem][IT_TS][TS_PISBRUT] := IIf(lSeek .And. aPos[FP_F4_PISBRUT], IIf(!lSS0, SF4->F4_PISBRUT, SS0->S0_PISBRUT), "2")
aNfItem[nItem][IT_TS][TS_COFBRUT] := IIf(lSeek .And. aPos[FP_F4_COFBRUT], IIf(!lSS0, SF4->F4_COFBRUT, SS0->S0_COFBRUT), "2")
aNfItem[nItem][IT_TS][TS_PISDSZF] := IIf(lSeek .And. aPos[FP_F4_PISDSZF], IIf(!lSS0, SF4->F4_PISDSZF, SS0->S0_PISDSZF), "2")
aNfItem[nItem][IT_TS][TS_COFDSZF] := IIf(lSeek .And. aPos[FP_F4_COFDSZF], IIf(!lSS0, SF4->F4_COFDSZF, SS0->S0_COFDSZF), "2")
aNfItem[nItem][IT_TS][TS_CRDEST]  := IIf(lSeek .And. aPos[FP_F4_CRDEST], IIf(!lSS0, SF4->F4_CRDEST , SS0->S0_CRDEST), "1")
aNfItem[nItem][IT_TS][TS_CRDPRES] := IIf(lSeek .And. aPos[FP_F4_CRDPRES], IIf(!lSS0, SF4->F4_CRDPRES, SS0->S0_CRDPRES) , 0)
aNfItem[nItem][IT_TS][TS_AFRMM]	 := IIf(lSeek .And. aPos[FP_F4_AFRMM], IIf(!lSS0, SF4->F4_AFRMM  , SS0->S0_AFRMM), "N")
aNfItem[nItem][IT_TS][TS_CRDTRAN] := IIf(lSeek .And. aPos[FP_F4_CRDTRAN], IIf(!lSS0, SF4->F4_CRDTRAN, SS0->S0_CRDTRAN), 0)
aNfItem[nItem][IT_TS][TS_CALCFET] := IIf(lSeek .And. aPos[FP_F4_CALCFET], IIf(!lSS0, SF4->F4_CALCFET, SS0->S0_CALCFET), "2")
aNfItem[nItem][IT_TS][TS_DESCOND] := IIf(lSeek .And. aPos[FP_F4_DESCOND], IIf(!lSS0, SF4->F4_DESCOND, SS0->S0_DESCOND), "2")
aNfItem[nItem][IT_TS][TS_CRPREPR] := IIf(lSeek .And. aPos[FP_F4_CRPREPR], IIf(!lSS0, SF4->F4_CRPREPR, SS0->S0_CRPREPR), 0)
aNfItem[nItem][IT_TS][TS_INTBSIC] := IIf(lSeek .And. aPos[FP_F4_INTBSIC], IIf(!lSS0, SF4->F4_INTBSIC, SS0->S0_INTBSIC), "0")
aNfItem[nItem][IT_TS][TS_OPERSUC] := IIf(lSeek .And. aPos[FP_F4_OPERSUC], IIf(!lSS0, SF4->F4_OPERSUC, SS0->S0_OPERSUC), "2")
aNfItem[nItem][IT_TS][TS_CREDACU] := IIf(lSeek .And. aPos[FP_F4_CREDACU], IIf(!lSS0, SF4->F4_CREDACU, SS0->S0_CREDACU), "3")
aNfItem[nItem][IT_TS][TS_CRPRERO] := IIf(lSeek .And. aPos[FP_F4_CRPRERO], IIf(!lSS0, SF4->F4_CRPRERO, SS0->S0_CRPRERO), 0)
aNfItem[nItem][IT_TS][TS_APLIRED] := IIf(lSeek .And. aPos[FP_F4_APLIRED], IIf(!lSS0, SF4->F4_APLIRED, SS0->S0_APLIRED), "2")
aNfItem[nItem][IT_TS][TS_APLIIVA] := IIf(lSeek .And. aPos[FP_F4_APLIIVA], IIf(!lSS0, SF4->F4_APLIIVA, SS0->S0_APLIIVA), "2")
aNfItem[nItem][IT_TS][TS_APLREDP] := IIf(lSeek .And. aPos[FP_F4_APLREDP], IIf(!lSS0, SF4->F4_APLREDP, SS0->S0_APLREDP), "2")
aNfItem[nItem][IT_TS][TS_CRPREPE] := IIf(lSeek .And. aPos[FP_F4_CRPREPE], IIf(!lSS0, SF4->F4_CRPREPE, SS0->S0_CRPREPE), 0)
aNfItem[nItem][IT_TS][TS_CPRESPR] := IIf(lSeek .And. aPos[FP_F4_CPRESPR], IIf(!lSS0, SF4->F4_CPRESPR, SS0->S0_CPRESPR), 0)
aNfItem[nItem][IT_TS][TS_CALCFAB] := Iif(lSeek .And. aPos[FP_F4_CFABOV], IIf(!lSS0, SF4->F4_CFABOV, SS0->S0_CFABOV), "2")
aNfItem[nItem][IT_TS][TS_CALCFAC] := Iif(lSeek .And. aPos[FP_F4_CFACS], IIf(!lSS0, SF4->F4_CFACS, SS0->S0_CFACS), "2")
aNfItem[nItem][IT_TS][TS_CRPRESP] := IIf(lSeek .And. aPos[FP_F4_CRPRESP], IIf(!lSS0, SF4->F4_CRPRESP, SS0->S0_CRPRESP), 0)
aNfItem[nItem][IT_TS][TS_MOTICMS] := IIf(lSeek .And. aPos[FP_F4_MOTICMS], IIf(!lSS0, SF4->F4_MOTICMS, SS0->S0_MOTICMS), " ")
aNfItem[nItem][IT_TS][TS_DUPLIST] := IIf(lSeek .And. aPos[FP_F4_DUPLIST], IIf(!lSS0, SF4->F4_DUPLIST, SS0->S0_DUPLIST), "2")
aNfItem[nItem][IT_TS][TS_PR35701] := IIf(lSeek .And. aPos[FP_F4_PR35701], IIf(!lSS0, SF4->F4_PR35701, SS0->S0_PR35701), 0)
aNfItem[nItem][IT_TS][TS_CODBCC]  := IIf(lSeek .And. aPos[FP_F4_CODBCC], IIf(!lSS0, SF4->F4_CODBCC , SS0->S0_CODBCC), " ")
aNfItem[nItem][IT_TS][TS_INDNTFR] := IIf(lSeek .And. aPos[FP_F4_INDNTFR], IIf(!lSS0, SF4->F4_INDNTFR, SS0->S0_INDNTFR), " ")
aNfItem[nItem][IT_TS][TS_VENPRES] := IIf(lSeek .And. aPos[FP_F4_VENPRES], IIf(!lSS0, SF4->F4_VENPRES, SS0->S0_VENPRES), " ")
aNfItem[nItem][IT_TS][TS_REDBCCE] := IIf(lSeek .And. aPos[FP_F4_REDBCCE], IIf(!lSS0, SF4->F4_REDBCCE, SS0->S0_REDBCCE), 0)
aNfItem[nItem][IT_TS][TS_VARATAC] := IIf(lSeek .And. aPos[FP_F4_VARATAC], IIf(!lSS0, SF4->F4_VARATAC, SS0->S0_VARATAC), "")
aNfItem[nItem][IT_TS][TS_DUPLIPI] := IIf(lSeek .And. aPos[FP_F4_DUPLIPI], IIf(!lSS0, SF4->F4_DUPLIPI, SS0->S0_DUPLIPI), "2")
aNfItem[nItem][IT_TS][TS_AGRPEDG] := IIf(lSeek .And. aPos[FP_F4_AGRPEDG], IIf(!lSS0, SF4->F4_AGRPEDG, SS0->S0_AGRPEDG), "3")
aNfItem[nItem][IT_TS][TS_FRETAUT] := IIf(lSeek, IIf(!lSS0, SF4->F4_FRETAUT , SS0->S0_FRETAUT), "1")
aNfItem[nItem][IT_TS][TS_MKPCMP]  := IIf(lSeek, IIf(!lSS0, SF4->F4_MKPCMP , SS0->S0_MKPCMP), "2")
aNfItem[nItem][IT_TS][TS_CFEXT]   := IIf(lSeek, IIf(!lSS0, SF4->F4_CFEXT , SS0->S0_CFEXT), "")
aNfItem[nItem][IT_TS][TS_MKPSOL]  := IIf(lSeek .And. aPos[FP_F4_MKPSOL], IIf(!lSS0, SF4->F4_MKPSOL , SS0->S0_MKPSOL), "2")
aNfItem[nItem][IT_TS][TS_LFICMST] := IIf(lSeek .And. aPos[FP_F4_LFICMST], IIf(!lSS0, SF4->F4_LFICMST, SS0->S0_LFICMST), "N")
aNfItem[nItem][IT_TS][TS_DESPRDIC]:= IIf(lSeek .And. aPos[FP_F4_DSPRDIC], IIf(!lSS0, SF4->F4_DSPRDIC, SS0->S0_DSPRDIC), "1")
aNfItem[nItem][IT_TS][TS_CTIPI]   := IIf(lSeek .And. aPos[FP_F4_CTIPI], IIf(!lSS0, SF4->F4_CTIPI, SS0->S0_CTIPI),"  ")
aNfItem[nItem][IT_TS][TS_SITTRIB] := IIf(lSeek .And. aPos[FP_F4_SITTRIB], IIf(!lSS0, SF4->F4_SITTRIB, SS0->S0_SITTRIB), "  ")
aNfItem[nItem][IT_TS][TS_CFPS]    := IIf(lSeek .And. aPos[FP_F4_CFPS], IIf(!lSS0, SF4->F4_CFPS , SS0->S0_CFPS), "")
aNfItem[nItem][IT_TS][TS_CRPRST]  := IIf(lSeek .And. aPos[FP_F4_CRPRST], IIf(!lSS0, SF4->F4_CRPRST , SS0->S0_CRPRST), 0)
aNfItem[nItem][IT_TS][TS_IPIOBS]  := IIf(lSeek .And. aPos[FP_F4_IPIOBS], IIf(!lSS0, SF4->F4_IPIOBS , SS0->S0_IPIOBS), "1")
aNfItem[nItem][IT_TS][TS_IPIPC]   := IIf(lSeek .And. aPos[FP_F4_IPIPC], IIf(!lSS0, SF4->F4_IPIPC  , SS0->S0_IPIPC), "1")
aNfItem[nItem][IT_TS][TS_PSCFST]  := IIf(lSeek .And. aPos[FP_F4_PSCFST], IIf(!lSS0, SF4->F4_PSCFST , SS0->S0_PSCFST), "2")
aNfItem[nItem][IT_TS][TS_CRPRELE] := IIf(lSeek .And. aPos[FP_F4_CRPRELE], IIf(!lSS0, SF4->F4_CRPRELE, SS0->S0_CRPRELE), 0)
aNfItem[nItem][IT_TS][TS_CONTSOC] := IIf(lSeek .And. aPos[FP_F4_CONTSOC], IIf(!lSS0, SF4->F4_CONTSOC, SS0->S0_CONTSOC), "1")
aNfItem[nItem][IT_TS][TS_COMPRED] := IIf(lSeek .And. aPos[FP_F4_COMPRED] .And. !Empty(IIf(!lSS0, SF4->F4_COMPRED, SS0->S0_COMPRED)), IIf(!lSS0, SF4->F4_COMPRED, SS0->S0_COMPRED), "1")
aNfItem[nItem][IT_TS][TS_CSTPIS]  := IIf(lSeek .And. aPos[FP_F4_CSTPIS], IIf(!lSS0, SF4->F4_CSTPIS , SS0->S0_CSTPIS), "")
aNfItem[nItem][IT_TS][TS_CSTCOF]  := IIf(lSeek .And. aPos[FP_F4_CSTCOF], IIf(!lSS0, SF4->F4_CSTCOF , SS0->S0_CSTCOF), "")
aNfItem[nItem][IT_TS][TS_RGESPST] := IIf(lSeek .And. aPos[FP_F4_RGESPST], IIf(!lSS0, SF4->F4_RGESPST, SS0->S0_RGESPST), "2")
aNfItem[nItem][IT_TS][TS_CLFDSUL] := IIf(lSeek .And. aPos[FP_F4_CLFDSUL], IIf(!lSS0, SF4->F4_CLFDSUL, SS0->S0_CLFDSUL), "2")
aNfItem[nItem][IT_TS][TS_ALSENAR] := IIf(lSeek .And. aPos[FP_F4_ALSENAR], IIf(!lSS0, SF4->F4_ALSENAR, SS0->S0_ALSENAR), 0)
aNfItem[nItem][IT_TS][TS_ESTCRED] := IIf(lSeek .And. aPos[FP_F4_ESTCRED], IIf(!lSS0, SF4->F4_ESTCRED, SS0->S0_ESTCRED), 0)
aNfItem[nItem][IT_TS][TS_CRPRSIM] := IIf(lSeek .And. aPos[FP_F4_CRPRSIM], IIf(!lSS0, SF4->F4_CRPRSIM, SS0->S0_CRPRSIM), 0)
aNfItem[nItem][IT_TS][TS_ANTICMS] := IIf(lSeek .And. aPos[FP_F4_ANTICMS], IIf(!lSS0, SF4->F4_ANTICMS, SS0->S0_ANTICMS), "2")
aNfItem[nItem][IT_TS][TS_FECPANT] := IIf(lSeek, aNfItem[nItem][IT_TS][TS_ISEFECP], "2")
aNfItem[nItem][IT_TS][TS_ISEFECP] := IIf(lSeek .And. aPos[FP_F4_ISEFECP], IIf(!lSS0, SF4->F4_ISEFECP, SS0->S0_ISEFECP), "1")
aNfItem[nItem][IT_TS][TS_BCPCST]  := IIf(lSeek .And. aPos[FP_F4_BCPCST], IIf(!lSS0, SF4->F4_BCPCST , SS0->S0_BCPCST), "1")
aNfItem[nItem][IT_TS][TS_REDANT]  := IIf(lSeek .And. aPos[FP_F4_REDANT], IIf(!lSS0, SF4->F4_REDANT , SS0->S0_REDANT), 0)
aNfItem[nItem][IT_TS][TS_PAUTICM] := IIf(lSeek .And. aPos[FP_F4_PAUTICM], IIf(!lSS0, SF4->F4_PAUTICM, SS0->S0_PAUTICM), "1")
aNfItem[nItem][IT_TS][TS_ATACVAR] := IIf(lSeek .And. aPos[FP_F4_ATACVAR], IIf(!lSS0, SF4->F4_ATACVAR, SS0->S0_ATACVAR), "2")
aNfItem[nItem][IT_TS][TS_BSRURAL] := IIf(lSeek .And. aPos[FP_F4_BSRURAL], IIf(!lSS0, SF4->F4_BSRURAL, SS0->S0_BSRURAL), "1")
aNfItem[nItem][IT_TS][TS_DBSTCSL] := IIf(lSeek .And. aPos[FP_F4_DBSTCSL], IIf(!lSS0, SF4->F4_DBSTCSL, SS0->S0_DBSTCSL), "2")
aNfItem[nItem][IT_TS][TS_DBSTIRR] := IIf(lSeek .And. aPos[FP_F4_DBSTIRR], IIf(!lSS0, SF4->F4_DBSTIRR, SS0->S0_DBSTIRR), "2")
aNfItem[nItem][IT_TS][TS_CROUTGO] := IIf(lSeek .And. aPos[FP_F4_CROUTGO], IIf(!lSS0, SF4->F4_CROUTGO, SS0->S0_CROUTGO), 0)
aNfItem[nItem][IT_TS][TS_STCONF]  := IIf(lSeek .And. aPos[FP_F4_STCONF], IIf(!lSS0, SF4->F4_STCONF , SS0->S0_STCONF), "2")
aNfItem[nItem][IT_TS][TS_CSTISS]  := IIf(lSeek .And. aPos[FP_F4_CSTISS], IIf(!lSS0, SF4->F4_CSTISS , SS0->S0_CSTISS), "  ")
aNfItem[nItem][IT_TS][TS_BSRDICM] := IIf(lSeek .And. aPos[FP_F4_BSRDICM], IIf(!lSS0, SF4->F4_BSRDICM, SS0->S0_BSRDICM), "1")
aNfItem[nItem][IT_TS][TS_CROUTSP] := IIf(lSeek .And. aPos[FP_F4_CROUTSP], IIf(!lSS0, SF4->F4_CROUTSP, SS0->S0_CROUTSP), 0)
aNfItem[nItem][IT_TS][TS_ICMSTMT] := IIf(lSeek .And. aPos[FP_F4_ICMSTMT] .And. !Empty(IIf(!lSS0, SF4->F4_ICMSTMT, SS0->S0_ICMSTMT)), IIf(!lSS0, SF4->F4_ICMSTMT, SS0->S0_ICMSTMT) , "1")
aNfItem[nItem][IT_TS][TS_CPPRODE] := IIf(lSeek .And. aPos[FP_F4_CPPRODE], IIf(!lSS0, SF4->F4_CPPRODE, SS0->S0_CPPRODE), 0)
aNfItem[nItem][IT_TS][TS_TPPRODE] := IIf(lSeek .And. aPos[FP_F4_TPPRODE], IIf(!lSS0, SF4->F4_TPPRODE, SS0->S0_TPPRODE), " ")
aNfItem[nItem][IT_TS][TS_VDASOFT] := IIf(lSeek .And. aPos[FP_F4_VDASOFT], IIf(!lSS0, SF4->F4_VDASOFT, SS0->S0_VDASOFT), "2")
aNfItem[nItem][IT_TS][TS_ISEFERN] := IIf(lSeek .And. aPos[FP_F4_ISEFERN], IIf(!lSS0, SF4->F4_ISEFERN, SS0->S0_ISEFERN), "1")
aNfItem[nItem][IT_TS][TS_NORESPE] := IIf(lSeek .And. aPos[FP_F4_NORESP], IIf(!lSS0, SF4->F4_NORESP , SS0->S0_NORESP), "2")
aNfItem[nItem][IT_TS][TS_SOMAIPI] := IIf(lSeek .And. aPos[FP_F4_SOMAIPI], IIf(!lSS0, SF4->F4_SOMAIPI, SS0->S0_SOMAIPI), "1")
aNfItem[nItem][IT_TS][TS_APSCFST] := IIf(lSeek .And. aPos[FP_F4_APSCFST], IIf(!lSS0, SF4->F4_APSCFST, SS0->S0_APSCFST), "1")
aNfItem[nItem][IT_TS][TS_CPRCATR] := IIf(lSeek .And. aPos[FP_F4_CPRECTR], IIf(!lSS0, SF4->F4_CPRECTR, SS0->S0_CPRECTR), "2")
aNfItem[nItem][IT_TS][TS_CREDPRE] := IIf(lSeek .And. aPos[FP_F4_CREDPRE], IIf(!lSS0, SF4->F4_CREDPRE, SS0->S0_CREDPRE), 0)
aNfItem[nItem][IT_TS][TS_CONSIND] := IIf(lSeek .And. aPos[FP_F4_CONSIND], IIf(!lSS0, SF4->F4_CONSIND, SS0->S0_CONSIND), "2")
aNfItem[nItem][IT_TS][TS_ISEFEMG] := IIf(lSeek .And. aPos[FP_F4_ISEFEMG], IIf(!lSS0, SF4->F4_ISEFEMG, SS0->S0_ISEFEMG), "1")
aNfItem[nItem][IT_TS][TS_ALQCMAJ] := IIf(lSeek .And. aPos[FP_F4_MALQCOF], IIf(!lSS0, SF4->F4_MALQCOF, SS0->S0_MALQCOF), 0)
aNfItem[nItem][IT_TS][TS_ALQPMAJ] := IIf(lSeek .And. aPos[FP_F4_MALQPIS], IIf(!lSS0, SF4->F4_MALQPIS, SS0->S0_MALQPIS), 0)
aNfItem[nItem][IT_TS][TS_ISEFEMT] := IIf(lSeek .And. aPos[FP_F4_ISEFEMT], IIf(!lSS0, SF4->F4_ISEFEMT, SS0->S0_ISEFEMT), "1")
aNfItem[nItem][IT_TS][TS_IPIANTE] := IIf(lSeek .And. aPos[FP_F4_IPIANT], IIf(!lSS0, SF4->F4_IPIANT , SS0->S0_IPIANT), "2")
aNfItem[nItem][IT_TS][TS_AGREGCP] := IIf(lSeek .And. aPos[FP_F4_AGREGCP], IIf(!lSS0, SF4->F4_AGREGCP, SS0->S0_AGREGCP), "1")
aNfItem[nItem][IT_TS][TS_NATOPER] := Iif(lSeek .And. aPos[FP_F4_NATOPER], IIf(!lSS0, SF4->F4_NATOPER, SS0->S0_NATOPER), "")
aNfItem[nItem][IT_TS][TS_TPCPRES] := IIf(lSeek .And. aPos[FP_F4_TPCPRES], IIf(!lSS0, SF4->F4_TPCPRES, SS0->S0_TPCPRES), "")
aNfItem[nItem][IT_TS][TS_IDHIST]  := IIf(lSeek .And. aPos[FP_F4_IDHIST], IIf(!lSS0, SF4->F4_IDHIST , SS0->S0_IDHIST), "")
aNfItem[nItem][IT_TS][TS_DEVPARC] := IIf(lSeek .And. aPos[FP_F4_DEVPARC], IIf(!lSS0, SF4->F4_DEVPARC, SS0->S0_DEVPARC), "1")
aNfItem[nItem][IT_TS][TS_PERCATM] := IIf(lSeek .And. aPos[FP_F4_PERCATM], IIf(!lSS0, SF4->F4_PERCATM, SS0->S0_PERCATM), 0 )
aNfItem[nItem][IT_TS][TS_DICMFUN] := IIf(lSeek .And. aPos[FP_F4_DICMFUN], IIf(!lSS0, SF4->F4_DICMFUN, SS0->S0_DICMFUN), "")
aNfItem[nItem][IT_TS][TS_IMPIND]  := IIf(lSeek .And. aPos[FP_F4_IMPIND], IIf(!lSS0, SF4->F4_IMPIND , SS0->S0_IMPIND), "")
aNfItem[nItem][IT_TS][TS_OPERGAR] := IIf(lSeek .And. aPos[FP_F4_OPERGAR], IIf(!lSS0, SF4->F4_OPERGAR, SS0->S0_OPERGAR), "2")
aNfItem[nItem][IT_TS][TS_FRETISS] := IIf(lSeek .And. aPos[FP_F4_FRETISS], IIf(!lSS0, SF4->F4_FRETISS, SS0->S0_FRETISS), "1")
aNfItem[nItem][IT_TS][TS_F4_STLIQ]:= IIf(lSeek .And. aPos[FP_F4_STLIQ], IIf(!lSS0, SF4->F4_STLIQ  , SS0->S0_STLIQ), "")
aNfItem[nItem][IT_TS][TS_CV139]   := IIf(lSeek .And. aPos[FP_F4_CV139], IIf(!lSS0, SF4->F4_CV139  , SS0->S0_CV139), "2")
aNfItem[nItem][IT_TS][TS_RFETALG] := IIf(lSeek .And. aPos[FP_F4_RFETALG], IIf(!lSS0, SF4->F4_RFETALG, SS0->S0_RFETALG), "")
aNfItem[nItem][IT_TS][TS_PARTICM] := IIf(lSeek .And. aPos[FP_F4_PARTICM], IIf(!lSS0, SF4->F4_PARTICM, SS0->S0_PARTICM), "")
aNfItem[nItem][IT_TS][TS_BSICMRE] := IIF(lSeek .And. aPos[FP_F4_BSICMRE], IIf(!lSS0, SF4->F4_BSICMRE, SS0->S0_BSICMRE), "")
aNfItem[nItem][IT_TS][TS_ALICRST] := IIF(lSeek .And. aPos[FP_F4_ALICRST], IIf(!lSS0, SF4->F4_ALICRST, SS0->S0_ALICRST), 0)
aNfItem[nItem][IT_TS][TS_TRANFIL] := IIf(lSeek .And. aPos[FP_F4_TRANFIL], IIf(!lSS0, SF4->F4_TRANFIL, SS0->S0_TRANFIL), "2")
aNfItem[nItem][IT_TS][TS_IPIVFCF] := IIf(lSeek .And. aPos[FP_IPIVFCF], IIf(!lSS0, SF4->F4_IPIVFCF, SS0->S0_IPIVFCF), "1")
aNfItem[nItem][IT_TS][TS_RDBSICM] := IIf(lSeek .And. aPos[FP_F4_RDBSICM], IIf(!lSS0, SF4->F4_RDBSICM, SS0->S0_RDBSICM), "2")
aNfItem[nItem][IT_TS][TS_CFAMAD]  := IIf(lSeek .And. aPos[FP_CFAMAD], IIf(!lSS0, SF4->F4_CFAMAD , SS0->S0_CFAMAD), "2")
aNfItem[nItem][IT_TS][TS_DESCISS] := IIf(lSeek .And. aPos[FP_F4_DESCISS], IIf(!lSS0, SF4->F4_DESCISS, SS0->S0_DESCISS), "1")
aNfItem[nItem][IT_TS][TS_OUTPERC] := IIf(lSeek .And. aPos[FP_F4_OUTPERC], IIf(!lSS0, SF4->F4_OUTPERC, SS0->S0_OUTPERC), 0)
aNfItem[nItem][IT_TS][TS_PISMIN]  := IIf(lSeek .And. aPos[FP_F4_PISMIN], IIf(!lSS0, SF4->F4_PISMIN, SS0->S0_PISMIN), "2")
aNfItem[nItem][IT_TS][TS_COFMIN]  := IIf(lSeek .And. aPos[FP_F4_COFMIN], IIf(!lSS0, SF4->F4_COFMIN, SS0->S0_COFMIN), "2")
aNfItem[nItem][IT_TS][TS_IPIMIN]  := IIf(lSeek .And. aPos[FP_F4_IPIMIN], IIf(!lSS0, SF4->F4_IPIMIN, SS0->S0_IPIMIN), "2")
aNfItem[nItem][IT_TS][TS_CUSENTR] := IIf(lSeek .And. aPos[FP_F4_CUSENTR], IIf(!lSS0, SF4->F4_CUSENTR, SS0->S0_CUSENTR), "2")
aNfItem[nItem][IT_TS][TS_GRPCST]  := IIf(lSeek .And. aPos[FP_F4_GRPCST], IIf(!lSS0, SF4->F4_GRPCST, SS0->S0_GRPCST), "")
aNfItem[nItem][IT_TS][TS_IPIPECR] := IIf(lSeek .And. aPos[FP_F4_IPIPECR], IIf(!lSS0, SF4->F4_IPIPECR, SS0->S0_IPIPECR), 0)
aNfItem[nItem][IT_TS][TS_CALCCPB] := IIf(lSeek .And. aPos[FP_F4_CALCCPB], IIf(!lSS0, SF4->F4_CALCCPB, SS0->S0_CALCCPB), "2")
aNfItem[nItem][IT_TS][TS_DIFAL]   := IIf(lSeek .And. aPos[FP_F4_DIFAL], IIf(!lSS0, SF4->F4_DIFAL, SS0->S0_DIFAL), "")
aNfItem[nItem][IT_TS][TS_BASCMP]  := IIf(lSeek  .And. aPos[FP_F4_BASCMP], IIf(!lSS0, SF4->F4_BASCMP, SS0->S0_BASCMP), 0)
aNfItem[nItem][IT_TS][TS_TXAPIPI] := IIf(lSeek  .And. aPos[FP_F4_TXAPIPI], IIf(!lSS0, SF4->F4_TXAPIPI, SS0->S0_TXAPIPI), 0)
aNfItem[nItem][IT_TS][TS_FTRICMS] := IIf(lSeek  .And. aPos[FP_F4_FTRICMS], IIf(!lSS0, SF4->F4_FTRICMS, SS0->S0_TXAPIPI), 0)
aNfItem[nItem][IT_TS][TS_AGRISS]  := IIf(lSeek .And. aPos[FP_F4_AGRISS], IIf(!lSS0, SF4->F4_AGRISS , SS0->S0_AGRISS), "2")
aNfItem[nItem][IT_TS][TS_CFUNDES] := IIf(lSeek .And. aPos[FP_F4_CFUNDES], IIf(!lSS0, SF4->F4_CFUNDES, SS0->S0_CFUNDES), "2")
aNfItem[nItem][IT_TS][TS_CIMAMT]  := IIf(lSeek .And. aPos[FP_F4_CIMAMT], IIf(!lSS0, SF4->F4_CIMAMT, SS0->S0_CIMAMT), "2")
aNfItem[nItem][IT_TS][TS_CFASE]   := IIf(lSeek .And. aPos[FP_F4_CFASE], IIf(!lSS0, SF4->F4_CFASE, SS0->S0_CFASE), "2")
aNfItem[nItem][IT_TS][TS_INDVF]   := Iif(lSeek .And. aPos[FP_F4_INDVF], IIf(!lSS0, SF4->F4_INDVF, SS0->S0_INDVF), "2")
aNfItem[nItem][IT_TS][TS_CSOSN]   := IIf(lSeek .And. aPos[FP_F4_CSOSN], IIf(!lSS0, SF4->F4_CSOSN, SS0->S0_CSOSN), "   ")
aNfItem[nItem][IT_TS][TS_ALIQPRO] := IIf(lSeek .And. aPos[FP_F4_ALIQPRO], IIf(!lSS0, SF4->F4_ALIQPRO, SS0->S0_ALIQPRO), 0)
aNfItem[nItem][IT_TS][TS_ALQFEEF] := IIf(lSeek .And. aPos[FP_F4_ALQFEEF], IIf(!lSS0, SF4->F4_ALQFEEF, SS0->S0_ALQFEEF) , 0)
aNfItem[nItem][IT_TS][TS_DEDDIF]  := IIf(lSeek .And. aPos[FP_F4_DEDDIF], IIf(!lSS0, SF4->F4_DEDDIF, SS0->S0_DEDDIF), "1")
aNfItem[nItem][IT_TS][TS_FCALCPR] := IIf(lSeek .And. aPos[FP_F4_FCALCPR], IIf(!lSS0, SF4->F4_FCALCPR, SS0->S0_FCALCPR), "")
aNfItem[nItem][IT_TS][TS_DIFALPC] := IIf(lSeek .And. aPos[FP_F4_DIFALPC], IIf(!lSS0, SF4->F4_DIFALPC, SS0->S0_DIFALPC), "")
aNFItem[nItem][IT_TS][TS_COLVDIF] := Iif(lSeek .AND. aPos[FP_F4_COLVDIF], IIF(!lSS0 , SF4->F4_COLVDIF , SS0->S0_COLVDIF ), "")
aNfItem[nItem][IT_TS][TS_STREDU]  := IIf(lSeek .And. aPos[FP_F4_STREDU], IIf(!lSS0, SF4->F4_STREDU, SS0->S0_STREDU) , "")
aNfItem[nItem][IT_TS][TS_FEEF]    := IIf(lSeek .And. aPos[FP_F4_FEEF], IIf(!lSS0, SF4->F4_FEEF, SS0->S0_FEEF) , "")
aNfItem[nItem][IT_TS][TS_BICMCMP] := IIf(lSeek .And. aPos[FP_F4_BICMCMP], IIf(!lSS0, SF4->F4_BICMCMP, SS0->S0_BICMCMP) ,"")
aNfItem[nItem][IT_TS][TS_CSENAR]  := IIf(lSeek .And. aPos[FP_F4_CSENAR], IIf(!lSS0, SF4->F4_CSENAR, SS0->S0_CSENAR) ,"2")
aNfItem[nItem][IT_TS][TS_CINSS]   := IIf(lSeek .And. aPos[FP_F4_CINSS], IIf(!lSS0, SF4->F4_CINSS, SS0->S0_CINSS) ,"2")
aNfItem[nItem][IT_TS][TS_APLREPC] := IIf(lSeek .And. aPos[FP_F4_APLREPC], IIf(!lSS0, SF4->F4_APLREPC, SS0->S0_APLREPC) ,"4")
aNfItem[nItem][IT_TS][TS_INDISEN] := IIf(lSeek .And. aPos[FP_F4_INDISEN], IIf(!lSS0, SF4->F4_INDISEN, SS0->S0_INDISEN) ,"2") 
aNfItem[nItem][IT_TS][TS_INFITEM] := IIf(lSeek .And. aPos[FP_F4_INFITEM], IIf(!lSS0, SF4->F4_INFITEM, SS0->S0_INFITEM) , "")


If lSeek
	If aDic[AI_CC7] .And. aDic[AI_CC6] .And. TamSx3("CC7_CODLAN")[1] == 10 .And. aPos[FP_CC7_TPREG]
		dbSelectArea("CC7")
		dbSetOrder(1)
		If CC7->(MsSeek(xFilial("CC7")+SF4->F4_CODIGO))
			While !CC7->(Eof()) .And. xFilial("CC7")+CC7->CC7_TES==xFilial("CC7")+SF4->F4_CODIGO
				// Codigos de Ajuste de Documento Fiscal (Tabela CC6)
				If (!(CC7->CC7_TPREG == "NA")) .And. (CC6->(MsSeek(xFilial("CC6")+CC7->CC7_CODLAN)))
					//Somente serao considerados lançamentos da UF do contribuinte
					//Caso o lançamento nao seja de Apuração Propria, o lançamento podera ser de qualquer UF
					If CC6->CC6_STUF == aSX6[MV_ESTADO]  .Or. CC6->CC6_TPAPUR <> "0"
						aAdd( aNFItem[nItem][IT_TS][TS_LANCFIS] ,;
								{	CC7->CC7_CODLAN ,;									// 01 - Codigo de Ajuste
								Iif( aPos[FP_CC7_IFCOMP] , CC7->CC7_IFCOMP , "" ) ,;	// 02 - Codigo da Informacao Complementar
								Iif( aPos[FP_CC7_CODREF] , CC7->CC7_CODREF , "" ) ,;	// 03 - Codigo do Reflexo
								Iif( aPos[FP_CC7_CLANC]  , CC7->CC7_CLANC  , ""  ) ,; 	// 04 - Complemento registro 0460
								Iif( aPos[FP_CC7_GUIA]   , CC7->CC7_GUIA	, "2" ) ,;	// 05 - Gera Guia de Recolhimento
								"1"} )		// 06 - Campo com código utilizado na Tes
					EndIf
				// Codigos de Ajuste de Apuracao (Tabela CDO)
				ElseIf Empty( CC7->CC7_CODLAN ) .And. aPos[FP_CC7_CLANAP] .And. !Empty( CC7->CC7_CLANAP )
					aAdd( aNFItem[nItem][IT_TS][TS_LANCFIS] ,;
							{	CC7->CC7_CLANAP ,;
							Iif( aPos[FP_CC7_IFCOMP] , CC7->CC7_IFCOMP , "" ) ,;
							Iif( aPos[FP_CC7_CODREF] , CC7->CC7_CODREF , "" ) ,;
							Iif( aPos[FP_CC7_CLANC]  , CC7->CC7_CLANC  , ""  ) ,;
							Iif( aPos[FP_CC7_GUIA]   , CC7->CC7_GUIA	, "2" ),;
							"2"} )
				ElseIf aPos[FP_CC7_CODIPI] .And. !Empty( CC7->CC7_CODIPI ) .And.  Empty( CC7->CC7_CODLAN ) .And. Empty( CC7->CC7_CLANAP )
						aAdd(  aNFItem[nItem][IT_TS][TS_LANCFIS] ,;
								{	CC7->CC7_CODIPI ,;
									Iif( aPos[FP_CC7_IFCOMP] , CC7->CC7_IFCOMP , ""  ) ,;
									Iif( aPos[FP_CC7_CODREF] , CC7->CC7_CODREF , ""  ) ,;
									Iif( aPos[FP_CC7_CLANC]  , CC7->CC7_CLANC  , ""  ) ,;
									Iif( aPos[FP_CC7_GUIA]   , CC7->CC7_GUIA  , "2" ) ,;
									"3"} )
				EndIf
				CC7->(dbSkip())
			EndDo
		EndIf
	EndIf
	RestArea(aArea)

	// Atualizo a referencia de cabecalho NF_PPDIFAL pois ela depende da config. do TES.
	// A atualizacao eh feita nesta funcao para que nao seja necessario faze-la nas demais
	// funcoes de impostos. Toda vez que o TES for carregado ela sera atualizada.
	aNfCab[NF_PPDIFAL] := ChkPPDIFAL( nItem, aMVPPDIFAL )

EndIf
cTes := aNfItem[nItem][IT_TS][TS_CODIGO]
If nItem <> Nil
	aNfItem[nItem][IT_IDSF4] := aNfItem[nItem][IT_TS][TS_IDHIST]
EndIf
Return

/*/{Protheus.doc} MaFisCPRB()
@description Contribuição Previdenciária Incidente sobre a Receita Bruta (CPRB)
@author Mauro A. Gonçalves

@history Vogas Júnior, 07/06/2018, (DSERFIS1-6133) alterada forma de obtensão da Base de cálculo CPRB.
/*/
Static Function MaFisCPRB(nItem )

Local nAlq 			:= 0
Local nBaseCPRB		:= 0
Local lAgreg		:= .F.

If aSX6[MV_CPRBNF] .And. aNFItem[nItem][IT_TS][TS_CALCCPB]=="1" .And. aNFItem[nItem][IT_BASEPS2]>0
	If aNFCab[NF_TIPONF] == "D" .And. !Empty(aNFItem[nItem][IT_RECORI]) // devolucao
		If aNFCab[NF_OPERNF] == "S" .And. aNFCab[NF_CLIFOR] == "F"
			dbSelectArea("SD1")
			MsGoto(aNFItem[nItem][IT_RECORI])
			nAlq := SD1->D1_ALIQCPB
		Else
			If cPaisLoc == "BRA"
				dbSelectArea("SD2")
				MsGoto(aNFItem[nItem][IT_RECORI])
				nAlq := SD2->D2_ALIQCPB
			EndIf
		EndIf
	Else
		nAlq := aNfItem[nItem][IT_PRD][SB_CG1_ALIQ]
	Endif
	If nAlq > 0
		If !aNFItem[nItem][IT_TS][TS_PISCRED] $ "5" .AND. !aNfItem[nItem][IT_TIPONF]$"I|P"

			nBaseCPRB := aNfItem[nItem][IT_VALMERC]-IIf(aNFItem[nItem][IT_TS][TS_AGREG]$"DR",aNfItem[nItem][IT_DEDICM],0)

			//Tratamento do Agrega Valor - PIS / COF / ICMS
			nAliqAgr := 0

			If aNFItem[nItem][IT_TS][TS_AGREG]=="I"
				If aNFItem[nItem][IT_TS][TS_ICM] == "N"
				nAliqAgr += aNfItem[nItem][IT_ALIQSOL]
					lAgreg	 := .T.
				Else
					If aNfCab[NF_PPDIFAL]
						nAliqAgr += aNfItem[nItem][IT_ALIQCMP]+aNfItem[nItem][IT_ALFCCMP]
					Else
						nAliqAgr += aNfItem[nItem][IT_ALIQICM]
					Endif
					lAgreg	 := .T.
				EndIf
			EndIf

			If aNFItem[nItem][IT_TS][TS_AGRPIS]=="P"
				nAliqAgr += aNfItem[nItem][IT_ALIQPS2]
				lAgreg	 := .T.
				If aNFItem[nItem][IT_TS][TS_AGRCOF]=="C"
					nAliqAgr += aNfItem[nItem][IT_ALIQCF2]
				Endif
			Endif

			If lAgreg

				If aSX6[MV_RNDICM]
					nBaseCPRB := Round(nBaseCPRB / ( 1 - (nAliqAgr/100)) , 2 )
				Else
					nBaseCPRB := nBaseCPRB / ( 1 - (nAliqAgr/100))
				EndIf

			Endif

			If aNFItem[nItem][IT_TS][TS_AGREG] == "I" .And. !lAgreg
				nBaseCPRB += If(aNFitem[nItem][IT_TIPONF ]<>"I",aNfItem[nItem][IT_VALICM],0)
			EndIf

			If !(aNFItem[nItem][IT_TS][TS_AGREG]=="I" .AND. lAgreg .AND. aSX6[MV_DBSTPIS]$"1|6" .AND. IntTms()) //Tratamento para não duplicar o valor do icms na base de pis
				nBaseCPRB := ( nBaseCPRB - IIf( aNFItem[nItem][IT_TS][TS_PISBRUT] == "1" , 0 , (aNfItem[nItem][IT_DESCONTO]+aNfItem[nItem][IT_DESCTOT]+aNfItem[nItem][IT_DS43080]) ) + aNfItem[nItem][IT_DESCZFCOF] + aNfItem[nItem][IT_DESCZFPIS] + IIf(aNfItem[nItem][IT_DESCZFPIS]<>0,0,IIF(aNFItem[nItem][IT_TS][TS_CRPRST]<>0 .And. IntTms(),aNfItem[nitem][IT_VLCSOL],aNfItem[nitem][IT_VALSOL])) )
			EndIf

			If ( !(aNfCab[NF_CLIFOR]=="C" .And. aNfCab[NF_CALCSUF]$"SI" .And. !aNFitem[nItem][IT_TIPONF ]$"BD" .And. ;
				aNFItem[nItem][IT_TS][TS_ISS] <> "S" .And. aSX6[MV_DESCZF] .And. aSX6[MV_DESZFPC] ) .And. aSX6[MV_FRTBASE] ) .Or. aSX6[MV_FRTBASE]
				nBaseCPRB += IIf(aNFItem[nItem][IT_TS][TS_DESPPIS] <> "2",aNfItem[nItem][IT_DESPESA],0) + IIF(aNFItem[nItem][IT_TS][TS_DESPPIS] <> "2",aNfItem[nItem][IT_SEGURO],0) + IIF(aNFItem[nItem][IT_TS][TS_DESPPIS] <> "2",aNfItem[nItem][IT_FRETE],0)
			EndIf

			If aNFItem[nItem][IT_TS][TS_CREDIPI] == "N" .AND. aSX6[MV_DEDBCPR]$"S,P" .AND. aNFItem[nItem][IT_TS][TS_IPI]<>"R"
				nBaseCPRB += aNfItem[nItem][IT_VALIPI]
			EndIf

			If aNFCab[NF_DEDBSPC] $ " 1" 

				If aSX6[MV_DEDBCPR]$"S,I"
					nBaseCPRB -= aNfItem[nItem][IT_VALICM]
				EndIf

				// Caso seja comerciante atacadista, o valor do IPI deve ser retirado da base de calculo do PIS pois esta embutido no valor da mercadoria
				If aNFItem[nItem][IT_TS][TS_CREDIPI] == "S" .And. aSX6[MV_DEDBCPR]$"S,P" .And. aNFItem[nItem][IT_TS][TS_IPI] == "R"
					nBaseCPRB -= aNfItem[nItem][IT_VALIPI]
				EndIf

			EndIf

			//Exclui valor do Difal (EC/15) da base de cálculo de PIS
			IF aNfItem[nItem][IT_TS][TS_DIFALPC] == '1'
				nBaseCPRB -= (aNfItem[nItem][IT_DIFAL]+aNfItem[nItem][IT_VALCMP]+aNfItem[nItem][IT_VFCPDIF])
			EndIF

			If aSX6[MV_CRDBPIS] $ "S" .And. Substr(aNfItem[nItem][IT_CF],1,1)=="3"
				nBaseCPRB += aNfItem[nItem][IT_VALICM]
			EndIf
			If aNFItem[nItem][IT_TS][TS_PISDSZF] == "2"
				nBaseCPRB += aNfItem[nItem][IT_DESCZF] - (aNfItem[nItem][IT_DESCZFCOF] + aNfItem[nItem][IT_DESCZFPIS])
			Endif

			// Tratamento para retirada do valor do ICMS solidario da base do PIS Apuracao
			If ((MaFisDbST("PS2",nItem) .Or. (aSX6[MV_RPCBIZF] .And. aNfCab[NF_SUFRAMA])) .And. aNfItem[nItem][IT_DESCZFPIS] == 0)
				nBaseCPRB -= IIF(aNFItem[nItem][IT_TS][TS_CRPRST]<>0 .And. IntTms(),aNfItem[nItem][IT_VLCSOL],aNfItem[nItem][IT_VALSOL])
			Endif						

			aNfItem[nItem][IT_BASECPB] := nBaseCPRB

			If !aSX6[MV_RNDICM] .And. lAgreg
				MaItArred(nItem,{"IT_BASECPB"})
			EndIf

			If aNFItem[nItem][IT_TS][TS_OPERSUC]=="1" .And. aNfCab[NF_SIMPSC]<>"1" .And. aNFCab[NF_SIMPNAC]<>"1" // Operacoes com Sucata
				nBaseCPRB := (aNFitem[nItem][IT_VALICM] / ( (100-(aNFitem[nItem][IT_ALIQICM]+aNFitem[nItem][IT_ALIQPS2]+aNFitem[nItem][IT_ALIQCF2]))/100 ) )
				aNfItem[nItem][IT_BASECPB] := nBaseCPRB
			Endif			

		Else
			aNfItem[nItem][IT_BASECPB] := 0
		EndIf
	
		aNfItem[nItem][IT_ALIQCPB]	:= nAlq
		aNfItem[nItem][IT_VALCPB]	:= aNfItem[nItem][IT_BASECPB] * nAlq / 100
		aNfItem[nItem][IT_CODATIV]	:= aNfItem[nItem][IT_PRD][SB_CODATIV]
	Endif
Else
	aNfItem[nItem][IT_ALIQCPB]	:= 0
	aNfItem[nItem][IT_BASECPB]	:= 0
	aNfItem[nItem][IT_VALCPB]	:= 0
Endif

Return

Function ActItemNf(nItem,nCampo,aActItem,lNoret)

	Default lNoret := .F.

	nCampo := Iif(nCampo <> 0,nCampo,VerificanCampo(nCampo))

	If ALLTRIM(FUNNAME()) $ "MATA410"
		If len (aNfItem) >= nItem
			aNfItem[nItem][IT_BASEIMP][nCampo]	:= aActItem[1]
			aNfItem[nItem][IT_ALIQIMP][nCampo]	:= aActItem[2]
			aNfItem[nItem][IT_VALIMP][nCampo]	:= IIF(aNfItem[nItem][IT_DELETED] .OR. lNoret = .T.,0,aNfItem[nItem][IT_VALIMP][nCampo])
		EndIf
	Else
		aNfItem[nItem][IT_BASEIMP][nCampo]	:= aActItem[1]
		aNfItem[nItem][IT_ALIQIMP][nCampo]	:= aActItem[2]
		aNfItem[nItem][IT_VALIMP][nCampo]	:= IIF(aNfItem[nItem][IT_DELETED] .OR. lNoret = .T.,0,aNfItem[nItem][IT_VALIMP][nCampo])
	EndIf

Return

Function ActCabNf(nCampo,cImposto,nBase,nReten)
	DEFAULT cImposto  := ""
	If len(aNfCab[NF_IMPOSTOS2]) > 0
		nPosimp = Ascan(aNfCab[NF_IMPOSTOS2],{|x| x[1] == cImposto })	   //33
		If nPosimp > 0
			aNfCab[NF_IMPOSTOS2][nPosimp][3] := nBase
			aNfCab[NF_IMPOSTOS2][nPosimp][4] := nReten
			aNfCab[NF_BASEIMP][nCampo] := nBase
			aNfCab[NF_VALIMP][nCampo] := nReten
			aNfCab[NF_VLRORIG][nCampo] := nReten
		Endif
	Endif
	If len(aNfCab[NF_IMPOSTOS]) > 0
		nPosimp = Ascan(aNfCab[NF_IMPOSTOS],{|x| x[1] == cImposto })      //30
		If nPosimp > 0
			if nbase==0
				aNfCab[NF_IMPOSTOS]:=Adel(aNfCab[NF_IMPOSTOS],nPosimp)
				aNfCab[NF_IMPOSTOS]:=aSize(aNfCab[NF_IMPOSTOS],Len(aNfCab[NF_IMPOSTOS])-1)
			else
				aNfCab[NF_IMPOSTOS][nPosimp][3] := nBase
				aNfCab[NF_IMPOSTOS][nPosimp][4] := nReten
			endif
		endif
	endif
Return

/*/{Protheus.doc} MaFisDbST()
@description Esta funcao retorna se o valor do ICMS-ST deverá ou não
ser descontado da base do PIS/COFINS/CSLL (apuração e retenção).
Estão concentradas aqui as regras genéricas para o desconto. Regras
especificas deverão ser implementadas na função do próprio tributo.
@author joao.pellegrini
/*/
Static Function MaFisDbST(cImposto, nItem)

Local lRet := .F.
Local cMVDBST := ""

// Obtendo valor do parametro MV_DBSTXXX conforme o imposto
Do Case
	Case cImposto == "PS2"
		cMVDBST := aSX6[MV_DBSTPIS]
	Case cImposto == "CF2"
		cMVDBST := aSX6[MV_DBSTCOF]
	Case cImposto == "PIS"
		cMVDBST := aSX6[MV_DBSTPSR]
	Case cImposto == "COF"
		cMVDBST := aSX6[MV_DBSTCFR]
	Case cImposto == "CSL"
		cMVDBST := aSX6[MV_DBSTCLR]
EndCase

// Conteudo dos parametros MV_DBSTXXX:
// 1 - Nunca retira
// 2 - Retira se houver credito do ICMS ST
// 3 - Retira se nao houver credito do ICMS ST
// 4 - Retira se houver credito do ICMS normal
// 5 - Retira se nao houver credito do ICMS normal
// 6 - Sempre retira
Do Case
	Case cMVDBST == "1"
		lRet := .F.
	Case cMVDBST == "2"
		lRet := (aNFItem[nItem][IT_TS][TS_CREDST] == "1" .Or. (aNFItem[nItem][IT_TS][TS_CREDST] == "2" .And. aNfCab[NF_OPERNF] == "E"))
	Case cMVDBST == "3"
		lRet := (aNFItem[nItem][IT_TS][TS_CREDST] == "4" .Or. (aNFItem[nItem][IT_TS][TS_CREDST] == "2" .And. aNfCab[NF_OPERNF] == "S"))
	Case cMVDBST == "4"
		lRet := aNFItem[nItem][IT_TS][TS_CREDICM] == "S"
	Case cMVDBST == "5"
		lRet := aNFItem[nItem][IT_TS][TS_CREDICM] == "N"
	Case cMVDBST == "6"
		lRet := .T.
EndCase

Return lRet

/*/
MaFisINSP - Diego Dias - 06/08/2016
Calcula o INSS Patronal.
/*/
Static Function MaFisINSP(nItem, cExecuta)

DEFAULT cExecuta  := "BSE|ALQ|VLR"

If "BSE" $ cExecuta
	
	aNfItem[nItem][IT_BASEINP]	:=	0

	If	aNFItem[nItem][IT_TS][TS_DUPLIC] == "S" .And. !Empty(aNfCab[NF_NATUREZA]) .And. aInfNat[NT_CALCINP] == "1" .And. ;
		aInfNat[NT_PERCINP] > 0 .And. aNfCab[NF_CALCINP] == "1" .And. aNFCab[NF_OPERNF] == "E" .And. aNFCab[NF_CLIFOR] == "F" .And. ;
		( (Len(AllTrim(aNFCab[NF_CNPJ])) < 14 .And. Len(AllTrim(aNFCab[NF_CNPJ])) > 1) .Or. aNfCab[NF_TPJFOR] == '3' ) //O Inss Patronal será calculado para pessoa física ou MEI.

		aNfItem[nItem][IT_BASEINP]	:= aNfItem[nItem][IT_VALMERC]

		If aNfItem[nItem][IT_REDINSS] > 0
			aNfItem[nItem][IT_BASEINP] := (aNfItem[nItem][IT_BASEINP] * (aNfItem[nItem][IT_REDINSS] / 100))
		EndIf	
	EndIf

EndIF

If "ALQ" $ cExecuta
	aNfItem[nItem][IT_PERCINP]	:=	0
	aNfItem[nItem][IT_PERCINP]	:= aInfNat[NT_PERCINP]
EndIF

If "VLR" $ cExecuta
	aNfItem[nItem][IT_VALINP]	:=	0
	aNfItem[nItem][IT_VALINP]	:= aNfItem[nItem][IT_BASEINP] * aInfNat[NT_PERCINP] /100
EndIF

Return

/*/{Protheus.doc} MaSeekCFC()
@description Função que trata posicionamento da tabela CFC (UF x UF)
para prencimento das váriaveis de calculo de FECP e DIFAL.
@author joao.balbio
/*/
Static Function MaSeekCFC(nOpc,nItem)

Default nOpc := 0
Default nItem := 0

//nOpc (variavel de controle da chamada da função)
//nOpc = 1 (MaFisIni - Atualiza somente o cabeçalho, caso não encontre gera com valores defaults)
//nOpc = 2 (MafisCfo - Atualiza item com base na CFC, caso não encontre gera com valores defaults)
//nOpc = 3 (MaFisCPO - Atualiza item com base na CFC, caso não econtre o cadastro não utiliza default)

// Se houver alteração do estado de destino reposiciono a tabela CFC UF x UF.
If nOpc == 1
	If aDic[AI_CFC] .And. aPos[FP_CFC_CODPRD] .And. CFC->( MsSeek( xFilial( "CFC" ) + Iif(aNfCab[NF_TIPONF] == "D", aNFCab[NF_UFDEST] + aNFCab[NF_UFORIGEM], aNFCab[NF_UFORIGEM] + aNFCab[NF_UFDEST]) + PadR( ' ' , TamSx3( 'CFC_CODPRD' )[1] ) ) )
		aNfCab[NF_UFXUF][UF_ALIQFECP]	:= CFC->CFC_ALQFCP
		aNfCab[NF_UFXUF][UF_MARGSTLIQ]	:= Iif( aPos[FP_CFC_MGLQST] , CFC->CFC_MGLQST , 0		)
		aNfCab[NF_UFXUF][UF_ALIQSTLIQ]	:= Iif( aPos[FP_CFC_ALQSTL] , CFC->CFC_ALQSTL , 0		)
		aNfCab[NF_UFXUF][UF_MARGEM]		:= Iif( aPos[FP_CFC_MARGEM] , CFC->CFC_MARGEM , 0		)
		aNfCab[NF_UFXUF][UF_ALQFCPO]	:= Iif( aPos[FP_CFC_ALFCPO] , CFC->CFC_ALFCPO , 0		)
		aNfCab[NF_UFXUF][UF_FECPAUX]	:= Iif( aPos[FP_CFC_FCPAUX] , CFC->CFC_FCPAUX , 0		)
		aNfCab[NF_UFXUF][UF_FECPDIF]	:= Iif( aPos[FP_CFC_FCPXDA] , CFC->CFC_FCPXDA , '1'	)
		aNfCab[NF_UFXUF][UF_FECPINT]	:= Iif( aPos[FP_CFC_FCPINT] , CFC->CFC_FCPINT , '1'	)
		aNfCab[NF_UFXUF][UF_RDCTIMP]	:= Iif( aPos[FP_CFC_RDCTIM] , CFC->CFC_RDCTIM , 1)
		aNfCab[NF_UFXUF][UF_MVAFRU]		:= Iif( aPos[FP_MV_MVAFRU] , &(aSX6[MV_MVAFRU]),0)
		aNfCab[NF_UFXUF][UF_MVAES]		:= Iif( aPos[FP_CFC_MVAES]  , CFC->CFC_MVAES  , '1'	)
		aNfCab[NF_UFXUF][UF_ADICST]		:= Iif( aPos[FP_CFC_ADICST] , CFC->CFC_ADICST  , 0 )
		aNfCab[NF_UFXUF][UF_PICM]		:= Iif( aPos[FP_CFC_PICM] , CFC->CFC_PICM  , 0 )
		aNfCab[NF_UFXUF][UF_VLICMP]		:= Iif( aPos[FP_CFC_VLICMP] , CFC->CFC_VLICMP  , 0 )
		aNfCab[NF_UFXUF][UF_VL_ICM]		:= Iif( aPos[FP_CFC_VL_ICM] , CFC->CFC_VL_ICM  , 0 )
		aNfCab[NF_UFXUF][UF_VL_ANT]		:= Iif( aPos[FP_CFC_VL_ANT] , CFC->CFC_VL_ANT  , 0 )
		aNfCab[NF_UFXUF][UF_BS_FCPPR]	:= Iif( aPos[FP_CFC_BFCPPR] , CFC->CFC_BFCPPR  , '' )
		aNfCab[NF_UFXUF][UF_BS_FCPST]	:= Iif( aPos[FP_CFC_BFCPST] , CFC->CFC_BFCPST  , '' )
		aNfCab[NF_UFXUF][UF_BS_FCPCM]	:= Iif( aPos[FP_CFC_BFCPCM] , CFC->CFC_BFCPCM  , '' )
		aNfCab[NF_UFXUF][UF_AFCPST]	   := Iif( aPos[FP_CFC_AFCPST] , CFC->CFC_AFCPST  , '1' )
		aNfCab[NF_UFXUF][UF_ALFEEF]	   := Iif( aPos[FP_CFC_ALFEEF] , CFC->CFC_ALFEEF  , 0 )
		aNfCab[NF_UFXUF][UF_PAUTFOB]   := Iif( aPos[FP_CFC_PAUTFB] , CFC->CFC_PAUTFB  , 0 )
	Else
		aNfCab[NF_UFXUF][UF_ALIQFECP]	:= 0
		aNfCab[NF_UFXUF][UF_MARGSTLIQ]	:= 0
		aNfCab[NF_UFXUF][UF_ALIQSTLIQ]	:= 0
		aNfCab[NF_UFXUF][UF_MARGEM]		:= 0
		aNfCab[NF_UFXUF][UF_ALQFCPO]	:= 0
		aNfCab[NF_UFXUF][UF_FECPAUX]	:= 0
		aNfCab[NF_UFXUF][UF_FECPDIF]	:= '1'
		aNfCab[NF_UFXUF][UF_FECPINT]	:= '1'
		aNfCab[NF_UFXUF][UF_RDCTIMP]	:= 0
		aNfCab[NF_UFXUF][UF_MVAFRU]		:= 0
		aNfCab[NF_UFXUF][UF_MVAES]		:= '1'
		aNfCab[NF_UFXUF][UF_ADICST]		:= 0
		aNfCab[NF_UFXUF][UF_PICM]		:= 0
		aNfCab[NF_UFXUF][UF_VLICMP]		:= 0
		aNfCab[NF_UFXUF][UF_VL_ICM]		:= 0
		aNfCab[NF_UFXUF][UF_VL_ANT]		:= 0
		aNfCab[NF_UFXUF][UF_BS_FCPPR]	:= ''
		aNfCab[NF_UFXUF][UF_BS_FCPST]	:= ''
		aNfCab[NF_UFXUF][UF_BS_FCPCM]	:= ''
		aNfCab[NF_UFXUF][UF_AFCPST]    := '1'
		aNfCab[NF_UFXUF][UF_ALFEEF]    := 0
		aNfCab[NF_UFXUF][UF_PAUTFOB]   := 0
	EndIf
Else
	If (nOpc == 2 .Or. nOpc == 3) .And. aNfitem <> NIL .And. nItem > 0
		If aDic[AI_CFC] .And. CFC->( MsSeek( xFilial( "CFC" ) + Iif(aNfCab[NF_TIPONF] == "D", aNFCab[NF_UFDEST] + aNFCab[NF_UFORIGEM], aNFCab[NF_UFORIGEM] + aNFCab[NF_UFDEST]) + aNfItem[nItem][IT_PRD][SB_COD] ) )
			aNfItem[nItem][IT_UFXPROD][UFP_ALIQFECP]	:=	CFC->CFC_ALQFCP
			aNfItem[nItem][IT_UFXPROD][UFP_MARGSTLIQ]	:=	Iif( aPos[FP_CFC_MGLQST] , CFC->CFC_MGLQST , 0   )
			aNfItem[nItem][IT_UFXPROD][UFP_ALIQSTLIQ]	:=	Iif( aPos[FP_CFC_ALQSTL] , CFC->CFC_ALQSTL , 0   )
			aNfItem[nItem][IT_UFXPROD][UFP_MARGEM]		:=	Iif( aPos[FP_CFC_MARGEM] , CFC->CFC_MARGEM , 0   )
			aNfItem[nItem][IT_UFXPROD][UFP_ALQFCPO]		:=	Iif( aPos[FP_CFC_ALFCPO] , CFC->CFC_ALFCPO , 0   )
			aNfItem[nItem][IT_UFXPROD][UFP_FECPAUX]		:=	Iif( aPos[FP_CFC_FCPAUX] , CFC->CFC_FCPAUX , 0   )
			aNfItem[nItem][IT_UFXPROD][UFP_FECPDIF]		:=	Iif( aPos[FP_CFC_FCPXDA] , CFC->CFC_FCPXDA , '1' )
			aNfItem[nItem][IT_UFXPROD][UFP_FECPINT]		:=	Iif( aPos[FP_CFC_FCPINT] , CFC->CFC_FCPINT , '1' )
			aNfItem[nItem][IT_UFXPROD][UFP_RDCTIMP]		:=	Iif( aPos[FP_CFC_RDCTIM] , CFC->CFC_RDCTIM , 1 )
			aNfItem[nItem][IT_IDCFC]			:= 	CFC->CFC_IDHIST
			aNfItem[nItem][IT_UFXPROD][UFP_MVAFRU]		:=	Iif( aPos[FP_MV_MVAFRU] , &(aSX6[MV_MVAFRU]) , 0   )
			aNfItem[nItem][IT_UFXPROD][UFP_MVAES]		:=	Iif( aPos[FP_CFC_MVAES]  , CFC->CFC_MVAES  , '1' )
			aNfItem[nItem][IT_UFXPROD][UFP_ADICST]   :=  Iif( aPos[FP_CFC_ADICST]  , CFC->CFC_ADICST  , 0 )
			aNfItem[nItem][IT_UFXPROD][UFP_PICM]   :=  Iif( aPos[FP_CFC_PICM]  , CFC->CFC_PICM  , 0 )
			aNfItem[nItem][IT_UFXPROD][UFP_VLICMP]   := Iif( aPos[FP_CFC_VLICMP]  , CFC->CFC_VLICMP  , 0 )
			aNfItem[nItem][IT_UFXPROD][UFP_VL_ICM]   := Iif( aPos[FP_CFC_VL_ICM]  , CFC->CFC_VL_ICM  , 0 )
			aNfItem[nItem][IT_UFXPROD][UFP_VL_ANT]   := Iif( aPos[FP_CFC_VL_ANT]  , CFC->CFC_VL_ANT  , 0 )
			aNfItem[nItem][IT_UFXPROD][UFP_BS_FCPPR]	:= Iif( aPos[FP_CFC_BFCPPR] , CFC->CFC_BFCPPR  , '' )
			aNfItem[nItem][IT_UFXPROD][UFP_BS_FCPST]	:= Iif( aPos[FP_CFC_BFCPST] , CFC->CFC_BFCPST  , '' )
			aNfItem[nItem][IT_UFXPROD][UFP_BS_FCPCM]	:= Iif( aPos[FP_CFC_BFCPCM] , CFC->CFC_BFCPCM  , '' )
			aNfItem[nItem][IT_UFXPROD][UFP_AFCPST]	   := Iif( aPos[FP_CFC_AFCPST] , CFC->CFC_AFCPST  , '1' )
			aNfItem[nItem][IT_UFXPROD][UFP_ALFEEF]	   := Iif( aPos[FP_CFC_ALFEEF] , CFC->CFC_ALFEEF  , 0 )
			aNfItem[nItem][IT_UFXPROD][UFP_PAUTFOB]	   := Iif( aPos[FP_CFC_PAUTFB] , CFC->CFC_PAUTFB  , 0 )
		ElseIf nOpc == 2
			aNfItem[nItem][IT_UFXPROD][UFP_ALIQFECP]	:=	0
			aNfItem[nItem][IT_UFXPROD][UFP_MARGSTLIQ]	:=	0
			aNfItem[nItem][IT_UFXPROD][UFP_ALIQSTLIQ]	:=	0
			aNfItem[nItem][IT_UFXPROD][UFP_MARGEM]		:=	0
			aNfItem[nItem][IT_UFXPROD][UFP_ALQFCPO]		:=	0
			aNfItem[nItem][IT_UFXPROD][UFP_FECPAUX]		:=	0
			aNfItem[nItem][IT_UFXPROD][UFP_FECPDIF]		:=	'1'
			aNfItem[nItem][IT_UFXPROD][UFP_FECPINT]		:=	'1'
			aNfItem[nItem][IT_UFXPROD][UFP_RDCTIMP]		:=	1
			aNfItem[nItem][IT_IDCFC]			:= 	''
			aNfItem[nItem][IT_UFXPROD][UFP_MVAFRU]		:=	Iif( aPos[FP_MV_MVAFRU] , &(aSX6[MV_MVAFRU]) , 0   )
			aNfItem[nItem][IT_UFXPROD][UFP_MVAES]		:=	'1'
			aNfItem[nItem][IT_UFXPROD][UFP_ADICST]   :=  0
			aNfItem[nItem][IT_UFXPROD][UFP_PICM]   :=  0
			aNfItem[nItem][IT_UFXPROD][UFP_VLICMP]   := 0
			aNfItem[nItem][IT_UFXPROD][UFP_VL_ICM]   := 0
			aNfItem[nItem][IT_UFXPROD][UFP_VL_ANT]   := 0
			aNfItem[nItem][IT_UFXPROD][UFP_BS_FCPPR]	:= ''
			aNfItem[nItem][IT_UFXPROD][UFP_BS_FCPST]	:= ''
			aNfItem[nItem][IT_UFXPROD][UFP_BS_FCPCM]	:= ''
			aNfItem[nItem][IT_UFXPROD][UFP_AFCPST]    := '1'
			aNfItem[nItem][IT_UFXPROD][UFP_ALFEEF]   := 0
			aNfItem[nItem][IT_UFXPROD][UFP_PAUTFOB]   := 0
		Endif
	EndIf
EndIf

Return

/*/
MaFisPROT - Diego Dias - 19/01/2017
Calcula o PROTEGE-GO.
/*/
Static Function MaFisPROT(nItem)
Local nCrOutPrtg := 0
Local nReduzICMS := 0
Local nVlrBase   := 0
Local nDifVlr    := 0
Local nRedPrtg   := 0
Local nVlrBaseCr := 0
Local nIsenPrtg  := 0
Local nRedBaST   := 0
Local nVlrBaseIs := 0

aNfItem[nItem][IT_BASEPRO]	:=	0
aNfItem[nItem][IT_ALIQPRO]	:=	0
aNfItem[nItem][IT_VALPRO]	:=	0

// Verifica se deverá calcular o PROTEGE-GO
If	(aNFItem[nItem][IT_TS][TS_ALIQPRO] > 0) .AND. ((aNFCab[NF_UFORIGEM]=="GO") .OR. (aNFCab[NF_UFDEST]=="GO"))

	// Carrega a reducao da base do ICMS
	If !Empty(aNFitem[nItem,IT_EXCECAO]) .And. aNfItem[nItem,IT_EXCECAO,14] > 0
		nReduzICMS := aNfItem[nItem,IT_EXCECAO,14]
	Else
		nReduzICMS := aNFItem[nItem][IT_TS][TS_BASEICM]
	EndIf

	// Carrega a reducao da base do ICMS ST
	nRedBaST	  := Iif(Len(aNFItem[nItem][IT_EXCECAO]) > 0 .And. aNFItem[nItem][IT_EXCECAO][26] > 0,aNFItem[nItem][IT_EXCECAO][26],aNFItem[nItem][IT_TS][TS_BSICMST])

	// Credito Outorgado
	If	aNFCab[NF_UFORIGEM]=="GO" .And. aNFCab[NF_OPERNF]=='S' .And. SubStr(aNfItem[nItem][IT_CF],1,1) $ "6" .And.;
		aNFItem[nItem][IT_TS][TS_CONSUMO]$"N" .And. aNfItem[nItem][IT_LIVRO][LF_CROUTGO] > 0 .Or. aNfItem[nItem][IT_LIVRO][LF_CRDPRES] > 0

		// Valor PROTEGE-GO no Credito Outorgado. Eh recomendavel utilizar SEMPRE o campo
		// de credito presumido generico - CRDPRES - pois eh com base nele que sao gerados
		// os lancamentos na apuracao atraves dos codigos de reflexo quando necessario.
		If aNfItem[nItem][IT_LIVRO][LF_CRDPRES] > 0
			nVlrBaseCr := aNfItem[nItem][IT_LIVRO][LF_CRDPRES]
		Else
			nVlrBaseCr	:= aNfItem[nItem][IT_LIVRO][LF_CROUTGO]
		EndIf

		nCrOutPrtg	:= nVlrBaseCr * aNFItem[nItem][IT_TS][TS_ALIQPRO] / 100
	Endif

	// Isenção de ICMS
	If	aNfItem[nItem][IT_LIVRO][LF_ISENICM] > 0
		nVlrBaseIs	:= aNfItem[nItem][IT_LIVRO][LF_ISENICM]
		nIsenPrtg	:= nVlrBaseIs * aNFItem[nItem][IT_TS][TS_ALIQPRO] / 100
	EndIf

	If	(nReduzICMS > 0) .Or. (nRedBaST > 0)
		If	aNFCab[NF_UFORIGEM]=="GO" .And. aNFCab[NF_OPERNF]=='S' .And. SubStr(aNfItem[nItem][IT_CF],1,1) $ "5"

			// Base Original do ICMS
			nVlrBase := aNfItem[nItem][IT_BASEICM] + aNfItem[nItem][IT_LIVRO][LF_OUTRICM]

			// Valor do ICMS Original - Valor do ICMS com redução
			nDifVlr  := (nVlrBase * aNfItem[nItem][IT_ALIQICM] / 100) - aNfItem[nItem][IT_VALICM]

			// Valor PROTEGE-GO na Redução de ICMS = Valor da diferença * Aliquota PROTEGE-GO
			nRedPrtg := nDifVlr * aNFItem[nItem][IT_TS][TS_ALIQPRO] / 100

		ElseIf aNFCab[NF_UFDEST]=="GO" .AND. aNFCab[NF_OPERNF]=='S' .And. SubStr(aNfItem[nItem][IT_CF],1,1) $ "6"

			// Base Original do ICMS ST
			nVlrBase := aNfItem[nItem][IT_BASESOL] + aNfItem[nItem][IT_LIVRO][LF_OUTRICM]

			// Valor do ICMS ST Original - Valor do ICMS com redução
			nDifVlr  := (nVlrBase * aNfItem[nItem][IT_ALIQSOL] / 100) - aNfItem[nItem][IT_VALSOL]

			// Valor PROTEGE-GO na Redução de ICMS ST = Valor da diferença * Aliquota PROTEGE-GO
			nRedPrtg := nDifVlr * aNFItem[nItem][IT_TS][TS_ALIQPRO] / 100

		Endif
	EndIf
EndIf

// Base PROTEGE-GO
aNfItem[nItem][IT_BASEPRO]	:= nVlrBaseIs + nVlrBaseCr + nDifVlr

// Aliquota PROTEGE-GO
aNfItem[nItem][IT_ALIQPRO]	:= aNFItem[nItem][IT_TS][TS_ALIQPRO]

// Valor do PROTEGE-GO
aNfItem[nItem][IT_VALPRO]	:=	nIsenPrtg + nCrOutPrtg + nRedPrtg

Return

/*/
MaFisFEEF - Simone dos Santos Oliveira # 22/02/2017
Calcula o FEEF-RJ.
/*/
static function MaFisFEEF(nItem)

local nVlrBaseIs:= 0
local nIsenFEEF	:= 0
local nVlrBase	:= 0
local nDifVlr	:= 0
local nRedFEEF	:= 0
local nVlrBaseST:= 0
local nDifVlrST	:= 0
local nRedSTFEEF:= 0
local nICMSDif	:= 0
local nICMCDif	:= 0
local nDifVlrDif:= 0
local nDifFEEF	:= 0
local nVlrBaseCr:= 0
local nCrPreFEEF:= 0
local nReduzICMS:= 0
local nRedBaST	:= 0
local nValIcIsen:= 0
local nAliqFEEF	:= 0
local nBaseCompl:= 0
local nValoCompl:= 0
local nVlrMerc	:= 0
local nPercRdICM:= 0
local nBaseICCmp:= 0
local nAliqICCmp:= 0
local nValoICCmp:= 0
Local lDevCompra:= aNfCab[NF_TIPONF] == "D" .And. aNfCab[NF_OPERNF] == "S" .And. aNFCab[NF_CLIFOR] == "F" .And. !Empty(aNFItem[nItem][IT_RECORI])
aNfItem[nItem][IT_BASFEEF]	:=	0
aNfItem[nItem][IT_ALQFEEF]	:=	0
aNfItem[nItem][IT_VALFEEF]	:=	0


	// Nova Regra # Verifico primeiro se há configuração na CFC com os devidos campos e caso não haja, busca o legado.
	// Se for utilizar nova regra pela CFC deverá preencher o campo Calc. FEEF ? (F4_FEEF) na TES para definir se cálcula ou não. Caso a configuração seja pelo legado (TES), o campo F4_FEEF poderá estar em branco.

	if aNfItem[nItem][IT_UFXPROD][UFP_ALFEEF] > 0 .and. aNFItem[nItem][IT_TS][TS_FEEF]== '1'  //Calcula FEEF = Sim
		nAliqFEEF:= aNfItem[nItem][IT_UFXPROD][UFP_ALFEEF]
	elseif (aNFItem[nItem][IT_TS][TS_ALQFEEF] > 0) .and. ( empty(aNFItem[nItem][IT_TS][TS_FEEF]) .or. aNFItem[nItem][IT_TS][TS_FEEF]== '1'  ) //legado
		nAliqFEEF:= aNFItem[nItem][IT_TS][TS_ALQFEEF]
	endif

	// Verifica se deverá calcular o FEEF, considerando configuração da TES ou UF X UF (Tabela CFC)


	If nAliqFEEF > 0

		/* Isenção */
		nVlrBaseIs := aNfItem[nItem][IT_LIVRO][LF_ISENICM]

		if nVlrBaseIs > 0
			//Verifico o valor que seria pago caso não houvesse isenção
			nValIcIsen := nVlrBaseIs * aNfItem[nItem][IT_ALIQICM] / 100

			//Valor FEEF - Isenção
			nIsenFEEF := nValIcIsen * nAliqFEEF / 100
		endif

		/* Redução de Base de Cálculo  */

		// Carrega a reducao da base do ICMS
		If ! empty(aNFitem[nItem,IT_EXCECAO]) .And. aNfItem[nItem,IT_EXCECAO,14] > 0
			nReduzICMS := aNfItem[nItem,IT_EXCECAO,14]
		Else
			nReduzICMS := aNFItem[nItem][IT_TS][TS_BASEICM]
		EndIf

		if nReduzICMS > 0
			if aNFItem[nItem][IT_TS][TS_BASEICM] > 0
				//Base do ICMS
				nVlrBase := aNfItem[nItem][IT_BASEICM] + aNfItem[nItem][IT_LIVRO][LF_OUTRICM] + aNfItem[nItem][IT_LIVRO][LF_ISENICM]

				//Calcula a diferença entre o valor do ICMS original com o valor do ICMS com Redução
				nDifVlr := (nVlrBase * aNfItem[nItem][IT_ALIQICM] / 100) - aNfItem[nItem][IT_VALICM]

				//Valor FEEF - Redução Base de Cálculo
				nRedFEEF := nDifVlr * nAliqFEEF / 100
			endif
		endif

		/* Redução de Base de Cálculo - ST  */

		// Carrega a reducao da base do ICMS ST
		nRedBaST	  := Iif(Len(aNFItem[nItem][IT_EXCECAO]) > 0 .And. aNFItem[nItem][IT_EXCECAO][26] > 0,aNFItem[nItem][IT_EXCECAO][26],aNFItem[nItem][IT_TS][TS_BSICMST])

		if nRedBaST > 0
			//Verifica se houve redução de ICMS ST
			nVlrBaseST := aNfItem[nItem][IT_BASESOL] + aNfItem[nItem][IT_LIVRO][LF_OUTRICM]

			//Calcula a diferença entre o valor do ICMS original e o valor do ICMS com redução
			nDifVlrST := (nVlrBaseST * aNfItem[nItem][IT_ALIQSOL] / 100) - aNfItem[nItem][IT_VALSOL]

			//Valor FEEF - Redução Base de Cálculo ST
			nRedSTFEEF := nDifVlrST * nAliqFEEF / 100
		endif

		/* Diferimento  */
		//Calcula a diferença entre o valor do ICMS sem Diferimento e o valor do ICMS D
		nDifVlrDif := aNfItem[nItem][IT_ICMSDIF]

		if nDifVlrDif > 0
			//Valor FEEF - Diferimento
			nDifFEEF := nDifVlrDif * nAliqFEEF / 100
		endif

		/* Credito Presumido  */
		//Valor da Base Crédito Presumido
		nVlrBaseCr := aNfItem[nItem][IT_LIVRO][LF_CRDPRES]

		if nVlrBaseCr > 0
			//Calcula o valor do FEEF
			nCrPreFEEF := nVlrBaseCr * nAliqFEEF / 100
		endif

		/* Cálculo do FEEF sobre o diferencial de alíquota com benefícios */  
		
		If aNfItem[nItem][IT_BSICARD] > 0 .and. aNfItem[nItem][IT_VLICARD] > 0
		
			nVlrMerc 	:=	aNfItem[nItem][IT_VALMERC] 								//Valor de Compra da Mercadoria				//O2 
			nBaseICCmp	:=	aNfItem[nItem][IT_BSICARD]								//Base ICMS Complementar					//T2
			nAliqICCmp	:=	aNfItem[nItem][IT_ALIQCMP] - aNFItem[nItem,IT_ALIQICM]	//Aliquota ICMS Comp.						//U2
			
			nValoICCmp	:=	(nBaseICCmp * nAliqICCmp) / 100	 						//Valor do ICMS Comp. 						//V2
			
			nBaseCompl	:=	((nVlrMerc - nBaseICCmp) * nAliqICCmp) / 100			//Base FEEF									//W2
			
			nValoCompl	:=	(nBaseCompl * nAliqFEEF) / 100							//Valor FEEF								//Y2
		
		EndIf
	EndIf	

	If lDevCompra .and. aPos[FP_D1_VALFEEF] .and. aPos[FP_D1_BASFEEF]
		SD1->(MsGoto(aNFItem[nItem][IT_RECORI]))
		If aNfItem[nItem][IT_QUANT] == SD1->D1_QUANT 
			nBaseCompl	:=	SD1->D1_BASFEEF	//Base FEEF		//W2
			nValoCompl	:=	SD1->D1_VALFEEF //Valor FEEF	//Y2
		EndIf	
	EndIf	

	/* Soma dos valores  */
	// Aliquota FEEF-RJ
	aNfItem[nItem][IT_ALQFEEF] := nAliqFEEF

	// Base FEEF-RJ
	aNfItem[nItem][IT_BASFEEF] := nVlrBaseIs + nDifVlr + nDifVlrST + nDifVlrDif + nVlrBaseCr + nBaseCompl

	// Valor FEEF-RJ
	aNfItem[nItem][IT_VALFEEF] := nIsenFEEF + nRedFEEF + nRedSTFEEF + nDifFEEF + nCrPreFEEF + nValoCompl

return

Static Function MaFisAIEst(nItem)
Local nAlqIcmOri	:= 0
Local cExceRes13	:=	"6107|6108|6929"

If aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST]
	// Se o usuario alterou a aliquota de ICMS e inseriu uma aliquota interestadual (7, 12 ou 4) respeito a aliquota inserida.
	If (aNfItem[nItem][IT_ALIQICM] == 4 .Or. aNfItem[nItem][IT_ALIQICM] == 7 .Or. aNfItem[nItem][IT_ALIQICM] == 12)
		nAlqIcmOri := aNfItem[nItem][IT_ALIQICM]
	Else
		If (aNFCab[NF_UFORIGEM] $ aSX6[MV_NORTE])
			nAlqIcmOri := 12
		Else
			nAlqIcmOri := IIf(aNFCab[NF_UFDEST] $ aSX6[MV_NORTE], 7, 12)
		EndIf

		If SubStr(aNfItem[nItem][IT_CLASFIS], 1, 1) $ "1|2|3|8"	 .And. !Alltrim(aNfItem[nItem][IT_CF]) $ cExceRes13
			nAlqIcmOri := 4
		EndIf
	EndIf

EndIf
Return nAlqIcmOri

/*/{Protheus.doc} MaAliqSimp()
@description Função responsável por retornar a alíquota do ICMS ou ISS
calculada pela apuração do SIMPLES NACIONAL.
@author joao.pellegrini
/*/
Static Function MaAliqSimp(nItem, cTpAliq)

Local nRet := 0
Local nPosAlq := 0

If cTpAliq == "ICMS" .And. !Empty(AllTrim(aNfItem[nItem][IT_CF]))
	nPosAlq := aScan(aNfCab[NF_ALIQSN], {|x| AllTrim(x[SN_CFOP]) == AllTrim(aNfItem[nItem][IT_CF])})
ElseIf cTpAliq == "ISS" .And. !Empty(AllTrim(aNfItem[nItem][IT_CODISS]))
	nPosAlq := aScan(aNfCab[NF_ALIQSN], {|x| AllTrim(x[SN_CODISS]) == AllTrim(aNfItem[nItem][IT_CODISS])})
EndIf

If nPosAlq > 0
	nRet := aNfCab[NF_ALIQSN][nPosAlq][SN_ALIQ]
EndIf

Return nRet

/*/{Protheus.doc} loadRefAlt()
@description Função responsável por efetuar a carga do array aRefAlt,
utilizado para controlar as referências que foram alteradas via MaFisAlt
ou MaFisLoad e, assim, evitar desfazer estas alterações durante os recálculos.
@author joao.pellegrini
/*/
Static Function loadRefAlt(nItem)

Local nX   := 0
Local nPos := 0

aAdd(aRefAlt, Array(Len(aNFItem[nItem])))
nPos := Len(aRefAlt)

For nX := 1 to Len(aNfItem[nItem])

	If ValType(aNfItem[nItem][nX]) == "A"
		aRefAlt[nPos, nX] := Array(Len(aNfItem[nItem][nX]))
		aFill(aRefAlt[nPos, nX], .F.)
	Else
		aRefAlt[nPos, nX] := .F.
	EndIf

Next nX

Return

/*/{Protheus.doc} PPDIFAL()
Função que fará validação para preencher a referência NF_PPDIFAL do aNfCAb
@author erick.dias
20/04/2018
/*/
Static Function ChkPPDIFAL( nItem, aMVPPDIFAL )

Local lRet:= .F.

lRet	:= Iif(valType(aMVPPDIFAL)== "A", Len(aMVPPDIFAL)>0 .And. Year(aNfCab[NF_DTEMISS]) >= aMVPPDIFAL[1][1] .And. ;
			    aNfItem[nItem][IT_TS][TS_DIFAL]=="1" .And. ;
			    aNFCab[NF_UFORIGEM] <> aNFCab[NF_UFDEST] .And. ;
			    aNFCab[NF_LINSCR] .And.;
			    (Iif(IntTms() .And. nModulo == 43, Iif(aNfCab[NF_TPFRETE] == "F",.T.,.F.),.T.)),.F.)

Return lRet


/*/{Protheus.doc} MaCodDecl()
Função que fará enquadramento da tabela F3K para calcular Valores Declaratorios
@author Rafael.Soliveira
20/04/2018
/*/
Static function MaCodDecl(nItem)
Local aArea    	:= {}
Local cChave	:= aNfItem[nItem][IT_PRD][SB_COD]+aNfItem[nItem][IT_CF]+SubStr(aNfItem[nItem][IT_CLASFIS],2,2)

If aNfCab[NF_CODDECL] == "N"
	Return
EndIf

aArea    	:= GetArea()
//Valida se possui estrutura para calcular valor Declaratorio
If  Empty(aNfCab[NF_CODDECL])
	IF !aSX6[MV_GIAEFD] .And. aDic[AI_F3K] .And. aDic[AI_CDV] .And. aPos[FP_F3K_CODREF] .And. aPos[FP_F3K_CST] .And. ;
		aPos[FP_CDV_NUMITE] .And. aPos[FP_CDV_SEQ] .And. aPos[FP_CDV_TPMOVI] .And. !Empty(F3K->(IndexKey(2)))		
		aNfCab[NF_CODDECL] := "S"
	Else 
		aNfCab[NF_CODDECL] := "N"
		RestArea(aArea)
		Return
	Endif
Endif

aNFItem[nItem][IT_CODDECL] := {}

dbSelectArea("F3K")
F3K->(dbSetOrder(2))

If F3K->(MsSeek(xFilial("F3K")+cChave))
	While !F3K->(Eof()) .AÐnd. xFilial("F3K")+F3K->(F3K_PROD+F3K_CFOP+F3K_CST)==xFilial("F3K")+cChave
		If (CDY->(MsSeek(xFilial("CDY")+F3K->F3K_CODAJU)))
			If Substring(F3K->F3K_CODAJU,1,2) == aSX6[MV_ESTADO] .And. !EmpTy(F3K->F3K_CST) .And. !EmpTy(F3K->F3K_CODREF)				
				aAdd( aNFItem[nItem][IT_CODDECL] ,;
					{F3K->F3K_CODAJU,;				// 1 - Codigo de Ajuste
					CDY->CDY_DESCR,; 				// 2 - Descricao Código
					F3K->F3K_CODREF,; 				// 3 - Codigo do Reflexo
					F3K->F3K_CFOP,;					// 4 - CFOP
					F3K->F3K_CST})  				// 5 - CST ICMS
					
			Endif
		Endif	
	F3K->(dbSkip())
	EndDo
Endif

RestArea(aArea)
Return

/*/{Protheus.doc} MaCalcRefl()
Função que Calculo do Reflexo
@author Rafael.Soliveira
20/04/2018
/*/

Static Function MaCalcRefl(aGrava,nZ,nI,aParam)

Local cBase		:= ""
Local cAliq		:= ""
Local cValor	:= ""
Local cVL197	:= ""
Local nAliqVal	:= 0
Local nValor	:= 0
Local nBase		:= 0
Local nAliq		:= 0
Local lGerou	:= .F.
Local cTrbGen   := ""
Local nPosGen   := 0

	//Se encontrar relacionamento com a tabela de Reflexo (CE0) nas validacoes acima, atribuo as variaveis abaixo
	cBase		:= CE0->CE0_NFBASE
	cAliq		:= CE0->CE0_NFALIQ
	nAliqVal	:= CE0->CE0_NFALVA
	cValor		:= CE0->CE0_NFVALO
	If aPos[FP_CE0_VL197]
		cVL197	:= CE0->CE0_VL197
	Endif
	cCodRefl := CE0->CE0_CODIGO
	If aPos[FP_CE0_TRGEN]
		cTrbGen := CE0->CE0_TRGEN
	EndIf

	//Case para definir o valor da Base de Calculo do ajuste
	Do Case
		Case cBase == '1'	; nBase	:=	aNfItem[ nZ , IT_BASEICM ]
		Case cBase == '2'	; nBase	:=	aNfItem[ nZ , IT_LIVRO , LF_VALCONT ]
		Case cBase == '3'	; nBase	:=	aNfItem[ nZ , IT_VALICM ]
		Case cBase == '4'	; nBase	:=	aNfItem[ nZ , IT_BASESOL ]
		Case cBase == '5'	; nBase	:=	aNfItem[ nZ , IT_BASEICA ]
		Case cBase == '6'	; nBase	:=	aNfItem[ nZ , IT_LIVRO , LF_CRDEST ]
		Case cBase == '7'	; nBase	:=	aNfItem[ nZ , IT_BASEDES ] //base de cálculo difal ec87/15
		Case cBase == '8'	; nBase	:=	aNfItem[ nZ , IT_BICMORI ] // Base original
		Case cBase == '9'	; nBase	:=	aNfItem[ nZ , IT_BASEIPI ]
		Case cBase == 'A'	; nBase	:=	aNfItem[ nZ , IT_BASETST]
		Case cBase == 'B'	; nBase	:=	aNfItem[ nZ , IT_VALTST]
		Case cBase == 'C'	; nBase	:=	aNfItem[ nZ , IT_BICMORI ] - aNfItem[ nZ , IT_BASEICM ]			
		Case cBase == 'D'	; nBase	:=	aNfItem[ nZ , IT_BASFEEF ] 
		Case cBase == 'E'   ; nBase :=  IIf((nPosGen := aScan(aNFItem[nZ][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_SIGLA]) == AllTrim(cTrbGen)})) > 0, aNFItem[nZ][IT_TRIBGEN][nPosGen][TG_IT_BASE], 0)
		Case cBase == 'F'   ; nBase :=  IIf((nPosGen := aScan(aNFItem[nZ][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_SIGLA]) == AllTrim(cTrbGen)})) > 0, aNFItem[nZ][IT_TRIBGEN][nPosGen][TG_IT_VALOR], 0)
		Case cBase == 'G'	; nBase	:=	aNfItem[ nZ , IT_BICMEFET ] 
		Case cBase == 'Z'	; nBase	:=	0
	EndCase
	//Case para definir o valor do ajuste
	Do Case
		Case cValor == '1'	; nValor	:= aNfItem[ nZ , IT_VALICM ]
		Case cValor == '2'	; nValor	:= aNfItem[ nZ , IT_VALCMP ] - aNfItem[ nZ,IT_VALFECP ]
		Case cValor == '3'	; nValor	:= aNfItem[ nZ , IT_VALMERC ]
		Case cValor == '4'	; nValor	:= aNfItem[ nZ , IT_VALANTI ]
		Case cValor == '5'	; nValor	:= aNfItem[ nZ , IT_LIVRO , LF_CRDPRES ]
		Case cValor == '6'	; nValor	:= aNfItem[ nZ , IT_VALSOL ]
		Case cValor == '7'	; nValor	:= aNfItem[ nZ , IT_ESTCRED ]
		Case cValor == '8'	; nValor	:= aNfItem[ nZ , IT_ICMSDIF ]
		Case cValor == '9'	; nValor	:= nBase * nAliqVal / 100
		Case cValor == 'A'	; nValor	:= aNfItem[ nZ , IT_VALFECP ] + aNfItem[ nZ , IT_VFECPMG ] + aNfItem[ nZ , IT_VFECPRN ] + aNfItem[ nZ , IT_VFECPMT ]
		Case cValor == 'B'	; nValor	:= aNfItem[ nZ , IT_VFECPST ] + aNfItem[ nZ , IT_VFESTMG ] + aNfItem[ nZ , IT_VFESTRN ] + aNfItem[ nZ , IT_VFESTMT ]
		Case cValor == 'C'	; nValor	:= aNfItem[ nZ , IT_VALICA ]
		Case cValor == 'D'	; nValor	:= aNfItem[ nZ , IT_DIFAL ]
		Case cValor == 'E'	; nValor	:= aNfItem[ nZ , IT_VALCMP ]
		Case cValor == 'F'	; nValor	:= aNfItem[ nZ , IT_VFCPDIF]
		Case cValor == 'G'	; nValor	:= aNfItem[ nZ , IT_VLSLXML] - aNfItem[ nZ , IT_VALSOL]// Ajust ICMS ST - CH TTZZE6
		Case cValor == 'H'	; nValor	:= aNfItem[ nZ , IT_VALSOL] - aNfItem[ nZ , IT_VALANTI]
		Case cValor == 'J'	; nValor	:= aNfItem[ nZ , IT_VALICM ] - aNfItem[ nZ , IT_LIVRO , LF_CRDPRES ]
		Case cValor == 'K'	; nValor	:= aNfItem[ nZ , IT_VALIPI ]
		Case cValor == 'L'	; nValor	:= aNfItem[ nZ , IT_VALTST]
		Case cValor == 'M'	; nValor	:= (aNfItem[ nZ , IT_BICMORI ] - aNfItem[ nZ , IT_BASEICM ]) * aNfItem[ nZ , IT_ALIQICM ] / 100
		Case cValor == 'N'  ; nValor    := IIf((nPosGen := aScan(aNFItem[nZ][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_SIGLA]) == AllTrim(cTrbGen)})) > 0, aNFItem[nZ][IT_TRIBGEN][nPosGen][TG_IT_VALOR], 0)
		Case cValor == 'O'	; nValor	:= aNfItem[ nZ , IT_LIVRO , LF_ISENICM ]
		Case cValor == 'P'	; nValor	:= aNfItem[ nZ , IT_LIVRO , LF_VALCONT ]
		Case cValor == 'Q'	; nValor	:= aNfItem[ nZ , IT_LIVRO , LF_OUTRICM ]
		Case cValor == 'R'	; nValor	:= aNfItem[ nZ , IT_LIVRO , LF_CPPRODE ]
		Case cValor == 'S'	; nValor	:= aNfItem[ nZ , IT_VALFEEF ] 
		Case cValor == 'T'	; nValor	:= aNfItem[ nZ,  IT_ICMNDES]  
		Case cValor == 'U'	; nValor	:= aNfItem[ nZ , IT_VICMEFET]
		Case cValor == 'V'	; nValor	:= aNfItem[ nZ , IT_VALSOL] + aNfItem[ nZ , IT_VALICM ]
		Case cValor == 'W'	; nValor	:= aNfItem[ nZ , IT_VICMEFET] + aNfItem[ nZ , IT_VALICM ]

	EndCase
	//Case para definir o valor da Aliquota do ajuste
	Do Case
		Case cAliq == '1'	; nAliq	:=	aNfItem[ nZ , IT_ALIQICM ]
		Case cAliq == '2'	; nAliq	:=	aNFItem[nZ][IT_TS][ TS_CRDPRES ]
		Case cAliq == '3'	; nAliq	:=	aNfItem[ nZ , IT_ALIQSOL ]
		Case cAliq == '4'	; nAliq	:=	aNFItem[nZ][IT_TS][ TS_ESTCRED ]
		Case cAliq == '5'	; nAliq	:=	aNfItem[ nZ , IT_ALIQCMP ] - aNfItem[ nZ, IT_ALIQICM ] - Iif( aNfItem[ nZ , IT_ALFCCMP ] > 0 , aNfItem[ nZ , IT_ALFCCMP ] , aNfItem[ nZ , IT_ALIQFECP ] )
		Case cAliq == '6'	; nAliq	:=	nAliqVal
		Case cAliq == '7'	; nAliq	:=	Iif( aNfItem[ nZ , IT_ALFCCMP ] > 0 , aNfItem[ nZ , IT_ALFCCMP ] , aNfItem[ nZ , IT_ALIQFECP ] + aNfItem[nZ, IT_ALFECMG] + aNfItem[nZ, IT_ALFECRN ] + aNfItem[nZ, IT_ALFECMT ] )
		Case cAliq == '8'	; nAliq	:=	aNfItem[ nZ , IT_ALFCST ] + aNfItem[nZ, IT_ALFECMG]	+ aNfItem[nZ, IT_ALFECRN ] + aNfItem[nZ, IT_ALFECMT ]
		Case cAliq == '9'	; nAliq	:=	aNfItem[ nZ , IT_ALIQCMP ] - aNfItem[ nZ , IT_ALIQDIF] - Iif( aNfItem[ nZ , IT_ALFCCMP ] > 0 , aNfItem[ nZ , IT_ALFCCMP ] , aNfItem[ nZ , IT_ALIQFECP ] )
		Case cAliq == 'A'	; nAliq	:=	aNfItem[ nZ , IT_ALIQIPI ]	//IPI
		Case cAliq == 'B'	; nAliq	:=	aNfItem[ nZ , IT_ALIQTST]
		Case cAliq == 'C'	; nAliq	:=	aNfItem[ nZ , IT_ALQFEEF]
		Case cAliq == 'D'   ; nAliq :=  IIf((nPosGen := aScan(aNFItem[nZ][IT_TRIBGEN], {|x| AllTrim(x[TG_IT_SIGLA]) == AllTrim(cTrbGen)})) > 0, aNFItem[nZ][IT_TRIBGEN][nPosGen][TG_IT_ALIQUOTA], 0)
		Case cAliq == 'E'	; nAliq	:=	aNfItem[ nZ , IT_ALQCMEFET]
		Case cAliq == 'Z'	; nAliq :=	0
	EndCase

	If nValor > 0 .Or. cValor == 'I'  //Ressarcimento
		aAdd(aGrava,{aNfItem[nZ,IT_ITEM],;//1 - Item
						aParam[1]	,;//2 - Codigo de Lancamento
						"1"	,;		//3 - Sistema
						nBase,;		//4 - Base de Calculo
						nAliq,;		//5 - Aliquota
						nValor,;	//6 - Valor Calculado
						aParam[2],;	//7 - Sequencia
						aParam[3],;	//8 - Informacoes Complementares
						aParam[4],;	//9 - Tipo de Utilidade do Lancamento
						cVL197,;	//10- Gravação do valor em ICMS ou OUTROS
						aParam[5],;	//11-Complemento para Registro 0460
						aParam[6],;	//12-Codigo Reflexo
						aParam[7],; //13 - Gera GNRE
						aParam[8],; //14 - Campo origem CC7
						aParam[9],;	// 15 - CFOP						
						aParam[10],; //16 - lIVRO
						aParam[11]}) //17 - Descrição DO CÓDIGO						

		lGerou	:=	.T.
	EndIf
Return lGerou

/*±±³Funcao    ³MaFisISSBi ³ Autor ³ Caio Martins Data  ³19/10/2018³ ±±
±±³Descrio ³A funcao efetua o calculo do ISS BI Tributado (Cepom) ³±±*/

Static Function MaFisISSBi(nItem,cExecuta)
Local cMunSM0	:= Iif(Len(Alltrim(SM0->M0_CODMUN))==5, Alltrim(SM0->M0_CODMUN), Substr(Alltrim(SM0->M0_CODMUN),3,5) )
Local lSeekCE1	:= .F.
Local cUFBusca	:= ""
Local cMunBusca	:= ""

DEFAULT cExecuta  := "BSE|ALQ|VLR"

CE1->(dbSetOrder(1))

If aNfItem[nItem][IT_ISSCPM] .And. aNfItem[nItem][IT_VALISS] > 0
	If ("ALQ" $ cExecuta)
		IF aNfCab[NF_OPERNF] == "E"
			cUFBusca := SM0->M0_ESTENT
			cMunBusca := cMunSM0
		Else
			cUFBusca := aNFCab[NF_UFDEST]
			cMunBusca := cMunForISS
		EndIf

		// Abaixo 2 Seeks na CE1 porque o produto não é obrigatório
		If CE1->(msSeek(xFilial("CE1")+aNfItem[nItem][IT_CODISS]+cUFBusca+cMunBusca+aNfItem[nItem][IT_PRODUTO]))
			lSeekCE1 := .T.
		ElseIf CE1->(msSeek(xFilial("CE1")+aNfItem[nItem][IT_CODISS]+cUFBusca+cMunBusca))
			lSeekCE1 := .T.
		EndIf

		If lSeekCE1
			aNfItem[nItem][IT_ALQCPM]:= CE1->CE1_ALQISS
		EndIf
	EndIf

	If ("BSE" $ cExecuta)
		aNfItem[nItem][IT_BASECPM] := aNfItem[nItem][IT_BASEISS]
	EndIf

	If ("VLR" $ cExecuta)
		If aNfItem[nItem][IT_ALQCPM] > 0
			aNfItem[nItem][IT_VALCPM] := aNfItem[nItem][IT_BASECPM] * (aNfItem[nItem][IT_ALQCPM]/100)
		EndIf
		If aNfItem[nItem][IT_VALCPM] <=0
			aNfItem[nItem][IT_VALCPM] := 0
			aNfItem[nItem][IT_BASECPM] := 0
		EndIf
	EndIf

EndIf

Return

/*±±³Funcao MaSeekCLI ³ Autor ³   Caio Martins     Data  ³19/10/2018³ ±±
±±³Descrio ³A funcao efetua o calculo do ISS BI Tributado (Cepom) ³±±*/

Static Function MaSeekCLI(nItem)
Local lBiTrib := .F.
Local cMunSM0 := Iif(Len(Alltrim(SM0->M0_CODMUN))==5, Alltrim(SM0->M0_CODMUN), Substr(Alltrim(SM0->M0_CODMUN),3,5) )

aNfItem[nItem][IT_ISSCPM] := .F.

If cPaisLoc == "BRA" .And. aDic[AI_CLI] .And. !(aNFCab[NF_TIPONF]$"DB")

	CLI->(dbSetOrder(1))

	IF aNfCab[NF_OPERNF] == "E" 
		IF CLI->(MsSeek(xFilial("CLI")+"1"+aNfItem[nItem][IT_CODISS]+SM0->M0_ESTENT+cMunSM0+aNfCab[NF_CODCLIFOR]+aNfCab[NF_LOJA]))
			aNfItem[nItem][IT_ISSCPM] := .T.
		EndIF
	Else
		IF CLI->(MsSeek(xFilial("CLI")+"2"+aNfItem[nItem][IT_CODISS]+aNFCab[NF_UFDEST]+cMunForISS))
			aNfItem[nItem][IT_ISSCPM] := .T.
		EndIf
	EndIf
EndIf

Return

/*/{Protheus.doc} MaFisTG()
@description Gravação/Exclusão dos tributos genéricos
@author erick.dias
/*/
Function MaFisTG(nOper, cAlias, nItem, cIdTrbGen)
Local cRet			:= ""
DEFAULT cAlias		:= ""
DEFAULT cIdTrbGen	:= ""
DEFAULT nOper 		:= 1

If aDic[AI_F2D]
	If nOper == 1 //Gravação dos tributos genéricos
		//Se já ter informações gravadas na F2d com este ID preciso deletar para refazer
		xFisDelTrbGen(aNfItem[nItem][IT_ID_TRBGEN])		
		//Chamo função para gravação.
		cRet	:= xFisGrvTrbGen(aNfItem, nItem,cAlias)
	ElseIF nOper == 2 //Exclusão dos tributos genéricos
		xFisDelTrbGen(cIdTrbGen)
	EndIF
EndIf
Return cRet

/*/{Protheus.doc} MaFisBrwTG()
@description Função responsável por retornar o grid para visualização
ou alteração dos tributos genéricos por item.
@author joao.pellegrini
@version 12.1.17
/*/
Function MaFisBrwTG(oJanela, aPosicao, lVisual)

Local oGrid := NIL
Local aHdrTrbGen := xFisHdrTG()
Local aColTrbGen := {{Space(4), CriaVar("F2D_TRIB"), CriaVar("F2B_DESC"), CriaVar("F2D_BASE"), CriaVar("F2D_ALIQ"), CriaVar("F2D_VALOR"), .F.}}

DEFAULT lVisual := .T.

oGrid := MsNewGetDados():New( aPosicao[1], aPosicao[2], aPosicao[4], aPosicao[3], Iif(lVisual,0,GD_UPDATE), "AllwaysTrue", "AllwaysTrue", "AllwaysTrue", {"F2D_BASE","F2D_ALIQ","F2D_VALOR"}, 0, 999, "AllwaysTrue", "", "AllwaysTrue", oJanela, aHdrTrbGen, aColTrbGen )

Return oGrid

/*/{Protheus.doc} MaFisLinTG()
@description Função responsável por efetuar a carga do browse
do componente de visualização/alteração dos tributos genéricos.
@author joao.pellegrini
@version 12.1.17
/*/
Function MaFisLinTG(oBrowse, nItem)

Local nTrbGen := 0
Local aColTrbGen := {{Space(4), CriaVar("F2D_TRIB"), CriaVar("F2B_DESC"), CriaVar("F2D_BASE"), CriaVar("F2D_ALIQ"), CriaVar("F2D_VALOR"), .F.}}

oBrowse:aCols := {}

If MaFisFound("IT", nItem) .And. !aNfItem[nItem][IT_DELETED]

	If !Empty(aNfItem[nItem][IT_TRIBGEN])	
		aColTrbGen	:= {}
		For nTrbGen := 1 to Len(aNfItem[nItem][IT_TRIBGEN])
			IF aNFitem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_BASE] > 0 .Or. aNFitem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_VALOR] > 0
				aAdd(aColTrbGen, {})
				nPosTrbGen := Len(aColTrbGen)
				aAdd(aColTrbGen[nPosTrbGen], aNFitem[nItem][IT_ITEM])
				aAdd(aColTrbGen[nPosTrbGen], aNFitem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_SIGLA])
				aAdd(aColTrbGen[nPosTrbGen], aNFitem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_DESCRICAO])
				aAdd(aColTrbGen[nPosTrbGen], aNFitem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_BASE])
				aAdd(aColTrbGen[nPosTrbGen], aNFitem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_ALIQUOTA])
				aAdd(aColTrbGen[nPosTrbGen], aNFitem[nItem][IT_TRIBGEN][nTrbGen][TG_IT_VALOR])
				aAdd(aColTrbGen[nPosTrbGen], .F.)
			EndIF
		Next nTrbGen
	EndIf
	
EndIf

oBrowse:SetArray(aClone(aColTrbGen))
oBrowse:Refresh(.T.)

Return .T.

/*/{Protheus.doc} MaFisTGRef()
@description Função utilizada no folder dos tributos genéricos por item
para disparar os recálculos quando houver alguma alteração manual na
base, alíquota ou valor.
@author joao.pellegrini
@version 12.1.17
/*/
Function MaFisTGRef(cReferencia,xValor,aTrbGen,nItem)

Local lRet := .F.
Local nPosBas   := aScan(aHeader, {|x| AllTrim(x[2]) == "F2D_BASE"})
Local nPosAlq   := aScan(aHeader, {|x| AllTrim(x[2]) == "F2D_ALIQ"})
Local nPosVal   := aScan(aHeader, {|x| AllTrim(x[2]) == "F2D_VALOR"})

If MaFisFound("NF")

	If lRet := MaFisVldAlt(cReferencia)

		MaFisAlt(cReferencia,xValor,nItem,,,,,,,aTrbGen)

		aCols[n][nPosBas]:= MaFisRet(nItem, cReferencia, {aTrbGen[1], "TG_IT_BASE"})
		aCols[n][nPosAlq]:= MaFisRet(nItem, cReferencia, {aTrbGen[1], "TG_IT_ALIQUOTA"})
		aCols[n][nPosVal]:= MaFisRet(nItem, cReferencia, {aTrbGen[1], "TG_IT_VALOR"})				

	EndIf

EndIf

Return lRet
