Static __cSx3Casas
Static __cEmpLog  := ""
Static __cFilLog  := ""
Static __lArrefat := Nil

#INCLUDE "PROTHEUS.CH"
#INCLUDE "FATXFUN.CH"
#INCLUDE "FWLIBVERSION.CH"

Static lMaAvCred	:= NIL
Static lMaAvCrPr	:= NIL
Static oTmpTrbFat	:= NIL
Static aLogMsg      := NIL
Static __aPrepared  := {}
Static lMTValAvC    := Nil
Static lMTVALEMP    := Nil
Static lRskIsAct    := Nil
Static __lMetric	:= Nil
Static lFATTRVSA1   := ExistBlock("FATTRVSA1")

/*/

Ŀ
Funo    FATXFUN    Autor  Eduardo Riera          Data  31.08.2001
Ĵ
Descrio Biblioteca de funcoes das rotinas de vendas                  
                                                                       
Ĵ
Uso       Materiais                                                    
ٱ




Ŀ
Descrio  PLANO DE MELHORIA CONTINUA                                 
Ĵ
ITEM PMC  Responsavel               Data          |BOPS:             
Ĵ
      01                                          |                  
      02  Flavio Luiz Vicco         13/04/2006    |00000096972       
      03                                          |                  
      04                                          |                  
      05                                          |                  
      06                                          |                  
      07                                          |                  
      08                                          |                  
      09                                          |                  
      10  Flavio Luiz Vicco         13/04/2006    |00000096762       
ٱ


/*/
/*/


Ŀ
Funcao    A440Grava  Rev.   Eduardo Riera          Data  10.03.99 
Ĵ
Descrio Gravacao da Liberacao do Pedido via Mata440                 
Ĵ
Retorno   ExpL1: lGravou                                              
Ĵ
ParametrosExpL1: Liberacao Parcial                                    
          ExpL2: Transfere Locais                                     
Ĵ
ObservacaoDeve estar numa transacao                                   
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
20/07/2006Erike Yuri     Alteracao das ref. de grade para objeto     
ٱ


/*/

Function A440Grava(lLiber,lTransf)

Local lGrade   := MaGrade() .And. MaReadGrd()<>NIL
Local bCampo   := {|n| FieldName(n) }
Local nCntFor  := 0
Local nCntFor2 := 0
Local nMaxFor  := Len(aCols)
Local nQtdLib  := 0
Local nQtdLib2 := 0
Local lLiberOk := .T.
Local lCredito := .F.
Local lEstoque := .F.
Local lItLib   := .F.
Local nPosItem := GDFieldPos("C6_ITEM")
Local nPosProd := GDFieldPos("C6_PRODUTO")
Local lIntegDef		:= ExistFunc("GETROTINTEG") .And. ExistFunc("FWHASEAI") .And. FWHasEAI("MATA410B",.T.,,.T.)//Integracao e rastreabilidade de pedidos ativa 

Private lbloqDCF := !Empty(SC9->C9_BLCRED+SC9->C9_BLEST)
Private nValItPed := 0

//Ŀ
// Se Grade estiver ativa, grava Acols conforme AcolsGrade      
// para depois continuar a gravar como um pedido comum          
//
If ( lGrade )
	If "MATA410" $ SuperGetMV("MV_GRDMULT",.F.,"")
		aCols := aGradeCols(oGrade,aCols,aHeader,"C6_PRODUTO","C6_ITEMGRD","C6_QTDVEN","C6_ITEM")
	Else
		Ma410GraGr()
	EndIf
	nMaxFor := Len(aCols)
EndIf
//Ŀ
// Grava arquivo SC5                                       
//
Begin Transaction
dbSelectArea("SC5")
RecLock("SC5")
For nCntFor := 1 To FCount()
	If ( "FILIAL" $ FieldName(nCntFor) )
		SC5->(FieldPut(nCntFor,xFilial("SC5")))
	Else
		SC5->(FieldPut(nCntFor,M->&(EVAL(bCampo,nCntFor))))
	EndIf
Next nCntFor
End Transaction
//Ŀ
// Grava arquivo SC6                                                      
//
dbSelectArea("SC6")
dbSetOrder(1)
MsSeek(xFilial("SC6")+M->C5_NUM)
For nCntFor := 1 To nMaxFor
	//Esta alterao foi necessria devido ao ponto de entrada "MA440SC6" permitir que itens sejam exibidos
	//ou no no momento da liberao do pedido e com isso o aCols vem com uma quantidade menor de itens.
	If SC6->C6_ITEM+SC6->C6_PRODUTO <> aCols[nCntFor][nPosItem]+aCols[nCntFor][nPosProd]
		MsSeek(xFilial("SC6")+M->C5_NUM+aCols[nCntFor][nPosItem]+aCols[nCntFor][nPosProd])
	EndIf
	Begin Transaction
	RecLock("SC6")
	For nCntFor2 := 1 To Len(aHeader)
		If ( aHeader[nCntFor2][10] <> "V" )
			SC6->(FieldPut(FieldPos(aHeader[nCntFor2][2]),aCols[nCntFor][nCntFor2]))
		EndIf
	Next nCntFor2
	//Ŀ
	//Efetua a Liberacao do Pedido por Item de Pedido                         
	//
	If SC6->C6_QTDLIB <> 0 .Or. (MaTesSel(SC6->C6_TES) .And. MaTesLZero()) .Or. Ma440Compl()
		lItLib := .T.
		If ( SC5->C5_TIPLIB<>"2" )
			nQtdLib := SC6->C6_QTDLIB
			nQtdLib2:= If( Empty( SC6->C6_QTDLIB2 ), NIL, SC6->C6_QTDLIB2 )
			nQtdLib := MaLibDoFat(SC6->(RecNo()),nQtdLib,@lCredito,@lEstoque,.T.,.T.,lLiber,lTransf,NIL,NIL,NIL,NIL,NIL,NIL,nQtdLib2)
		EndIf
	EndIf
	//Ŀ
	//Verifica se Todos os Itens foram Liberados                              
	//
	If ( SC6->C6_QTDVEN > SC6->C6_QTDEMP + SC6->C6_QTDENT .And. lLiberOk .And. AllTrim(SC6->C6_BLQ)<>"R")
		lLiberOk := .F.
	EndIf
	If lLiberOk
		//Ŀ
		// PCO - Grava o lancamentos de liberacao do item do pedido de venda 
		//
		PcoDetLan("000103","01","MATA440")
	EndIf
	End Transaction
	dbSelectArea("SC6")
	dbSkip()
Next nCntFor
//Ŀ
//Liberacao por Pedido                                                    
//
Begin Transaction
If ( SC5->C5_TIPLIB=="2" .And. lItLib )
	MaAvLibPed(SC5->C5_NUM,lLiber,lTransf,@lLiberOk)
EndIf
//Ŀ
//Atualiza do C5_LIBEROK                                                  
//
If ( lLiberOk )
	dbSelectArea("SC5")
	RecLock("SC5")
	SC5->C5_LIBEROK := "S"
	MsUnlock()
	//Ŀ
	// PCO - Grava o lancamento de liberacao de pedido de venda 
	//
	PcoDetLan("000103","02","MATA440")
					
	If lIntegDef                
		FwIntegDef("MATA410B")
	EndIf
	
EndIf
//Ŀ
// Ponto de entrada para todos os itens do pedido.     
//
If ( ExistTemplate("MTA410T") )
	ExecTemplate("MTA410T",.f.,.f.)
EndIf

If ( ExistBlock("MTA410T") )
	ExecBlock("MTA410T",.f.,.f.)
EndIf

If ExistBlock("MAAVSC5")
	ExecBlock("MAAVSC5",.F.,.F.,{3})
EndIf

End Transaction
Return(.T.)

/*/


Ŀ
Funcao    A440VerSb2 Rev.   Eduardo Riera          Data 15.03.99  
Ĵ
Descrio Verifica o Estoque quanto a quantidade liberada             
Ĵ
Retorno   ExpL1: Indica se o estoque foi liberado                     
Ĵ
ParametrosExpN1: Quantidade a ser liberada                            
          ExpL2: Permite Liberacao Parcial                            
          ExpL3: Permite transferencia de Locais automaticamente      
          ExpA4: Array com os locais de transferencia                 
          ExpA5: Empenhos ( Caso seja informado nao efetua a gravacao 
                 apenas avalia ).                                     
Ĵ
ObservacaoO SC6 deve estar posicionado                                
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function A440VerSB2(nQtdLib,lLiber,lTransf,aLocal,aEmpenho,lVerPar)

Local cFiltro  := ""
Local cLocCq   := SuperGetMV('MV_CQ', .F., '98')
Local lRetorno := .F.
Local nSaldo   := 0
Local nDecimal := TamSx3("B2_QATU")[2]
Local nRegEmp  := 0
Local nSldSB2  := 0
Local nQtdJaEmp:= 0
Local cLocCQOri:= ''
Local aSaldoCQ := {}
Local nSaldoCQ := 0
Local nQtd440L := 0
Local nQtdEmp  := 0
Local aEmpBN   := If(FindFunction("A410CarBen"),A410CarBen(SC6->C6_NUM,SC6->C6_ITEM),{})
Local nX		 := 0
Local lConsTerc:= .F.
//Ŀ
//Parametros default                                                      
//
DEFAULT lLiber   := .F.
DEFAULT lTransf  := .F.
DEFAULT aLocal   := {}
DEFAULT lVerPar  := .T.

cLocCQOri := cLocCq //-- Inicializa variavel somente com o Armazem de CQ

If ( ExistBlock("MTA440A") )
	cFiltro := ExecBlock("MTA440A")
	If !Empty(cFiltro) .And. (ValType(cFiltro) == "C")
		cLocCQ += "/"+cFiltro
	EndIf
EndIf
//Ŀ
//Verifica a movimentacao de Estoque.                                     
//
dbSelectArea("SF4")
dbSetOrder(1)
If ( MsSeek(xFilial("SF4")+SC6->C6_TES) )
	If ( SF4->F4_ESTOQUE == "S" )
		If !Empty(aEmpBN)
			//-- Chama funcao para baixar empenho caso haja remessa para terceiros
			For nX := 1 To Len(aEmpBN)
				nQtdEmp += A410LibBen(1,aEmpBN[nX,1],aEmpBN[nX,2],SC6->C6_QTDVEN,SC6->C6_UNSVEN)
			Next nX
		EndIf
		dbSelectArea("SB1")
		dbSetOrder(1)
		MsSeek(xFilial("SB1")+SC6->C6_PRODUTO)
		dbSelectArea("SB2")
		dbSetOrder(1)
		If ( MsSeek(xFilial("SB2")+SC6->C6_PRODUTO+SC6->C6_LOCAL) )
			If ( aEmpenho <> Nil )
				nQtdJaEmp := 0
				For nRegEmp := 1 To Len(aEmpenho[2])
					If aEmpenho[2][nRegEmp][1] == SB2->(RecNo())
						If Empty(SC6->C6_LOCALIZ+SC6->C6_NUMSERI+SC6->C6_NUMLOTE+SC6->C6_LOTECTL) .Or.;
								aEmpenho[2][nRegEmp][3] == SC6->C6_LOCALIZ+SC6->C6_NUMSERI+SC6->C6_NUMLOTE+SC6->C6_LOTECTL
							nSaldo -= aEmpenho[2][nRegEmp][2] //B2_RESERVA
							nQtdJaEmp += aEmpenho[2][nRegEmp][2] //B2_RESERVA
						EndIf
					EndIf
				Next nRegEmp
			EndIf
			nQtd440L  := If(ExistBlock("MTA440L"),ExecBlock("MTA440L",.F.,.F.),0)
			nSaldo    -= nQtd440L

			lConsTerc := (SF4->F4_PODER3<>"N" .Or. !Empty(SF4->F4_TESP3))

			If lVerPar
				nSaldo   += SldAtuEst(SC6->C6_PRODUTO,SC6->C6_LOCAL,nQtdLib+nQtdJaEmp+IIf(nQtd440L>0,nQtd440L,0),SC6->C6_LOTECTL,SC6->C6_NUMLOTE,SC6->C6_LOCALIZ,SC6->C6_NUMSERI,SC6->C6_RESERVA,lConsTerc,SF4->F4_SLDNPT=="1",SC6->C6_PROJPMS,SC6->C6_TASKPMS,SC6->C6_SERVIC,!Empty(aEmpBN))
			Else
				nSaldo   += SldAtuEst(SC6->C6_PRODUTO,SC6->C6_LOCAL,nQtdLib+nQtdJaEmp+IIf(nQtd440L>0,nQtd440L,0),,,,SC6->C6_NUMSERI,SC6->C6_RESERVA,lConsTerc,SF4->F4_SLDNPT=="1",SC6->C6_PROJPMS,SC6->C6_TASKPMS,SC6->C6_SERVIC,!Empty(aEmpBN))
			EndIf
			nSaldo   += SC6->C6_QTDRESE
			//Ŀ
			// Para Devolucoes subtrai o saldo do CQ (ainda Nao Liberado e Nao Rejeitado) 
			//
			If SC5->C5_TIPO == 'D' .And. !Empty(SC6->C6_NFORI+SC6->C6_SERIORI) .And. SC6->C6_LOCAL == cLocCQOri
				aSaldoCQ := SaldoRjCQ(SC6->C6_PRODUTO,SC6->C6_NFORI,SC6->C6_SERIORI,SC6->C6_CLI,SC6->C6_LOJA,SC6->C6_NUMLOTE,SC6->C6_ITEMORI,/*dDataAtu*/,SC6->C6_LOCAL)
				nSaldoCQ := aSaldoCQ[1] - aSaldoCQ[8]
				nSaldo   := Min( nSaldoCQ, nSaldo )
			EndIf
			If ( NoRound(nQtdLib,nDecimal) <= NoRound(nSaldo,nDecimal) )
				lTransf  := .F.
				lRetorno := .T.
			Else
				If ( lLiber .And. nSaldo > 0)
					nQtdLib  := nSaldo
					lTransf  := .F.
					lRetorno := .T.
				EndIf
			EndIf
			//Ŀ
			//Verifica os demais almoxarifados                                        
			//
			If ( lTransf .And. !Rastro(SC6->C6_PRODUTO) .And. !Localiza(SC6->C6_PRODUTO, .T.) )
				dbSelectArea("SB2")
				dbSetOrder(1)
				MsSeek(xFilial("SB2")+SC6->C6_PRODUTO) //posiciona no primeiro local
				While ( !Eof() .And. xFilial("SB2") == SB2->B2_FILIAL .And.;
						SC6->C6_PRODUTO== SB2->B2_COD )
					If ( !SB2->B2_LOCAL $ cLocCq .And.;
					      SB2->B2_LOCAL <> SC6->C6_LOCAL .And.;
					      !BlqInvent(SB2->B2_COD,SB2->B2_LOCAL,,If(!__lPyme, SB2->B2_LOCALIZ, '' )) .And.;
					      !(FindFunction('AvalBlqLoc') .And. AvalBlqLoc(SB2->B2_COD,SB2->B2_LOCAL,Nil,.F.)) )
						//Ŀ
						//Trava o SB2 dos Locais a serem Transferidos                             
						//
						If RecLock("SB2")
							nSldSb2 := SaldoSb2(,Empty(aEmpBN) .And. GetMv("MV_QEMPV"),,SF4->F4_PODER3<>"N" .Or. (!Empty(SF4->F4_TESP3)))
							If ( aEmpenho <> Nil )
								For nRegEmp := 1 To Len(aEmpenho[2])
									If aEmpenho[2][nRegEmp][1] == SB2->(RecNo())
										If Empty(SC6->C6_LOCALIZ+SC6->C6_NUMSERI+SC6->C6_NUMLOTE+SC6->C6_LOTECTL) .Or.;
												aEmpenho[2][nRegEmp][3] == SC6->C6_LOCALIZ+SC6->C6_NUMSERI+SC6->C6_NUMLOTE+SC6->C6_LOTECTL
											nSldSB2 -= aEmpenho[2][nRegEmp][2] //B2_RESERVA
										EndIf
									EndIf
								Next nRegEmp
							EndIf
							If ( nSldSb2<>0 )
								AAdd(aLocal, { SB2->B2_LOCAL , Min(nSldSb2,nQtdLib-nSaldo) } )
								nSaldo += Min(nSldSb2,aLocal[Len(aLocal),2])
								If ( nQtdLib <= nSaldo .Or. (lliber .And. nSaldo > 0))
									nQtdLib  := nSaldo
									lRetorno := .T.
									Exit
								EndIf
							EndIf
						EndIf
					EndIf
					dbSelectArea("SB2")
					dbSkip()
				EndDo
			EndIf
		Else
			lRetorno := .F.
		EndIf

		If !Empty(aEmpBN) .And. (!(aEmpenho==Nil) .or. nSaldo < If(nQtdEmp < SC6->C6_QTDVEN,nQtdEmp,SC6->C6_QTDVEN))
			For nX := 1 To Len(aEmpBN)
				A410LibBen(2,aEmpBN[nX,1],aEmpBN[nX,2],If(nQtdEmp < SC6->C6_QTDVEN,nQtdEmp,SC6->C6_QTDVEN) - If(lLiber,nSaldo,0))
			Next nX
		EndIf
	Else
		lRetorno := .T.
	EndIf
EndIf

Return(lRetorno)

/*/

Ŀ
Funo     A440Qtdl  Autor  Claudinei M. Benzi     Data  22.01.92 
Ĵ
Descrio  Consiste qtde liberada se maior que qtde vendida           
Ĵ
 Uso       Mata440                                                    
ٱ


/*/
Function A440Qtdl(nQuant)

Local aTam      := TamSX3("C6_QTDVEN")

Local cLote     := ""
Local cProduto  := ""
Local cLocal    := ""
Local cItem     := ""
Local cAlias    := Alias()
Local cGrade    := ""
Local cReserv   := ""
Local cLoteCtl  := ""
Local cLocaliza := ""
Local cNumSerie := ""
Local cProjeto  := ""
Local cTarefa   := ""
Local cServico  := ""
Local cTipProd  := ""

Local nSaldo    := 0
Local nQtdRese  := 0
Local nQtdEnt   := 0
Local nx        := 0
Local nQtdLib   := 0
Local nQtdVen   := 0

Local lRsDoFAt  := IIF(SuperGetMv("MV_RSDOFAT") == "S",.F.,.T.)
Local lBloq     := .F.
Local lGrade    := MaGrade()
Local lMata410  := AtIsRotina("MATA410")

//Ŀ
// Integracao SIGAFAT e SIGADPR                                 
//
Local lIFatDpr := SuperGetMV("MV_IFATDPR",.F.,.F.)


nQtdLib := IF(nQuant == NIL .Or. ValType(nQuant) # "N",&(ReadVar()),nQuant)

For nx=1 to Len(aHeader)
	If Trim(aHeader[nX][2]) == "C6_ITEM"
		cItem := aCols[n][nx]
	ElseIf Trim(aHeader[nx][2]) == "C6_BLQ"
		If ( AllTrim(acols[n][nx]) $ "RS" )
			lBloq := .T.
		Endif
	ElseIf Trim(aHeader[nX][2]) == "C6_PRODUTO"
		cProduto := aCols[n][nx]
		//Ŀ
		// Verifica se a grade esta ativa, e se o produto digitado e'   
		// uma referencia                                               
		//
		If lGrade
			MatGrdPrrf(@cProduto)
		Endif
	ElseIf Trim(aHeader[nX][2]) == "C6_LOCAL"
		cLocal := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_NUMLOTE"
		cLote := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_LOTECTL"
		cLoteCtl := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_LOCALIZ"
		cLocaliza := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_NUMSERI"
		cNumSerie := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_QTDVEN"
		nQtdVen := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_QTDENT"
		nQtdEnt := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_GRADE"
		cGrade := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_TES"
		cTes := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_RESERVA"
		cReserv := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_PROJPMS"
		cProjeto := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_TASKPMS"
		cTarefa := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_SERVIC"
		cServico:= aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_TPPROD"
		cTipProd:= aCols[n][nx]
	EndIf
Next nX

//Ŀ
// M_SER004_CRM019_Integraao_Faturamento_DPR                           
// Se o item eh do tipo "Desenvolvimento" nao libera para faturamento   
// Autor: Alexandre Felicio													   
// Data: 12/05/2014														   
//
If ( (lIFatDpr) )
	If cTipProd == "2" .AND. nQtdLib > 0
		MsgAlert(STR0019) //"Item do tipo Desenvolvimento no podem ter sua quantidade liberada para Faturamento."
		Return .F.
	EndIf
EndIf


If ( lBloq .And. lRsDoFat .and. nQtdLib > 0  )
	Help(" ",1,"A410ELIM")
	Return .F.
Endif

If SuperGetMv("MV_LIBACIM") .And. nQtdLib > 0
	If ( INCLUI )
		If Round(nQtdLib,aTam[2]) > Round(nQtdVen,aTam[2])
			HELP(" ",1,"A440QTDL")
			Return .F.
		EndIf
	Else
		If !lGrade  .Or. cGrade <> "S"
			dbSelectArea("SC6")
			dbSetOrder(1)
			MsSeek(xFilial("SC6")+M->C5_NUM+cItem)
			//CHAMADA DE FUNCAO AGROINDUSTRIA
			If FindFunction("OGX225C") .AND. (SuperGetMV("MV_AGRUBS",.F.,.F.))
				If !(OGX225C(nQtdVen, nQtdLib))
					Return .F.
				EndIf 
			EndIf
			
			If !lMata410
				If Found() .And. Round(nQtdLib,aTam[2]) > Round(C6_QTDVEN - (C6_QTDEMP+C6_QTDENT),aTam[2])
					HELP(" ",1,"A440QTDL")
					Return .F.
				Endif
			Else
				If Found() .And. Round(nQtdLib,aTam[2]) > Round(nQtdVen - C6_QTDENT,aTam[2])
					HELP(" ",1,"A440QTDL")
					Return .F.
				Endif
			Endif
		Endif
	EndIf
Endif
//Ŀ
//Caso movimente Estoque em Quantidade                                    
//
dbSelectArea("SF4")
dbSetOrder(1)
MsSeek(xFilial("SF4")+cTes)
If ( SF4->F4_ESTOQUE == "S" .And. !(M->C5_TIPO$"CIP") .And. !Empty(cReserv) )
	//Ŀ
	//Validacao para Reserva                                   
	//
	If ( INCLUI )
		dbSelectArea("SC0")
		dbSetOrder(1)
		If ( MsSeek(xFilial("SC0")+cReserv+cProduto+cLocal) )
			nQtdRese := Min(SC0->C0_QUANT,nQtdVen)
		EndIf
	Else
		dbSelectArea("SC6")
		dbSetOrder(1)
		If ( MsSeek(xFilial("SC6")+M->C5_NUM+cItem+cProduto,.F.) )
			If ( cReserv == SC6->C6_RESERVA )
				nQtdRese := Min(SC6->C6_QTDRESE,nQtdLib)
			Else
				dbSelectArea("SC0")
				dbSetOrder(1)
				If ( MsSeek(xFilial("SC0")+cReserv+cProduto+cLocal) )
					nQtdRese := Min(SC0->C0_QUANT,nQtdVen)
				EndIf
			EndIf
		EndIf
	EndIf
	If ( NoRound(nQtdLib,aTam[2]) > NoRound(nQtdRese,aTam[2]) )
		Help(" ",1,"A440RESE01",,Str(nQtdRese),03,20)
		Return(.F.)
	EndIf
Else
	If ((Rastro(cProduto) .Or. Localiza(cProduto,.T.)) .And. !(M->C5_TIPO $ "CIP") .And. SF4->F4_ESTOQUE == "S" ) .And. SuperGetMv("MV_GERABLQ")=="N"
		nSaldo := SldAtuEst(cProduto,cLocal,nQtdLib,cLoteCtl,cLote,cLocaliza,cNumSerie,cReserv,SF4->F4_PODER3<>"N" .Or. (!Empty(SF4->F4_TESP3)),NIL,cProjeto,cTarefa,cServico)
		dbSelectArea("SC6")
		dbSetOrder(1)
		If ( MsSeek(xFilial("SC6")+M->C5_NUM+cItem+cProduto,.F.) )
			nSaldo += SC6->C6_QTDEMP
		EndIf
		If ( nSaldo < nQtdLib )
			If ( Localiza(cProduto,.T.) )
				Help(" ",1,"SALDOLOCLZ")
				Return(.F.)
			EndIf
			If ( Rastro(cProduto) )
				Help(" ",1,"A440ACILOT")
				Return(.F.)
			EndIf
		EndIf
	EndIf
EndIf
//Ŀ
// S permitir alterar a quantidade quando esta for maior que a 
// quantidade entregue, somente para outros paises...           
//Lucas
If cPaisLoc <> "BRA"
	If nQtdLib < nQtdEnt
		Help(" ",1,"CANTRESERV")
		Return(.F.)
	EndIf
EndIf
dbSelectArea(cAlias)
Return( .T. )

/*


Ŀ
Funo     A460Especie Autor  Juan Jose Pereira    Data  14/10/96 
Ĵ
Descrio  Busca tipo de documento fiscal utilizado para gerar nota   
Ĵ
 Uso       MATA460                                                    
ٱ


*/
Function A460Especie(cSerie)
Local cSvAlias:=Alias(), cTiposDoc:=MaSerEspNF(),;
	cEspecie:=Space(5),nLinhas:=0,nL:=0,nPosSign:=0

If cTiposDoc<>NIL
	cTiposDoc:=StrTran(cTiposDoc,";",chr(13)+chr(10))
	nLinhas:=MLCount(cTiposDoc)
	For nL:=1 to nLinhas
		cEspecie:=Alltrim(StrTran(MemoLine(cTiposDoc,,nL),Chr(13),Chr(10)))
		nPosSign:=Rat("=",cEspecie)
		If nPosSign>0 .and. Alltrim(cSerie)==Alltrim(Substr(cEspecie,1,nPosSign-1)) // Heverson
			cEspecie:=Substr(cEspecie,nPosSign+1)
			SX5->(MsSeek(xFilial("SX5")+"42"+cEspecie))
			If SX5->(!Found())
				cEspecie:=Space(5)
			Endif
			Exit
		Else
			cEspecie:=Space(5)
		Endif
	Next
Endif
dbSelectArea(cSvAlias)
Return(cEspecie)

/*/


Ŀ
Funcao    a460Estorn Autor Eduardo Riera           Data 31.03.99  
Ĵ
Descrio Efetua o estorno da liberacao do pedido de venda            
Ĵ
Retorno   ExpL1: Indica se houve o estorno                            
Ĵ
ParametrosExpL1: Indica se o programa chamador eh o MATA410           
			 ExpL2: Indica se Atualizar Empenhos				          
          ExpN3: Valor a ser adicionado ao limite de credito          
Ĵ
ObservacaoDeve estar numa transacao                                   
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
16/05/2007Norbert Waage  Bops 125161 - Atualizacao do status do orca-
                         mento no Televendas (SIGATMK) apos estorno. 
ٱ


/*/
Function A460Estorna(lMata410,lAtuEmp,nVlrCred,cTipLib)

Local aArea       := GetArea()
Local aAux        := {}
Local lContinua   := .T.
Local lDeletaDCF  := .F.
Local lIntACD 	  := SuperGetMV("MV_INTACD",.F.,"0") == "1"
Local aEmpBN	  := If(FindFunction("A410CarBen"),A410CarBen(SC9->C9_PEDIDO,SC9->C9_ITEM),{})
Local nX		  := 0
Local cBlq		  := ""
Local cItemBlq	  := ""
Local lLibMan	  := .F.
Local lAGRUBS	  := SuperGetMV("MV_AGRUBS",.F.,.F.)
Local cSeq        := ""
Local lResAut	  := SuperGetMv("MV_RESAUT",.F.,.F.)
Local lDelRes	  := SuperGetMv("MV_DELRES",.F.,.F.)
Local lDelRes2	  := SuperGetMV("MV_DELRES2",.F.,.F.)
Local lResEst     := SuperGetMv("MV_RESEST",.F.,.F.)
Local lTipRes     := SuperGetMv("MV_TIPRES",.F.,.F.)
Local cGeraBlq    := SuperGetMv("MV_GERABLQ",.F.,"N")
Local lGrvBlq2    := SuperGetMv("MV_GRVBLQ2",.F.,.F.)
Local l456LibMan  := IsInCallStack("a456LibMan")
Local l456LibAut  := IsInCallStack("a456LibAut")

/* 
	lEstSeqAtu = No estorno do item do pedido de vendas (SC6), estorna so a sequencia atual

	Tratamento para Liberacao Manual ou Automatica de itens do pedido de venda
	quando e gerada Reserva Automatica nos casos em que ocorre o bloqueio de estoque (MV_RESEST = T)
	e a delecao das reservas nos casos de estorno da liberacao ocorram (MV_DELRES = T).
	Todos os parametros considerados para esta tratativa:
		MV_RESEST = T
		MV_DELRES = T
		MV_RESAUT = F
		MV_TIPRES = F
		MV_GERABLQ = N
		MV_GRVBLQ2 = F
*/
Local lEstSeqAtu :=	(l456LibMan .Or. l456LibAut) ;	// Tela de Liberacao automatica ou manual
						.And. ;
					(lResEst                  .And. ;	// MV_RESEST = T
					 lDelRes                  .And. ;	// MV_DELRES = T
					 !lResAut                 .And. ;	// MV_RESAUT = F
					 !lTipRes                 .And. ;	// MV_TIPRES = F
					 AllTrim(cGeraBlq) == "N" .And. ;	// MV_GERABLQ = N
					 !lGrvBlq2)							// MV_GRVBLQ2 = F

Default cTipLib   := ""

//- Status dos Bloqueios do pedido de venda. Se .T. DCF gerado, tem que estornar.
If Type("lbloqDCF") <> "L"
	lbloqDCF := .F.
EndIf


If Type("lVerCarg461") <> "L"
	lVerCarg461 := .F.
EndIf

//CHAMADA DE FUNCAO AGROINDUSTRIA
If FindFunction("OGX225A") .AND. lAGRUBS
   lContinua := OGX225A()
End

//Ŀ
//Verifica os parametros defaults                                         
//
lMata410 := If(lMata410==Nil,.F.,lMata410)
//Ŀ
// Integracao com o  ACD - Faz validacao do estorno da liberacao dos PV's  	  
//
If lContinua .And. lIntACD .And. FindFunction("CBMT460EST")
	lContinua := CBMT460EST()
	If ValType(lContinua) # "L"
		lContinua:=.T.
	EndIf
//Ŀ
//Pontos de Entrada                                                       
//
ElseIf lContinua .And. (ExistTemplate("MT460EST",.F.,.F.))
	lContinua := ExecTemplate("MT460EST",.F.,.F.)
	If ValType(lContinua) # "L"
		lContinua:=.T.
	EndIf
EndIf

//Ŀ
//Pontos de Entrada                                                       
//
If lContinua .And. ( ExistBlock("MT460EST",.F.,.F.) )
	lContinua := ExecBlock("MT460EST",.F.,.F.)
	If ValType(lContinua) # "L"
		lContinua:=.T.
	EndIf
EndIf

//Validaes referentes  integrao do OMS com o TPR - TOTVS Planejamento de Rotas Neolog
If SuperGetMV("MV_ROTAINT",.F.,.F.) .And. FindFunction("OMSTPR410P")
	lContinua := OMSTPR410P(6,,,SC9->C9_PEDIDO,SC9->C9_ITEM,SC9->C9_SEQUEN,SC9->C9_PRODUTO)
EndIf

//Ŀ
//Atualiza o orcamento do Televendas, se foi originado a partir
//dele no modulo Call Center (SIGATMK)                         
//
If lContinua
	TkAtuTlv(SC9->C9_PEDIDO,1,,,,.T.)
EndIf

//Ŀ
//Posiciona Registros e trava registros                                   
//
dbSelectArea("SC9")

If lVerCarg461
	//--> Verifica algum dos pedidos selecionados tem carga montada
	If OmsHasCg(SC9->C9_PEDIDO,SC9->C9_ITEM)
		Help(" ",1,"MATA46101")
		RestArea(aArea)
		Return (.F.)
	EndIf
EndIf

If ( lContinua )
	lDeletaDCF := .T.
	If lbloqDCF
		lDeletaDCF := .F.
	EndIf

	//Se for a liberao de crdito de pedido manual, guarda o status do pedido e item.
	If lMata410 .And. IsInCallStack("A450LibMan") .And.;
		!Empty(cTipLib) .And. cTipLib == "2"
		cBlq 	 := SC5->C5_BLQ
		cItemBlq := SC6->C6_BLOQUEI
		lLibMan	 := .T.
	EndIf

	//Ŀ
	//Restaura empenhos relacionados a remessa para beneficiamento 
	//
	If !Empty(aEmpBN) .And. Empty(SC9->C9_BLEST)
		For nX := 1 To Len(aEmpBN)
			A410LibBen(2,aEmpBN[nX,1],aEmpBN[nX,2],SC9->C9_QTDLIB,SC9->C9_QTDLIB2)
		Next nX
	EndIf

	FatAtuEmpN("-",,,.T.)
	// --- 2.Estorno do SC9 / Estorno da Liberacao de 6.Estoque/4.Credito do SC9 / WMS
	MaAvalSC9("SC9",2,,,,,lAtuEmp,,@nVlrCred,,lDeletaDCF)
	// --- 8.Estorno Mont.Carga
	MaAvalSC9("SC9",8)
	//Ŀ
	//Deleta o Registro no SC9                                                
	//
	dbSelectArea("SC9")
	RecLock("SC9")
	SC9->C9_BLCRED := If(SC9->C9_BLCRED=="05","",SC9->C9_BLCRED)

	If lContinua
	   dbDelete()
	EndIf
	//Ŀ
	//Executa o ExecBlock                                                     
	//
	dbSelectArea("SC9")
	
	//CHAMADA DE FUNCAO AGROINDUSTRIA
	If FindFunction("OGX225D") .AND. lAGRUBS
		OGX225D("SC9")
	End
	
	If ( !lMata410 )
		If (ExistBlock("M460DEL"))
			ExecBlock("M460DEL",.f.,.f.)
		EndIf
	EndIf

	//Ŀ
	// O SC6 eh posicionado na funcao maavalsc9                               
	//
	If !Empty(SC6->C6_RESERVA) .And. (SC6->C6_QTDEMP == 0 .Or. lEstSeqAtu)
		dbSelectArea("SC0")
		dbSetOrder(1)
		If ( MsSeek(xFilial("SC0")+SC6->C6_RESERVA+SC6->C6_PRODUTO+SC6->C6_LOCAL,.F.) ) .Or. lResAut
			
			If lEstSeqAtu
				//Estornar somente a sequencia atual (SC9) de liberao do item do pedido de venda
				MaAvalSC6("SC6",2,"SC5", , , , , , , , , , , , , .F.)
			Else
				MaAvalSC6("SC6",2,"SC5")
			EndIf

			aAux := {SC6->C6_NUMLOTE,SC6->C6_LOTECTL,SC6->C6_LOCALIZ,SC6->C6_NUMSERI}
			If lDelRes .And. lDelRes2
				RecLock("SC6")
				SC6->C6_NUMLOTE := ""
				SC6->C6_LOTECTL := ""
				SC6->C6_LOCALIZ := ""
				SC6->C6_NUMSERI := ""
			EndIf

			MaAvalSC6("SC6",1,"SC5")

			//Se for a liberao de crdito de pedido manual, volta o status anterior de bloqueio,
			//pois a funo da regra de negcio  processada na liberao manual.
			If lLibMan
				If !Empty(SC5->C5_BLQ)
					RecLock("SC5", .F.)
					SC5->C5_BLQ := cBlq
				EndIf
				If !Empty(SC6->C6_BLOQUEI)
					RecLock("SC6", .F.)
					SC6->C6_BLOQUEI := cItemBlq
				EndIf
			EndIf

			If lDelRes .And. lDelRes2
				RecLock("SC6")
				SC6->C6_NUMLOTE := aAux[1]
				SC6->C6_LOTECTL := aAux[2]
				SC6->C6_LOCALIZ := aAux[3]
				SC6->C6_NUMSERI := aAux[4]
			EndIf

		Else
			//Ŀ
			//Caso a Reserva foi depurada       
			//
			dbSelectArea("SB2")
			RecLock("SB2")
			If !(lResAut .And. lDelRes)
				SB2->B2_RESERVA -= SC6->C6_QTDRESE
				SB2->B2_RESERV2 -= ConvUM(SB2->B2_COD, SC6->C6_QTDRESE, 0, 2)
			EndIf
			SB2->B2_QPEDVEN += SC6->C6_QTDRESE
			SB2->B2_QPEDVE2 += ConvUM(SB2->B2_COD, SC6->C6_QTDRESE, 0, 2)
			dbSelectArea("SC6")
			RecLock("SC6")
			SC6->C6_QTDRESE := 0
			SC6->C6_RESERVA := ""
		EndIf
	ElseIf !lMata410
		//Ŀ
		// Se nao existir controle de reserva e o estorno da liberacao estiver sendo 
		// feito pela rotina MATA461, verifica se houve transferencia entre almoxari-
		// fados e executa o estorno da transferencia.    							  
		//
	 	MaTrfLocal(SC6->C6_PRODUTO, , , ,SC6->C6_NUM,.T.,@cSeq)
	EndIf
	FatAtuEmpN("+")
EndIf
RestArea(aArea)
Return(lContinua)

/*/


Ŀ
Funcao    AtTrfEqpto Autor  Eduardo Riera          Data 05.01.98  
Ĵ
Descrio  Transferencia de Cliente x Equipamento                     
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros cCodFab: Codigo do Fabricante                              
           cLojaFa: Loja do Fabricante                                
           cCodPro: Codigo do Produto                                 
           cNumSer: Numero de Serie                                   
           cCodCli: Codigo do Cliente                                 
           cLoja  : Loja do Cliente                                   
           aHeadA4: aHeader do AA4 (Somente Inclusao)                 
           aColsA4: aCols do AA4 ( Somente Inclusao )                 
           aEnchoi: Vetor com os campos a serem atualizados           
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function AtTrfEqpto(cCodFab,cLojaFa,cCodPro,cNumSer,cCodCli,cLoja,aHeadAA4,aColsAA4,aEnchoice)

Local aArea       := GetArea()
Local nOpcao      := 0
Local aSavaHead   := If(Type("aHeader")=="U",{},aHeader)
Local aSavaCols   := If(Type("aCols")=="U",{},aCols)
Local aSavN       := If(Type("N")=="U",1,N)
Local nCntFor     := 0
Private aHeader   := {}
Private aCols     := {}
Private uCampo    := ""

aEnchoice := If(aEnchoice==Nil,{},aEnchoice)

dbSelectArea("AA3")
dbSetOrder(4)
If ( MsSeek(xFilial("AA3")+cCodFab+cLojaFa+cCodPro+cNumSer) )
	nOpcao := 4
	dbSelectArea("SX3")
	dbSetOrder(1)
	MsSeek("AA3")
	While ( !Eof() .And. (SX3->X3_ARQUIVO == "AA3") )
		uCampo := SX3->X3_CAMPO
		If ( SX3->X3_CONTEXT=="V" )
			M->&(uCampo) := CriaVar(SX3->X3_CAMPO,.F.)
		Else
			M->&(uCampo) := AA3->(FieldGet(FieldPos(SX3->X3_CAMPO)))
		EndIf
		dbSelectArea("SX3")
		dbSkip()
	EndDo
	For nCntFor := 1 To Len(aEnchoice)
		uCampo := aEnchoice[nCntFor][1]
		M->&(uCampo) := aEnchoice[nCntFor][2]
	Next nCntFor
	At040Grava(nOpcao,cCodCli,cLoja)
Else
	//Ŀ
	//Verifica se ha componentes a serem considerados                         
	//
	If ( aColsAA4 <> Nil .And. aHeadAA4 <> Nil )
		aCols   := aClone(aColsAA4)
		aHeader := aClone(aHeadAA4)
	EndIf
	nOpcao := 1
	//Ŀ
	//Inicializa as Variaveis necessarias a gravacao                          
	//
	dbSelectArea("SX3")
	dbSetOrder(1)
	MsSeek("AA3")
	While ( !Eof() .And. (SX3->X3_ARQUIVO == "AA3") )
		uCampo := SX3->X3_CAMPO
		M->&(uCampo) := CriaVar(SX3->X3_CAMPO,If(SX3->X3_CONTEXT=="V",.F.,.T.))
		dbSelectArea("SX3")
		dbSkip()
	EndDo
	//Ŀ
	//Preenche as Variaveis Necessarias                                       
	//
	M->AA3_CODCLI  := cCodCli
	M->AA3_LOJA    := cLoja
	M->AA3_CODPRO  := cCodPro
	M->AA3_NUMSER  := cNumSer
	M->AA3_DTVEND  := SD2->D2_EMISSAO
	M->AA3_CODFAB  := cCodFab
	M->AA3_LOJAFA  := cLojaFa
	M->AA3_NFVEND  := SD2->D2_DOC
	M->AA3_CONTRT  := ""
	M->AA3_DTGAR   := &(SuperGetMv("MV_FORMGAR"))
	For nCntFor := 1 To Len(aEnchoice)
		uCampo := aEnchoice[nCntFor][1]
		M->&(uCampo) := aEnchoice[nCntFor][2]
	Next nCntFor
	At040Grava(nOpcao,cCodCli,cLoja)
EndIf
//Ŀ
//Retorna as condicoes de entrada                                         
//
aCols   := aSavACols
aHeader := aSavAhead
N       := aSavN
RestArea(aArea)
Return(.T.)

/*/


Ŀ
Funo    At040Grava Autor  Eduardo Riera          Data  16/09/98 
Ĵ
Descrio  Programa de Gravacao  amarrao Cliente x Equipamento      
Ĵ
Sintaxe    Void At040Grava()                                          
Ĵ
Parametros ExpN1 = 1 - Inclui, 2 - Altera , 3 - Exclui                
Ĵ
 Uso       TECA040                                                    
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
25/08/05  Henry F        Bops 85869 - Tratamento da gravacao do      
                         cliente anterior no campo AAF_LOGINI        
Ĵ
02/10/0600Conrado Q.     Bops 107368 - Localizacao dos acessorios do 
                         produto quando AA4 trabalha em modo exclu.  
ٱ


/*/
Function At040Grava(nOpcao,cCodCli,cLoja)

Local nCntFor		:= 0                      							//Variavel para For - Next
Local nCntFor2		:= 0												//Variavel para For - Next
Local nUsado		:= Len(aHeader)										//Tamanho do aHeader
Local aRecAA4		:= {}												//Array de registros da tabela AA4
Local nPosProd		:= Ascan(aHeader,{|x| Trim(x[2])=="AA4_PRODAC" })	//Posicao do campo Produro no aHeader
Local bCampo		:= {|x| FieldName(x) }								//Bloco de codigo para pegar o nome do campo na gravacao
Local nRegAA3		:= AA3->(RecNo())									//Array de registros da tabela AA3
Local cPlano		:= ""												//Armazena codigo do plano de manutencao do parametr MV_ATPLANO
Local cCodCliAnt	:= ""												//Codigo do cliente anterior a alteracao do historico
Local cLojaCliAnt	:= ""												//Loja do cliente anterior a alteracao do historico

Local lGravou   := .T.
Local lAA3NF	 :=  SuperGetMV('MV_GSAA3NF',,.F.)

dbSelectArea("AA4")
dbSetOrder(1)
MsSeek(xFilial("AA4")+M->AA3_CODCLI+M->AA3_LOJA+M->AA3_CODPRO+M->AA3_NUMSER)

While ( !Eof() .And. AA4->AA4_FILIAL==xFilial("AA4") .And.;
		AA4->AA4_CODCLI==M->AA3_CODCLI .And.;
		AA4->AA4_LOJA  ==M->AA3_LOJA   .And.;
		AA4->AA4_CODPRO==M->AA3_CODPRO .And.;
		AA4->AA4_NUMSER==M->AA3_NUMSER )
	AAdd(aRecAA4,RecNo())
	dbSelectArea("AA4")
	dbSkip()
EndDo
//Ŀ
//Bloco de Inclusao / Alteracao                                           
//
Do Case
Case ( nOpcao < 3 )
	//Ŀ
	// Grava arquivo AA3 (Cabecalho da Amarracao             
	//
	dbSelectArea("AA3")
	dbSetOrder(1)
	MsSeek(xFilial("AA3")+M->AA3_CODCLI+M->AA3_LOJA+M->AA3_CODPRO+M->AA3_NUMSER+M->AA3_FILORI)
	RecLock("AA3",!Found())
	For nCntFor := 1 To FCount()
		If ( "FILIAL"$Field(nCntFor) )
			FieldPut(nCntFor,xFilial("AA3"))
		Else
			FieldPut(nCntFor,M->&(EVAL(bCampo,nCntFor)))
		EndIf
	Next nCntFor
	//Ŀ
	//Grava os campos memos                                                   
	//
	MSMM(M->AA3_CODMEM,,,M->AA3_OBS,1,,,"AA3","AA3_CODMEM")
	AA3->( MsUnlock() )
	AA3->(FKCommit())
	//Ŀ
	// Grava Historico de Equipamento                      
	//
	dbSelectarea("AAF")
	dbSetOrder(1)
	If !MsSeek(xFilial("AAF")+M->AA3_CODCLI+M->AA3_LOJA+M->AA3_CODPRO+M->AA3_NUMSER+M->AA3_CODPRO+M->AA3_NUMSER)
		Reclock("AAF",.T.)
		AAF->AAF_FILIAL := xFilial("AAF")
		AAF->AAF_CODCLI := M->AA3_CODCLI
		AAF->AAF_LOJA   := M->AA3_LOJA
		AAF->AAF_CODPRO := M->AA3_CODPRO
		AAF->AAF_NUMSER := M->AA3_NUMSER
		AAF->AAF_PRODAC := M->AA3_CODPRO
		AAF->AAF_NSERAC := M->AA3_NUMSER
		AAF->AAF_CODFAB := M->AA3_CODFAB
		AAF->AAF_LOJAFA := M->AA3_LOJAFA
		AAF->AAF_DTINI  := dDataBase
		AAF->AAF_LOGINI := STR0001 // # "CADASTRO AMARRACAO CLIENTE X EQPTO"
		MsUnlock()
		AAF->(FKCommit())
	EndIf
	//Ŀ
	// Grava arquivo AA4 (itens da amarracao)              
	//
	dbSelectArea("AA4")
	For nCntFor := 1 To Len(aCols)
		If ( !aCols[nCntFor][nUsado+1] .And. !Empty(aCols[nCntFor][nPosProd]) )
			If ( nCntFor > Len(aRecAA4) )
				RecLock("AA4",.T.)
			Else
				AA4->(MsGoto(aRecAA4[nCntFor]))
				RecLock("AA4",.F.)
			EndIf
			For nCntFor2 := 1 To nUsado
				If ( aHeader[nCntFor2][10] <> "V" )
					FieldPut(FieldPos(aHeader[nCntFor2][2]),aCols[nCntFor][nCntFor2])
				EndIf
			Next nCntFor2
			AA4->AA4_FILIAL:= xFilial("AA4")
			AA4->AA4_CODCLI:= M->AA3_CODCLI
			AA4->AA4_LOJA  := M->AA3_LOJA
			AA4->AA4_CODPRO:= M->AA3_CODPRO
			AA4->AA4_NUMSER:= M->AA3_NUMSER
			//Ŀ
			// Atualiza historico dos acessorios                                   
			//
			dbSelectArea("AAF")
			dbSetOrder(1)
			If ( !MsSeek(xFilial("AAF")+M->AA3_CODCLI+M->AA3_LOJA+M->AA3_CODPRO+M->AA3_NUMSER+AA4->AA4_PRODAC+AA4->AA4_NSERAC) )
				Reclock("AAF",.T.)
				AAF->AAF_FILIAL := xFilial("AAF")
				AAF->AAF_CODCLI := M->AA3_CODCLI
				AAF->AAF_LOJA   := M->AA3_LOJA
				AAF->AAF_CODPRO := M->AA3_CODPRO
				AAF->AAF_NUMSER := M->AA3_NUMSER
				AAF->AAF_PRODAC := AA4->AA4_PRODAC
				AAF->AAF_NSERAC := AA4->AA4_NSERAC
				AAF->AAF_DTINI  := dDataBase
				AAF->AAF_CODFAB := M->AA3_CODFAB
				AAF->AAF_LOJAFA := M->AA3_LOJAFA
				AAF->AAF_LOGINI := STR0001 // # "CADASTRO AMARRACAO CLIENTE X EQPTO"
				MsUnlock()
			EndIf
		Else
			If ( nCntFor <= Len(aRecAA4) )
				AA4->(MsGoto(aRecAA4[nCntFor]))
				RecLock("AA4",.F.)
				dbDelete()
				dbSelectArea("AAF")
				dbSetOrder(1)
				If ( MsSeek(xFilial("AAF")+M->AA3_CODCLI+M->AA3_LOJA+M->AA3_CODPRO+M->AA3_NUMSER+AA4->AA4_PRODAC+AA4->AA4_NSERAC) )
					Reclock("AAF",.F.)
					AAF->AAF_DTFIM  := dDataBase
					AAF->AAF_LOGFIM := STR0002 // # "EXCLUIDO PELA AMARRACAO"
				EndIf
			EndIf
		EndIf
	Next nCntFor
	AA4->(FKCommit())
	AAF->(FKCommit())

	//Ŀ
	//Altera o Status da equipamento                                          
	//
	AtEqStatus(FunName())
	//Ŀ
	//Expande o Plano de Manutencao quando for inclusao                       
	//
	If ( nOpcao == 1 )
		cPlano := &(SuperGetMv("MV_ATPLANO"))
		If ( !Empty(cPlano) )
			AtExpPlano( cPlano )
		EndIf
	EndIf

Case nOpcao == 3
	//Ŀ
	//Bloco de Exclusao                                                       
	//
	For nCntFor := 1 To Len(aRecAA4)
		dbSelectArea("AA4")
		MsGoto(aRecAA4[nCntFor])
		//Ŀ
		//Atualiza historico dos acessorios                                  
		//
		dbSelectarea("AAF")
		dbSetOrder(1)
		If ( MsSeek(xFilial("AAF")+M->AA3_CODCLI+M->AA3_LOJA+M->AA3_CODPRO+M->AA3_NUMSER+AA4->AA4_PRODAC+AA4->AA4_NSERAC) )
			Reclock("AAF",.F.)
			AAF->AAF_DTFIM  := dDataBase
			AAF->AAF_LOGFIM := STR0002 // # "EXCLUIDO PELA AMARRACAO"
		EndIf
		dbSelectArea("AA4")
		RecLock("AA4")
		dbDelete()
	Next nCntFor
	AAF->(FKCommit())
	AA4->(FKCommit())
	//Ŀ
	// Deleta o cabecalho do contrato (amarracao).                  
	//
	dbSelectarea("AAF")
	dbSetOrder(1)
	If ( MsSeek(xFilial("AAF")+M->AA3_CODCLI+M->AA3_LOJA+M->AA3_CODPRO+M->AA3_NUMSER) )
		Reclock("AAF",.F.)
		AAF->AAF_DTFIM  := dDataBase
		AAF->AAF_LOGFIM := STR0002 // # "EXCLUIDO PELA AMARRACAO"
	EndIf
	//Ŀ
	// Deleta localizacao fisica 
	//
	If AliasInDic("AGW")
		AGW->(dbSetOrder(3))
		If AGW->(dbSeek(xFilial("AGW")+M->AA3_CODCLI+M->AA3_LOJA+M->AA3_CODPRO+M->AA3_NUMSER))
			RecLock("AGW",.F.)
			AGW->(dbDelete())
			AGW->(MsUnLock())
		EndIf
	EndIf
	MSMM(M->AA3_CODMEM,,,,2)
	dbSelectArea("AA3")
	RecLock("AA3",.F.,.T.)
	dbDelete()
	AA3->(FKCommit())

Case ( nOpcao == 4 )
	lGravou := .F.

	dbSelectArea("SA1")
	dbSetOrder(1)
	If ( MsSeek(xFilial("SA1")+cCodCli+cLoja) )
		dbSelectArea("AA3")
		dbSetOrder(1)
		If ( !MsSeek(xFilial("AA3")+cCodCli+cLoja+AA3->AA3_CODPRO+AA3->AA3_NUMSER+AA3->AA3_FILORI) )
			MsGoto(nRegAA3)

			//Ŀ
			//Armazena codigo do cliente e loja antes de gravar o AA3
			//
			cCodCliAnt	:= AA3->AA3_CODCLI
			cLojaCliAnt	:= AA3->AA3_LOJA

			//Ŀ
			// Atualiza a base instalada                                         
			//
			dbSelectArea("AA3")
			RecLock("AA3",.F.)
			AA3->AA3_CODCLI := cCodCli
			AA3->AA3_LOJA   := cLoja
			AA3->AA3_CONTRT := ""
			AA3->AA3_CTAPRE := ""
			AA3->AA3_DTCTAM := Ctod("")
			
			If lAA3NF
				If IsIncallstack('MaDelNFS')  
					//-- Excluso da NF
					AA3->AA3_NFVEND := ""
				ElseIf IsIncallstack('Ma410PvNfs') .And. Empty(AA3->AA3_NFVEND)
					//-- Incluso de pedido com base de atendimento sem NF preenchida (reemisso do pedido) 
					AA3->AA3_NFVEND := SD2->D2_DOC
				EndIf
			EndIf			

			//Ŀ
			//Bloco de Transferencia                                                  
			//
			For nCntFor := 1 To Len(aRecAA4)
				dbSelectArea("AA4")
				MsGoto(aRecAA4[nCntFor])
				//Ŀ
				//Atualiza historico dos acessorios                                  
				//
				dbSelectArea("AA4")
				RecLock("AA4")
				AA4->AA4_CODCLI := cCodCli
				AA4->AA4_LOJA   := cLoja
			Next nCntFor

			//Ŀ
			// Atualiza o historico do equipamento                               
			//
			Reclock("AAF",.T.)
			AAF->AAF_FILIAL := xFilial("AAF")
			AAF->AAF_CODCLI := cCodCli
			AAF->AAF_LOJA   := cLoja
			AAF->AAF_CODPRO := AA3->AA3_CODPRO
			AAF->AAF_NUMSER := AA3->AA3_NUMSER
			AAF->AAF_PRODAC := AA3->AA3_CODPRO
			AAF->AAF_NSERAC := AA3->AA3_NUMSER
			AAF->AAF_DTINI  := dDataBase
			AAF->AAF_CODFAB := AA3->AA3_CODFAB
			AAF->AAF_LOJAFA := AA3->AA3_LOJAFA
			AAF->AAF_LOGINI := Left( STR0003 + cCodCliAnt + "/" + ;
								cLojaCliAnt + STR0004 + cCodCli + "/" + cLoja, Len( AAF->AAF_LOGINI ) ) // # "TRANSFERENCIA DE CLIENTE/LOJA " ## " PARA "
			AAF->( MsUnlock() )

			lGravou := .T.

		Else
			If ( nModulo == 28 ) // Variavel Public
				Help(" ",1,"AT040INC01")
			EndIf
			lGravou := .F.
		EndIf
	Else
		If ( nModulo == 28 ) // Variavel Public
			Help(" ",1,"RECNOIS")
		EndIf
		lGravou := .F.
	EndIf
	//Ŀ
	//Altera o Status do equipamento                                          
	//
	AtEqStatus(FunName())
EndCase
//Ŀ
// Limpa variaveis de campos virtuais                  
//
M->AA3_DESPRO := ""
M->AA3_NOMCLI := ""
M->AA3_NOMTEC := ""

AA3->( MsUnlock() )

//Ŀ
// Executa o ponto de entrada                          
//
If lGravou
	If ExistBlock( "AT040GRV" )
		ExecBlock( "AT040GRV", .F., .F., { nOpcao } )
	EndIf
EndIf

Return .T.

/*/


Ŀ
Funcao    SldAtuEst  Autor  Eduardo Riera          Data  01.02.99 
Ĵ
Descrio Avalia os saldo por Almoxarifado, Lote e Localizacao,       
          ate a quantidade informada no parametro (3).                
Ĵ
Retorno   ExpN1: Quantidade em estoque disponivel                     
Ĵ
ParametrosExpC1: Codigo do Produto         - Obrigatorio              
          ExpC2: Local                     - Obrigatorio              
          ExpC3: Quantidade                - Obrigatorio              
          ExpC4: Lote de Controle          - Obrig. se Inf. Sub-Lote  
          ExpC5: Sub-Lote                                             
          ExpC6: Localizacao               - Obrig. se inf. Nr.Serie  
          ExpC7: Numero de Serie                                      
          ExpC8: Reserva                                              
          ExpL9: Indica se considera poder de terceiro                
          ExpLA: Indica se considera poder em terceiro                
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function SldAtuEst(cCodPro,cLocal,nQtd,cLoteCtl,cNumLote,cLocaliz,cNumSer,cReserva,lConsTerc,lConsQNPt,cProjeto,cTarefa,cServico,lPrdBn)

Local cLoteSb8     := ""
Local cNumLSb8     := ""

Local cAliasSB8    := "SB8"
Local cAliasSBF    := "SBF"
Local cFilialSB8   :=  xFilial("SB8")
Local cFilialSBF   :=  xFilial("SBF")

Local nSaldo       := 0
Local nEmpenho     := 0

Local nQtdSB8      := 0
Local nReserva     := 0
Local nReservaSB8  := 0
Local nBFSaldo     := 0
Local lContSB8     := .T.
Local lContSBF     := .T.
Local lUsaVenc     := .F.
Local lQuery       := .F.
Local lLocaliza    := Localiza(cCodPro,.T.)
Local nRecSB8      := 0
Local lEmpPrev     := If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)
Local lQEmpNF	   := GetNewPar("MV_QEMPNF",.F.)	//Considera o campo B2_QEMPN no calculo do Saldo
Local lAtuSGJ      := SuperGetMV("MV_PVCOMOP",.F.,.F.) .And. FindFunction("ALIASINDIC") .And. AliasIndic("SGJ")
Local lWmsNew      := SuperGetMV("MV_WMSNEW",.F.,.F.)
Local l455LibAlt   := IsInCallStack("A455LibAlt") .And. SuperGetMv("MV_GRVBLQ2",.F.,.F.)
Local aStruSB8     := {}
Local aStruSBF     := {}
Local cQuery       := ""
Local nX           := 0
Local aInsert 	   := {}
Local nIniLoopPS   := 1
Local nLen 		   := 0 
Local nPosPrepared := 0 
Local cMD5 		   := "" 
Local lVerLib	   := FatxVerLib()


DEFAULT lConsQNPT := .F.
DEFAULT cProjeto	:= ""
DEFAULT cTarefa		:= ""
DEFAULT cServico    := ""
DEFAULT lPrdBn		:= .F.

If lAtuSGJ
	lQEmpNF	:= .F.
Endif

//Ŀ
//Analisa os dados de entrada da funcao                                   
//
cLoteCtl  := If(cLoteCtl == NIL .Or. Empty(cLoteCtl),"",cLoteCtl)
cNumLote  := If(cNumLote == NIL .Or. Empty(cNumLote) .Or. Rastro(cCodPro,"L"),"",cNumLote)
cLocaliz  := If(cLocaliz == NIL .Or. Empty(cLocaliz),If(!Empty(cNumSer),Space(Len(SBF->BF_LOCALIZ)),""),cLocaliz)
cNumSer   := If(cNumSer  == NIL .Or. Empty(cNumSer) ,"",cNumSer)
lUsaVenc  := If(!Empty(cLoteCtl+cNumLote),.T.,(SuperGetMv('MV_LOTVENC')=='S'))
cReserva  := If("C6_RESERVA"$ ReadVar(),&(ReadVar()),cReserva)

If !BlqInvent(cCodPro,cLocal,,If(!__lPyme, cLocaliz, '')) .And. !(FindFunction('AvalBlqLoc') .And. AvalBlqLoc(cCodPro,cLocal,Nil,.F.))
	If ( Empty(cReserva) .OR. Iif(ExistFunc("LjxValEst"), LjxValEst(SC5->C5_ORCRES), .F. ))
		//Ŀ
		//Verifica os Saldos por Lote / Sub-Lote / Localizacao                    
		//
		If ( Rastro(cCodPro) ) .And. Empty(cServico)
			dbSelectArea("SB8")
			dbSetOrder(3)
			SB8->(dbCommit())

			lQuery    := .T.
			cAliasSB8 := "SLDATUEST"
			aStruSB8  := SB8->(dbStruct())

			For nX := 1 To Len(aStruSB8)
				cQuery += ",SB8."+aStruSB8[nX][1]
			Next nX
			If lLocaliza .And. !(lWmsNew .And. IntWms(cCodPro))
				SBF->(dbCommit())
				cAliasSBF := "SLDATUEST"
				aStruSBF  := SBF->(dbStruct())
				For nX := 1 To Len(aStruSBF)
					cQuery += ",SBF."+aStruSBF[nX][1]
				Next nX
			EndIf

			cQuery    := "SELECT "+SubStr(cQuery,2)+" "
			cQuery    += ",SB8.R_E_C_N_O_ SB8RECNO "

			Aadd(aInsert,RetSqlName("SB8"))
			nIniLoopPS++
			cQuery    += "FROM ? SB8 "
			
			If lLocaliza .And. !(lWmsNew .And. IntWms(cCodPro))
				Aadd(aInsert,RetSqlName("SBF"))
				cQuery += ", ? SBF "
				nIniLoopPS++
			EndIf
			Aadd(aInsert,cFilialSB8)
			cQuery    += "WHERE SB8.B8_FILIAL= ? AND "
			
			Aadd(aInsert,cCodPro)
			cQuery    += "SB8.B8_PRODUTO= ? AND "
			
			Aadd(aInsert,cLocal)
			cQuery    += "SB8.B8_LOCAL= ? AND "

			If !Empty(cLoteCtl)
				Aadd(aInsert,cLoteCtl)
				cQuery    += "SB8.B8_LOTECTL= ? AND "
			EndIf
			If !Empty(cNumLote)
				Aadd(aInsert,cNumLote)
				cQuery    += "SB8.B8_NUMLOTE= ? AND "
			EndIf

			cQuery    += "SB8.B8_SALDO > 0 AND SB8.D_E_L_E_T_ = ' ' "
			If lLocaliza .And. !(lWmsNew .And. IntWms(cCodPro))
				Aadd(aInsert,cFilialSBF)
				cQuery    += " AND SBF.BF_FILIAL= ? AND "
				
				Aadd(aInsert,cCodPro)
				cQuery    += "SBF.BF_PRODUTO= ? AND "
				
				Aadd(aInsert,cLocal)
				cQuery    += "SBF.BF_LOCAL= ? AND "
				cQuery    += "SBF.BF_LOTECTL=SB8.B8_LOTECTL AND "
				If !Empty(cNumLote)
					cQuery    += "SBF.BF_NUMLOTE=SB8.B8_NUMLOTE AND "
				EndIf
				cQuery    += "SBF.D_E_L_E_T_=' ' "
				cQuery    += "ORDER BY "+SqlOrder(SB8->(IndexKey()))+","+SqlOrder(SBF->(IndexKey()))
			Else
				cQuery    += "ORDER BY "+SqlOrder(SB8->(IndexKey()))
			EndIf

			nLen := Len(aInsert)
			cMD5 := MD5(cQuery) 
			If (nPosPrepared := Ascan(__aPrepared,{|x| x[2] == cMD5})) == 0 
				cQuery := ChangeQuery(cQuery)
				Aadd(__aPrepared,{IIf(lVerLib,FwExecStatement():New(cQuery),FWPreparedStatement():New(cQuery)),cMD5})
				nPosPrepared := Len(__aPrepared)
			Endif 
			__aPrepared[nPosPrepared][1]:SetUnsafe(1,aInsert[1])

			If nIniLoopPS > 2
				__aPrepared[nPosPrepared][1]:SetUnsafe(2,aInsert[2])
			EndIf

			For nX := nIniLoopPS to nLen
				__aPrepared[nPosPrepared][1]:SetString(nX,aInsert[nX])
			Next 

			If lVerLib
				__aPrepared[nPosPrepared][1]:OpenAlias(cAliasSB8)
			Else
				cQuery := __aPrepared[nPosPrepared][1]:getFixQuery()
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB8,.T.,.T.)
			EndIf
			aInsert := aSize(aInsert,0)
			
			For nX := 1 To Len(aStruSB8)
				If aStruSB8[nX][2]<>"C"
					TcSetField(cAliasSB8,aStruSB8[nX][1],aStruSB8[nX][2],aStruSB8[nX][3],aStruSB8[nX][4])
				EndIf
			Next nX
			If lLocaliza .And. !(lWmsNew .And. IntWms(cCodPro))
				For nX := 1 To Len(aStruSBF)
					If aStruSBF[nX][2]<>"C"
						TcSetField(cAliasSBF,aStruSBF[nX][1],aStruSBF[nX][2],aStruSBF[nX][3],aStruSBF[nX][4])
					EndIf
				Next nX
			EndIf
			
			While ( !Eof() .And. cFilialSB8 == (cAliasSB8)->B8_FILIAL .And.;
					cCodPro        == (cAliasSB8)->B8_PRODUTO .And.;
					cLocal         == (cAliasSB8)->B8_LOCAL   .And.;
					(cLoteCtl      == (cAliasSB8)->B8_LOTECTL.Or.Empty(cLoteCtl)).And.;
					(cNumLote      == (cAliasSB8)->B8_NUMLOTE.Or.Empty(cNumLote)).And.;
					lContSB8 )
				//Ŀ
				//Avalia os Saldos por Lote e Sub-Lote                                    
				//
				nReservaSB8:=0
				lContSBF := .T.
				If lQuery
					nRecSB8:=(cAliasSB8)->SB8RECNO
				EndIf
				nQtdSB8:=Min(nQtd-nReserva,SB8Saldo(NIL,lUsaVenc,NIL,NIL,cAliasSB8,lEmpPrev,NIL,dDataBase))
				If nQtdSB8 > 0 .And. If(lUsaVenc, .T., ((cAliasSB8)->B8_DTVALID >= dDataBase .Or.Empty((cAliasSB8)->B8_DTVALID)))
					//Ŀ
					//Avalia os saldos por Localizacao e Nr.Serie                             
					//
					If lLocaliza  .And. !(lWmsNew .And. IntWms(cCodPro))
						cNumLSb8 := If(Rastro(cCodPro,"S"),(cAliasSB8)->B8_NUMLOTE,Space(Len(SB8->B8_NUMLOTE)))
						cLoteSb8 := (cAliasSB8)->B8_LOTECTL
						If !lQuery
							dbSelectArea("SBF")
							dbSetOrder(2)
							MsSeek(cFilialSBF+cCodPro+cLocal+cLoteSb8+cNumLSb8)
						EndIf
						While ( !Eof() .And. cFilialSBF == (cAliasSBF)->BF_FILIAL .And.;
								cCodPro        == (cAliasSBF)->BF_PRODUTO .And.;
								cLocal         == (cAliasSBF)->BF_LOCAL  .And.;
								cLoteSb8       == (cAliasSBF)->BF_LOTECTL .And.;
								lContSBF)
							If ( ((cAliasSBF)->BF_LOCALIZ == cLocaliz .Or.;
									Empty(cLocaliz) ) .And.;
									((cAliasSBF)->BF_NUMSERI == cNumSer  .Or.;
									Empty(cNumSer)) .And.;
									(cNumLSb8 == (cAliasSBF)->BF_NUMLOTE .Or.;
									Empty(cNumLSb8)) )
									nBFSaldo := SBFSaldo(,cAliasSBF)
								If ( nBFSaldo > 0 )
									nEmpenho := nQtdSB8 - nReservaSB8
									nEmpenho := Min(nBFSaldo,nEmpenho)
									nSaldo   += nEmpenho
									nReserva += nEmpenho
									nReservaSB8 += nEmpenho
								EndIf
							EndIf
							If (nReservaSB8 >= nQtdSB8)
								lContSBF := .F.
							EndIf
							dbSelectArea(cAliasSBF)
							dbSkip()
						EndDo
					Else
						nEmpenho := nQtdSB8 - nReservaSB8
						nEmpenho := Min(SB8Saldo(NIL,lUsaVenc,NIL,NIL,cAliasSB8,lEmpPrev,NIL,dDataBase),nEmpenho)
						nSaldo   += nEmpenho
						nReserva += nEmpenho
						nReservaSB8 += nEmpenho
					EndIf
				EndIf
				If (nReserva >= nQtd)
					lContSB8 := .F.
				EndIf
				dbSelectArea(cAliasSB8)
				If lQuery
					While !Eof() .And. (cAliasSB8)->SB8RECNO == nRecSB8
						dbSkip()
					End
				Else
					dbSkip()
				EndIf
			EndDo
			If lQuery
				dbSelectArea(cAliasSB8)
				dbCloseArea()
				dbSelectArea("SB8")
			EndIf
			dbSelectArea("SB2")
			dbSetOrder(1)
			DbSeek(xFilial("SB2")+cCodPro+cLocal)
			nSaldo := Min(nSaldo,SaldoSb2(,If(!Empty(cServico),.T.,!lPrdBn .And. GetNewPar("MV_QEMPV",.F.)),,lConsTerc,lConsQNPT))
		EndIf
		//Ŀ
		//Verifica os saldo por Localizacao quando nao ha rastro                  
		//
		If ( !Rastro(cCodPro) .And. lLocaliza .And. nSaldo == 0 ) .And. Empty(cServico) .And. !(lWmsNew .And. IntWms(cCodPro))
			dbSelectArea("SBF")
			dbSetOrder(2)
			SBF->(dbCommit())
			lQuery := .T.
			aStruSBF  := SBF->(dbStruct())
			cAliasSBF := "SLDATUESTSBF"

			cQuery    := "SELECT * "

			Aadd(aInsert, RetSqlName("SBF"))
			cQuery    += "FROM ? SBF "

			Aadd(aInsert, cFilialSBF)
			cQuery    += "WHERE SBF.BF_FILIAL= ? AND "

			Aadd(aInsert, cCodPro)
			cQuery    += "SBF.BF_PRODUTO= ? AND "
			
			Aadd(aInsert, cLocal)
			cQuery    += "SBF.BF_LOCAL= ? AND "

			If !Empty(cLocaliz)
				Aadd(aInsert, cLocaliz)
				cQuery    += "SBF.BF_LOCALIZ = ? AND "
			EndIf
			If !Empty(cNumSer)
				Aadd(aInsert, cNumSer)
				cQuery    += "SBF.BF_NUMSERI = ? AND "
			EndIf
			cQuery    += "SBF.D_E_L_E_T_=' ' "
			cQuery    += "ORDER BY "+SqlOrder(SBF->(IndexKey()))

			nLen := Len(aInsert)
			cMD5 := MD5(cQuery) 
			If (nPosPrepared := Ascan(__aPrepared,{|x| x[2] == cMD5})) == 0 
				cQuery := ChangeQuery(cQuery)
				Aadd(__aPrepared,{IIf(lVerLib,FwExecStatement():New(cQuery),FWPreparedStatement():New(cQuery)),cMD5})
				nPosPrepared := Len(__aPrepared)				
			Endif 

			__aPrepared[nPosPrepared][1]:SetUnsafe(1,aInsert[1])
			
			For nX := 2 to nLen
				__aPrepared[nPosPrepared][1]:SetString(nX,aInsert[nX])
			Next 
			
			If lVerLib
				__aPrepared[nPosPrepared][1]:OpenAlias(cAliasSBF)
			Else
				cQuery := __aPrepared[nPosPrepared][1]:getFixQuery()
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSBF,.T.,.T.)
			EndIF

			aInsert := aSize(aInsert,0)
			
			For nX := 1 To Len(aStruSBF)
				If aStruSBF[nX][2]<>"C"
					TcSetField(cAliasSBF,aStruSBF[nX][1],aStruSBF[nX][2],aStruSBF[nX][3],aStruSBF[nX][4])
				EndIf
			Next nX
			While ( !Eof() .And. cFilialSBF == (cAliasSBF)->BF_FILIAL .And.;
					cCodPro        == (cAliasSBF)->BF_PRODUTO .And.;
					cLocal         == (cAliasSBF)->BF_LOCAL .And.;
					lContSBF)
				If ( ((cAliasSBF)->BF_LOCALIZ == cLocaliz .Or.;
						Empty(cLocaliz) ) .And.;
						((cAliasSBF)->BF_NUMSERI == cNumSer  .Or.;
						Empty(cNumSer)) )
						nBFSaldo := SBFSaldo(,cAliasSBF)
					If ( nBFSaldo > 0 )
						nEmpenho := nQtd - nReserva
						nEmpenho := Min(nBFSaldo,nEmpenho)
						nReserva += nEmpenho
						nSaldo   += nEmpenho
					EndIf
				EndIf
				dbSelectArea(cAliasSBF)
				dbSkip()
				If ( nReserva >= nQtd )
					lContSBF:= .F.
				EndIf
			EndDo
			If lQuery
				dbSelectArea(cAliasSBF)
				dbCloseArea()
				dbSelectArea("SBF")
			EndIf
			dbSelectArea("SB2")
			dbSetOrder(1)
			DbSeek(xFilial("SB2")+cCodPro+cLocal)
			nSaldo := Min(nSaldo,SaldoSb2(,If(!Empty(cServico),.T.,!lPrdBn .And. GetNewPar("MV_QEMPV",.F.)),,lConsTerc,lConsQNPT))
		EndIf
		//Ŀ
		//Verifica SB2 quando nao ha rastro nem localizacao ou qdo se usa o WMS   
		//
		If (!Rastro(cCodPro) .And. !Localiza(cCodPro,.T.)) .Or. !Empty(cServico)
			dbSelectArea("SB2")
			dbSetOrder(1)
			dbSeek(xFilial("SB2")+cCodPro+cLocal)
			nSaldo	:= SaldoSb2(,If(!Empty(cServico),.T.,!lPrdBn .And. GetNewPar("MV_QEMPV",.F.)),,lConsTerc,lConsQNPT)
			If !Empty(cProjeto) .And. !Empty(cTarefa)
				nSaldo := MAX(nSaldo,0)
				dbSelectArea("AFJ")
				dbSetOrder(1)
				MsSeek(xFilial("AFJ")+cProjeto+cTarefa)
				While !Eof() .And.xFilial("AFJ")+cProjeto+cTarefa == AFJ->AFJ_FILIAL + AFJ->AFJ_PROJET + AFJ->AFJ_TAREFA
					nSaldo += Max(AFJ->AFJ_QEMP - AFJ->AFJ_QATU,0)
					dbSkip()
				End
			EndIf
			nSaldo := Min(nQtd,nSaldo)
		Else
			If lConsQNPT
				dbSelectArea("SB2")
				dbSetOrder(1)
				MsSeek(xFilial("SB2")+cCodPro+cLocal)
				nSaldo += SB2->B2_QNPT
			EndIf
		EndIf
	Else
		dbSelectArea("SC0")
		dbSetOrder(1)
		MsSeek(xFilial("SC0")+cReserva+cCodPro+cLocal)
		nSaldo := Min(SC0->C0_QUANT,nQtd)
	EndIf
EndIf
//Ŀ
//Soma ao Saldo o Valor Empenhado na B2_QEMPN para este Pedido            
//
If lQEmpNF
	If !l455LibAlt .And. (!Empty(SC6->C6_NUMOP) .Or. !Empty(SC6->C6_NUMSC) .Or. SC6->C6_OP = "05")
		nSaldo += SC6->C6_QTDVEN - If(FindFunction("A650QLibPV"),A650QLibPV(),0)
	EndIf
Endif
Return(nSaldo)

/*/


Ŀ
Funcao    AtIsRotina Autor  Eduardo Riera          Data  29.01.99 
Ĵ
Descrio Verifica qual eh a rotina chamadora.                        
Ĵ
Retorno   ExpL1: Logico                                               
Ĵ
ParametrosExpC1: Descricao da Rotina Chamadora para Teste.            
                                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function AtIsRotina(cRotina)

Local lRetorno := .F.
Local nContador:= 1
//Ŀ
//Verifica qual a rotina chamadora                                        
//
While ( !lRetorno .And. !Empty(ProcName(nContador)) )
	If ( Upper(ProcName(nContador))==cRotina )
		lRetorno := .T.
	EndIf
	nContador++
EndDo
Return(lRetorno)

/*/


Ŀ
Funcao    MaAvalCred Autor  Eduardo Riera          Data  10.03.99 
Ĵ
Descrio Funcao Generica de Avaliacao de Credito de Clientes         
Ĵ
Retorno   ExpL1: Credito (Sim/Nao)                                    
Ĵ
ParametrosExpC1: Codigo do Cliente                                    
          ExpC2: Loja do Cliente                                      
          ExpN3: Valor a ser avaliado                                 
          ExpN4: Moeda do valor a ser avaliado                        
          ExpL5: Considera acumulados de Pedido de Venda do SA1       
          ExpC6: Codigo do Bloqueio.                                  
          ExpC7: aEmpenho                                             
          ExpN8: Valor a ser adicionado ao limite de credito          
          ExpN9: Valor adicional de credito 					           
          ExpN10: Array de referencia tipo de bloqueio de credito     
          ExpL11: Indica se realizar o Save/Rest das reas (.T./.F.) 
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function MaAvalCred(cCodCli, cLoja, nValor, nMoeda, lPedido, cCodigo, aEmpenho, nVlrCred, nVlAdicCre, aValdet, lSaveArea,cComplTur,cSegTur,cArqAC)
Local aArea			:= {}
Local aAreaSA1		:= {}
Local aAreaSE1		:= {}
Local aStruSA1		:= {}
Local cTipoLim		:= SuperGetMv("MV_CREDCLI")
Local cQuery			:= ""
Local cAliasSE1		:= "SE1"
Local cAliasSA1		:= "SA1"
Local cAliasQry		:= ""
Local nLimCred		:= 0
Local nLimCredFin		:= 0
Local nVlrReal		:= xMoeda(nValor,nMoeda,1,dDataBase,2)
Local nVlrFin			:= 0
Local nVlrPed			:= nVlrReal
Local nLiminCr		:= SuperGetMv("MV_LIMINCR")  //Limite Minimo de Credito
Local nPerMax			:= SuperGetMv("MV_PERMAX")   //Percentual Maximo comprometido com o Limite de Credito
Local nFaixaA			:= SuperGetMv("MV_PEDIDOA")  //Limite de Credito para a Faixa A
Local nFaixaB			:= SuperGetMv("MV_PEDIDOB")  //Limite de Credito para a Faixa B
Local nFaixaC			:= SuperGetMv("MV_PEDIDOC")  //Limite de Credito para a Faixa C
Local nNumDias		:= 0
Local nRegEmp			:= 0
Local nMCusto			:= 0
Local nX				:= 0
Local lQuery			:= .F.
Local lRetorno		:= .T.
Local lCredito		:= .F.
Local lTitVenc		:= .F.
Local xRetorno		:= ""
Local cRiscoAC 		:= ""
Local nLimiteAC		:= 0
Local nMoedaAC 		:= 0
Local dVencAC  		:= StoD("")
Local cSepNeg			:= If("|"$MV_CRNEG,"|",",")
Local cSepProv		:= If("|"$MVPROVIS,"|",",")
Local cSepRec			:= If("|"$MVRECANT,"|",",")
Local lIntGC	 		:= IIf((SuperGetMV("MV_VEICULO",,"N")) == "S"   ,.T.,.F.)
Local lIntTUR	 		:= .F.
Local lMaAvCrFin		:= ExistBlock("MAAVCRFIN")

Default nVlrCred		:= 0
Default nVlAdicCre	:= 0
Default aValdet		:= {} // [cCodigo[lCredito,lTitVenc]] Detalha o tipo de bloqueio por credito (Credito,Ttulo)
Default lSaveArea		:= .T.	// .T.=Executa o Save/Rest das reas / .F. = No executa o Save/Rest das reas
DEFAULT cComplTur  	:= "" //Complemento do mdulo de turismo
DEFAULT cSegTur    	:= "" //Complemento do mdulo de turismo
DEFAULT cArqAC     	:= ""

lIntTUR	 := IIf( !Empty(cComplTur) .And. !Empty(cSegTur) ,.T.,.F.)
cArqAC   := "SA1"

If	lMaAvCred == NIL
	lMaAvCred			:= ExistBlock("MAAVCRED")
EndIf
If	lMaAvCrPr == NIL
	lMaAvCrPr			:= ExistBlock("MAAVCRPR")
EndIf

If	lSaveArea
	aArea				:= GetArea()
	aAreaSA1			:= SA1->(GetArea())
	aAreaSE1			:= SE1->(GetArea())
EndIf

dbSelectArea("SA1")
dbSetOrder(1)
If ( (SuperGetMv("MV_BLOQUEI" ) .or. lIntTUR ) .And. !lMaAvCred )
	Do Case
		//Ŀ
		//Aqui e Verificado o Cliente Por Codigo + Loja                           
		//
	Case ( cTipoLim=="L" )
		If ( MsSeek(xFilial("SA1")+cCodCli+cLoja) )
			
			If lIntTUR
				If G8T->(dbSeek(xFilial("G8T")+cComplTur+cSegTur))
					cRiscoAC := G8T->G8T_RISCO
					dVencAC  := G8T->G8T_VENCTO
					nLimiteAC:= G8T->G8T_LIMITE
					nMoedaAC := Posicione("G5T",1,xFilial("G5T") + G8T->G8T_MOEDA,"G5T_MOEDAF") //G8T->G8T_MOEDA
					cArqAC   := "G8T"
				Else
					cRiscoAC := SA1->A1_RISCO
					dVencAC  := SA1->A1_VENCLC
					nLimiteAC:= SA1->A1_LC
					nMoedaAC := SA1->A1_MOEDALC
				EndIf
			Else
				cRiscoAC := SA1->A1_RISCO
				dVencAC  := SA1->A1_VENCLC
				nLimiteAC:= SA1->A1_LC
				nMoedaAC := SA1->A1_MOEDALC				
			EndIf
			
			If ( cRiscoAC == "A" )
				lRetorno := .T.
			EndIf
			If ( cRiscoAC == "E" .And. nVlrCred<=0)
				lRetorno := .F.
				cCodigo  := "01" // Limite de Credito
				lCredito := .T.
				
			EndIf

			//Ŀ
			//Aqui e avaliado o Vencimento do Limite de Credito do Cliente            
			//
			If ( !Empty(dVencAC) .And. dVencAC < dDataBase ) .And. nVlrCred <= 0
				cCodigo  := "04" //Vencimento do Limite de Credito
				lRetorno := .F.
				lCredito := .T.
			EndIf
			If ( cRiscoAC <> "A" .And. !(cRiscoAC $ "E,Z" .And. nVlrCred<=0) .And. lRetorno)
				//Ŀ
				//Aqui e verificado o Limite de Credito do Cliente + Loja                 
				//
				//Ŀ
				//O Limite de Credito sempre esta na Moeda MV_MCUSTO, mas os calculos sao 
				//em na moeda corrente.                                                   
				//
				nMCusto	 := IIf( nMoedaAC > 0 , nMoedaAC , Val(SuperGetMv("MV_MCUSTO")) )
				nVlrCred := xMoeda(nVlrCred,nMoeda,1,dDataBase,2)
				If cRiscoAC $ "E,Z"
					nLimCred := 0
				Else
					nLimCred := xMoeda(nLimiteAC,nMCusto,1,dDataBase,2)
				EndIf
				//Ŀ
				//Adicional de Crdito quando utilizado o 9o Parmetro							
				//
				If nVlAdicCre > 0 .and. lIntGC // Modulo de Concessionrias
					nLimCred += nVlAdicCre
				Endif
				//Ŀ
				//Verifica se o Valor nao eh maior que o Limite de Credito                
				//
				If ( lPedido )
					If nVlrCred < nVlrReal
						nVlrReal += SA1->A1_SALDUP + xMoeda(SA1->A1_SALPEDL,nMCusto,1,dDatabase,2)
					Else
						nVlrReal += SA1->A1_SALDUP + xMoeda(SA1->A1_SALPEDL,nMCusto,1,dDatabase,2)
						nLimCred += nVlrCred
					EndIf
					If ( aEmpenho <> Nil ) .And. ( !Empty(aEmpenho) )
						nRegEmp  := aScan(aEmpenho[1],{|x| x[1]==SA1->(RecNo())})
						If ( nRegEmp <> 0 )
							nVlrReal += xMoeda(aEmpenho[1][nRegEmp][2],nMCusto,1,dDatabase,2)
						EndIf
					EndIf
				EndIf
				If( lIntTUR )
					If nVlrCred < nVlrReal
						nVlrReal += SA1->A1_SALDUP
					EndIf
				EndIf
				If ( nVlrReal > nLimCred .And. nVlrReal > 0)
					cCodigo  := "01" // Limite de Credito
					lRetorno := .F.
					lCredito := .T.
				EndIf
				
				//Ŀ
				//Controle de limite de credito secundario                                
				//
				If cRiscoAC $ "E,Z"
					nLimCredFin	:= xMoeda(SA1->A1_LCFIN,nMCusto,1,dDataBase,MsDecimais(1))
				Else
					nLimCredFin := 0
				EndIf
				If ( aEmpenho <> Nil ) .And. ( !Empty(aEmpenho) )
					nRegEmp  := aScan(aEmpenho[1],{|x| x[1]==SA1->(RecNo())})
					If ( nRegEmp <> 0 )
						nLimCredFin -= aEmpenho[1][nRegEmp][3]
					EndIf
				EndIf				
				If SA1->A1_SALFIN > nLimCredFin .And. SA1->A1_LCFIN > 0
					cCodigo 	:= "01" // Limite de Credito
					lRetorno := .F.
					lCredito := .T.
				EndIf
				//Ŀ
				//Verifica as Classes de Cliente                                          
				//
				If nVlrReal > 0
					Do Case
						Case ( nVlrReal <= nLiMinCr )
							lRetorno := .T.
							cCodigo  := ""
							lCredito := .T.
						Case ( nVlrReal > ((nPerMax * nLimCred) / 100) )
							lRetorno := .F.
							cCodigo  := "01" // Limite de Credito
							lCredito := .T.
						Case ( SA1->A1_CLASSE == "A" .And. nVlrPed > nfaixaA .And. nFaixaA <> 0 )
							lRetorno := .F.
							cCodigo  := "01" // Limite de Credito
							lCredito := .T.
						Case ( SA1->A1_CLASSE == "B" .And. nVlrPed > nfaixaB .And. nFaixaB <> 0 )
							lRetorno := .F.
							cCodigo  := "01" // Limite de Credito
							lCredito := .T.
						Case ( SA1->A1_CLASSE == "C" .And. nVlrPed > nfaixaC .And. nFaixaC <> 0 )
							lRetorno := .F.
							cCodigo  := "01" // Limite de Credito
							lCredito := .T.
					EndCase
					//Ŀ
					//Aqui e verificado o Grau de Risco do Cliente + Loja                     
					//
					If ( lRetorno .And. !Empty(cRiscoAC) .And. !cRiscoAC $"E,Z")
						
						If lIntTUR
							nNumDias := SuperGetMv("MV_RISCO"+cRiscoAC+ Iif(cSegTur=="1","C",Iif(cSegTur=="2","E","L")))
						Else
							nNumDias := SuperGetMv("MV_RISCO"+cRiscoAC)
						EndIf
						
						dbSelectArea("SE1")
						dbSetOrder(8)
						lQuery    := .T.
						cAliasSE1 := "MAAVALCRED"

						cQuery    := "SELECT MIN(E1_VENCREA) VENCREAL "
						cQuery    += "FROM "+RetSqlName("SE1")+" SE1 "
						cQuery    += "WHERE SE1.E1_FILIAL='"+xFilial("SE1")+"' AND "
						cQuery    += "SE1.E1_CLIENTE='"+cCodCli+"' AND "
						cQuery    += "SE1.E1_LOJA='"+cLoja+"' AND "
						cQuery    += "SE1.E1_STATUS='A' AND "
						cQuery    += "SE1.E1_TIPO NOT IN " + FormatIn(MVABATIM,"|") + " AND "
						cQuery    += "SE1.E1_TIPO NOT IN " + FormatIn(MV_CRNEG,cSepNeg)  + " AND "
						cQuery    += "SE1.E1_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv) + " AND "
						cQuery    += "SE1.E1_TIPO NOT IN " + FormatIn(MVRECANT,cSepRec)  + " AND "
						cQuery    += "SE1.D_E_L_E_T_=' ' "

						If lMaAvCrFin
							cQuery:= ExecBlock("MAAVCRFIN", .F., .F., {cQuery, cCodCli, cLoja})
						EndIf
						cQuery := ChangeQuery(cQuery)
						
						dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSE1,.T.,.T.)

						TcSetField(cAliasSE1,"VENCREAL","D",8,0)

						If (cAliasSE1)->(!Eof()) .And. !Empty((cAliasSE1)->VENCREAL) .And. (dDataBase - (cAliasSE1)->VENCREAL) > nNumDias
							lRetorno := .F.
							cCodigo  := "01" // Limite de Credito
							lTitVenc := .T.
						EndIf

						dbSelectArea(cAliasSE1)
						dbCloseArea()
						dbSelectArea("SE1")

					EndIf
				EndIf
			EndIf
		EndIf
		//Ŀ
		//Aqui e verificado apenas o Codigo ( Matriz )                            
		//
	Case ( cTipoLim == "C" )
		If ( MsSeek(xFilial("SA1")+cCodCli) )
			//Ŀ
			// O Grau de Risco deve ser Avaliado da Matriz                   
			//

			If lIntTUR
				If G8T->(dbSeek(xFilial("G8T")+cComplTur+cSegTur))
					cRiscoAC := G8T->G8T_RISCO
					dVencAC  := G8T->G8T_VENCTO
					nLimiteAC:= G8T->G8T_LIMITE
					nMoedaAC := Posicione("G5T",1,xFilial("G5T") + G8T->G8T_MOEDA,"G5T_MOEDAF") // G8T->G8T_MOEDA
					cArqAC   := "G8T"
				Else
					cRiscoAC := SA1->A1_RISCO
					dVencAC  := SA1->A1_VENCLC
					nLimiteAC:= SA1->A1_LC
					nMoedaAC := SA1->A1_MOEDALC
				EndIf
			Else
				cRiscoAC := SA1->A1_RISCO
				dVencAC  := SA1->A1_VENCLC
				nLimiteAC:= SA1->A1_LC
				nMoedaAC := SA1->A1_MOEDALC
			EndIf

			If ( cRiscoAC == "A" )
				lRetorno := .T.
				cCodigo  := ""
			EndIf
			If ( cRiscoAC == "E"  .And. nVlrCred<=0)
				lRetorno := .F.
				cCodigo  := "01" // Limite de Credito
				lCredito := .T.
			EndIf
			
			//Ŀ
			//Aqui e avaliado o Vencimento do Limite de Credito do Cliente            
			//
			If ( !Empty(dVencAC) .And. dVencAC < dDataBase )
				lRetorno := .F.
				cCodigo  := "04" // Vencimento do Limite de Credito
			EndIf
			//Ŀ
			//Aqui e verificado o Limite de Credito do Cliente                        
			//
			//Ŀ
			//O Limite de Credito sempre esta na Moeda MV_MCUSTO, mas os calculos sao 
			//em na moeda corrente.                                                   
			//
			If ( cRiscoAC <> "A" .And. !(cRiscoAC $ "E,Z" .And. nVlrCred<=0) .And. lRetorno )
	
				nLimCred := 0
				nLimCredFin	:= 0
				dbSelectArea("SA1")
				dbSetOrder(1)
				cAliasSA1 := "QRYSA1"
				lQuery    := .T.

				aStruSa1  := SA1->(dbStruct())

				cQuery := "SELECT A1_FILIAL,A1_COD,A1_MOEDALC,A1_LC,A1_LCFIN,A1_SALFIN,A1_SALDUP,A1_SALPEDL,A1_VENCLC,A1_RISCO,R_E_C_N_O_ RECSA1 "
				cQuery += " FROM "+RetSqlName("SA1")+" SA1 "
				cQuery += "WHERE "
				cQuery += "A1_FILIAL = '"+xFilial("SA1")+"' AND "
				cQuery += "A1_COD = '"+cCodCli+"' AND "
				cQuery += "SA1.D_E_L_E_T_ = ' ' "
				cQuery += "ORDER BY "+SqlOrder(SA1->(IndexKey()))

				cQuery := ChangeQuery(cQuery)

				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSA1,.T.,.T.)

				For nX := 1 To Len(aStruSA1)
					If aStruSA1[nX,1]$"A1_FILIAL,A1_COD,A1_MOEDALC,A1_LC,A1_LCFIN,A1_SALFIN,A1_SALDUP,A1_SALPEDL,A1_VENCLC"
						If aStruSA1[nX,2] <> "C" 
							TcSetField(cAliasSA1,aStruSA1[nX,1],aStruSA1[nX,2],aStruSA1[nX,3],aStruSA1[nX,4])
						EndIf
					EndIf
				Next nX

				If lIntTUR
					If G8T->(dbSeek(xFilial("G8T")+cComplTur+cSegTur))
						nMoedaAC := Posicione("G5T",1,xFilial("G5T") + G8T->G8T_MOEDA,"G5T_MOEDAF")//G8T->G8T_MOEDA
						cArqAC   := "G8T"
					Else
						nMoedaAC := (cAliasSA1)->A1_MOEDALC
					EndIf
				Else
					nMoedaAC := (cAliasSA1)->A1_MOEDALC				
				EndIf
				
				nMCusto	:= IIf( nMoedaAC > 0,nMoedaAC,Val(SuperGetMv("MV_MCUSTO")))
				nVlrCred := xMoeda(nVlrCred,nMoeda,1,dDataBase,2)
				nLimCred := 0
				While lRetorno .AND. (cAliasSA1)->(! Eof()) .And. xFilial("SA1") == (cAliasSA1)->A1_FILIAL .And. cCodCli == (cAliasSA1)->A1_COD
					If lIntTUR
						If G8T->(dbSeek(xFilial("G8T")+cComplTur+cSegTur))
							cRiscoAC := G8T->G8T_RISCO
							dVencAC  := G8T->G8T_VENCTO
							nLimiteAC:= G8T->G8T_LIMITE
							nMoedaAC := Posicione("G5T",1,xFilial("G5T") + G8T->G8T_MOEDA,"G5T_MOEDAF")//G8T->G8T_MOEDA
							cArqAC   := "G8T"
						Else
							cRiscoAC := (cAliasSA1)->A1_RISCO
							dVencAC  := (cAliasSA1)->A1_VENCLC
							nLimiteAC:= (cAliasSA1)->A1_LC
							nMoedaAC := (cAliasSA1)->A1_MOEDALC
						EndIf
					Else
						cRiscoAC := (cAliasSA1)->A1_RISCO
						dVencAC  := (cAliasSA1)->A1_VENCLC
						nLimiteAC:= (cAliasSA1)->A1_LC
						nMoedaAC := (cAliasSA1)->A1_MOEDALC
					EndIf

					If !cRiscoAC $ "E,Z"
						nLimCred += xMoeda(nLimiteAC,nMCusto,1,dDataBase,2)
					Else
						nLimCred := 0
					EndIf
					If (cAliasSA1)->A1_LCFIN >= 0
						nLimCredFin	+= xMoeda((cAliasSA1)->A1_LCFIN,nMCusto,1,dDataBase,MsDecimais(1))
						nVlrFin 	+= (cAliasSA1)->A1_SALFIN
					EndIf
					If ( lPedido )
						nVlrReal += (cAliasSA1)->A1_SALDUP + xMoeda((cAliasSA1)->A1_SALPEDL,nMCusto,1,dDatabase,2)
						If nVlrCred >= nVlrReal
							nLimCred += nVlrCred
						EndIf
						If ( aEmpenho <> Nil ) .And. ( !Empty(aEmpenho) )
							nRegEmp  := aScan(aEmpenho[1],{|x| x[1]==(cAliasSA1)->RECSA1 })
							If ( nRegEmp <> 0 )
								nVlrReal += xMoeda(aEmpenho[1][nRegEmp][2],nMCusto,1,dDatabase,2)
							EndIf
							If ( nRegEmp <> 0 )
								nVlrFin += aEmpenho[1][nRegEmp][3]
							EndIf
						EndIf
					EndIf
				   	If( lIntTUR )
						If nVlrCred < nVlrReal
							nVlrReal += (cAliasSA1)->A1_SALDUP
						EndIf
					EndIf
					//Ŀ
					//Aqui e avaliado o Vencimento do Limite de Credito do Cliente            
					//
					If ( !Empty(dVencAC) .And. dVencAC < dDataBase ) .And. nVlrCred <= 0
						lRetorno := .F.
						cCodigo  := "04" // Vencimento do Limite de Credito
					EndIf
					dbSelectArea(cAliasSA1)
					dbSkip()
				EndDo
				If lQuery
					dbSelectArea(cAliasSA1)
					dbCloseArea()
					dbSelectArea("SA1")
				EndIf
				//Ŀ
				//Adicional de Crdito quando utilizado o 9o Parmetro							
				//
				If nVlAdicCre > 0 .and. lIntGC // Modulo de Concessionrias
					nLimCred += nVlAdicCre
				EndIf
				//Ŀ
				//Verifica se o Valor nao eh maior que o Limite de Credito                
				//
				If ( lRetorno .And. nVlrReal > nLimCred .And. nVlrReal > 0)
					lRetorno := .F.
					cCodigo  := "01" // Limite de Credito
					lCredito := .T.
				EndIf
				//Ŀ
				//Controle de limite de credito secundario                                
				//
				If lRetorno .And. nVlrFin > nLimCredFin .And. nLimCredFin > 0
					cCodigo 	:= "01" // Limite de Credito
					lRetorno := .F.
					lCredito := .T.
				EndIf
				//Ŀ
				//Verifica as Classes de Cliente                                          
				//
				If nVlrReal > 0
					dbSelectArea("SA1")
					dbSetOrder(1)
					MsSeek(xFilial("SA1")+cCodCli)
					
					If lIntTUR
						If G8T->(dbSeek(xFilial("G8T")+cComplTur+cSegTur))
							cRiscoAC := G8T->G8T_RISCO
							cArqAC   := "G8T"
						Else
							cRiscoAC := SA1->A1_RISCO
						EndIf
					Else
						cRiscoAC := SA1->A1_RISCO
					EndIf
					
					Do Case
						Case ( lRetorno .And. nVlrReal <= nLiMinCr )
							lRetorno := .T.
							cCodigo  := ""
						Case ( lRetorno .And. nVlrReal > ((nPerMax * nLimCred) / 100) )
							lRetorno := .F.
							cCodigo  := "01" // Limite de Credito.
							lCredito := .T.
						Case ( lRetorno .And. SA1->A1_CLASSE == "A" .And. nVlrPed > nfaixaA .And. nFaixaA <> 0 )
							lRetorno := .F.
							cCodigo  := "01" // Limite de Credito
							lCredito := .T.
						Case ( lRetorno .And. SA1->A1_CLASSE == "B" .And. nVlrPed > nfaixaB .And. nFaixaB <> 0 )
							lRetorno := .F.
							cCodigo  := "01" // Limite de Credito
							lCredito := .T.
						Case ( lRetorno .And. SA1->A1_CLASSE == "C" .And. nVlrPed > nfaixaC .And. nFaixaC <> 0 )
							lRetorno := .F.
							cCodigo  := "01" // Limite de Credito
							lCredito := .T.
					EndCase
					//Ŀ
					// Aqui e avaliado o risco do Cliente - ( Matriz + Filiais )   
					//
					If ( lRetorno .And. !Empty(cRiscoAC) .And. !cRiscoAC$"E,Z" )
			
						dbSelectArea("SE1")
						dbSetOrder(8)

						cAliasQry  := "QRYAVALCRD"
						lQuery     := .T.

						cQuery := "SELECT A1_FILIAL,A1_COD,A1_LOJA,A1_RISCO,E1_FILIAL,E1_CLIENTE,E1_LOJA,E1_TIPO,E1_VENCREA"
						cQuery += " FROM "+RetSqlName("SA1")+" SA1, "
						cQuery += RetSqlName("SE1")+" SE1 "
						cQuery += "WHERE "
						cQuery += "A1_FILIAL ='"+xFilial("SA1")+"' AND "
						cQuery += "A1_COD = '"+cCodCli+"' AND "
						cQuery += "SA1.D_E_L_E_T_ = ' ' AND "
						cQuery += "E1_FILIAL = '"+xFilial("SE1")+"' AND "
						cQuery += "E1_CLIENTE = A1_COD AND "
						cQuery += "E1_LOJA = A1_LOJA AND "
						cQuery += "E1_STATUS = 'A' AND "
						cQuery += "SE1.D_E_L_E_T_ = ' ' "
						cQuery += "ORDER BY "+SqlOrder(StrTran(SE1->(IndexKey()),"E1_LOJA+",""))

						cQuery := ChangeQuery(cQuery)

						dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)

						TcSetField(cAliasQry,"E1_VENCREA","D",8,0)

						While (cAliasQry)->(!Eof()) .And. lRetorno
								
							If lIntTUR
								If G8T->(dbSeek(xFilial("G8T")+cComplTur+cSegTur))
									cRiscoAC := G8T->G8T_RISCO
									cArqAC   := "G8T"
								Else
									cRiscoAC := (cAliasQry)->A1_RISCO
								EndIf
							Else
								cRiscoAC := (cAliasQry)->A1_RISCO
							EndIf

							nNumDias	:= 0
							If !Empty(cRiscoAC)
								If	cRiscoAC <> "A"
									If lIntTUR
										nNumDias := SuperGetMv("MV_RISCO" + cRiscoAC + Iif(cSegTur=="1","C",Iif(cSegTur=="2","E","L")))
									Else
										nNumDias := SuperGetMv("MV_RISCO" + cRiscoAC)
									EndIf
								EndIf
							Else
								If (cAliasQry)->A1_LOJA <> "01"
									Aviso(STR0011,STR0012,{STR0013},2)//"Ateno"#" necessario que o cliente e loja estejam com configuraes de risco conforme outras lojas"
									lRetorno := .F.
									cCodigo  := "01" // Limite de Credito
									Exit
								EndIf
							EndIf
							If cRiscoAC <> "A" .AND. ( !(cAliasQry)->E1_TIPO $ MVRECANT+"/"+MVPROVIS+"/"+MV_CRNEG .And. !(cAliasQry)->E1_TIPO $ MVABATIM )
								If ( ( dDataBase - (cAliasQry)->E1_VENCREA ) > nNumDias )
									lRetorno := .F.
									cCodigo  := "01" // Limite de Credito
									lTitVenc := .T.
								EndIf
								Exit
							EndIf

							dbSelectArea(cAliasQry)
							dbSkip()
						EndDo
						If lQuery
							dbSelectArea(cAliasQry)
							dbCloseArea()
							dbSelectArea("SA1")
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	EndCase

	If ( lMaAvCrPr )
		lRetorno := ExecBlock("MAAVCRPR",.F.,.F.,{cCodCli,cLoja,nValor,nMoeda,lPedido,cTipoLim,lRetorno,cCodigo,cComplTur,cSegTur})
		If !lRetorno .And. Empty(cCodigo)
			cCodigo := "01"
		EndIf
		If lRetorno .And. !Empty(cCodigo)
			cCodigo := ""
		EndIf
	Endif

Else
	If ( lMaAvCred )
		xRetorno := ExecBlock("MAAVCRED",.F.,.F.,{cCodCli,cLoja,nValor,nMoeda,lPedido,cComplTur,cSegTur})
		If ValType(xRetorno)=="C"
			lRetorno := Empty(xRetorno)
			cCodigo  := xRetorno
		Else
			If !xRetorno
				cCodigo := "01"
				lRetorno := .F.
			Else
				lRetorno := .T.
			EndIf
		Endif
	EndIf
EndIf
//Ŀ
//Carrega o Array de detalhes da avaliao de credito                     
//
If !Empty( cCodigo )
	Do Case
		Case cCodigo == "01"
			aAdd( aValDet, {cCodigo,{ lCredito, lTitVenc } } ) //Cdigo do bloqueio [Bloqueio Credito][Bloqueio por ttulo atrasado]
		Case cCodigo == "04"
			aAdd( aValDet, {cCodigo, {} } )
	EndCase
EndIf

If	lSaveArea
	//Ŀ
	//Restaura a Entrada da Rotina                                            
	//
	RestArea(aAreaSA1)
	RestArea(aAreaSE1)
	RestArea(aArea)
EndIf
Return( lRetorno )

/*/


Ŀ
Funcao    MaIniLiber Autor Eduardo Riera           Data 22.02.99  
Ĵ
Descrio Inicializa a Quantidade Liberada.                           
          Esta funcao necessita do acols, aheader do SC6 e Enchoice   
          do SC5 preenchidos.                                         
Ĵ
Retorno   Sempre .T.                                                  
Ĵ
ParametrosExpN1: Numero do Pedido.                                    
          ExpN2: Quantidade Vendida.                                  
          ExpN3: Linha da GetDados.                                   
          ExpL4: Codigo de Barras.                                    
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function MaIniLiber(cPedido,nQtdaLib,nLinha,lCb)

Local aArea       := GetArea()
Local aAreaSC6    := SC6->(GetArea())
Local nCntFor     := 0
Local cItem       := ""
Local cProduto    := ""
Local cLocal      := ""
Local cNumLote    := ""
Local cLoteCtl    := ""
Local cLocaliz    := ""
Local cNumSer     := ""
Local cTes        := ""
Local cBlq        := ""
Local cBloquei    := ""
Local nQtdLib     := 0
Local nPQtdLib    := 0
Local cReserva    := ""
Local nColGr      := 0
Local nLinGr      := 0
Local cProdRef    := ""
Local nQtdLibGr   := 0
Local nQtdVen     := 0
Local nPosQtdVen  := 0
Local nPosQtdLib  := 0
Local nPosQtdEnt  := 0
Local lMata410 := AtIsRotina("MATA410")

DEFAULT lCb       := .F.

If ( lCB )
	//Ŀ
	// Cria variaveis ja existentes na validacao do Produto na      
	// GetDados para compatibilizar as duas validacoes.             
	//
	nLinha := Len(aCols)
EndIf
//Ŀ
// Caso o item do pedido tenha sido bloqueado pelo usuario      
// nao deve sugerir a quantidade liberada                       
//
For nCntFor := 1 To Len(aHeader)
	Do Case
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_ITEM" )
		cItem    := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_PRODUTO" )
		cProduto := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_LOCAL" )
		cLocal   := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_TES" )
		cTes     := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_QTDLIB" )
		nPQtdLib := nCntFor
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_BLQ" )
		cBlq     := AllTrim(aCols[nLinha][nCntFor])
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_BLOQUEI" )
		cBloquei := AllTrim(aCols[nLinha][nCntFor])
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_NUMLOTE" )
		cNumLote := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_LOTECTL")
		cLoteCtl := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_LOCALIZ" )
		cLocaliz := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_NUMSER")
		cNumSer  := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_RESERVA")
		cReserva := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_QTDVEN")
		nQtdVen  := aCols[nLinha][nCntFor]
		If ( M->(Type("C6_QTDVEN"))=="N" )
			nQtdVen := M->C6_QTDVEN
		EndIf
	EndCase
Next nCntFor

If !(xFilial("SC6") == SC6->C6_FILIAL .And. cPedido == SC6->C6_NUM .And. cItem == SC6->C6_ITEM)
	dbSelectArea("SC6")
	dbSetOrder(1)
	MsSeek(xFilial("SC6")+cPedido+cItem)
EndIf
If ( xFilial("SC6") == SC6->C6_FILIAL .And. cPedido == SC6->C6_NUM .And. cItem == SC6->C6_ITEM .And. !Empty(cReserva) )
	nQtdLib := Min(SC6->C6_QTDRESE,nQtdVen - If(ALTERA.And.lMata410,0,SC6->C6_QTDEMP) - SC6->C6_QTDENT)
Else
	If ( nQtdALib > ( nQtdVen - If(ALTERA.And.lMata410,0,SC6->C6_QTDEMP) - SC6->C6_QTDENT ) .And. xFilial("SC6") == SC6->C6_FILIAL .And. cPedido == SC6->C6_NUM .And. cItem == SC6->C6_ITEM )
		nQtdALib := nQtdVen - If(ALTERA.And.lMata410,0,SC6->C6_QTDEMP) - SC6->C6_QTDENT
	  	nQtdALib := Iif(nQtdALib<0.And.INCLUI.And.lMata410,nQtdVen,nQtdALib)
	EndIf
	//Ŀ
	//Calcula o Saldo que pode ser liberado                                   
	//
	If ( !cBlq $ "SR" .And. (!(M->C5_TIPO$"CIP") .Or. ( cPaisLoc == "BRA" .And. AllTrim(M->C5_TIPO) == "C" .And. M->C5_TPCOMPL == "2" )) .And. Empty(cBloquei))
		cProdRef := cProduto
		If ( MatGrdPrrf(@cProdRef) )
			nPosQtdVen := &(MaReadGrd()):GetFieldGrdPos("C6_QTDVEN")
			nPosQtdLib := &(MaReadGrd()):GetFieldGrdPos("C6_QTDLIB")
			nPosQtdEnt := &(MaReadGrd()):GetFieldGrdPos("C6_QTDENT")
			For nLinGr := 1 To Len(&(MaReadGrd()):aColsGrade[nLinha])
				For nColGr := 2 To Len(&(MaReadGrd()):aHeadGrade[nLinha])
					nQtdALib  := &(MaReadGrd()):aColsGrade[nLinha][nLinGr][nColGr][nPosQtdVen]-&(MaReadGrd()):aColsGrade[nLinha][nLinGr][nColGr][nPosQtdEnt]
					nQtdLibGr := nQtdALib
					&(MaReadGrd()):aColsGrade[nLinha][nLinGr][nColGr][nPosQtdLib] := nQtdLibGr
					nQtdLib += nQtdLibGr
				Next nColGr
			Next nLinGr
		Else
			nQtdLib := nQtdALib
		EndIf
	EndIf
EndIf
//Ŀ
//Atualiza o Acols                                                        
//
aCols[nLinha][nPQtdLib] := nQtdLib
//Ŀ
//Retorna o Estado de Entrada da Rotina                                   
//
RestArea(aAreaSC6)
RestArea(aArea)

Return( .T. )

/*/


Ŀ
Funcao    MaLibDoFat Autor Eduardo Riera           Data 09.03.99  
Ĵ
Descrio Liberacao dos Itens de Pedido de Venda                      
Ĵ
Retorno   ExpN1: Quantidade Liberada                                  
Ĵ
Transacao Nao possui controle de Transacao a rotina chamadora deve    
          controlar a Transacao e os Locks                            
Ĵ
ParametrosExpN1: Registro do SC6                                      
          ExpN2: Quantidade a Liberar                                 
          ExpL3: Bloqueio de Credito                                  
          ExpL4: Bloqueio de Estoque                                  
          ExpL5: Avaliacao de Credito                                 
          ExpL6: Avaliacao de Estoque                                 
          ExpL7: Permite Liberacao Parcial                            
          ExpL8: Tranfere Locais automaticamente                      
          ExpA9: Empenhos ( Caso seja informado nao efetua a gravacao 
                 apenas avalia ).                                     
          ExpbA: CodBlock a ser avaliado na gravacao do SC9           
          ExpAB: Array com Empenhos previamente escolhidos            
                 (impede selecao dos empenhos pelas rotinas)          
          ExpLC: Indica se apenas esta trocando lotes do SC9          
          ExpND: Valor a ser adicionado ao limite de credito          
          ExpNE: Quantidade a Liberar - segunda UM                    
          ExpLF: Indica se a funcao deve armazenar as mensagens de    
                 inconsistencias e alertas no processo de liberacao   
          ExpLG: Indica se existe ordem de separacao em aberto para o 
                 item que estah sendo avaliado pela funcao            
Ĵ
ObservacaoDeve estar numa transacao                                   
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function MaLibDoFat( nRegSC6   , nQtdaLib  , lCredito  , lEstoque  , ;
					 lAvCred   , lAvEst    , lLibPar   , lTrfLocal , ;
					 aEmpenho  , bBlock    , aEmpPronto, lTrocaLot , ;
					 lGeraDCF  , nVlrCred  , nQtdalib2 , lLogMsg   , ;
					 lOrdSepLib)

Local aArea    	    := GetArea("SC6")
Local aAreaSA1 	    := SA1->(GetArea())
Local aAreaSF4 	    := SF4->(GetArea())
Local aAreaSC5 	    := {}
Local aAreaSC6 	    := {}
Local nQtdLib  	    := nQtdALib
Local nQtdLib2 	    := nQtdALib2
Local lContinua	    := .T.
Local lLibItPrev    := SuperGetMV( 'MV_FATLBPR', .F., .T. )	//Indica se permite a liberao de Itens previstos do Pedido de Venda

//Ŀ
// Integracao SIGAFAT e SIGADPR                                 
//
Local lIFatDpr	 := SuperGetMV("MV_IFATDPR",.F.,.F.)

nQtdLib := nQtdALib
//Ŀ
//Seta os parametros defaults                                             
//
DEFAULT nQtdALib   := SC6->C6_QTDLIB
DEFAULT nQtdALib2  := SC6->C6_QTDLIB2
DEFAULT lCredito   := .T.
DEFAULT lEstoque   := .T.
DEFAULT lAvCred    := .T.
DEFAULT lAvEst     := .T.
DEFAULT lGeraDCF   := .T.
DEFAULT lLogMsg    := .F.
DEFAULT lOrdSepLib := .F.
//Ŀ
//Posiciona Pedido                                                        
//
If Empty(SC6->C6_BLOQUEI) .And. AllTrim(SC6->C6_BLQ)<>"R" .And. !(lOrdSepLib)

	dbSelectArea("SC6")
	If nRegSC6<>0
		aAreaSC6 := GetArea()
		MsGoto(nRegSC6)
	Else
		aAreaSC6 := GetArea("SC6")
	EndIf

	If SB1->B1_FILIAL+SB1->B1_COD <> xFilial('SB1')+SC6->C6_PRODUTO
		SB1->(DbSetOrder(1))
		SB1->(MsSeek(xFilial('SB1')+SC6->C6_PRODUTO))
	Endif
	dbSelectArea("SC5")
	dbSetOrder(1)
	If ( xFilial("SC5")==SC5->C5_FILIAL .And. SC5->C5_NUM==SC6->C6_NUM )
		aAreaSC5 := GetArea("SC5")
	Else
		MsSeek(xFilial("SC5")+SC6->C6_NUM)
		aAreaSC5 := GetArea()
	EndIf
	//Ŀ
	//Integracao com EEC													   
	//Funcao: AvChkStDesp()												   
	//Parametros: Nro do pedido de venda. 									   
	//Retorno: True  - O pedido de venda podera ser liberado visto que as 	   
	//					despesas ja foram integradas.						   
	//         False - O pedido de venda no poder ser liberado visto que    
	//					existem pendencias para as despesas.				   
	//
	If !Empty(SC5->C5_PEDEXP)
		If FindFunction("AvChkStDesp")
			If !AvChkStDesp(SC5->C5_NUM)
				lContinua := .F.
			EndIf
		EndIf
	EndIf

	//------------------------------------------------------------------------------
	// Verifica o tipo de operao (C6_TPOP) antes de liberar. Itens previstos no
	// podem ser liberados a menos que o parmetro MV_FATLBPR esteja como .T.
	// Alterao realizada para atender o requisito de Programao de Entrega.
	//------------------------------------------------------------------------------
	If ( SC6->C6_TPOP == "P" ) .And. ( !lLibItPrev )
		lContinua := .F.
	EndIf

	//Ŀ
	// M_SER004_CRM019_Integraao_Faturamento_DPR                           
	// Se o item eh do tipo "Desenvolvimento" nao libera para faturamento   
	// Autor: Thiago Tavares													   
	// Data: 25/10/2013															   
	//
	If lIFatDpr
		If SC6->C6_TPPROD == "2"
			lContinua := .F.
		EndIf
	EndIf

	If lContinua
		If nRegSC6 == 0 .Or. ( RecLock("SC5") .And. RecLock("SC6") )
			If Empty(SC5->C5_BLQ)
				If nQtdALib2 == 0 .And. SC6->C6_UNSVEN <> 0
					nQtdALib2 := SB1->(ConvUm(SC6->C6_PRODUTO,nQtdALib,Nil,2))
					If nQtdALib2 == 0
						If SC6->C6_QTDVEN-SC6->C6_QTDEMP-SC6->C6_QTDENT-nQtdALib==0
							nQtdALib2 := SC6->C6_UNSVEN-SC6->C6_QTDEMP2-SC6->C6_QTDENT2
						Else
							nQtdALib2 := nQtdALib*SC6->C6_UNSVEN/SC6->C6_QTDVEN
						EndIf
					EndIf
					SC6->C6_QTDLIB2:= nQtdALib2
					nQtdALib2 := SC6->C6_QTDLIB2
				EndIf
				SC6->C6_QTDLIB := nQtdALib
				SC6->C6_QTDLIB2:= nQtdALib2
				FatAtuEmpN("-")
				nQtdLib := a440GeraC9(@nQtdLib,@lCredito,@lEstoque,lAvCred,lAvEst,lLibPar,lTrfLocal,@aEmpenho,bBlock,aEmpPronto,lTrocaLot,lGeraDCF,@nVlrCred,@nQtdlib2)
				FatAtuEmpN("+")
			EndIf
		EndIf
	Else
		nQtdLib := 0
	EndIf
	RestArea(aAreaSC5)
	RestArea(aAreaSC6)

Else
	nQtdLib := 0
Endif

//Ŀ
//Restaura a Entrada                                                      
//
RestArea(aAreaSA1)
RestArea(aAreaSF4)
RestArea(aArea)
Return(nQtdLib)

/*/


Ŀ
Funcao    MaLiberOk  Autor Eduardo Riera           Data 10.03.99  
Ĵ
Descrio Atualizacao do Campo C5_LiberOk                             
Ĵ
Retorno   Nenhum                                                      
Ĵ
ParametrosExpA1: Array com os Pedidos de Venda                        
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
 07/05/99  Aline C. Vale  Controle de Eliminacao de Residuos Mata500 
ٱ


/*/
Function MaLiberOk(aPedidos,lResiduo)

Local aArea    := GetArea()
Local nCntFor  := 0
Local lLiberOk := .T.
Local lTotal   := .T.
Local cQuery   := ""
Local cQry     := ""
Local lIntegDef		:= ExistFunc("GETROTINTEG") .And. ExistFunc("FWHASEAI") .And. FWHasEAI("MATA410B",.T.,,.T.)//Integracao e rastreabilidade de pedidos ativa
Local cFilSD0  := xFilial("SD0") 

lResiduo    := If(ValType(lResiduo)=='U',.F.,lResiduo)

For nCntFor := 1 To Len(aPedidos)
	dbSelectArea("SC5")
	dbSetOrder(1)
	If MsSeek(xFilial("SC5")+aPedidos[nCntFor])

		SC6->(dbCommit())
		cQry   := "MALIBEROK1"

		cQuery := "SELECT COUNT(*) QTDVEN FROM "+RetSqlName("SC6")
		cQuery += " WHERE C6_FILIAL = '"+xFilial("SC6")+"' AND"
		cQuery += " C6_NUM = '"+aPedidos[nCntFor]+"' AND"
		cQuery += " C6_QTDVEN>(C6_QTDEMP+C6_QTDENT) AND"
		cQuery += " C6_BLQ <> 'R ' AND "
		cQuery += " D_E_L_E_T_ = ' ' "
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cQry,.T.,.T.)
		If ( QTDVEN > 0 )
			lLiberOk := .F.
		EndIf
		dbCloseArea()
		dbSelectArea("SC6")
		If ( lResiduo )
			SC6->(dbCommit())

			cQuery := "SELECT COUNT(*) RESIDUO FROM "+RetSqlName("SC6")
			cQuery += " WHERE C6_FILIAL = '"+xFilial("SC6")+"' AND"
			cQuery += " C6_NUM = '"+aPedidos[nCntFor]+"' AND"
			cQuery += " C6_QTDVEN>C6_QTDENT AND"
			cQuery += " C6_BLQ<>'R ' AND "
			cQuery += " D_E_L_E_T_ = ' ' "
			cQuery := ChangeQuery(cQuery)
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cQry,.T.,.T.)
			If ( RESIDUO > 0 )
				lTotal := .F.
			EndIf
			dbCloseArea()
		EndIf
		dbSelectArea("SC6")
		dbSetOrder(1)
		MsSeek(xFilial("SC6")+aPedidos[nCntFor])
		While ( !Eof() .And. xFilial("SC6")       == SC6->C6_FILIAL .And.;
				aPedidos[nCntFor] == SC6->C6_NUM )
			//Ŀ
			//Verifica se Todos os Itens foram Liberados                              
			//
			If ( Alltrim(SC6->C6_BLQ) <> "R" )
				If ( SC6->C6_QTDVEN > SC6->C6_QTDEMP + SC6->C6_QTDENT .And. lLiberOk )
					lLiberOk := .F.
				EndIf
				If ( lResiduo .And. SC6->C6_QTDVEN > SC6->C6_QTDENT )
					lTotal := .F.
				EndIf
				If !lLiberOk
					Exit
				EndIf
			EndIf
			dbSelectArea("SC6")
			dbSkip()
		EndDo

		dbSelectArea("SC5")
		//Ŀ
		//Atualiza do C5_LIBEROK                                                  
		//
		If lLiberOk
			RecLock("SC5")
			SC5->C5_LIBEROK := "S"
			If lResiduo .And. lTotal .And. Empty(SC5->C5_NOTA)
				SC5->C5_NOTA := Repl("X",Len(SC5->C5_NOTA))
				SC5->C5_BLQ  := Space(Len(SC5->C5_BLQ))
				SD0->(DbSetOrder(3))	//D0_FILIAL + D0_PEDIDO + D0_CLIENTE + D0_LOJA
				If ( SD0->(MsSeek(cFilSD0 + SC5->C5_NUM) ) )	
					RecLock( "SD0", .F. )
					SD0->D0_STATUS := "03" //Atualiza Status da Programao de entrega
					SD0->(MsUnlock())
				EndIf
			EndIf
			MsUnLock()

			//Ŀ
			//Elimina o saldo do relacionamento de pedidos finalizados.
			//
			If lResiduo                    .AND.;
			   lTotal                      .AND.;
			   A410UsaAdi(SC5->C5_CONDPAG)
				FPedAdtRsd("R", {SC5->C5_NUM})
			EndIf
						
			If lIntegDef                
				FwIntegDef("MATA410B")
			EndIf
			
		EndIf
	Endif
Next nCntFor
//Ŀ
//Restaura o Area  de Entrada                                             
//
RestArea(aArea)
Return(.T.)

/*/


Ŀ
Funcao    A440GeraC9 Rev.  Eduardo Riera           Data 22.03.99  
Ĵ
Descrio Gravacao do item liberado do pedido de Venda                
Ĵ
Retorno    ExpN1: Quantidade realmente liberada                       
Ĵ
Parametros ExpN1: Quantidade a Liberar                                
           ExpL2: Indica se o Credito foi Liberado                    
           ExpL3: Indica se o Estoque foi Liberado                    
           ExpL4: Avalia Credito                                      
           ExpL5: Avalia Estoque                                      
           ExpL6: Permite Liberacao Parcial                           
           ExpL7: Tranfere Locais automaticamente                     
           ExpA8: Empenhos ( Caso seja informado nao efetua a gravacao
                 apenas avalia ).                                     
           Expb9: CodBlock a ser avaliado na gravacao do SC9          
           ExpAB: Array com Empenhos previamente escolhidos           
                 (impede selecao dos empenhos pelas rotinas)          
          ExpL8: Indica se apenas esta trocando lotes do SC9          
          ExpN9: Valor a ser adicionado ao limite de credito          
          ExpNA: Quantidade a Liberar na segunda UM                   
Ĵ
Observacao O registro do SC5/SC6 deve estar posicionado               
           Deve estar numa transacao                                  
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Static Function a440GeraC9(nQtdLib,lCredito,lEstoque,lAvCred,lAvEst,lLiber,lTransf,aEmpenho,;
							bBlock,aEmpPronto,lTrocaLot,lGeraDCF,nVlrCred,nQtdLib2)

Local aArea     := GetArea(Alias())
Local aAreaSA1  := SA1->(GetArea())
Local aAreaSB2  := SB2->(GetArea())
Local aAreaSF4  := SF4->(GetArea())
Local aSaldos   := {}
Local aLocal    := {}

Local nSldSB6   := 0
Local cBlCred   := ""
Local cBlEst    := ""
Local cAliasSB6 := "SB6"
Local lQuery    := .F.

Local cGeraBlq	     := SuperGetMv("MV_GERABLQ")
Local lGrvBlq2	     := SuperGetMv("MV_GRVBLQ2")

Local lBlqCrd        := GetMv("MV_BLQCRED")
Local lTravas        := .T.

Local nQtdJaLib      := 0
Local nQtdPoder3     := 0
Local nQtdNPT        := 0
Local nQtdNosso      := 0
Local nValAv	     := 0
Local aEmpBN	     := {}
Local nX             := 0
Local nMvTipCrd 	 := SuperGetMV("MV_TIPACRD", .F., 1)
Local cMvLibNodp	 := GetMv("MV_LIBNODP")
Local nVlrTitAbe	 := 0
Local nVlrTitAtr	 := 0
Local cQuery         := ""
Local lUseOffBalance := .F.
Local lRiskCred		 := .F.
Local lRskTermB		 := .T.
Local lLibPed  		 := .F.
Local lTrvSA1        := .T.

//Ŀ
//Ajusta a Entrada da Rotina                                              
//
DEFAULT lAvCred    := .T.
DEFAULT lAvEst     := .T.
DEFAULT lLiber     := .F.
DEFAULT lTransf    := .F.
DEFAULT lGeraDCF   := .T.

If lMTValAvC == Nil 
	lMTValAvC := ExistBlock("MTVALAVC")
EndIf

If lRskIsAct == Nil
	lRskIsAct := FindFunction( "RskIsActive" )
EndIf

lUseOffBalance := lRskIsAct .And. RskIsActive()

If ( At(SC5->C5_TIPO,"CIP") > 0 )
	lLiber := .F.
EndIf
dbSelectArea("SF4")
dbSetOrder(1)
MsSeek(xFilial("SF4")+SC6->C6_TES)

//Ŀ
//Posiciona Registros                                                     
//
If ( At(SC5->C5_TIPO,"DB") == 0 .And. (SF4->F4_DUPLIC=='S' .Or. cMvLibNodp == "S"))
	dbSelectArea("SA1")
	dbSetOrder(1)
	MsSeek(xFilial("SA1")+SC6->C6_CLI+SC6->C6_LOJA)
	lTrvSA1 := IIf(cPaisLoc == "BRA" .And. lFATTRVSA1, ExecBlock("FATTRVSA1", .F., .F., {xFilial("SA1"), SA1->A1_COD, SA1->A1_LOJA}), .T.)
	If lTrvSA1
		lTravas := RecLock("SA1")
	EndIf
EndIf

dbSelectArea("SB2")
dbSetOrder(1)
If ( MsSeek(xFilial("SB2")+SC6->C6_PRODUTO+SC6->C6_LOCAL) .And. lTravas )
	lTravas := RecLock("SB2")
EndIf

/* Integrao RISK - TOTVS Mais Negcios
Avalia as condies do uso no TOTVS Mais Negcios */
lLibPed := IIf(lUseOffBalance, SuperGetMV("MV_RSKNTKT",,.F.), .F.)
If lUseOffBalance .and. lLibPed
	lRiskCred := RskEvlCredit( 2, SC5->C5_CONDPAG )
	lRskTermB := RskTermB(SA1->A1_COD+SA1->A1_LOJA,SC5->C5_CONDPAG)
EndIf

//Ŀ
//Verifica se o SB2 e o SA1 estao Travados                                
//
If ( lTravas )
	//Ŀ
	//Complementos nao devem ter o Credito ou Estoque Avaliado.               
	//Devolucao de Poder de Terceiro nao deve ter o Credito avaliado.         
	//
	If ( (AT(SC5->C5_TIPO,"CIP") > 0 .AND. ( IIf(cPaisLoc == "BRA" , SC5->C5_TPCOMPL != "2" ,.T.))) .Or. ( SF4->F4_PODER3 == "D" .And. SF4->F4_ESTOQUE=="N") .Or. MaTesSel(SF4->F4_CODIGO) )
		lEstoque := .T.
		lCredito := .T.
	Else
		//Ŀ
		//Avaliacao de Estoque                                                    
		//
		If ( lAvEst )
			//Ŀ
			//Somente avalia-se estoque quando ha movimentacao e nao ha reserva       
			//
			If ( SF4->F4_ESTOQUE == "S" .And. (Empty(SC6->C6_RESERVA) .OR. (Iif(ExistFunc("LjxValEst"), LjxValEst(SC5->C5_ORCRES), .F. ) .AND. !AtIsRotina("MATA455"))))
				If SuperGetMV("MV_AVALEST")==3 .And. !AtIsRotina("MATA455")
					If !((Rastro(SC6->C6_PRODUTO) .Or. Localiza(SC6->C6_PRODUTO,.T.)) .And. cGeraBlq =="N")
						lEstoque := .F.
						aEmpBN	:= If(FindFunction("A410CarBen"),A410CarBen(SC6->C6_NUM,SC6->C6_ITEM),{})
						For nX := 1 To Len( aEmpBN )
							A410LibBen(1,aEmpBN[nX,1],aEmpBN[nX,2],SC6->C6_QTDVEN,SC6->C6_UNSVEN)
						Next
					Else
						lEstoque := A440VerSB2(@nQtdLib,lLiber,lTransf,@aLocal,@aEmpenho)
					EndIf
				Else
					lEstoque := A440VerSB2(@nQtdLib,lLiber,lTransf,@aLocal,@aEmpenho)
				EndIf
			Else
				If ( !Empty(SC6->C6_RESERVA) )
					lEstoque := .T.

					If cPaisLoc<>"BRA" .AND. SC6->C6_QTDRESE == 0
						nQtdLib := Min(SC6->C6_QTDVEN,nQtdLib)
					Else
						nQtdLib := Min(SC6->C6_QTDRESE,nQtdLib)
					EndIf
				Else
					lEstoque := .T.
				EndIf
			EndIf
		EndIf
		//Ŀ
		//Avaliacao de Credito                                                    
		//
		If ( lAvCred )
			If ( !SC5->C5_TIPO $ "DB" )
				If ( SF4->F4_DUPLIC == "S" .Or. cMvLibNodp == "S" )
					If ( lBlqCrd .And. !lEstoque )
						lCredito := .F.
						cBlCred  := "02"
					Else
						If lMTValAvC
							nValAv	:=	ExecBLock("MTValAvC",.F.,.F.,{'A440GERAC9',SC6->C6_PRCVEN*nQtdLib,Nil})
						Else
							nValAv	:=	SC6->C6_PRCVEN*nQtdLib
						Endif
						//A variavel nValItPed (Private) he criada nas funcoes:(A440Grava, A410Grava e a440Proces)
						If nMvTipCrd == 2 .AND. FindFunction("FatCredTools") .AND. Type("nValItPed") <> "U"

							If nValItPed == 0
								//Consulta os titulos em aberto
								nVlrTitAbe := SldCliente(SC9->C9_CLIENTE + SC9->C9_LOJA, Nil, Nil, .F.)
								//Consulta os titulos em atraso
								nVlrTitAtr := CrdXTitAtr(SC9->C9_CLIENTE + SC9->C9_LOJA, Nil, Nil, .F.)
							EndIf

							nValItPed += nValAv

							LJMsgRun(STR0010,,{|| lCredito := FatCredTools(SA1->A1_COD,SA1->A1_LOJA, nValItPed, nVlrTitAbe, nVlrTitAtr)})//"Aguarde... Efetuando Analise de Crdito."
							//lCredito := FatCredTools(SA1->A1_COD,SA1->A1_LOJA, nValItPed, nVlrTitAbe, nVlrTitAtr)
						Else
							/* Integrao RISK - TOTVS Mais Negcios
							Se o tipo for full ou off-balance com condicao mais negocio ativada no avalia o crdito. */
							If !lRiskCred .and. lRskTermB
								lCredito := MaAvalCred(SA1->A1_COD,SA1->A1_LOJA,nValAV,SC5->C5_MOEDA,.T.,@cBlCred,@aEmpenho,@nVlrCred)
							EndIf
						EndIf
					EndIf
				Else
					lCredito := .T.
				EndIf
			Else
				lCredito := .T.
			EndIf
		EndIf
	EndIf
EndIf

/* Integrao RISK - TOTVS Mais Negcios				
Se o tipo for full ou off-balance com condicao mais negocio 
ativada gera ticket.*/
If lUseOffBalance .And. aEmpenho == Nil .And. !FwIsInCallStack( "RskUpdLibPed" ) .And. !FwIsInCallStack( "MaDelNfs" ) .and. !lCredito
	If lRiskCred
		cBlCred		:= "80"
		lCredito 	:= .F.
	elseif !lRskTermB
		cBlCred		:= "91"  
		lCredito 	:= .F.
	EndIf 
EndIf 

//Para Orcamento com origem do SigaLoja verifica regra de bloqueio de crdito especifica
If (! Empty(SC5->C5_ORCRES) .Or. ! Empty(SC5->C5_PEDECOM)) 
	If ExistFunc("LjxjPedBlq")
		LjxjPedBlq( SC5->C5_ORCRES , @cBlCred , @lCredito)
	ElseIf SuperGetMV("MV_LJECOMM",,.F.) .And. SuperGetMV("MV_LJECOMO",,.F.) .And. Val(SC5->C5_PEDECOM) > 0
		cBlCred  := "02"
		lCredito := .F.
	EndIf	
EndIf

//Ŀ
//Neste momento eh gerado os empenhos e o SC9 dependendo do caso          
//
If ( lTravas .And. (SC5->C5_TIPO$"CIP" .Or. nQtdLib > 0 .Or. MaTesSel(SF4->F4_CODIGO)) )
	//Ŀ
	//Busca dados ref. ao Beneficiamento no SB6 para gerar Registros no SC9 
	//
	If ( SF4->F4_PODER3=='D' .And. !(SC5->C5_TIPO$"CIPD") )
		nQtdPoder3 := nQtdLib
	Else
		If lCredito .And. lEstoque
			aSaldos := MaNeedP3(nQtdLib)
			nQtdNosso := aSaldos[1]
			nQtdPoder3:= aSaldos[2]
			nQtdNPT   := aSaldos[3]
		Else
			nQtdNosso := nQtdLib
		EndIf
	EndIf
	//Ŀ
	//Verifica os codigos de bloqueio                                         
	//
	If ( Empty(cBlCred) )
		If ( !lCredito )
			If At(SC5->C5_TIPO,"DB") == 0 .And. SF4->F4_DUPLIC == 'S' .And. SC5->C5_TIPLIB == "2" .And.;
				( !Empty(SA1->A1_VENCLC) .And. SA1->A1_VENCLC < dDataBase ) .And. nVlrCred <= 0
				cBlCred := "04"		//Vencimento do Limite de Credito
			Else
				cBlCred := "01"
			EndIf
		EndIf
	EndIf
	If ( Empty(cBlEst) )
		If ( !lEstoque )
			cBlEst := "02"
		EndIf
	EndIf
	//Ŀ
	//Tratamento da quantidade a ser liberada do poder de terceiros           
	//
	If nQtdPoder3 > 0
		//Ŀ
		//Posiciona Registros                                              
		//
		dbSelectArea("SB6")
		If Empty(SC6->C6_IDENTB6)
			dbSetOrder(1)
		Else
			dbSetOrder(3)
		EndIf
		cAliasSB6 := "A440GERAC9"
		lQuery    := .T.
		aStruSB6  := SB6->(dbStruct())
		SB6->(dbCommit())

		cQuery := "SELECT B6_FILIAL,B6_CLIFOR,B6_LOJA,B6_IDENT,B6_PRODUTO,"
		cQuery += "B6_QULIB,B6_SALDO "
		cQuery += "FROM "+RetSqlName("SB6")+" SB6 "
		cQuery += "WHERE SB6.B6_FILIAL='"+xFilial("SB6")+"' AND "
		cQuery += "SB6.B6_PRODUTO='"+SC6->C6_PRODUTO+"' AND "
		If !Empty(SC6->C6_IDENTB6)
			cQuery += "SB6.B6_IDENT='"+SC6->C6_IDENTB6+"' AND "
		EndIf
		cQuery += "(SB6.B6_SALDO-SB6.B6_QULIB)>0 AND "
		cQuery += "SB6.D_E_L_E_T_=' ' "
		cQuery += "ORDER BY "+SqlOrder(SB6->(IndexKey()))

		cQuery := ChangeQuery(cQuery)

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB6,.T.,.T.)
		For nX := 1 To Len(aStruSB6)
			If aStruSB6[nX][2] <> "C" 
				TcSetField(cAliasSB6,aStruSB6[nX][1],aStruSB6[nX][2],aStruSB6[nX][3],aStruSB6[nX][4])
			EndIf
		Next nX
		
		While (!Eof() .And.  xFilial("SB6") == (cAliasSB6)->B6_FILIAL .And.;
				IIf(Empty(SC6->C6_IDENTB6),.T.,;
				SC6->C6_IDENTB6==(cAliasSB6)->B6_IDENT) .And.;
				SC6->C6_PRODUTO==(cAliasSB6)->B6_PRODUTO .And.;
				nQtdPoder3 > 0 )
			nSldSB6 := ( (cAliasSB6)->B6_SALDO - (cAliasSB6)->B6_QULIB )
			If ( nSldSB6 > 0 )
				nSldSb6 := Min(nSldSB6,nQtdPoder3)
				If !( ( Rastro(SC6->C6_PRODUTO).Or.Localiza(SC6->C6_PRODUTO,.T.) ) .And.;
						cGeraBlq =="N" .And. !lEstoque )
					MaGravaSc9(nSldSb6,cBlCred,cBlEst,@aLocal,@aEmpenho,(cAliasSB6)->B6_IDENT,bBlock,aEmpPronto,nQtdLib2,@nVlrCred)
					nQtdJaLib += nSldSb6
				EndIf
				nQtdPoder3 -= nSldSB6
			EndIf
			dbSelectArea(cAliasSB6)
			dbSkip()
		EndDo
		If lQuery
			dbSelectArea(cAliasSB6)
			dbCloseArea()
			dbSelectArea("SB6")
		EndIf
	EndIf
	//Ŀ
	//Tratamento da quantidade a ser liberada - Nossa em Terceiros            
	//
	If nQtdNPT > 0
		//Ŀ
		//Verificacao do Parametro MV_GERABLQ                                     
		//
		If !( (Rastro(SC6->C6_PRODUTO) .Or. Localiza(SC6->C6_PRODUTO,.T.)) .And.;
				cGeraBlq =="N" .And. !lEstoque )
			MaGravaSc9(nQtdNPT,cBlCred,cBlEst,@aLocal,@aEmpenho,,bBlock,aEmpPronto,,@nVlrCred)
			nQtdJaLib += nQtdNPT
		EndIf
	EndIf
	//Ŀ
	//Tratamento da quantidade a ser liberada - Nosso Poder                   
	//

	If nQtdNosso > 0 .Or. MaTesSel(SF4->F4_CODIGO)	.Or. Ma440Compl()
		//Ŀ
		//Verificacao do Parametro MV_GERABLQ                                     
		//
		If !( (Rastro(SC6->C6_PRODUTO) .Or. Localiza(SC6->C6_PRODUTO,.T.)) .And.;
				cGeraBlq =="N" .And. !lEstoque )
			MaGravaSc9(nQtdNosso,cBlCred,cBlEst,@aLocal,@aEmpenho,,bBlock,aEmpPronto,nQtdLib2,@nVlrCred,,lGeraDCF)
			nQtdJaLib += nQtdNosso
		EndIf
		//Ŀ
		//Verificacao do Parametro MV_GRVBLQ2                                     
		//
		If ( lGrvBlq2 .And. aEmpenho == Nil ) .And. cGeraBlq =="S"
			If ( nQtdLib <> SC6->C6_QTDLIB ) .OR. ( SC6->C6_QTDLIB <> 0 ) 
				nQtdLib := SC6->C6_QTDLIB
				If ( nQtdLib <> 0 )
					If !lCredito
						lAvEst := .F.
						lEstoque := .F.
					Else
						lAvEst := .T.
					EndIf
					nQtdJaLib += a440GeraC9(nQtdLib,lCredito,lEstoque,lAvCred,lAvEst,lLiber,lTransf,@aEmpenho,bBlock,aEmpPronto,lTrocaLot,lGeraDCF,@nVlrCred)
				EndIf
			EndIf
		EndIf
	EndIf
EndIf
If ( lTravas )
	//Ŀ
	//Atualiza a quantidade liberada para zero                                
	//
	If ( aEmpenho == Nil )
		SC6->C6_QTDLIB  := 0
		SC6->C6_QTDLIB2 := 0
	EndIf
EndIf
If ( !lTravas )
	lCredito := .F.
	lEstoque := .F.
	nQtdLib  := 0
EndIf
RestArea(aAreaSA1)
RestArea(aAreaSB2)
RestArea(aAreaSF4)
RestArea(aArea)
Return(nQtdJaLib)

/*/


Ŀ
Funcao    MaGravaSC9 Autor Eduardo Riera           Data 19.03.99  
Ĵ
Descrio Gravacao da Liberacao do pedido de Venda                    
Ĵ
Retorno   Nenhum                                                      
Ĵ
ParametrosExpN1: Quantidade a Ser Liberada                            
          ExpC2: Codigo do Bloqueio de Credito                        
                 "01" - Bloqueio de Credito por valor                 
                 "04" - Bloqueio por Vencimento do Limite de Credito  
          ExpC3: Codigo do Bloqueio de Estoque                        
                 "02" - Bloqueio de Estoque                           
          ExpA4: Array com os locais a serem transferidos             
          ExpA5: Empenhos ( Caso seja informado nao efetua a gravacao 
                 apenas avalia ).                                     
          ExpC6: Identificador do SB6                                 
          Expb7: CodBlock a ser avaliado na gravacao do SC9           
          ExpA8: Array com Empenhos previamente escolhidos            
                 (impede selecao dos empenhos pelas rotinas)          
          ExpN9: Quantidade a ser liberada na segunda UM              
          ExpNA: Valor a ser adicionado ao limite de credito          
          ExpCB: Codigo de bloqueio do WMS                            
                     01 - Bloqueio de Enderecamento do WMS/Somente SB2
                     02 - Bloqueio de Enderecamento do WMS            
                     03 - Bloqueio de WMS - Externo                   
Ĵ
Observacao1) Esta funcao deve gerar os empenhos de Lote e Localizacao 
          2) Quando ha Reserva no SC6 os empenhos ja foram efetuados  
             mas devem ser trocados.                                  
          3) deve estar numa transacao                                
          4) SC5/SC6 devem estar posicionados e travados              
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
16/05/2007Norbert Waage  Bops 125161 - Atualizacao do status do orca-
                         mento no Televendas (SIGATMK) apos liberacao
ٱ


/*/
Static Function MaGravaSC9(nQtdLib,cBlqCred,cBlqEst,aLocal,aEmpenho,cIdentB6,bBlock,aEmpPronto,nQtdLib2,nVlrCred,cBlqWMS,lGeraDCF)

Static lMA440GrLt
Static cTiposLC

Local aArea    	     := GetArea(Alias())
Local aAreaSA1 	     := SA1->(GetArea())
Local aAreaSB2 	     := SB2->(GetArea())
Local aAreaSF4 	     := SF4->(GetArea())
Local aAreaSB1 	     := SB1->(GetArea())
Local aAuxiliar      := {}
Local aLocaliz       := {}
Local aSaldos        := {}
Local nX             := 0
Local nY             := 0
Local nAuxiliar      := 0
Local nQtdRese       := 0
Local nMCusto        := 0
Local nSaveSX8       := GetSX8Len()
Local nRegEmp        := 0
Local cQuery         := ""
Local cNameQry       := ""
Local cSeqSC9        := "00"
Local cReserva       := ""
Local lAtualiza      := If(aEmpenho==Nil,.T.,.F.)
Local lEstoque       := .F.
Local lCredito       := .F.
Local lHasWMS        := IntWms(SC6->C6_PRODUTO) .And. !Empty(SC6->C6_SERVIC) //-- Soh considera o uso do WMS se houver Servico Preenchido para o Item do SC6
Local lUsaVenc       := .F.
Local lReserva       := .F.
Local lEmpenha       := .F.
Local lContercOk     := .F.
Local lInfLote       := .F.
Local lResEst        := SuperGetMv("MV_RESEST")
Local lIntACD	     := SuperGetMV("MV_INTACD",.F.,"0") == "1"
Local lACDSer        := SuperGetMV("MV_SUBNSER",.F.,'1') $ '2|3'
Local dValidLote     := Ctod( "" )
Local nRecSC9        := 0
Local nPrcVen        := 0
Local nTotSC9        := 0
Local nTotSC9Aux     := 0
Local nDecimal       := TamSx3("C9_PRCVEN")[2]
Local aInsert 	     := {}
Local nLen 		     := 0 
Local nPosPrepared   := 0 
Local cMD5 		     := "" 
Local lVerLib		 := FatxVerLib()
//Ŀ
//Tratamento para e-Commerce      
//
Local lECommerce     := SuperGetMV("MV_LJECOMM",,.F.)
Local lRetWmsPE      := lHasWMS
Local cSeq           := ""
Local lUseOffBalance := .F.
Local lLibPed  		 := .F.
Local lNSer0End      := .F.
Local lTrvSA1        := .T.

   //Este ponto de entrada  utilizado pelo Nestl para simular uma integrao com o WMS
   //Deve obrigatoriamente ficar neste ponto antes do DEAFAULT para forar um bloqueio de WMS no pedido
   If ExistBlock("MA440WMS")
      lRetWmsPE := ExecBlock("MA440WMS",.F.,.F.,{lHasWMS})
      lHasWMS   := Iif(ValType(lRetWmsPE)=="L",lRetWmsPE,lHasWMS)
	  cBlqWms   := Iif(lHasWMS,"01","")
   EndIf

DEFAULT cBlqWms    := Iif(lHasWMS,Iif(IsInCallStack("MaDelNFS"),"05","01"),"")
DEFAULT cIdentB6   := ""
DEFAULT lMA440GrLt := ExistBlock("MA440GRLT")
DEFAULT aEmpPronto := {}
DEFAULT cTiposLC   := GetSESTipos({ || ES_SALDUP == "2"},"1")
DEFAULT lGeraDCF   := .T.

If lRskIsAct == Nil
	lRskIsAct := FindFunction( "RskIsActive" )
EndIf

lUseOffBalance := lRskIsAct .And. RskIsActive()

If cPaisLoc == "PAR" .And. SC5->C5_TIPLIB=="2" .And. ValType(aEmpenho) == "A" .And. Len(aEmpenho[1]) == 0
	lAtualiza := .T.
EndIf

//Ŀ
// Configura a reserva de estoque quando for e-Commerce                   
//
If  lECommerce .AND. !( Empty(SC5->C5_ORCRES) ) .AND. (Posicione("SL1",1,xFilial("SL1")+SC5->C5_ORCRES,"L1_ECFLAG")=="1")
	lResEst := .T.
EndIf

//Ŀ
// Baixa as qtdes transferidas para o local do pedido  
//
If ( lAtualiza )
	For nX :=1 To Len(aLocal)
		MaTrfLocal(SC6->C6_PRODUTO,aLocal[nX][1],SC6->C6_LOCAL,aLocal[nX][2],SC6->C6_NUM,.F.,@cSeq)
	Next nX
EndIf

//Ŀ
//Posiciona Registros                                                     
//
dbSelectArea("SF4")
dbSetOrder(1)
MsSeek(xFilial("SF4")+SC6->C6_TES)
//Ŀ
//Verifica a Sequencia de Liberacao do SC9                                
//

SC9->(dbCommit())
cNameQry := "MAGRAVASC9"

cQuery := "SELECT MAX(C9_SEQUEN) SEQUEN "

Aadd(aInsert, RetSqlName("SC9"))
cQuery +=   "FROM ? SC9 "

Aadd(aInsert, xFilial("SC9"))
cQuery +=   "WHERE C9_FILIAL= ? AND "

Aadd(aInsert, SC6->C6_NUM)
cQuery +=         "C9_PEDIDO= ? AND "

Aadd(aInsert, SC6->C6_ITEM)
cQuery +=         "C9_ITEM= ? AND "

cQuery +=         "SC9.D_E_L_E_T_ = ' '"

nLen := Len(aInsert)
cMD5 := MD5(cQuery) 
If (nPosPrepared := Ascan(__aPrepared,{|x| x[2] == cMD5})) == 0 
	cQuery := ChangeQuery(cQuery)
	Aadd(__aPrepared,{IIf(lVerLib,FwExecStatement():New(cQuery),FWPreparedStatement():New(cQuery)),cMD5})
	nPosPrepared := Len(__aPrepared)
Endif 

__aPrepared[nPosPrepared][1]:SetUnsafe(1,aInsert[1])

For nX := 2 to nLen
	__aPrepared[nPosPrepared][1]:SetString(nX,aInsert[nX])
Next 

If lVerLib
	cNameQry := __aPrepared[nPosPrepared][1]:OpenAlias(cNameQry)
	If !Empty((cNameQry)->SEQUEN)
		cSeqSC9 := AllTrim((cNameQry)->SEQUEN)
	EndIf
Else
	cQuery := __aPrepared[nPosPrepared][1]:getFixQuery()
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cNameQry,.T.,.T.)
	If !Empty(SEQUEN)
		cSeqSC9 := AllTrim(SEQUEN)
	EndIF
EndIf

aInsert := aSize(aInsert,0)

dbCloseArea()
dbSelectArea("SC9")

cSeqSC9 := Soma1(cSeqSC9,Len(SC9->C9_SEQUEN))

// Tratamento referente ao controle de armazem de terceiros para gravar o lote informado no pedido mesmo com TES que nao atualiza estoque
If FindFunction("EstArmTerc")
	lContercOk := EstArmTerc()	// Verifica se o controle de armazem de terceiros esta habilitado
	If lContercOk .And. SF4->F4_ESTOQUE == "N" .And. SF4->F4_CONTERC == "1"
		lInfLote := .T.
	EndIf
EndIf

//Ŀ
//Inicializa as variaveis                                                 
//
nQtdLib2  := If(nQtdLib2==Nil,SB1->(ConvUm(SC6->C6_PRODUTO,nQtdLib,0,2)),nQtdLib2)
If nQtdLib2 == 0 .And. SC6->C6_UNSVEN <> 0
	If Empty( SC6->C6_QTDVEN-SC6->C6_QTDEMP-SC6->C6_QTDENT-nQtdLib )
		//Ŀ
		// Se baixou toda a quantidade na primeira UM, baixa totalmente a segunda UM 
		//
		nQtdLib2 := SC6->C6_UNSVEN-SC6->C6_QTDEMP2-SC6->C6_QTDENT2
	Else
		//Ŀ
		// Se nao, baixa proporcionamenre a quantidade baixada na primeira UM     
		//
		nQtdLib2 := nQtdLib*SC6->C6_UNSVEN/SC6->C6_QTDVEN
	EndIf
	SC6->C6_QTDLIB2:= nQtdLib2
	nQtdLib2 := SC6->C6_QTDLIB2
EndIf
lReserva  := !Empty(SC6->C6_RESERVA)
lEstoque  := Empty(AllTrim(cBlqEst))
lCredito  := Empty(AllTrim(cBlqCred))

If ( (SF4->F4_ESTOQUE=="S" .Or. lInfLote) .And. nQtdLib > 0 .And. lEstoque .And. (lCredito .Or. lResEst) .And. lAtualiza)
	//Ŀ
	//Verifica os novos lotes.                                                
	//
	If !Rastro(SC6->C6_PRODUTO) .And. !Localiza(SC6->C6_PRODUTO,.T.)
		If Len(aEmpPronto) > 0
			aSaldos := ACLONE(aEmpPronto)
			lEmpenha := .T.
		Else
			aSaldos := {{ "","","","",nQtdLib,nQtdLib2,Ctod(""),"","","",SC6->C6_LOCAL,0}}
		EndIf
		aLocaliz := { aSaldos }
	Else
		//Ŀ
		// Ponto de Entrada p/ movimentar estoque antes da selecao Lote X Localiz.
		//
		If lMA440GrLt
			ExecBlock("MA440GRLT",.F.,.F.,{SC6->C6_PRODUTO,SC6->C6_LOCAL,nQtdLib,SC6->C6_LOTECTL,SC6->C6_NUMLOTE,SC6->C6_LOCALIZ,SC6->C6_NUMSERI})
		EndIf
		//Ŀ
		// Verifica se devem ser escolhidos Lotes/Sub-Lotes/Localizacao ou nao    
		//
		If Len(aEmpPronto) > 0
			aSaldos := ACLONE(aEmpPronto)
			lEmpenha := .T.
		Else
			lUsaVenc:= If(!Empty(SC6->C6_LOTECTL+SC6->C6_NUMLOTE),.T.,(SuperGetMv('MV_LOTVENC')=='S'))
			If ( !lHasWMS .Or. !Empty(SC6->C6_LOCALIZ+SC6->C6_NUMSERI) ) .And.;
				(!lReserva .Or. (lReserva .And. Rastro(SC6->C6_PRODUTO) .And.;
				(xFilial("SC0")+SC6->C6_RESERVA+SC6->C6_PRODUTO+SC6->C6_LOCAL==SC0->C0_FILIAL+SC0->C0_NUM+SC0->C0_PRODUTO+SC0->C0_LOCAL) .And.;
				Empty(SC0->C0_LOTECTL+SC0->C0_NUMLOTE))) .And.;
				!(IsInCallStack('MATA521A') .And. IntWms(SC6->C6_PRODUTO))
				If lIntACD .And. lACDSer .And. IsInCallStack("MaDelNFS")
					aSaldos:= ACDCB9Ser(SC6->C6_PRODUTO,SC6->C6_LOCAL,nQtdLib,nQtdLib2,SC6->C6_LOTECTL,SC6->C6_NUMLOTE,SC6->C6_LOCALIZ,SC6->C6_NUMSERI,lUsaVenc,dDataBase,SC9->C9_ORDSEP,SC9->C9_PEDIDO)
				Else
					aSaldos := SldPorLote(SC6->C6_PRODUTO,SC6->C6_LOCAL,nQtdLib,nQtdLib2,SC6->C6_LOTECTL,SC6->C6_NUMLOTE,SC6->C6_LOCALIZ,SC6->C6_NUMSERI,NIL,NIL,NIL,lUsaVenc,nil,nil,dDataBase)
				EndIf
				lEmpenha := .T.
			Else
				SC0->( dbSetOrder(1) )
				If !Empty(SC6->C6_RESERVA) .And.;
					(xFilial("SC0")+SC6->C6_RESERVA+SC6->C6_PRODUTO+SC6->C6_LOCAL==SC0->C0_FILIAL+SC0->C0_NUM+SC0->C0_PRODUTO+SC0->C0_LOCAL .Or. ;
					SC0->( dbSeek( xFilial("SC0")+SC6->C6_RESERVA+SC6->C6_PRODUTO+SC6->C6_LOCAL ) ) )

					//Ŀ
					// Pesquisa a data de validade dos lotes                                  
					//
					If Rastro(SC6->C6_PRODUTO,"L")
						SB8->( dbSetOrder( 3 ) )
						SB8->( MsSeek( xFilial( "SB8" ) + SC0->C0_PRODUTO + SC0->C0_LOCAL + SC0->C0_LOTECTL ) )
						dValidLote := SB8->B8_DTVALID
					ElseIf Rastro(SC6->C6_PRODUTO,"S")
						SB8->( dbSetOrder( 3 ) )
						SB8->( MsSeek( xFilial( "SB8" ) + SC0->C0_PRODUTO + SC0->C0_LOCAL + SC0->C0_LOTECTL + SC0->C0_NUMLOTE ) )
						dValidLote := SB8->B8_DTVALID
					Else
						dValidLote := Ctod( "" )
					EndIf

					aSaldos := {{ SC0->C0_LOTECTL,SC0->C0_NUMLOTE,SC0->C0_LOCALIZ,SC0->C0_NUMSERI,nQtdLib,nQtdLib2,dValidLote,"","","",SC0->C0_LOCAL,0}}
				Else
					If lHasWMS .And. !lReserva
						//Ŀ
						// Pesquisa a data de validade dos lotes                                  
						//
						If Rastro(SC6->C6_PRODUTO,"L")
							SB8->( dbSetOrder( 3 ) )
							SB8->( MsSeek( xFilial( "SB8" ) + SC6->C6_PRODUTO + SC6->C6_LOCAL + SC6->C6_LOTECTL ) )
							dValidLote := SB8->B8_DTVALID
						ElseIf Rastro(SC6->C6_PRODUTO,"S")
							SB8->( dbSetOrder( 3 ) )
							SB8->( MsSeek( xFilial( "SB8" ) + SC6->C6_PRODUTO + SC6->C6_LOCAL + SC6->C6_LOTECTL + SC6->C6_NUMLOTE ) )
							dValidLote := SB8->B8_DTVALID
						Else
							dValidLote := Ctod( "" )
						EndIf
					EndIf

					cReserva := ""
					lReserva := .F.
					aSaldos := {{ SC6->C6_LOTECTL,SC6->C6_NUMLOTE,SC6->C6_LOCALIZ,SC6->C6_NUMSERI,nQtdLib,nQtdLib2,dValidLote,"","","",SC6->C6_LOCAL,0}}
				EndIf
			EndIf
		EndIf
		//Ŀ
		//Aglutina os lotes/sub-lotes iguais                                      
		//Quando ha criacao de reservas na liberacao nao se deve aglutinar as     
		//localizacoes fisicas.                                                   
		//
		If ( lCredito .Or. lResEst)
			aAuxiliar := aClone(aSaldos)
			aSaldos   := {}
			For nX := 1 To Len(aAuxiliar)
				
				// Verificar se o usuario preencheu o endereco ou numero de serie
				lNSer0End := IIf(!Empty(SC6->C6_LOCALIZ) .Or.; //Endereo
				                 !Empty(SC6->C6_NUMSERI), ;    //Nmero de Srie)
								 .T., .F.)

				// Caso nao tenha preenchido no pedido de venda o Endereco ou numero de serie para 
				// o produto em questao, vamos verificar se temos algum item nas linhas dos itens 
				// do pedido com o mesmo codigo, lote, sub-lote e armazem
				nAuxiliar := IIf(lNSer0End, 0, aScan(aSaldos,{|x|x[1]==aAuxiliar[nX,1] .And.; // Lote
					                                             x[2]==aAuxiliar[nX,2] .And.; // Sublote
					                                             x[11]==aAuxiliar[nX,11] }))  // Armazem
				
				If ( nAuxiliar == 0 )
					// Foi preenchido Endereco ou Numero de Serie, ou nao foi encontrado
					// um produto com o mesmo preenchimento de lote, sublote e armazem.
					// Entao vamos incluir um novo item no aSaldos para o processamento do SC9.
					AAdd(aSaldos,Array(Len(aAuxiliar[nX])))
					For nY := 1 To Len(aAuxiliar[nX])
						aSaldos[Len(aSaldos)][nY] := aAuxiliar[nX,nY]
					Next nY
					// Limpar os dados de Endereco e numero de serie para realizar a aglutinacao,
					// caso o usuario nao tenha informado Endereco ou Numero de Serie
					If !lNSer0End
						aSaldos[Len(aSaldos)][3] := Space(TamSX3("C6_LOCALIZ")[1])
						aSaldos[Len(aSaldos)][4] := Space(TamSX3("C6_NUMSERI")[1])
					EndIf
					AAdd(aLocaliz,{ aAuxiliar[nX] })
				Else
					// Nao foi preenchido Endereco e Numero de Serie e foi encontrado
					// um produto com o mesmo preenchimento de lote, sublote e armazem no pedido.
					// Entao vamos aglutinar este item que esta sendo processado ao(s) item(ns) 
					// ja existente(s)/aglutinados no aSaldos com mesmo preenchimento de 
					// codigo de produto, lote e sub-lote.
					aSaldos[nAuxiliar][5] += aAuxiliar[nX,5]
					aSaldos[nAuxiliar][6] += aAuxiliar[nX,6]
					AAdd(aLocaliz[nAuxiliar],aAuxiliar[nX])
				EndIf

			Next nX
		Else
			aLocaliz:= { aSaldos }
		EndIf
	EndIf
Else
	If Len(aEmpPronto) > 0
		aSaldos := ACLONE(aEmpPronto)
		lEmpenha := .T.
	Else
		aSaldos := {{ "","","","",nQtdLib,nQtdLib2,Ctod(""),"","","",SC6->C6_LOCAL,0}}
	EndIf
	aLocaliz:= { aSaldos }
EndIf
//Ŀ
// Verifica se o Bloqueio de Enderecamento do WMS deve ser efetuado       
//
For nX := 1 To Len(aSaldos)
	//Ŀ
	// Efetua a Gravacao do SC9                                               
	//
	If lAtualiza
		//Ŀ
		//Garante o estoque caso haja bloqueio de credito atraves de uma reserva  
		//de material.                                                            
		//
		If !lCredito .And. lResEst .And. SF4->F4_ESTOQUE=="S" .And. !lReserva .And. lEstoque
			cReserva := CriaVar("C0_NUM")
			nQtdRese := aSaldos[nX,5]
			If Empty(cReserva)
				cReserva := NextNumero("SC0",1,"C0_NUM",.T.)
			Else
				While ( GetSX8Len() > nSaveSX8 )
					ConfirmSx8()
				EndDo
			EndIf
			If !a430Reserva({1,"PD",SC5->C5_NUM,"",cFilAnt},@cReserva,;
					SC6->C6_PRODUTO,aSaldos[nX,11],nQtdRese,;
					{aSaldos[nX,2],aSaldos[nX,1],aSaldos[nX,3],aSaldos[nX,4]})
				cReserva := ""
			Else
				//Ŀ
				// Atualiza a qtde em aberto do pedido de venda                 
				//
				dbSelectArea("SB2")
				dbSetOrder(1)
				If ( !MsSeek(xFilial("SB2")+SC6->C6_PRODUTO+aSaldos[nX,11]) )
					CriaSB2( SC6->C6_PRODUTO,aSaldos[nX,11] )
				EndIf
				RecLock("SB2")
				SB2->B2_QPEDVEN -= nQtdRese
				SB2->B2_QPEDVE2 -= ConvUM(SB2->B2_COD, nQtdRese, 0, 2)
				//Ŀ
				// Atualiza o saldo da reserva                                  
				//
				dbSelectArea("SC0")
				dbSetOrder(1)
				If (xFilial("SC0")+cReserva+SC6->C6_PRODUTO+aSaldos[nX,11]==SC0->C0_FILIAL+SC0->C0_NUM+SC0->C0_PRODUTO+SC0->C0_LOCAL .Or. ;
						MsSeek(xFilial("SC0")+cReserva+SC6->C6_PRODUTO+aSaldos[nX,11]) )
					RecLock("SC0")
					SC0->C0_QUANT -= nQtdRese
					SC0->C0_TIPO  := "PD"
					SC0->C0_QTDPED += nQtdRese
				EndIf
				//Ŀ
				// Atualiza o item do pedidod de venda                          
				//
				RecLock("SC6")
				SC6->C6_QTDRESE += nQtdRese
				SC6->C6_RESERVA := cReserva
			EndIf
		Else
			cReserva := SC6->C6_RESERVA
			nQtdRese := SC6->C6_QTDRESE
		EndIf
		nValor := A410Arred(nQtdLib*SC6->C6_PRCVEN,"C6_PRCVEN")

		If nX == Len(aSaldos) .And. Len(aSaldos) > 1 .And. Empty(SC6->C6_LOTECTL) .And. Rastro(SC6->C6_PRODUTO)
			nPrcVen := noRound(nValor - nTotSC9,nDecimal) / aSaldos[nX,5]
			nPrcVen := A410Arred(nPrcVen,"C6_PRCVEN")
			If ( SuperGetMv("MV_ARREFAT") == "N" )
				nTotSC9Aux := nTotSC9
				nTotSC9 += a410Arred(aSaldos[nX,5] * nPrcVen ,"C9_PRCVEN")
				If nValor - nTotSC9 <> 0
					nPrcVen += a410Arred((nValor-nTotSC9)/aSaldos[nX,5] ,"C6_PRCVEN")
				EndIf
				nTotSC9 := nTotSC9Aux
			EndIf
		EndIf
		RecLock("SC9",.T.)
		SC9->C9_FILIAL := xFilial("SC9")
		SC9->C9_PEDIDO := SC6->C6_NUM
		SC9->C9_ITEM    := SC6->C6_ITEM
		SC9->C9_SEQUEN  := cSeqSC9
		SC9->C9_PRODUTO := SC6->C6_PRODUTO
		SC9->C9_CLIENTE := SC6->C6_CLI
		SC9->C9_LOJA    := SC6->C6_LOJA
		SC9->C9_PRCVEN  := IIF(nPrcVen==0,SC6->C6_PRCVEN,nPrcVen)
		SC9->C9_DATALIB := dDataBase
		SC9->C9_LOTECTL := aSaldos[nX,1]
		SC9->C9_NUMLOTE := aSaldos[nX,2]
		SC9->C9_QTDLIB  := aSaldos[nX,5]
		SC9->C9_QTDLIB2 := aSaldos[nX,6]
		SC9->C9_DTVALID := aSaldos[nX,7]
		SC9->C9_POTENCI := aSaldos[nX,12]
		SC9->C9_BLCRED  := cBlqCred
		SC9->C9_BLEST   := cBlqEst
		SC9->C9_BLWMS   := Iif(SF4->F4_ESTOQUE == "S",cBlqWMS,"")
		SC9->C9_QTDRESE := Min(nQtdRese,SC9->C9_QTDLIB)
		SC9->C9_RESERVA := cReserva
		SC9->C9_AGREG  := &(SuperGetMv("MV_AGREG"))
		SC9->C9_GRUPO  := &(SuperGetMv("MV_GRUPFAT"))
		SC9->C9_IDENTB6:= cIdentB6
		SC9->C9_LOCAL  := aSaldos[nX,11]
		SC9->C9_SERVIC := SC6->C6_SERVIC
		SC9->C9_PROJPMS:= SC6->C6_PROJPMS
		SC9->C9_TASKPMS:= SC6->C6_TASKPMS
		SC9->C9_TRT  	 := SC6->C6_TRT
		SC9->C9_LICITA := SC6->C6_LICITA
		SC9->C9_TPCARGA:= SC5->C5_TPCARGA
		SC9->C9_ENDPAD := SC6->C6_ENDPAD
		SC9->C9_EDTPMS := SC6->C6_EDTPMS
		SC9->C9_DATENT := SC6->C6_ENTREG
		//Grava tipo da Ordem de Produo na liberao
		If ( SC6->C6_TPOP == ' ' ) .Or. ( SC6->C6_TPOP == 'F' )
			SC9->C9_TPOP := '1'
		Else
			SC9->C9_TPOP := '2'
		EndIf
		If !Empty(cSeq)
			SC9->C9_SD3SEQ := cSeq
		Endif

	   nTotSC9 += a410Arred(SC9->C9_QTDLIB * SC9->C9_PRCVEN ,"C9_PRCVEN")
		//Ŀ
		// Regra do WMS, onde: 1=Apanhe por Lote/2=Apanhe por Numero de Serie/3=Apanhe por Data 
		//
		SC9->C9_REGWMS := SC6->C6_REGWMS
		If cPaisLoc == "COL" //Tratamento de Terceros em Vendas
			SC9->C9_NIT := SC6->C6_NIT
		Endif
		If cPaisLoc == "BRA"
			SC9->C9_CODISS := SC6->C6_CODISS
		EndIf	

		SB1->(dbSetOrder(1))
		SB1->(dbSeek(xFilial("SB1")+SC6->C6_PRODUTO))
		//Ŀ
		//O campo C9_RETOPER  considerado na quebra de Nota Fiscal.(BRASIL)      |
		//Alguns Clientes que migraram da versao 8 para 10 estao tendo problemas  |
		//com esta quebra pois na versao 8 esse campo nao possuia um inicializador|
		//padrao e muitos produtos estao com esse campo em branco.                |
		//Os campos em branco "" devem ser considerados como "2"=Nao. Assim qdo   |
		//|houver dois produtos ou mais onde alguns estao com os campos em branco e|
		//|e outros com "2" todos devem sair na mesma Nota Fiscal                  |
		//
		If cPaisLoc == "BRA"
			If !Empty(SB1->B1_RETOPER)
				SC9->C9_RETOPER := SB1->B1_RETOPER
			Else
				SC9->C9_RETOPER := "2"
			Endif
		EndIf	

		//Verifica se o novo DCL est configurado
		If SuperGetMv("MV_DCLNEW",.F.,.F.)
			DCLMTA440C()
		//Ŀ
		// Ponto de entrada para todos os itens do pedido.     
		//
		ElseIf ( ExistTemplate("MTA440C9") )
			ExecTemplate("MTA440C9",.F.,.F.)
		EndIf

		//-- Executa bloco de comandos para montagem de cargas (Oms521Car)
		If ( bBlock <> Nil )
			nRecSC9 := SC9->(Recno())
			Eval(bBlock)
			SC9->(dbGoto(nRecSC9))
			If SoftLock("SC9")
				RecLock("SC9",.F.)
			EndIf
		EndIf

		If ExistBlock("M440SC9I")
			ExecBlock("M440SC9I",.F.,.F.)
		EndIf
		MaAvalSC9("SC9",1,aLocaliz[nX],Nil,Nil,Nil,Nil,Nil,@nVlrCred,,,,lGeraDCF)
		
		/* Integrao RISK - TOTVS Mais Negcios
		Preenche a liberao do pedido conforme as regras do risk. */
		lLibPed := IIf(lUseOffBalance, SuperGetMV("MV_RSKNTKT",,.F.), .F.)
		If lUseOffBalance .And. RskEvlCredit( 2, SC5->C5_CONDPAG ) .and. lLibPed
			RskFillSC9() 
		EndIf
		
		//Ŀ
		//Atualiza o orcamento do Televendas, se foi originado a partir
		//dele no modulo Call Center (SIGATMK)                         
		//
		TkAtuTlv(SC9->C9_PEDIDO,2)

		//Ŀ
		// Ponto de entrada para todos os itens do pedido.     
		//
		If ( ExistBlock("MTA440C9") )
			ExecBlock("MTA440C9",.F.,.F.)
		EndIf
	Else
		//Ŀ
		//Acumula os dados na variavel aEmpenho                                   
		//
		If ( SF4->F4_ESTOQUE == "S" .And. aSaldos[nX,5] > 0 )
			//Ŀ
			// Atualiza qtde a ser reservada no pedido informado            
			//
			dbSelectArea("SB2")
			dbSetOrder(1)
			MsSeek(xFilial("SB2")+SC6->C6_PRODUTO+aSaldos[nX,11])
			RecLock("SB2")
			//Ŀ
			//Verifica se ha bloqueio de estoque                                      
			//
			If ( lCredito .And. lEstoque )
				//Ŀ
				//Atualiza os empenhos quando ha localizacao                              
				//
				nRegEmp := aScan(aEmpenho[2],{|x| x[1]==SB2->(RecNo()) .And.;
					x[3] == SC6->C6_LOCALIZ+SC6->C6_NUMSERI+SC6->C6_NUMLOTE+SC6->C6_LOTECTL })
				If ( nRegEmp == 0 )
					AAdd(aEmpenho[2],{ SB2->(RecNo()),aSaldos[nX,5],SC6->C6_LOCALIZ+SC6->C6_NUMSERI+SC6->C6_NUMLOTE+SC6->C6_LOTECTL,aSaldos[nX,6]})
				Else
					aEmpenho[2][nRegEmp][2] += aSaldos[nX,5]
					aEmpenho[2][nRegEmp][4] += aSaldos[nX,6]
				EndIf
			EndIf
		EndIf
		If ( SF4->F4_DUPLIC=="S" .And. !SC5->C5_TIPO$"DB" )
			dbSelectArea("SA1")
			dbSetOrder(1)
			MsSeek(xFilial("SA1")+SC6->C6_CLI+SC6->C6_LOJA)
			lTrvSA1 := IIf(cPaisLoc == "BRA" .And. lFATTRVSA1, ExecBlock("FATTRVSA1", .F., .F., {xFilial("SA1"), SA1->A1_COD, SA1->A1_LOJA}), .T.)
			If lTrvSA1
				RecLock("SA1")
			EndIf
			nMCusto :=  If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC,Val(SuperGetMv("MV_MCUSTO")))
			If ( Empty(cBlqCred) )
				nRegEmp := aScan(aEmpenho[1],{|x| x[1]==SA1->(RecNo())})
				If ( nRegEmp == 0 )
					AAdd(aEmpenho[1],{ SA1->(RecNo()),0,0})
					nRegEmp := Len(aEmpenho[1])
				EndIf
				aEmpenho[1][nRegEmp][2] += xMoeda( aSaldos[nX,5] * SC6->C6_PRCVEN , SC5->C5_MOEDA , nMCusto , dDataBase )
				aEmpenho[1][nRegEmp][3] += xMoeda( aSaldos[nX,5] * SC6->C6_PRCVEN , SC5->C5_MOEDA , nMCusto , dDataBase )
			EndIf
		EndIf
	EndIf
	//Ŀ
	//Incrementa o SC9                                                        
	//
	cSeqSC9 := Soma1(cSeqSC9,Len(SC9->C9_SEQUEN))

Next nX
//Ŀ
//Restaura a entrada da rotina                                            
//
RestArea(aAreaSA1)
RestArea(aAreaSB2)
RestArea(aAreaSF4)
RestArea(aAreaSB1)
RestArea(aArea)
Return(.T.)
/*/


Ŀ
Funcao    MaTrfLocal Autor Eduardo Riera           Data 19.03.99  
Ĵ
Descrio Efetua a transferencia de Locais                            
Ĵ
Retorno   Nenhum                                                      
Ĵ
ParametrosExpC1: Produto                                              
          ExpC2: Local de Origem                                      
          ExpC3: Local de Destino                                     
          ExpN4: Quantidade                                           
          ExpC5: Documento                                            
          ExpL6: Indica se eh um estorno                              
          ExpL7: D3_NUMSEQ para manter a integridade com a SC9        
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function MaTrfLocal(cCodPro,cOrigem,cDestino,nQuant,cDocumento,lEstorno,cSeq)

Local aArea    := GetArea()
Local aAreaSB1 := SB1->(GetArea())
Local aAreaSB2 := SB2->(GetArea())
Local aAreaSD3 := SD3->(GetArea())
Local cNumSeq  := ""
Local aCm      := {}
Local aSd3     := {}
Local lSD3Seq := SC9->(FieldPos("C9_SD3SEQ") > 0)
Local nCntFor  := 0
Local nCntFor2 := 0

Local cArmazDest := ""
Local cArmazOrig := ""
Local aLinLogMsg := {}
Local lIsTrfExc  := Type("aColTrfExc") == "A"

dbSelectArea("SB1")
dbSetOrder(1)
MsSeek(xFilial("SB1")+cCodPro)

If !lEstorno
	//Ŀ
	//Requisicao do produto e local de origem                                 
	//
	dbSelectArea("SB2")
	dbSetOrder(1)
	If ( !MsSeek(xFilial("SB2")+SB1->B1_COD+cOrigem) )
		CriaSB2( SB1->B1_COD,cOrigem )
	EndIf
	RecLock("SB2",.F.)

	cNumSeq  := ProxNum()
	aCM := PegaCMAtu(SB1->B1_COD,cOrigem)
	RecLock("SD3",.T.)
	SD3->D3_FILIAL  := xFilial("SD3")
	SD3->D3_COD     := SB1->B1_COD
	SD3->D3_QUANT   := nQuant
	SD3->D3_CF      := "RE4"
	SD3->D3_CHAVE   := "E0"
	SD3->D3_LOCAL   := cOrigem
	SD3->D3_DOC     := cDocumento
	SD3->D3_EMISSAO := dDatabase
	SD3->D3_UM      := SB1->B1_UM
	SD3->D3_GRUPO   := SB1->B1_GRUPO
	SD3->D3_TIPO    := SB1->B1_TIPO
	SD3->D3_NUMSEQ  := cNumSeq
	SD3->D3_QTSEGUM := ConvUm(SB1->B1_COD,nQuant,0,2)
	SD3->D3_SEGUM   := SB1->B1_SEGUM
	SD3->D3_PARCTOT := "V"
	SD3->D3_TM      := "999"
	aCusto := GravaCusD3(aCM)
	B2AtuComD3(aCusto)

	//Ŀ
	//Cria almoxarifado de destino                                            
	//
	dbSelectArea("SB2")
	dbSetOrder(1)
	If ( !MsSeek(xFilial("SB2")+SB1->B1_COD+cDestino) )
		CriaSB2( SB1->B1_COD,cDestino )
	EndIf
	RecLock("SB2",.F.)

	RecLock("SD3",.T.)
	SD3->D3_FILIAL  := xFilial("SD3")
	SD3->D3_COD     := SB1->B1_COD
	SD3->D3_QUANT   := nQuant
	SD3->D3_CF      := "DE4"
	SD3->D3_CHAVE   := "E9"
	SD3->D3_LOCAL   := cDestino
	SD3->D3_DOC     := cDocumento
	SD3->D3_EMISSAO := dDatabase
	SD3->D3_UM      := SB1->B1_UM
	SD3->D3_GRUPO   := SB1->B1_GRUPO
	SD3->D3_TIPO    := SB1->B1_TIPO
	SD3->D3_NUMSEQ  := cNumSeq
	SD3->D3_QTSEGUM := ConvUm(SB1->B1_COD,nQuant,0,2)
	SD3->D3_SEGUM   := SB1->B1_SEGUM
	SD3->D3_PARCTOT := "V"
	SD3->D3_TM      := "499"

	aCusto := GravaCusD3(aCM)
	B2AtuComD3(aCusto)

	If lSD3Seq
		cSeq := SD3->D3_NUMSEQ
	EndIf
Else
	cDocumento := cDocumento + Space(Len(SD3->D3_DOC) - Len(AllTrim(cDocumento)))
	dbSelectArea("SD3")
	dbSetOrder(2)
	MsSeek(xFilial("SD3")+cDocumento+SB1->B1_COD)
	While ( !Eof() .And. cDocumento== SD3->D3_DOC .And.;
			cCodPro   == SD3->D3_COD )
		If ( SD3->D3_PARCTOT=="V" ) .And. (IIF(lSD3Seq, SD3->D3_NUMSEQ == SC9->C9_SD3SEQ, .T.))
			If (SD3->D3_EMISSAO > MvUlMes())
				AAdd(aSd3,{})
				For nCntFor := 1 To SD3->(FCount())
					AAdd(aSD3[Len(aSD3)],SD3->(FieldGet(nCntFor)))
				Next nCntFor
				RecLock("SD3",.F.)
				SD3->D3_ESTORNO := "S"
			ElseIf lIsTrfExc

				If (SD3->D3_CF == "DE4")
					cArmazDest := SD3->D3_LOCAL
				ElseIf (SD3->D3_CF == "RE4")
					cArmazOrig := SD3->D3_LOCAL
				EndIf

				// Guardar os dados no array para informar ao usuario apos o final do processamento
				If !Empty(cArmazDest) .And. !Empty(cArmazOrig)
					aLinLogMsg := { SC6->C6_ITEM,                                         ; // 01 - Item do Pedido de Venda
									SC6->C6_PRODUTO,                                      ; // 02 - Codigo do Produto
									cArmazOrig,              		                      ; // 03 - Armazm Origem
									cArmazDest,       		                              ; // 04 - Armazm Destino
									SD3->D3_NUMSEQ,                            	          ; // 05 - Sequencia do movimento
									SD3->D3_QUANT,                            	          ; // 06 - Quantidade movimentada
									SD3->D3_EMISSAO,                           	          ; // 07 - Data Transf.
									.F.                                                   ; // 08 - Indica se a linha foi deletada ou nao (.T.=Deletado, .F.=Nao Deletado)
								}
					AAdd(aColTrfExc, aLinLogMsg)
					FreeObj(aLinLogMsg)
					cArmazOrig := ""
					cArmazDest := ""
				EndIf
			EndIf
		EndIf
		dbSelectArea("SD3")
		dbSkip()
	EndDo
	For nCntFor := 1 To Len(aSd3)
		RecLock("SD3",.T.)
		For nCntFor2 := 1 To Len(aSd3[nCntFor])
			SD3->(FieldPut(nCntFor2,aSd3[nCntFor][nCntFor2]))
		Next nCntFor2
		aCm   := PegaCMAtu(SD3->D3_COD,SD3->D3_LOCAL)
		If ( SD3->D3_CF == "DE4" )
			SD3->D3_CF     := "RE4"
			SD3->D3_CHAVE  := "E0"
			SD3->D3_TM     := "999"
			SD3->D3_ESTORNO:= "S"
			SD3->D3_EMISSAO:= dDataBase
		Else
			SD3->D3_CF     := "DE4"
			SD3->D3_CHAVE  := "E9"
			SD3->D3_TM     := "499"
			SD3->D3_ESTORNO:= "S"
			SD3->D3_EMISSAO:= dDataBase
		EndIf
		aCusto := GravaCusD3(aCm)
		B2AtuComD3(aCusto)

	Next nCntFor
EndIf

//Ŀ
//Restaura a entrada da rotina                                            
//
RestArea(aAreaSB1)
RestArea(aAreaSB2)
RestArea(aAreaSD3)
RestArea(aArea)

Return(.T.)

/*/


Ŀ
Funcao    MaAvLibPed Autor Eduardo Riera           Data 23.03.99  
Ĵ
Descrio Verifica se um pedido pode ser totalmente liberado          
Ĵ
Retorno   ExpL1: Pedido pode ser totalmente liberado                  
Ĵ
ParametrosExpC1: Numero do Pedido                                     
          ExpL2: Liberacao Parcial                                    
          ExpL3: Transfere Locais                                     
          ExpL4: lLiberOk                                             
          ExpA5: Registros a serem processados ( Default Todos )      
          Expb6: Code Block a ser avaliado na gravacao do SC9         
          ExpL7: Indica se ha estorno de liberacao                    
          ExpL8: Indica se ha avaliacao de credito                    
          ExpL9: Indica se ha avaliacao de estoque                    
Ĵ
ObservacaoDeve estar numa transacao                                   
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function MaAvLibPed(cNumPed,lLiber,lTransf,lLiberOk,aRegistros,bBlock,lEstLib,lAvCred,lAvEst,nVlrCred)

Local aArea    := GetArea()
Local aAreaSA1 := SA1->(GetArea())
Local aAreaSF4 := SF4->(GetArea())
Local aAreaSC5 := SC5->(GetArea())
Local aAreaSC6 := SC6->(GetArea())
Local aAreaSC9 := SC9->(GetArea())
Local aEmpenho := {{},{}}
Local lRetorno := .F.
Local lBloqueio:= .F.
Local lLibEst  := .F.
Local lLibCred := .F.
Local lCredito := .F.
Local lEstoque := .F.
Local lFind	   := .F.
Local nX       := 0
Local nQtdLib  := 0
Local nCredito := nVlrCred
Local nSldOrdSep := 0

lLiberOk := .T.
DEFAULT nVlrCred   := 0
DEFAULT aRegistros := {}
DEFAULT lAvCred    := .T.
DEFAULT lAvEst     := .T.
DEFAULT lEstLib    := .F.
//Ŀ
//MEMORIA DE CALCULO DO ARRAY aEmpenho                                    
//                                                                        
//[1] - SA1                                                               
//[1][1] - Registro                                                       
//[1][2] - A1_SALPEDL                                                     
//[2] - SB2                                                               
//[2][1] - Registro                                                       
//[2][2] - B2_RESERVA                                                     
//                                                                        
//
//Ŀ
//Posiciona Registros                                                     
//
dbSelectArea("SC5")
dbSetOrder(1)
lFind := MsSeek(xFilial("SC5")+cNumPed)

If lFind
	lRetorno := RecLock("SC5")
	If !( SC5->C5_TIPO$"BD" )
		dbSelectArea("SA1")
		dbSetOrder(1)
		MsSeek(xFilial("SA1")+SC5->C5_CLIENTE+SC5->C5_LOJACLI)
		lTrvSA1 := IIf(cPaisLoc == "BRA" .And. lFATTRVSA1, ExecBlock("FATTRVSA1", .F., .F., {xFilial("SA1"), SA1->A1_COD, SA1->A1_LOJA}), .T.)
		If lTrvSA1
			lRetorno := RecLock("SA1")
		EndIf
	Else
		dbSelectArea("SA2")
		dbSetOrder(1)
		MsSeek(xFilial("SA2")+SC5->C5_CLIENTE+SC5->C5_LOJACLI)
		lRetorno := RecLock("SA2")
	EndIf
	//Ŀ
	//Verifica o tipo de processamento                                        
	//
	If Len(aRegistros) > 0
		lLibEst  := .T.
		lLibCred := .T.
		For nX := 1 To Len(aRegistros)
			nSldOrdSep := 0
			SC6->(MsGoto(aRegistros[nX]))
			lRetorno := RecLock("SC6")
			If ( lRetorno )
				If lEstLib
					//Ŀ
					//Verifica a necessidade de estorno da liberacao                          
					//
					nSldOrdSep := FtGtSldOS()
					nQtdLib := SC6->C6_QTDEMP - nSldOrdSep
					If nQtdLib > 0
						MaAvalSC6("SC6",4,"SC5",Nil,Nil,Nil,Nil,Nil,Nil,@nCredito)
						RecLock("SC6")
						SC6->C6_QTDLIB := nQtdLib
					Else
						nQtdLib := SC6->C6_QTDLIB
					EndIf
				Else
					nQtdLib := SC6->C6_QTDLIB
				EndIf
				lCredito := .F. .Or. !lAvCred
				lEstoque := .F.
				MaLibDoFat(SC6->(RecNo()),nQtdLib,@lCredito,@lEstoque,lAvCred,lAvEst,lLiber,lTransf,@aEmpenho,bBlock,Nil,Nil,Nil,@nCredito)
			Else
				lCredito := .F.
				lEstoque := .F.
			EndIf
			lLibCred := lCredito .And. lLibCred
			lLibEst  := lEstoque .And. lLibEst
			If ( !lLibEst .And. !lLibCred )
				nX := Len(aRegistros)+1
			EndIf
		Next nX
	Else
		lLibEst  := .T.
		lLibCred := .T.
		lBloqueio:= .F.
		dbSelectArea("SC6")
		dbSetOrder(1)
		MsSeek(xFilial("SC6")+SC5->C5_NUM,.F.)
		While ( !Eof() .And. xFilial("SC6") == SC6->C6_FILIAL .And.;
				SC5->C5_NUM    == SC6->C6_NUM )
			lRetorno := RecLock("SC6")
			If ( lRetorno )
				AAdd(aRegistros,SC6->(RecNo()))
				If !lBloqueio
					lCredito := .F. .Or. !lAvCred
					lEstoque := .F.
					MaLibDoFat(SC6->(RecNo()),SC6->C6_QTDLIB,@lCredito,@lEstoque,lAvCred,lAvEst,lLiber,lTransf,@aEmpenho,bBlock,Nil,Nil,Nil,@nCredito)
				EndIf
			Else
				lCredito := .F.
				lEstoque := .F.
			EndIf
			lLibCred := lCredito .And. lLibCred
			lLibEst  := lEstoque .And. lLibEst
			If ( !lLibEst .And. !lLibCred )
				lBloqueio := .T.
			EndIf
			dbSelectArea("SC6")
			dbSkip()
		EndDo
	EndIf
	//Ŀ
	//Atualiza os dados com base no processamento anterior                    
	//
	lEstoque := .T.
	For nX := 1 To Len(aRegistros)
		nSldOrdSep := 0
		SC6->(MsGoto(aRegistros[nX]))
		RecLock("SC6")
		If ( !lLibEst .Or. !lLibCred )
			lRetorno := .F.
			If lEstLib
				//Ŀ
				//Verifica a necessidade de estorno da liberacao                          
				//
				nSldOrdSep := FtGtSldOS()
				nQtdLib := SC6->C6_QTDEMP - nSldOrdSep
				If nQtdLib > 0
					MaAvalSC6("SC6",4,"SC5",Nil,Nil,Nil,Nil,Nil,Nil,@nVlrCred)
				Else
					nQtdLib := SC6->C6_QTDLIB
				EndIf
			Else
				nQtdLib := SC6->C6_QTDLIB
			EndIf
			lCredito := lLibCred
			lEstoque := (lLibCred .And. lLibEst) .Or. (lLibEst .And. lEstoque .And. SuperGetMv("MV_RESEST"))
			MaLibDoFat(SC6->(RecNo()),nQtdLib,@lCredito,@lEstoque,lCredito .And. lAvCred,lEstoque,lLiber,lTransf,,bBlock,Nil,Nil,Nil,@nVlrCred)
			Do Case
			Case lLibCred <> lCredito .And. lLibCred
				lLibCred := .F.
			Case lLibEst <> lEstoque .And. lLibEst
				lLibEst := .F.
			EndCase
		Else
			MaLibDoFat(SC6->(RecNo()),SC6->C6_QTDLIB,@lCredito,@lEstoque,lAvCred,.T.,lLiber,lTransf,,bBlock,Nil,Nil,Nil,@nVlrCred)
		EndIf
		//Ŀ
		//Verifica se Todos os Itens foram Liberados                              
		//
		If ( SC6->C6_QTDVEN > SC6->C6_QTDEMP + SC6->C6_QTDENT .And. lLiberOk .And. AllTrim(SC6->C6_BLQ)<>"R" )
			lLiberOk := .F.
		EndIf
	Next nX
EndIf

RestArea(aAreaSC9)
RestArea(aAreaSA1)
RestArea(aAreaSF4)
RestArea(aAreaSC5)
RestArea(aAreaSC6)
RestArea(aArea)
Return(lRetorno)

/*/


Ŀ
Funcao    a410Grade  Autor  Eduardo Riera          Data  03.12.98 
Ĵ
Descrio Montagem do aHeader, aCols , aColsGrade e aHeaderGrade.     
          para os itens que possuem grade.                            
Ĵ
Retorno   Nenhum                                                      
Ĵ
ParametrosExpL1: Se True e adionado o controle de Deletados           
          ExpL2: Indica se a chamada eh feita pela Liberacao          
          ExpC3: Alias de referencia ao SC6 ( Query )                 
          ExpL4: Indica se os registros bloqueado devem ser considera-
                 dos.                                                 
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function a410Grade(lDelAcols,lMata440,cAlias,lBloqueados,lCriaCols)

Local nTamaCols:=Len(aCols)
Local nPosItem :=aScan(aHeader,{|x| AllTrim(x[2])=="C6_ITEM"})
Local nPosQtd  :=aScan(aHeader,{|x| AllTrim(x[2])=="C6_QTDVEN"})
Local nPosQtd2 :=aScan(aHeader,{|x| AllTrim(x[2])=="C6_UNSVEN"})
Local nPosVlr  :=aScan(aHeader,{|x| AllTrim(x[2])=="C6_VALOR"})
Local nPosSld  :=aScan(aHeader,{|x| AllTrim(x[2])=="C6_SLDALIB"})
Local nPosDesc :=aScan(aHeader,{|x| AllTrim(x[2])=="C6_VALDESC"})
Local nCntFor  :=0
Local nItGrade := 1
Local cProdRef := ""
Local cLinha   := ""
Local cColuna  := ""
Local nLinha   := 0
Local nColuna  := 0
DEFAULT lBloqueados := .F.
DEFAULT lCriaCols   := .T.
lMata440 := If(lMata440==Nil,.F.,lMata440)
cAlias   := If(cAlias==Nil,"SC6",cAlias)

If ( nTamAcols <> 0 )
	nItGrade := nTamAcols
	If ( aCols[nTamaCols][nPosItem] <> (cAlias)->C6_ITEM )
		nItGrade ++
	EndIf
EndIf

cProdRef := (cAlias)->C6_PRODUTO

//Ŀ
//Inicializa o aHeadGrade e o AcolsGrade                                  
//
&(MaReadGrd()):MontaGrade(nItGrade,@cProdRef,,lBloqueados)

cLinha   := AllTrim(Substr((cAlias)->C6_PRODUTO,&(MaReadGrd()):TamRef()+1,&(MaReadGrd()):TamLin()))
cColuna  := AllTrim(Substr((cAlias)->C6_PRODUTO,(&(MaReadGrd()):TamRef()+&(MaReadGrd()):TamLin()+1),&(MaReadGrd()):TamCol()))

nColuna := &(MaReadGrd()):RetPosCol(nItGrade,cColuna)
nLinha  := &(MaReadGrd()):RetPosLin(nItGrade,cLinha)
If ( nColuna<>0 .And. nLinha <> 0 )
	nColuna++
	&(MaReadGrd()):aColsGrade[nItGrade][nLinha][nColuna][&(MaReadGrd()):GetFieldGrdPos("C6_QTDVEN")] 	+= (cAlias)->C6_QTDVEN
	&(MaReadGrd()):aColsGrade[nItGrade][nLinha][nColuna][&(MaReadGrd()):GetFieldGrdPos("C6_QTDLIB")] 	:= 0
	&(MaReadGrd()):aColsGrade[nItGrade][nLinha][nColuna][&(MaReadGrd()):GetFieldGrdPos("C6_QTDENT")] 	:= If(lMata440,(cAlias)->C6_QTDENT+(cAlias)->C6_QTDEMP,(cAlias)->C6_QTDENT)
	&(MaReadGrd()):aColsGrade[nItGrade][nLinha][nColuna][&(MaReadGrd()):GetFieldGrdPos("C6_ITEM")]	:= (cAlias)->C6_ITEM
	&(MaReadGrd()):aColsGrade[nItGrade][nLinha][nColuna][&(MaReadGrd()):GetFieldGrdPos("C6_UNSVEN")] 	:= (cAlias)->C6_UNSVEN
	&(MaReadGrd()):aColsGrade[nItGrade][nLinha][nColuna][&(MaReadGrd()):GetFieldGrdPos("C6_BLQ")] 	:= (cAlias)->C6_BLQ
	&(MaReadGrd()):aColsGrade[nItGrade][nLinha][nColuna][&(MaReadGrd()):GetFieldGrdPos("C6_OPC")] 	:= (cAlias)->C6_OPC
EndIf
//Ŀ
//Monta o Acols                                                                        
//
// -- Nao monta aCols se for chamada pelo bloco de codigo da FillGetDados
If lCriaCols
	If ( nTamAcols==0 .Or. aCols[nTamAcols][nPosItem] <> (cAlias)->C6_ITEM )
		AAdd(aCols,Array(Len(aHeader)+If(lDelaCols,1,0)))
		nTamAcols++
		For nCntFor := 1 To Len(aHeader)
			If ( aHeader[nCntFor][10] == "V" )
				aCols[nTamAcols][nCntFor] := CriaVar(aHeader[nCntFor][2])
			Else
				aCols[nTamAcols][nCntFor] := (cAlias)->(FieldGet(FieldPos(aHeader[nCntFor][2])))
			EndIf
			If ( AllTrim(aHeader[nCntFor][2]) == "C6_PRODUTO" )
				aCols[nTamAcols][nCntFor] := PadR(cProdRef,Len(SB1->B1_COD))
			EndIf
		Next nCntFor
		If ( lDelaCols )
			aCols[nTamAcols][Len(aHeader)+1] := .F.
		EndIf
	Else
		aCols[nTamAcols][nPosQtd]  += (cAlias)->C6_QTDVEN
		If nPosQtd2 <> 0
			aCols[nTamAcols][nPosQtd2] += (cAlias)->C6_UNSVEN
		EndIf
		If ( nPosDesc > 0 )
			aCols[nTamAcols][nPosDesc] += (cAlias)->C6_VALDESC
		Endif
		If ( nPosSld > 0 )
			aCols[nTamAcols][nPosSld] += Ma440SaLib()
		EndIf
		aCols[nTamAcols][nPosVlr] += (cAlias)->C6_VALOR
	EndIf
EndIf
Return(.T.)

/*/


Ŀ
Funcao    a410Arred  Autor  Eduardo Riera          Data  19.02.99 
Ĵ
Descrio  Retorna o valor com o padrao de arredondamento MV_ARREFAT. 
Ĵ
Retorno    ExpN1: Novo Valor conforme parametro MV_ARREFAT            
Ĵ
Parametros ExpN1: Valor                                               
           ExpC2: Nome do Campo                                       
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function A410Arred(nVArred,cCampo,nMoeda)

Local aArea    := GetArea()
Local aAreaSX3 := {}
Local nPosDec  := 0
Local nCasas   := 2

DEFAULT cCampo := "C6_PRCVEN"
DEFAULT __cSX3Casas  := ""

cCampo := Upper(Alltrim(cCampo))

//Se a empresa for trocada via SIGAADV, o cache  zerado.
If cEmpAnt <> __cEmpLog
	__cSX3Casas := ""
	__cEmpLog	:= cEmpAnt
	__cFilLog   := cFilAnt
	__lArrefat 	:= Nil
ElseIf cFilAnt <> __cFilLog
	__cFilLog   := cFilAnt
	__lArrefat 	:= Nil
EndIf

If __lArrefat == Nil
	__lArrefat := ( SuperGetMv("MV_ARREFAT") == "S" )
EndIf

If cPaisLoc <> "BRA" .And. nMoeda <> NIL
	nCasas := MsDecimais(nMoeda)
Else
	nPosDec := AT(cCampo+"/",__cSX3Casas)
	IF nPosDec <> 0
		nCasas  := Val(Subs(__cSX3Casas,nPosDec+Len(cCampo)+1,2))
	Else
		aAreaSX3 := SX3->(GetArea())

		nCasas := TamSX3(cCampo)[2]
		__cSX3Casas += cCampo+"/"+StrZero(nCasas,2,0)+"//"

		RestArea(aAreaSX3)
	EndIf
EndIf
If __lArrefat
	nVArred := Round(nVarred,nCasas)
Else
	nVArred := NoRound(nVarred,nCasas)
EndIf

//Ŀ
//Retorna o estado de entrada                                             
//
RestArea(aArea)
Return(nVArred)

/*/


Ŀ
Funcao    Ma440SaLib Autor Eduardo Riera           Data  08.03.99 
Ĵ
Descrio Calculo do Saldo da Quantidade a Liberar.                   
Ĵ
Retorno   ExpN1: Saldo da Quantidade Liberada.                        
Ĵ
ParametrosNenhum                                                      
                                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function Ma440SaLib()

Local nSaldo := 0

nSaldo := Max(SC6->C6_QTDVEN - SC6->C6_QTDEMP - SC6->C6_QTDENT,0)

Return(nSaldo)

/*/


Ŀ
Funcao    IncNota    Autor Claudia Cabral          Data  08.08.00 
Ĵ
Descrio Inclusao Automatica de Nota Fiscal para a Exportacao(SIGAEEC) |
Ĵ
Retorno   Nenhum                                                      
Ĵ
ParametrosNumero do Pedido de Venda                                   
          Serie da Nota Fiscal                                        
          Numero do Embarque de Exportacao                            
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
24/10/2006Ronald Piscion.BOPS 108518: o array aPvlNfs era enviado co-
                         mo parametro para a funcao MaPvlNfs zerado, 
                         quando o nro. de itens era igual ao parame- 
                         tro MV_NUMITEN (var. nItemNF)               
ٱ


/*/

Function IncNota(cC5Num,cSerie,cEmbExp,aNotas)
Local aPvlNfs := {}
Local nPrcVen := 0
Local nItemNf := a460NumIt(cSerie)

Default aNotas := {}

SC5->(DbSetOrder(1))
SC5->(MsSeek(xFilial("SC5")+cC5Num))

SC6->(dbSetOrder(1))
SC6->(MsSeek(xFilial("SC6")+SC5->C5_NUM))

While SC6->(!Eof() .And. C6_FILIAL == xFilial("SC6")) .And.;
		SC6->C6_NUM == SC5->C5_NUM

	SC9->(DbSetOrder(1))
	SC9->(MsSeek(xFilial("SC9")+SC6->(C6_NUM+C6_ITEM))) //FILIAL+NUMERO+ITEM

	SE4->(DbSetOrder(1))
	SE4->(MsSeek(xFilial("SE4")+SC5->C5_CONDPAG) )  //FILIAL+CONDICAO PAGTO

	SB1->(DbSetOrder(1))
	SB1->(MsSeek(xFilial("SB1")+SC6->C6_PRODUTO))    //FILIAL+PRODUTO

	SB2->(DbSetOrder(1))
	SB2->(MsSeek(xFilial("SB2")+SC6->(C6_PRODUTO+C6_LOCAL))) //FILIAL+PRODUTO+LOCAL

	SF4->(DbSetOrder(1))
	SF4->(MsSeek(xFilial("SF4")+SC6->C6_TES))   //FILIAL+TES

	nPrcVen := SC9->C9_PRCVEN
	If ( SC5->C5_MOEDA <> 1 )
		nPrcVen := xMoeda(nPrcVen,SC5->C5_MOEDA,1,dDataBase)
	EndIf

	AAdd(aPvlNfs,{ SC9->C9_PEDIDO,;
		SC9->C9_ITEM,;
		SC9->C9_SEQUEN,;
		SC9->C9_QTDLIB,;
		nPrcVen,;
		SC9->C9_PRODUTO,;
		.f.,;
		SC9->(RecNo()),;
		SC5->(RecNo()),;
		SC6->(RecNo()),;
		SE4->(RecNo()),;
		SB1->(RecNo()),;
		SB2->(RecNo()),;
		SF4->(RecNo())})


	If ( Len(aPvlNfs) >= nItemNf )
		cNota := MaPvlNfs(aPvlNfs,cserie , .F.    , .F.    , .F.     , .T.    , .F.    , 0      , 0          , .T.  ,.F.,cEmbExp)
		//cNota := MaPvlNfs(aPvlNfs,cSerie,lMostraCtb,lAglutCtb,lCtbOnLine,lCtbCusto,lReajusta,nCalAcrs,nArredPrcLis,lAtuSA7,lECF,cembexp)
		aPvlNfs := {}
		AAdd( aNotas, { cSerie, cNota } )
	EndIf
	SC6->(DbSkip())
EndDo
If Len(aPvlNfs) > 0
    cNota := MaPvlNfs(aPvlNfs,cserie, .F.    , .F.    , .F.     , .T.    , .F.    , 0      , 0          , .T.  ,.F.,cEmbExp)
    AAdd( aNotas, { cSerie, cNota } )
EndIf

Return

/*/


Ŀ
Funcao    Estorna_PV Autor Claudia Cabral          Data  08.08.00 
Ĵ
Descrio Estorno e Exclusao do Pedido de Venda para a Exportacao (SigaEEC)|
Ĵ
Retorno   Nenhum                                                      
Ĵ
ParametrosNumero do Pedido de Venda                                   
          Matriz de Cabecalho                                         
          Matriz de Itens                                             
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function Estorna_PV(cSC5Num,aMata410Cab,aMata410Itens)

dbSelectArea("SC6")
dbSetOrder(1)    //C6_FILIAL+C6_NUM+C6_ITEM+C6_PRODUTO
If MsSeek(xFilial("SC6")+cSC5Num)
	While !Eof() .and. cSC5Num == SC6->C6_NUM .and. xFilial("SC6") == SC6->C6_FILIAL
		//Ŀ
		// Eliminacao de residuo por item de pedido              
		//
		If SC6->C6_QTDEMP > 0
			dbSelectArea("SC9")
			dbSetOrder(1)
			If MsSeek(xFilial("SC9")+SC6->C6_NUM+SC6->C6_ITEM)
				SC9->(a460Estorna())
			Endif
		Endif

		dbSelectArea("SC6")

		dbSkip()
	EndDo
Endif

MATA410( aMata410Cab ,aMata410Itens , 5 )

Return

/*/


Ŀ
Funcao    MaAvalSC5  Autor Eduardo Riera           Data 13.02.2000
Ĵ
Descrio Rotina de avaliacao dos eventos do Cabecalho do Pedido de   
          Venda.                                                      
Ĵ
ParametrosExpC1: Alias da tabela de Cabecalho do Pedido de Venda      
          ExpN2: Codigo do Evento                                     
                 [1] Implantacao do Pedido de Venda                   
                 [2] Estorno do Pedido de Venda                       
                 [3] Liberacao do Pedido de Venda                     
                 [4] Estorno da Liberacao do Pedido de Venda          
                 [5] Preparacao da Nota Fiscal de Saida               
                 [6] Exclusao da Nota Fiscal de Saida                 
                 [7] Reavaliacao de Credito (Por Pedido)              
                 [8] Estorno da Reavalizacao de Credito ( Por Pedido )
          ExpL3: Liberacao Parcial                                    
          ExpL4: Transfere Locais                                     
          ExpL5: Verifica se todos os itens foram liberados           
          ExpL6: Verifica os residuos do pedido de venda              
          ExpL7: Verifica se todos os itens foram faturados           
          ExpL8: Atualiza somente os acumulados          (DEFA: .F.)  
          ExpL9: Indica que todos os itens foram gravado (DEFA: .T.)  
          ExpCA: Numero do Pedido de Venda                      (OPC) 
          ExpAB: Array com os recnos do SC6                     (OPC) 
          ExpLC: Estorna liberacoes anteriores                  (OPC) 
          ExpLD: Avalia Credito                                 (OPC) 
          ExpNE: Valor a ser adicionado ao limite de credito    (OPC) 
Ĵ
Retorno   Nenhum                                                      
                                                                      
Ĵ
Descrio Esta rotina tem como objetivo atualizar os eventos vinculado
          ao cabecalho do pedido de venda                             
          A) Atualizacao das tabelas complementares.                  
          B) Atualizacao das informacoes complementares do PV         
                                                                      
Ĵ
Uso        Materiais                                                  
ٱ


/*/
Function MaAvalSC5(cAliasSC5,nEvento,lLiber,lTransf,lLiberOk,lResidOk,lFaturOk,lAcumulado,lFinal,cPedido,aRegSC6,lEstLib,lAvCred,nVlrCred)

Local aArea     := GetArea(cAliasSC5)
Local lAtuSC5   := .F.
Local cQuery    := ""
Local lResAut   := SuperGetMv("MV_RESAUT")
Local lNoRunFlCx:= ExistBlock("FtNRunFlCx")
Local LExecFlCx	:= .T.

DEFAULT lAcumulado:= .F.
DEFAULT lFinal    := .T.
DEFAULT cPedido   := (cAliasSC5)->C5_NUM
DEFAULT nVlrCred  := 0

RecLock("SC5")
Do Case
	//Ŀ
	//Implantacao de um do pedido de venda                                    
	//
	Case nEvento == 1
		//Valida a data da LIB para utilizao na Telemetria
		If FatLibMetric()
			//Telemetria - MV_RESTAUT - Gerao de Reserva Automtica de Estoque pelo Pedido de Venda
			FwCustomMetrics():setUniqueMetric("FATXFUN","faturamento-protheus_reserva-automatica-estoque-pedido-venda_total", IIf(lResAut,".T.",".F."), /*dDateSend*/, /*nLapTime*/,"FATXFUN")
		EndIf
		Do Case
			Case lLiberOk
				(cAliasSC5)->C5_LIBEROK := "S"
			Case lResidOk
				(cAliasSC5)->C5_LIBEROK := "E"
			OtherWise
				(cAliasSC5)->C5_LIBEROK := ""
		EndCase
		If ( lFaturOk )
			//Ŀ
			//Release 11.5 Localizao Chile/Colombia                                  		    
			//Para esses paises ser informada a serie da tela de controle de formularios 			
			//por tanto no zera o campo C5_SERIE que sera alimentada pelo parametro MV_LOJAPED	
			//
			If cPaisloc$"COL|CHI" .AND. nModulo == 12 .AND. !Empty(SC5->C5_ORCRES)
				(cAliasSC5)->C5_NOTA  := ""
			Else
				(cAliasSC5)->C5_NOTA  := ""
				(cAliasSC5)->C5_SERIE := ""
			EndIf
		Else
			If Empty((cAliasSC5)->C5_NOTA) .AND. !((cAliasSC5)->C5_TIPO $ "CIP")
				(cAliasSC5)->C5_NOTA  := "XXXXXX"
				(cAliasSC5)->C5_SERIE := "XXX"
			EndIf
		EndIf
		//Ŀ
		//Integracao com o SIGAEEC                                                
		//
		If GetMv("MV_EECFAT")
			If FindFunction("AE100STATUS")
				AE100STATUS(SC5->C5_PEDEXP)
			EndIf
		EndIf

		If lNoRunFlCx
			LExecFlCx := ExecBlock("FtNRunFlCx",.F.,.F.)
			If Valtype(LExecFlCx) <> "L"
				LExecFlCx := .T.
			EndIf
		EndIf
		
		If !lAcumulado .And. LExecFlCx
			StartJob("FtJobPvCF",GetEnvServer(),.F.,cEmpAnt,cFilAnt,(cAliasSC5)->C5_NUM)
		EndIf
		
		If !lAcumulado
			//Ŀ
			// Grava os lancamentos nas contas orcamentarias SIGAPCO    
			//
			PcoDetLan("000100","03","MATA410")
		EndIf
		// Elimina o saldo do relacionamento do Pedido de Venda que foi finalizado
		If (cAliasSC5)->C5_LIBEROK == "S"                                   .AND.;
		   (cAliasSC5)->C5_NOTA == PadR("XXXXXX",Len((cAliasSC5)->C5_NOTA)) .AND.;
		   (cAliasSC5)->C5_SERIE == "XXX"                                   .AND.;
		   A410UsaAdi(SC5->C5_CONDPAG)
			FPedAdtRsd("R", {SC5->C5_NUM})
		EndIf
	//Ŀ
	//Estorno de um pedido de venda                                           
	//
	Case nEvento == 2
		//Ŀ
		//Atualiza a tabela de fluxo de caixa do PV        
		//
		cQuery := "DELETE FROM "+RetSqlName("AID")+" WHERE AID_FILIAL='"+xFilial("AID")+"' AND AID_NUMPV='"+cPedido+"' "
		TcSqlExec(cQuery)
		//Ŀ
		//Libera bloqueio de regra ou de verba                                    
		//
		If !__lPyme
			(cAliasSC5)->C5_BLQ := Space(Len(SC5->C5_BLQ))
		EndIf
	//Ŀ
	//Liberacao de um pedido de venda                                         
	//
	Case nEvento == 3
		lLiberOk := .F.
		If !lAcumulado .And. lFinal
			MaAvLibPed((cAliasSC5)->C5_NUM,lLiber,lTransf,@lLiberOk,aRegSC6,,lEstLib,lAvCred,Nil,@nVlrCred)
		EndIf
		If ( lLiberOk )
			(cAliasSC5)->C5_LIBEROK := "S"
		EndIf
	//Ŀ
	//Estorno da liberacao do pedido de venda                                 
	//
	Case nEvento == 4
		//Ŀ
		// PCO - Estorna os lancamentos de liberacao das contas orcamentarias 
		//
		If !Empty((cAliasSC5)->C5_LIBEROK)
			PcoDetLan("000103","02","MATA440",.T.)
		EndIf
		(cAliasSC5)->C5_LIBEROK := ""
	//Ŀ
	//Preparacao da Nota Fiscal de Saida                                      
	//
	Case nEvento == 5
		//Ŀ
		//Atualiza o Pedido de Venda                                              
		//
		lAtuSC5 := .T.

		SC6->(dbCommit())
		cQuery  := ""
		cQuery  += "SELECT COUNT(*) NUMERO FROM "+RetSqlName("SC6")+" "
		cQuery  += "WHERE C6_FILIAL='"+xFilial("SC6")+"' AND "
		cQuery  +=     "C6_NUM='"+cPedido+"' AND "
		cQuery  +=     "C6_BLQ<>'R ' AND "
		cQuery  +=     "C6_QTDVEN > C6_QTDENT AND "
		cQuery  +=     "D_E_L_E_T_=' '"
		cQuery := ChangeQuery(cQuery)

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"MAAVALSC5",.F.,.T.)

		If ( NUMERO == 0 )
			lAtuSC5 := .F.
		EndIf
		dbCloseArea()
		dbSelectArea("SC5")
		dbSetOrder(1)
		If ( !lAtuSC5 )
			If ( MsSeek(xFilial("SC5")+cPedido) )
				RecLock("SC5",.F.)
				If cPaisLoc == "BRA"
					SC5->C5_NOTA  := SF2->F2_DOC
					SC5->C5_SERIE := SF2->F2_SERIE
				Else
					If IsRemito(1,"SF2->F2_TIPODOC")
						SC5->C5_NOTA  := "REMITO"
						SC5->C5_SERIE := "RXX"
					Else
						SC5->C5_NOTA  := SF2->F2_DOC
						If SC5->C5_SERIE <> "RXX"
							SC5->C5_SERIE := SF2->F2_SERIE
						Endif
					Endif
				Endif
				MsUnlock()
				//Ŀ
				//Elimina o saldo do relacionamento de pedidos finalizados.
				//
				If 	A410UsaAdi( SC5->C5_CONDPAG )
					FPedAdtRsd( "R", { SC5->C5_NUM } )
				EndIf
			EndIf
		EndIf
		//Ŀ
		//Atualiza a tabela de fluxo de caixa do PV        
		//
		dbSelectArea("AID")
		cQuery := "DELETE FROM "+RetSqlName("AID")+" WHERE AID_FILIAL='"+xFilial("AID")+"' AND AID_NUMPV='"+cPedido+"' "
		TcSqlExec(cQuery)
	//Ŀ
	//Estorno da Nota fiscal de Saida                                         
	//
	Case nEvento == 6
		//Ŀ
		//Atualiza a tabela de fluxo de caixa do PV        
		//
		dbSelectArea("AID")
		cQuery := "DELETE FROM "+RetSqlName("AID")+" WHERE AID_FILIAL='"+xFilial("AID")+"' AND AID_NUMPV='"+cPedido+"' "
		TcSqlExec(cQuery)

		If cPaisLoc=="BRA"
			(cAliasSC5)->C5_LIBEROK := ""
			(cAliasSC5)->C5_SERIE   := ""
			(cAliasSC5)->C5_NOTA    := ""
		Else
			If Empty(SD2->D2_REMITO)
				(cAliasSC5)->C5_LIBEROK := ""
				(cAliasSC5)->C5_SERIE   := ""
				(cAliasSC5)->C5_NOTA    := ""
			Else
				If (cAliasSC5)->C5_SERIE == "RXX"
					(cAliasSC5)->C5_NOTA := "REMITO"
				Else
					(cAliasSC5)->C5_NOTA  := ""
					(cAliasSC5)->C5_SERIE := ""
				Endif
			Endif
		Endif
	//Ŀ
	//Liberacao de regras ou verbas                                           
	//
	Case nEvento == 9

		dbSelectArea("SC6")
		dbSetOrder(1)
		cAliasSC6 := "QRYSC6"

		dbSelectArea('SC6')
		dbCommit() //-- Atualiza as gravacoes pendentes na tabela

		cQuery := "UPDATE "+RetSqlName("SC6")
		cQuery += " SET C6_BLOQUEI = '  ' "
		cQuery += " WHERE C6_FILIAL='"+xFilial('SC6')+"' AND "
		cQuery += " C6_NUM='"+SC5->C5_NUM+"' AND "
		cQuery += "(C6_BLOQUEI = '01' OR C6_BLOQUEI = '02') AND "
		cQuery += " D_E_L_E_T_ = ' '"

		TcSqlExec(cQuery)
		dbGoto(Recno()) //-- Reposiciona na tabela/registro atual somente para atualizar gravacoes pendentes

		Reclock("SC5",.F.)
		SC5->C5_BLQ :=Space(Len(SC5->C5_BLQ))
		MsUnlock()

		If ExistBlock("MALIBREG")
			ExecBlock("MALIBREG",.F.,.F.,{SC5->C5_NUM})
		EndIf

EndCase
RestArea(aArea)

//-- Ponto de entrada apos avaliacao dos eventos do cabecalho do Pedido de Vendas.
If ExistBlock("MAAVSC5")
	ExecBlock("MAAVSC5",.F.,.F.,{nEvento})
EndIf
Return(.T.)

/*/


Ŀ
Funcao    MaAvalSC6  Autor Eduardo Riera           Data 13.02.2000
Ĵ
Descrio Rotina de avaliacao dos eventos do item do Pedido de Venda  
Ĵ
ParametrosExpC1: Alias da tabela dos itens do Pedido de Venda         
          ExpN2: Codigo do Evento                                     
                 [1] Implantacao do Pedido de Venda                   
                 [2] Estorno  do Pedido de Venda                      
                 [3] Liberacao do Pedido de Venda                     
                 [4] Estorno da Liberacao do Pedido de Venda          
                 [5] Preparacao da Nota Fiscal de Saida               
                 [6] Estorno da Nota Fiscal de Saida                  
          ExpC3: Alias do pedido de venda                             
          ExpL4: Liberacao Parcial                                    
          ExpL5: Transfere Locais                                     
          ExpL6: Verifica se todos os itens foram liberados           
          ExpL7: Verifica os residuos do pedido de venda              
          ExpL8: Verifica se todos os itens foram faturados           
          ExpL9: Atualiza somente os acumulados                       
          ExpNA: Valor a ser adicionado ao limite de credito          
          ExpCB: Alias do SD2 ( Uso Interno para otimizacao )         
          ExpLC: Indica se esta o SC6 esta sendo baixado por un REMITO
          ExpCD: Moeda do pedido de venda ( opcional )                
          ExpLE: Validacao regra de negocios pelo Televendas          
          ExpLF: Validacao analise de credito para o pedido.          
          ExpLG: Valida se considera estorno de todas lib. - Evento=2 
Ĵ
Retorno   Nenhum                                                      
                                                                      
Ĵ
Descrio Esta rotina tem como objetivo atualizar os eventos vinculado
          ao item do pedido de venda.                                 
          A) Atualizacao das tabelas complementares.                  
          B) Atualizacao das informacoes complementares do PV         
                                                                      
Ĵ
Uso        Materiais                                                  
Ĵ
Michel M. 29/03/078.11  Bops: 119212 - Corrigido nao-conformidade   
                        ao tentar Travar registro com o SA1 em EOF. 
                                                                	  
Norbert W.12/04/079.12  Bops: 122632 - Removido o codigo onde o cam-
                        po C5_BLQ era limpo a cada validacao do SC6,
                        eliminando o bloqueio de um item anterior.  
ٱ


/*/
Function MaAvalSC6(cAliasSC6,;
					nEvento,;
					cAliasSC5,;
					lLiber,;
					lTransf,;
					lLiberOk,;
					lResidOk,;
					lFaturOk,;
					lAcumulado,;
					nVlrCred,;
					cAliasSD2,;
					lRemito,;
					nMoeda,;
					lTLVReg,;
					lAvCred,;
					lTdsSqLb)

Local aArea    := GetArea(cAliasSC6)
Local aAreaSA1 := SA1->(GetArea())
Local aAreaSB2 := SB2->(GetArea())
Local aAreaSF4 := SF4->(GetArea())
Local aProdDesc:= {}
Local nQtdRese := 0
Local nQtdLib  := 0
Local nQtdLib2 := 0
Local nSldPed  := 0
Local nSldPed2 := 0
Local nMCusto  := 0

Local nSaveSX8 := GetSX8Len()
Local cReserva := ""
Local cPedido  := ""
Local cItemPV  := ""
Local cProduto := ""
Local cTipoPV  := ""
Local cTipLib  := ""
Local cEstado  := ""
Local cFunName := ""
Local cRet     := ""
Local cFilAB8  := ""
Local cFilSC9  := ""
Local dEmissao := Ctod("")
Local lContinua:= .T.
Local lCredito := .F.
Local lEstoque := .F.
Local lTipoAB7 := .F.
Local lResAut  := SuperGetMv("MV_RESAUT")
Local lTipRes  := SuperGetMv("MV_TIPRES")
Local lECommerce := SuperGetMV("MV_LJECOMM",,.F.)
Local lECCia 	:= lECommerce .AND. SuperGetMV("MV_LJECOMO",,.F.) .AND. (SC5->(ColumnPos("C5_PEDECOM")> 0 )) //E-commerce CiaShop Implantado?
Local lECCiaRes := lECCia .AND. !SuperGetMv("MV_RESAUT") .AND. SuperGetMv("MV_LJECOM0",.F., .F.) //Realiza reserva de estoque e-commerce CiaShop?

Local lBlqReg  := .F.
Local lProgEnt := .F.	//Indica se o Pedido de Venda foi gerado por uma Programao de Entrega

Local lExtB2DMOV   := (SB2->(ColumnPos("B2_DMOV")) > 0)
Local lExtB2HMOV   := (SB2->(ColumnPos("B2_HMOV")) > 0)

Local cSeq     := ""
Local lTrvSA1  := .T.

//Ŀ
//Inicializa variaveis                                                    
//
DEFAULT cAliasSC5 := "SC5"
DEFAULT cAliasSC6 := "SC6"
DEFAULT cAliasSD2 := "SD2"
DEFAULT lLiber    := .F.
DEFAULT lTransf   := .F.
DEFAULT lAcumulado:= .F.
DEFAULT lRemito   := .F.
DEFAULT lTLVReg   := .F.
DEFAULT lAvCred   := .T.  // Variavel que controla analise de credito para o pedido.
DEFAULT lTdsSqLb  := .T.  // Considerar todas as sequencias de liberacao

If !xFilial("SC5")+(cAliasSC6)->C6_NUM==(cAliasSC5)->C5_FILIAL+(cAliasSC5)->C5_NUM .And.;
		!Empty((cAliasSC6)->C6_NUM)
	SC5->( DBSetOrder( 1 ) )
	SC5->( MsSeek(xFilial("SC5")+(cAliasSC6)->C6_NUM) )
EndIf

//Ŀ
// Inicializa a moeda do pedido                                           
//
DEFAULT nMoeda    := (cAliasSC5)->C5_MOEDA

cPedido  := (cAliasSC5)->C5_NUM
cItemPV  := (cAliasSC6)->C6_ITEM
cProduto := (cAliasSC6)->C6_PRODUTO
cTipoPV  := (cAliasSC5)->C5_TIPO
cTipLib  := (cAliasSC5)->C5_TIPLIB
dEmissao := (cAliasSC5)->C5_EMISSAO

Do Case
	//Ŀ
	//Implantacao de um item do pedido de venda                               
	//
Case nEvento == 1

	//Ŀ
	//Posiciona registros                                                     
	//
	If !cTipoPV$'DB'
		SA1->( DBSetOrder( 1 ) )
		SA1->( MsSeek(xFilial("SA1")+(cAliasSC5)->C5_CLIENTE+(cAliasSC5)->C5_LOJACLI,.F.) )
	EndIf
	SF4->( DBSetOrder( 1 ) )
	SF4->( MsSeek(xFilial("SF4")+(cAliasSC6)->C6_TES) )
	
	SB2->( DBSetOrder( 1 ) )
	
	If SB2->( !MsSeek(xFilial("SB2")+(cAliasSC6)->C6_PRODUTO+(cAliasSC6)->C6_LOCAL) )
		//Ŀ
		//Sempre criar o SB2 para otimizacao da Query do MATA461                  
		//
		CriaSB2((cAliasSC6)->C6_PRODUTO,(cAliasSC6)->C6_LOCAL)
	EndIf
	
	//Ŀ
	//Efetua travamento dos registros                                         
	//
	If lContinua .And. SF4->F4_DUPLIC=="S" .And. !cTipoPV$'DB'
		SA1->( DBSetOrder(1) )
		If ( lContinua := SA1->( MsSeek(xFilial("SA1")+(cAliasSC5)->C5_CLIENTE+(cAliasSC5)->C5_LOJACLI,.F.) ) )
			lTrvSA1 := IIf(cPaisLoc == "BRA" .And. lFATTRVSA1, ExecBlock("FATTRVSA1", .F., .F., {xFilial("SA1"), SA1->A1_COD, SA1->A1_LOJA}), .T.)
			If lTrvSA1
				lContinua := RecLock("SA1")
			EndIf
		EndIf
	EndIf
	
	If lContinua .And. SF4->F4_ESTOQUE=="S"
		lContinua := RecLock("SB2")
	EndIf
	//Ŀ
	//Avalia se existe regra de negocio ou bloqueio para verificar verba      
	//

	If !__lPyme
		
		cEstado := AllTrim(SuperGetMv("MV_ESTADO"))
		
		If !(FwIsInCallStack('A310Proc')) .And. (cAliasSC5)->C5_TIPO == 'N' .And. (ACN->(dbSeek(xFilial("ACN"))) .Or. cEstado == "AL")
			
			//Ŀ
			//Verifica verba de venda caso nao houve bloqueio de regra de negocio     
			//
			If !lAcumulado .Or. cEstado == "AL"
				nDescon   := (100 - ((cAliasSC6)->C6_PRCVEN / (cAliasSC6)->C6_PRUNIT) * 100 )  
				aProdDesc := {{(cAliasSC6)->C6_PRODUTO,(cAliasSC6)->C6_ITEM,(cAliasSC6)->C6_PRCVEN,(cAliasSC6)->C6_PRUNIT,nDescon,0,"",0,Empty((cAliasSC6)->C6_NFORI)}}

				//Ŀ
				//Avalia se Existe Bloqueio de Regra                                      
				//
				
				cFunName := Upper(FunName())
				
				If	cFunName<>"TMKA271" .And.;	//SIGATMK
					cFunName<>"TMSA200"			//SIGATMS
					If cEstado == "AL" //Legislao somente para alagoas
						lBlqReg := BlPVLFat((cAliasSC5)->C5_CLIENTE,(cAliasSC5)->C5_LOJACLI,(cAliasSC5)->C5_BLQ=="1")
					EndIf
					If !lBlqReg
						lBlqReg := !ACN->(FtRegraNeg((cAliasSC5)->C5_CLIENTE,(cAliasSC5)->C5_LOJACLI,(cAliasSC5)->C5_TABELA,(cAliasSC5)->C5_CONDPAG,,@aProdDesc, .F., nil, .F. ))
					EndIf
				EndIf
				If lBlqReg .Or. lTLVReg
					//Ŀ
					//Avalia se existe Bloqueio de Venda                                      
					//
					If aProdDesc[1,7] == "02"
						cRet := ACN->(FtVerbaVen(cAliasSC5,cAliasSC6,(cAliasSC5)->C5_CLIENTE,(cAliasSC5)->C5_LOJACLI,(cAliasSC5)->C5_VEND1,(cAliasSC6)->C6_PRODUTO, @aProdDesc[1],.T. ))
						If cRet <> "1"
							cRet := If(cRet == "3","1","2")
						Else
							cRet := "3"
						EndIf
					Else
						cRet := "1"
					EndIf
				Else
					cRet := "3"
				EndIf
				Do Case
					//Ŀ
					//Grava SC5 / SC6 bloqueados por Verba                                    
					//
					Case cRet == "2"
						RecLock("SC5", .F.)
						(cAliasSC5)->C5_BLQ := StrZero(2, Len(SC5->C5_BLQ))

						RecLock("SC6", .F.)
						(cAliasSC6)->C6_BLOQUEI :=  StrZero(2, Len(SC6->C6_BLOQUEI))
						//Ŀ
						//Grava SC5 / SC6 bloqueado por Regra                                     
						//
					Case cRet == "1"
						RecLock("SC5", .F.)
						(cAliasSC5)->C5_BLQ := StrZero(1, Len(SC5->C5_BLQ))

						RecLock("SC6", .F.)
						(cAliasSC6)->C6_BLOQUEI := StrZero(1, Len(SC6->C6_BLOQUEI))
					OtherWise
						RecLock("SC6", .F.)
						(cAliasSC6)->C6_BLOQUEI := Space(Len(SC6->C6_BLOQUEI))
				EndCase
			EndIf
		EndIf
	EndIf

	If lContinua
		//Ŀ
		// Complemento da atualizacao no item do pedido de venda                  
		//
		If !lAcumulado

			(cAliasSC6)->C6_FILIAL	:= xFilial("SC6")
			(cAliasSC6)->C6_NUM		:= (cAliasSC5)->C5_NUM
			(cAliasSC6)->C6_CLI		:= (cAliasSC5)->C5_CLIENTE
			(cAliasSC6)->C6_LOJA 	:= (cAliasSC5)->C5_LOJACLI
			//Ŀ
			//No grava C6_GERANF para pedido de vendas.
			//
			If cPaisLoc <> "BRA".And. Empty((cAliasSC6)->C6_GERANF)
				(cAliasSC6)->C6_GERANF := If((cAliasSC5)->C5_TIPOREM$"01A","S","N")
			EndIf
			//Ŀ
			// Atualiza as Tabela Auxiliares                                          
			//
			//Ŀ
			// Efetua amarracao com o projeto - SIGATEC                         
			//
			SC5->(FkCommit())
			SC6->(FkCommit())

			ABI->( dbSetOrder( 1 ) )
			If ABI->( MsSeek( xFilial( "ABI" ) + (cAliasSC6)->C6_PROJET + (cAliasSC6)->C6_ITPROJ ) )
				Reclock( "ABI", .F. )
				ABI->ABI_NUMPV  := (cAliasSC6)->C6_NUM
				ABI->ABI_ITEMPV := (cAliasSC6)->C6_ITEM
				ABI->( MsUnlock() )
			EndIf

			AB8->( DBSetOrder( 1 ) )
			If !Empty((cAliasSC6)->C6_NUMOS)
				If AB8->( MsSeek(xFilial("AB8")+(cAliasSC6)->C6_NUMOS) )
					RecLock("AB8")
					AB8->AB8_NUMPV := (cAliasSC5)->C5_NUM+SC6->C6_ITEM
					
					AB7->( DBSetOrder(1) )
					If AB7->( MsSeek(xFilial("AB7")+SubStr(SC6->C6_NUMOS,1,8)) )
						RecLock("AB7")
						AB7->AB7_TIPO := AtTipoAB7()
					EndIf
				EndIf
			EndIf
			If !Empty((cAliasSC6)->C6_NUMOSFA)
				If AB8->( MsSeek(xFilial("AB8")+(cAliasSC6)->C6_NUMOSFA ) )
					RecLock("AB8")
					AB8->AB8_NUMPVF := (cAliasSC5)->C5_NUM+SC6->C6_ITEM
					
					AB7->( DBSetOrder(1) )
					If AB7->( MsSeek(xFilial("AB7")+SubStr(SC6->C6_NUMOSFA,1,8)) )
						RecLock("AB7")
						AB7->AB7_TIPO := AtTipoAB7()
					EndIf
				EndIf
			EndIf
			//Ŀ
			// Atualiza o status da OS ( AB6 )                                  
			//
			If !Empty((cAliasSC6)->C6_NUMOS) .OR. !Empty((cAliasSC6)->C6_NUMOSFA)
				AB6->( DBSetOrder(1) )
				If AB6->( MsSeek(xFilial("AB6") + If( Empty( SubStr(SC6->C6_NUMOS,1,6) ),;
					SubStr(SC6->C6_NUMOSFA,1,6), SubStr(SC6->C6_NUMOS,1,6) ) ) )
					RecLock("AB6")
					AB6->AB6_STATUS := AtOsStatus( AB6->AB6_NUMOS )
				EndIf
			EndIf
			//Ŀ
			// Atualiza Contratos de Parceria                                         
			//
			If !Empty(SC6->C6_CONTRAT) .And. !Empty(SC6->C6_ITEMCON)
		
				ADB->( DBSetOrder(1) )
				If ADB->( MsSeek(xFilial("ADB")+SC6->C6_CONTRAT+SC6->C6_ITEMCON) )

					//Ŀ
					//Tratamento especifico - SIGAAGR(UBS)               	
					//
					If AliasInDic("NPN")
						NPN->(dbSetOrder(3))
						lContinua := !IsIncallStack("AGRA900") .And. !NPN->(dbSeek(xFilial("NPN")+SC6->(C6_NUM+C6_ITEM)))
					EndIf

					If lContinua
						RecLock("ADB")
						If Empty(ADB->ADB_PEDCOB) .And. SC6->C6_TES==ADB->ADB_TESCOB
							ADB->ADB_PEDCOB := SC6->C6_NUM
						Else
							ADB->ADB_QTDEMP += SC6->C6_QTDVEN
							If ADB->ADB_QTDEMP > ADB->ADB_QUANT
								ADB->ADB_QTDEMP -= SC6->C6_QTDVEN
								(cAliasSC6)->C6_CONTRAT := ""
								(cAliasSC6)->C6_ITEMCON := ""
							EndIf
						EndIf
						MsUnLock()
						
						ADA->( DBSetOrder(1) )
						If ADA->( MsSeek(xFilial("ADA")+SC6->C6_CONTRAT) )
							Ft400StatCt()
						EndIf
					Else
						lContinua := .T.
					EndIf
				EndIf
			EndIf
		EndIf
		
		//Ŀ
		// Atualiza os Saldos Fisicos e Financeiros - SB2                         
		//
		If !("S" $ (cAliasSC6)->C6_BLQ .Or. "R" $ (cAliasSC6)->C6_BLQ) //Se nao Bloqueado
			If SF4->F4_ESTOQUE == "S"
				//Ŀ
				//Verificar se o material com lote deve ser reservado mesmo que nao haja  
				//liberacao de pedido, a fim de garantir o lote na data do faturamento    
				//
				If !lAcumulado

					If !Empty((cAliasSC6)->C6_RESERVA)
						//Ŀ
						//Se a reserva estiver preenchida, verificar se e valida                  
						//
						SC0->( dbSetOrder( 1 ) )
						If !SC0->( MsSeek( xFilial( "SC0" ) + (cAliasSC6)->C6_RESERVA + (cAliasSC6)->C6_PRODUTO) )
							(cAliasSC6)->C6_RESERVA := ""
							(cAliasSC6)->C6_QTDRESE := 0
						EndIf
					EndIf

					If lResAut .And. Empty((cAliasSC6)->C6_RESERVA) .And. Rastro((cAliasSC6)->C6_PRODUTO) .And. ;
						( (cAliasSC6)->C6_QTDVEN - (cAliasSC6)->C6_QTDEMP - (cAliasSC6)->C6_QTDENT > 0 )

						If !Empty((cAliasSC6)->C6_NUMLOTE) .Or. !Empty((cAliasSC6)->C6_LOTECTL)
							cReserva := CriaVar("C0_NUM")

							//Ŀ
							//Verifica se a reserva sera feita pelo total da quantidade vendida
							//ou pelo saldo do lote.                                           
							//
							If lTipRes
								nSaldo := (cAliasSC6)->C6_QTDVEN
							Else
								nSaldo   := SldAtuEst((cAliasSC6)->C6_PRODUTO,;
									(cAliasSC6)->C6_LOCAL,;
									(cAliasSC6)->C6_QTDVEN,;
									(cAliasSC6)->C6_LOTECTL,;
									(cAliasSC6)->C6_NUMLOTE,;
									(cAliasSC6)->C6_LOCALIZ,;
									(cAliasSC6)->C6_NUMSERI,;
									(cAliasSC6)->C6_RESERVA,;
									SF4->F4_PODER3<>"N" .Or. !Empty(SF4->F4_TESP3),;
									,;
									(cAliasSC6)->C6_PROJPMS,;
									(cAliasSC6)->C6_TASKPMS,;
									(cAliasSC6)->C6_SERVIC)
							Endif

							If Empty(cReserva)
								cReserva := NextNumero("SC0",1,"C0_NUM",.T.)
							Else
								While ( GetSX8Len() > nSaveSX8 )
									ConfirmSx8()
								EndDo
							EndIf
							If a430Reserva({1,"VD",(cAliasSC6)->C6_NUM,"",cFilAnt},cReserva,;
									(cAliasSC6)->C6_PRODUTO,;
									(cAliasSC6)->C6_LOCAL,;
									nSaldo,;
									{(cAliasSC6)->C6_NUMLOTE,(cAliasSC6)->C6_LOTECTL,(cAliasSC6)->C6_LOCALIZ,(cAliasSC6)->C6_NUMSERI})

								(cAliasSC6)->C6_RESERVA := cReserva

							EndIf
						EndIf
					EndIf
				EndIf
				//Ŀ
				//Atualiza previsoes de saida de material                                 
				//
				nSldPed := Max((cAliasSC6)->C6_QTDVEN-(cAliasSC6)->C6_QTDENT-(cAliasSC6)->C6_QTDEMP,0)
				nSldPed2:= SB1->(ConvUm(SB2->B2_COD,nSldPed,nSldPed2,2))
				FatAtuEmpN("+")
				RecLock("SB2")
				SB2->B2_QPEDVEN += nSldPed
				SB2->B2_QPEDVE2 += nSldPed2
				
				//atualizao de campos usados na mensagem de atualizao de estoque
				If lExtB2DMOV
					SB2->B2_DMOV := dDataBase
				EndIf
			
				If lExtB2HMOV
					SB2->B2_HMOV := Time() 
				EndIf							
				
				//Ŀ
				// Tratamento para Reserva de material                  
				//
				If !lAcumulado
					If !Empty((cAliasSC6)->C6_RESERVA)
						If !cTipoPV$"CIP"
						
							SC0->( DBSetOrder(1) )
							If SC0->( MsSeek(xFilial("SC0")+(cAliasSC6)->C6_RESERVA+(cAliasSC6)->C6_PRODUTO+(cAliasSC6)->C6_LOCAL) )
								If !((cAliasSC6)->C6_NUMLOTE<>SC0->C0_NUMLOTE   .Or.;
									(cAliasSC6)->C6_LOTECTL<>SC0->C0_LOTECTL  .Or.;
									(cAliasSC6)->C6_LOCALIZ<>SC0->C0_LOCALIZ  .Or.;
									(cAliasSC6)->C6_NUMSERI<>SC0->C0_NUMSERI )
									RecLock("SC0")
									nQtdRese := Min(SC0->C0_QUANT,(cAliasSC6)->C6_QTDVEN)
									SC0->C0_QUANT  -= nQtdRese
									SC0->C0_TIPO   := "PD"
									SC0->C0_QTDPED += nQtdRese
								EndIf
							Endif
							//Ŀ
							// Atualiza o campo de qtd.reservada do Pedido de Venda 
							//
							(cAliasSC6)->C6_QTDRESE += nQtdRese
							//Ŀ
							//Nao deve atualizar a Quantidade em Pedido de Venda quando houver Reserva
							//pois neste caso o estoque ja esta liberado.                             
							//
							SB2->B2_QPEDVEN -= nQtdRese
							SB2->B2_QPEDVE2 -= ConvUM(SB2->B2_COD,nQtdRese,0,2)
							
							//atualizao de campos usados na mensagem de atualizao de estoque
							If lExtB2DMOV
								SB2->B2_DMOV := dDataBase
							EndIf
						
							If lExtB2HMOV
								SB2->B2_HMOV := Time() 
							EndIf							
							
						Else
							(cAliasSC6)->C6_RESERVA := ""
						EndIf
					Else
						(cAliasSC6)->C6_RESERVA := ""
					EndIf
				Else
					SB2->B2_QPEDVEN -= (cAliasSC6)->C6_QTDRESE
					SB2->B2_QPEDVE2 -= ConvUM(SB2->B2_COD,(cAliasSC6)->C6_QTDRESE,0,2)
					
					//atualizao de campos usados na mensagem de atualizao de estoque
					If lExtB2DMOV
						SB2->B2_DMOV := dDataBase
					EndIf
				
					If lExtB2HMOV
						SB2->B2_HMOV := Time() 
					EndIf									
					
				EndIf
			EndIf
		EndIf
		//Ŀ
		//Atualiza o Saldo de Pedidos - SA1                                       
		//
		If SF4->F4_DUPLIC == "S" .And. !cTipoPV$"DB"
			nSldPed := Max((cAliasSC6)->C6_QTDVEN-(cAliasSC6)->C6_QTDENT-(cAliasSC6)->C6_QTDEMP,0)
			If nSldPed > 0 .And. !AllTrim((cAliasSC6)->C6_BLQ)$"RS"
				nMCusto :=  If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC, Val(SuperGetMv("MV_MCUSTO")))
				If lTrvSA1
					SA1->A1_SALPED += xMoeda(nSldPed*(cAliasSC6)->C6_PRCVEN,nMoeda,nMCusto,dEmissao)
				EndIf
			EndIf
		EndIf
		If !lAcumulado .And. !("S" $ (cAliasSC6)->C6_BLQ .Or. "R" $ (cAliasSC6)->C6_BLQ)
			//Ŀ
			//Verifica a necessidade de Liberacao do Item                             
			//
			SC5->(FkCommit())
			SC6->(FkCommit())
			MaAvalSC6(cAliasSC6,3,cAliasSC5,lLiber,lTransf,Nil,Nil,Nil,Nil,@nVlrCred,,,,,lAvCred)
		EndIf
	EndIf
	//Ŀ
	//Verificacao dos acumulados do SC5                                       
	//
	If ( SC6->C6_QTDVEN > (SC6->C6_QTDEMP+SC6->C6_QTDENT) .And. AllTrim(SC6->C6_BLQ)<>"R")
		lLiberOk := .F.
	EndIf
	If (! "R" $ SC6->C6_BLQ )
		lResidOk := .F.
	EndIf
	If ( SC6->C6_QTDVEN > SC6->C6_QTDENT .And. AllTrim(SC6->C6_BLQ)<>"R" ) .Or. ( SF4->F4_QTDZERO=="1" .And. !lAcumulado )
		lFaturOk := .T.
	EndIf
	If !lAcumulado
		//Ŀ
		// Grava os lancamentos nas contas orcamentarias SIGAPCO    
		//
		PcoDetLan("000100","01","MATA410")
	EndIf
	SC5->(FkCommit())
	SC6->(FkCommit())
	SC9->(FkCommit())
	//Ŀ
	//Estorno de um item do pedido de venda                                   
	//
Case nEvento == 2

	If !__lPyme

		If !Empty(ACM->(LastRec()))

			//Ŀ
			//Busca movimentacao das verbas                                           
			//
			cQuery := "SELECT ACM_OPERA, ACM.R_E_C_N_O_ RECACM, ACL.R_E_C_N_O_ RECACL FROM "
			cQuery += RetSqlName("ACM")+ " ACM, "
			cQuery += RetSqlName("ACL")+ " ACL  "
			cQuery += " WHERE "
			cQuery += "ACM_FILIAL = '"+xFilial("ACM")+"' AND "
			cQuery += "ACM_NUMPED = '"+(cAliasSC6)->C6_NUM+"' AND "
			cQuery += "ACM_ITEPED = '"+(cAliasSC6)->C6_ITEM+"' AND "
			cQuery += "ACM.D_E_L_E_T_ = ' ' AND "
			cQuery += "ACL_FILIAL = '"+xFilial("ACL")+"' AND "
			cQuery += "((ACL_CODPRO = '"+cProduto+"' AND ACL_CODVER = ACM_CODVER ) OR "
			cQuery += "(ACL_CODPRO = '"+Space(Len(SB1->B1_COD))+"' AND ACL_CODVER = ACM_CODVER )) AND "
			cQuery += "ACL.D_E_L_E_T_ = ' ' "

			cQuery := ChangeQuery(cQuery)

			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"QRYACL",.T.,.T.)

			While QRYACL->(!Eof())

				ACL->(MsGoto(QRYACL->RECACL))
				ACM->(MsGoto(QRYACL->RECACM))

				Do Case

					Case QRYACL->ACM_OPERA == "D"
						RecLock("ACL",.F.)
							ACL->ACL_SALDO += ACM->ACM_VALOR
						MsUnlock()
					Case QRYACL->ACM_OPERA == "C"
						RecLock("ACL",.F.)
							ACL->ACL_SALDO -= ACM->ACM_VALOR
						MsUnlock()
				EndCase

				RecLock("ACM",.F.)
					dbDelete()
				MsUnlock()

				QRYACL->(dbSkip())

			EndDo

			(cAliasSC6)->C6_BLOQUEI := Space(Len(SC6->C6_BLOQUEI))

			QRYACL->( DbCloseArea() )
			DbSelectArea("SC6")

		EndIf
	Endif


	If !cTipoPV$'DB'
		SA1->( DBSetOrder(1) )
		SA1->( MsSeek(xFilial("SA1")+(cAliasSC6)->C6_CLI+(cAliasSC6)->C6_LOJA,.F.) )
	EndIf
	
	SF4->( DBSetOrder(1) )
	SF4->( MsSeek(xFilial("SF4")+(cAliasSC6)->C6_TES) )

	SB2->( DBSetOrder(1) )
	If SB2->( !MsSeek(xFilial("SB2")+(cAliasSC6)->C6_PRODUTO+(cAliasSC6)->C6_LOCAL) )
		//Ŀ
		//Sempre criar o SB2 para otimizacao da Query do MATA461                  
		//
		CriaSB2((cAliasSC6)->C6_PRODUTO,(cAliasSC6)->C6_LOCAL )
	EndIf
	If lTdsSqLb
		//Ŀ
		//Verifica a necessidade de estorno da liberacao                          
		//
		MaAvalSC6(cAliasSC6,4,cAliasSC5,lLiber,Nil,Nil,Nil,Nil,Nil,@nVlrCred)
	EndIf
	//Ŀ
	//Efetua travamento dos registros                                         
	//
	If lContinua .And. SF4->F4_DUPLIC=="S" .And. !cTipoPV$'DB'
		lTrvSA1 := IIf(cPaisLoc == "BRA" .And. lFATTRVSA1, ExecBlock("FATTRVSA1", .F., .F., {xFilial("SA1"), SA1->A1_COD, SA1->A1_LOJA}), .T.)
		If lTrvSA1
			lContinua := RecLock("SA1")
		EndIf
	EndIf
	If lContinua .And. SF4->F4_ESTOQUE=="S"
		lContinua := RecLock("SB2")
	EndIf
	//Ŀ
	// Estorna as Tabela Auxiliares                                           
	//
	If lContinua
		//Ŀ
		//Estorna o Saldo de Pedidos - SA1                                        
		//
		If ( SF4->F4_DUPLIC=="S" .And. !cTipoPV$"DB" )
			SA1->( DBSetOrder(1) )
			If SA1->( MsSeek(xFilial("SA1")+(cAliasSC6)->C6_CLI+(cAliasSC6)->C6_LOJA,.F.) )
				nSldPed := Max((cAliasSC6)->C6_QTDVEN-(cAliasSC6)->C6_QTDENT-(cAliasSC6)->C6_QTDEMP,0)
				If ( nSldPed > 0 .And. !AllTrim((cAliasSC6)->C6_BLQ)$"RS" )
					nMCusto :=  If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC, Val(SuperGetMv("MV_MCUSTO")))
					If lTrvSA1
						SA1->A1_SALPED -= xMoeda(nSldPed*(cAliasSC6)->C6_PRCVEN,nMoeda,nMCusto,dEmissao)
					EndIf
				EndIf
			EndIf
		EndIf
		//Ŀ
		// Atualiza os Saldos Fisicos e Financeiros - SB2                         
		//
		If !("S"$(cAliasSC6)->C6_BLQ .Or. "R"$(cAliasSC6)->C6_BLQ)
			If SF4->F4_ESTOQUE == "S"
				//Ŀ
				// Tratamento para Reserva de material                  
				//
				If !Empty((cAliasSC6)->C6_RESERVA)

					SC0->( dbSetOrder(1) )
					If SC0->( MsSeek(xFilial("SC0")+(cAliasSC6)->C6_RESERVA+(cAliasSC6)->C6_PRODUTO+(cAliasSC6)->C6_LOCAL) )
						RecLock("SC0")
						SC0->C0_TIPO   := If(SC0->C0_QTDPED==0,"VD","PD")
						SC0->C0_QUANT  += SC6->C6_QTDRESE
						SC0->C0_QTDPED -= SC6->C6_QTDRESE
					EndIf

					SB2->B2_QPEDVEN += (cAliasSC6)->C6_QTDRESE

					//atualizao de campos usados na mensagem de atualizao de estoque
					If lExtB2DMOV
						SB2->B2_DMOV := dDataBase
					EndIf
				
					If lExtB2HMOV
						SB2->B2_HMOV := Time() 
					EndIf							

					(cAliasSC6)->C6_QTDRESE := 0
					If SuperGetMv("MV_DELRES")
						(cAliasSC6)->C6_RESERVA := ""
						a430Reserva({3,SC0->C0_TIPO,SC0->C0_DOCRES,SC0->C0_SOLICIT,SC0->C0_FILRES},;
							SC0->C0_NUM,;
							SC0->C0_PRODUTO,;
							SC0->C0_LOCAL,;
							SC0->C0_QUANT,;
							{SC0->C0_NUMLOTE,;
							SC0->C0_LOTECTL,;
							SC0->C0_LOCALIZ,;
							SC0->C0_NUMSERI})
					EndIf
				EndIf

				//Ŀ
				//Atualiza previsoes de saida de material                                 
				//
				nSldPed := Max((cAliasSC6)->C6_QTDVEN-(cAliasSC6)->C6_QTDENT-(cAliasSC6)->C6_QTDEMP,0)
				nSldPed2:= SB1->(ConvUm(SB2->B2_COD,nSldPed,nSldPed2,2))

				FatAtuEmpN("-")
				RecLock("SB2")
				SB2->B2_QPEDVEN -= nSldPed
				SB2->B2_QPEDVE2 -= nSldPed2

			EndIf
		EndIf
	EndIf
	//Ŀ
	// Atualiza Contratos de Parceria                                         
	//
	If !Empty(SC6->C6_CONTRAT) .And. !Empty(SC6->C6_ITEMCON)
		ADB->( DBSetOrder(1) )
		If ADB->( MsSeek(xFilial("ADB")+SC6->C6_CONTRAT+SC6->C6_ITEMCON) )
			//Ŀ
			//Tratamento especifico - SIGAAGR(UBS)               	
			//
			If AliasInDic("NPN")
				NPN->(dbSetOrder(3))
				lContinua := !IsIncallStack("AGRA900") .And. !NPN->(dbSeek(xFilial("NPN")+SC6->(C6_NUM+C6_ITEM)))
			EndIf

			If lContinua
				RecLock("ADB")
				If !Empty(ADB->ADB_PEDCOB) .And. SC6->C6_NUM==ADB->ADB_PEDCOB
					ADB->ADB_PEDCOB := ""
				Else
					ADB->ADB_QTDEMP -= SC6->C6_QTDVEN
				EndIf
				MsUnLock()
			
				ADA->( dbSetOrder(1) )
				If ADA->( MsSeek(xFilial("ADA")+SC6->C6_CONTRAT) )
					Ft400StatCt()
				EndIf
			EndIf
		EndIf
	EndIf
	//Ŀ
	// Estorna amarracao com a Ordem de Servico - SIGATEC               
	//
	If ( !Empty((cAliasSC6)->C6_NUMOS) .Or. !Empty((cAliasSC6)->C6_NUMOSFA) )
		lTipoAb7 := .T.
		
		cFilAB8 := xFilial("AB8")
		
		AB8->( DBSetOrder(1) )
		If ( AB8->( MsSeek(cFilAB8+SC6->C6_NUMOSFA) ) .And. !Empty(SC6->C6_NUMOSFA))
			RecLock("AB8")
			AB8->AB8_NUMPVF := ""
		EndIf
		If ( AB8->( MsSeek(cFilAB8+SC6->C6_NUMOS) ) .And. !Empty(SC6->C6_NUMOS))
			RecLock("AB8")
			AB8->AB8_NUMPV := ""
		EndIf
		If AB8->( MsSeek(cFilAB8+SubStr(SC6->C6_NUMOS,1,8)) )
			While ( AB8->( !Eof() ) .And. cFilAB8 == AB8->AB8_FILIAL .And.;
					AB8->AB8_NUMOS+AB8->AB8_ITEM == SubStr(SC6->C6_NUMOS,1,8) )
				If ( !Empty(AB8->AB8_NUMPV) .Or. !Empty(AB8->AB8_NUMPVF) )
					lTipoAb7 := .F.
				EndIf
				AB8->( DBSkip() )
			EndDo
		EndIf
		If ( lTipoAb7 )
			
			AB7->( DBSetOrder(1) )

			If !Empty( SubStr(SC6->C6_NUMOS,1,8))
				If AB7->( MsSeek(xFilial("AB7")+SubStr(SC6->C6_NUMOS,1,8)) )
					RecLock("AB7")
					AB7->AB7_TIPO := AtTipoAB7()
				EndIf
			EndIf

			If !Empty( SubStr(SC6->C6_NUMOSFA,1,8))
				If AB7->( MsSeek(xFilial("AB7")+SubStr(SC6->C6_NUMOSFA,1,8)) )
					RecLock("AB7")
					AB7->AB7_TIPO := AtTipoAB7()
				EndIf
			EndIf
			If !Empty((cAliasSC6)->C6_NUMOS) .OR. !Empty((cAliasSC6)->C6_NUMOSFA)
				//Ŀ
				// Atualiza o status da OS ( AB6 )                                  
				//
				AB6->( DBSetOrder(1) )
				If AB6-> ( MsSeek(xFilial("AB6") + If( Empty( SubStr(SC6->C6_NUMOS,1,6) ),;
						SubStr(SC6->C6_NUMOSFA,1,6), SubStr(SC6->C6_NUMOS,1,6) ) ) )
					RecLock("AB6")
					AB6->AB6_STATUS := AtOsStatus( AB6->AB6_NUMOS )
				EndIf
			EndIf
		EndIf
	EndIf
	//Ŀ
	// Estorna amarracao com o projeto - SIGATEC                        
	//
	ABI->( dbSetOrder( 3 ) )
	If ABI->( MsSeek( xFilial( "ABI" ) + (cAliasSC6)->C6_NUM + (cAliasSC6)->C6_ITEM ) )
		Reclock( "ABI", .F. )
		ABI->ABI_NUMPV  := Space( Len( ABI->ABI_NUMPV ) )
		ABI->ABI_ITEMPV := Space( Len( ABI->ABI_ITEMPV ) )
		ABI->( MsUnlock() )
	EndIf

	//Ŀ
	//Liberacao de um item do pedido de venda                                 
	//
Case nEvento == 3
	nQtdLib  := (cAliasSC6)->C6_QTDLIB
	nQtdLib2 := If( Empty( (cAliasSC6)->C6_QTDLIB2 ), Nil, (cAliasSC6)->C6_QTDLIB2 )
	If nQtdLib > 0 .Or. IIf(cPaisLoc == "BRA",; 
		(cTipoPV$"IP" .Or. (cTipoPV$"C" .And. (cAliasSC5)->C5_TPCOMPL == "1")),;
		 cTipoPV$"CIP") .Or.  MaTesSel((cAliasSC6)->C6_TES)
		If cTipLib<>"2"
			MaLibDoFat(0,@nQtdLib,@lCredito,@lEstoque,lAvCred,.T.,lLiber,lTransf,Nil,Nil,Nil,Nil,Nil,@nVlrCred,@nQtdLib2)
		EndIf
	EndIf

	//Ŀ
	//Estorno de um item do pedido de venda                                   
	//
Case nEvento == 4
	//Ŀ
	//Estornar as liberacoes efetuadas desde que nao possuam NFS              
	//
	cFilSC9 := xFilial("SC9")
	SC9->( DBSetOrder(1) )
	If ( SC9->( MsSeek(cFilSC9+cPedido+cItemPV) ) )
		While SC9->( !Eof() ) .And. cFilSC9==SC9->C9_FILIAL .And.;
				cPedido==SC9->C9_PEDIDO .And.;
				cItemPv==SC9->C9_ITEM
			If cProduto==SC9->C9_PRODUTO
				If SC9->C9_BLCRED <> "ZZ" .And. SC9->C9_BLEST <> "ZZ" .And. SC9->C9_BLCRED <> "10" .And. SC9->C9_BLEST <> "10" .And. Empty(SC9->C9_REMITO)
					//Ŀ
					//Efetua o estorno das movimentacoes internas                        
					//
					MaTrfLocal((cAliasSC6)->C6_PRODUTO, , , ,(cAliasSC6)->C6_NUM,.T.,@CSeq)
					//Ŀ
					//Efetua o estorno do itens de pedido de venda liberados             
					//
					SC9->(a460Estorna(.T.,,@nVlrCred,cTipLib))
				EndIf
			EndIf
		
			SC9->( DBSkip() )
		EndDo
		//Ŀ
		// PCO - Estorna os lancamentos de liberacao das contas orcamentarias 
		//
		PcoDetLan("000103","01","MATA440",.T.)
	EndIf
	//Ŀ
	//Preparacao da Nota Fiscal de Saida                                      
	//
Case nEvento == 5
	If lAcumulado
		RecLock("SC6",.F.)
	EndIf
	If lRemito .Or. Empty( (cAliasSD2)->D2_REMITO )
		(cAliasSC6)->C6_QTDENT  += (cAliasSD2)->D2_QUANT
		(cAliasSC6)->C6_QTDENT2 += (cAliasSD2)->D2_QTSEGUM
		If !lAcumulado
			(cAliasSC6)->C6_QTDEMP  -= (cAliasSD2)->D2_QUANT
			(cAliasSC6)->C6_QTDEMP2 := Max( (cAliasSC6)->C6_QTDEMP2 - (cAliasSD2)->D2_QTSEGUM, 0 )
		EndIf
	Endif
	If !lRemito
		(cAliasSC6)->C6_NOTA   := (cAliasSD2)->D2_DOC
		(cAliasSC6)->C6_SERIE  := (cAliasSD2)->D2_SERIE
		(cAliasSC6)->C6_DATFAT := (cAliasSD2)->D2_EMISSAO
		If (cAliasSC6)->C6_QTDRESE == 0
			(cAliasSC6)->C6_RESERVA := ""
		EndIf

		//------------------------------------------------------------------------------
		// Se o Pedido de Venda foi gerado por uma Programao de Entrega (MATA412),
		// grava o nmero do Documento de Sada no item da Programao
		//------------------------------------------------------------------------------
		
		
		SD0->(DbSetOrder(3))	//D0_FILIAL + D0_PEDIDO + D0_CLIENTE + D0_LOJA
		If ( SD0->( MsSeek( xFilial("SD0") + (cAliasSC6)->C6_NUM ) ) )

			lProgEnt := .T.

			SDX->(DbSetOrder(1))	//DX_FILIAL + DX_NUMENT + DX_ITEM + DX_PRODUTO
			If ( SDX->( MsSeek( xFilial("SDX") + SD0->D0_NUMENT + AllTrim((cAliasSC6)->C6_ITEM) + (cAliasSC6)->C6_PRODUTO ) ) )
				RecLock( "SDX", .F. )
				SDX->DX_NOTA := (cAliasSD2)->D2_DOC
			EndIf

		EndIf
		
	Else
		(cAliasSC6)->C6_NOTA   := "REMITO"
		(cAliasSC6)->C6_SERIE  := (cAliasSD2)->D2_SERIE
	Endif
	If lAcumulado
		MsUnLock()
	EndIf
	//Ŀ
	//Estorno da Nota fiscal de Saida                                         
	//
Case nEvento == 6
	//Ŀ
	//Posiciona registros                                                     
	//
	If !cTipoPV $ 'DB'
		If !xFilial("SA1")+(cAliasSC6)->C6_CLI+(cAliasSC6)->C6_LOJA ==;
				SA1->A1_FILIAL+SA1->A1_COD+SA1->A1_LOJA
			
			SA1->( DBSetOrder(1) )
			SA1->( MsSeek(xFilial("SA1")+(cAliasSC6)->C6_CLI+(cAliasSC6)->C6_LOJA) )
		EndIf
		lTrvSA1 := IIf(cPaisLoc == "BRA" .And. lFATTRVSA1, ExecBlock("FATTRVSA1", .F., .F., {xFilial("SA1"), SA1->A1_COD, SA1->A1_LOJA}), .T.)
		If lTrvSA1
			lContinua := RecLock("SA1")
		EndIf
	EndIf
	If !(xFilial("SC5")==SC5->C5_FILIAL .And.;
			SC5->C5_NUM==(cAliasSC6)->C6_NUM)
		
		SC5->( DBSetOrder(1) )
		SC5->( MsSeek(xFilial("SC5")+(cAliasSC6)->C6_NUM) )
	EndIf
	If !xFilial("SF4")+SC6->C6_TES == SF4->F4_FILIAL+SF4->F4_CODIGO
		SF4->( dbSetOrder(1) )
		SF4->( MsSeek(xFilial("SF4")+SC6->C6_TES) )
	EndIf
	
	SB2->( dbSetOrder(1) )
	If SB2->( !MsSeek(xFilial("SB2")+(cAliasSC6)->C6_PRODUTO+(cAliasSC6)->C6_LOCAL) )
		//Ŀ
		//Sempre criar o SB2 para otimizacao da Query do MATA461                  
		//
		CriaSB2((cAliasSC6)->C6_PRODUTO,(cAliasSC6)->C6_LOCAL )
	EndIf
	If lContinua
		(cAliasSC6)->C6_NOTA  := ""
		(cAliasSC6)->C6_SERIE := ""
		If "R" $ (cAliasSC6)->C6_BLQ
			MaAvalSC6(cAliasSC6,2,cAliasSC5,lLiber,lTransf,lLiberOk,lResidOk,lFaturOk,lAcumulado,@nVlrCred,cAliasSD2,lRemito,nMoeda)
			(cAliasSC6)->C6_BLQ := ""
			MaAvalSC6(cAliasSC6,1,cAliasSC5,lLiber,lTransf,lLiberOk,lResidOk,lFaturOk,lAcumulado,@nVlrCred,cAliasSD2,lRemito,nMoeda)
		EndIf
		If lRemito .Or. Empty( SD2->D2_REMITO )
			(cAliasSC6)->C6_QTDENT  -= SD2->D2_QUANT
			(cAliasSC6)->C6_QTDENT2 := Max( (cAliasSC6)->C6_QTDENT2 - SD2->D2_QTSEGUM, 0 )
		Else
			If !Empty(SD2->D2_REMITO)
				(cAliasSC6)->C6_NOTA  := "REMITO"
				(cAliasSC6)->C6_SERIE := SD2->D2_SERIREM
			Endif
		EndIf
		If (cAliasSC6)->C6_QTDENT == 0 .Or. !lRemito
			(cAliasSC6)->C6_DATFAT := Ctod("")
		EndIf
		If ( SF4->F4_DUPLIC == "S" .And. !SC5->C5_TIPO$"DB" .And. !AllTrim((cAliasSC6)->C6_BLQ)$"RS" ) .And. (!lRemito .And. Empty(SD2->D2_REMITO))
			nMCusto :=  If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC, Val(SuperGetMv("MV_MCUSTO")))
			nSldPed := SD2->D2_QUANT
			nSldPed := If(nSldPed>(SC6->C6_QTDVEN-SC6->C6_QTDEMP+nSldPed-SC6->C6_QTDENT),SC6->C6_QTDVEN-SC6->C6_QTDEMP+nSldPed-SC6->C6_QTDENT,nSldPed)
			If lTrvSA1
				SA1->A1_SALPED += xMoeda(nSldPed*(cAliasSC6)->C6_PRCVEN,SC5->C5_MOEDA,nMCusto,SC5->C5_EMISSAO)
			EndIf
		EndIf
		If ( SF4->F4_ESTOQUE == "S" ) .And. ( lRemito .Or. Empty( SD2->D2_REMITO ) ) .And. !AllTrim((cAliasSC6)->C6_BLQ)$"RS"

			//Ŀ
			//Atualiza previsoes de saida de material                                 
			//
			nSldPed := Max((cAliasSC6)->C6_QTDVEN-((cAliasSC6)->C6_QTDENT+SD2->D2_QUANT)-(cAliasSC6)->C6_QTDEMP,0)
			nSldPed := Max((cAliasSC6)->C6_QTDVEN-(cAliasSC6)->C6_QTDENT-(cAliasSC6)->C6_QTDEMP,0)-nSldPed

			nSldPed2:= SB1->(ConvUm(SB2->B2_COD,nSldPed,nSldPed2,2))

			//Ŀ
			//                Notas sobre o campo C6_OP                               
			// 01 - OP Gerada pelo MATA650                                            
			// 02 - Liberacao de PV bloqueada ( Sem OP )                              
			// 03 - Liberacao de PV bloqueada ( Item 01 )                             
			// 04 - Bloqueio de credito pelo MATA650                                  
			// 05 - OP nao gerada pois ha qtde em Estoque                             
			// 06 - Liberacao de PV liberada  ( Item 05 )                             
			// 07 - Liberacao de credito efetuada / Estoque pendente/bloqueada        
			// 08 - Liberacao de estoque efetuada ( item 01 )                         
			//
			If SC6->C6_QTDVEN-SC6->C6_QTDEMP-SC6->C6_QTDENT > 0
				Do Case
					Case SC6->C6_OP == "02"
						SC6->C6_OP     := ""
					Case SC6->C6_OP == "08"
						SC6->C6_OP     := "01"
					Case SC6->C6_OP == "06"
						SC6->C6_OP     := "05"
				EndCase
			EndIf

			//Se no for ecommerce ciaShop ou ecommerce sem reserva, volta saldo para quantidade de pedido
			If  (!SC5->(ColumnPos("C5_PEDECOM")) > 0 .OR. Empty(SC5->C5_PEDECOM))  .OR. !lECCiaRes
				RecLock("SB2")
				SB2->B2_QPEDVEN += nSldPed
				SB2->B2_QPEDVE2 += nSldPed2
				
				//atualizao de campos usados na mensagem de atualizao de estoque
				If lExtB2DMOV
					SB2->B2_DMOV := dDataBase
				EndIf
			
				If lExtB2HMOV
					SB2->B2_HMOV := Time() 
				EndIf							
	
			EndIf

		EndIf
	EndIf

	//------------------------------------------------------------------------
	// Tratativa para reconhecer se o pedido gerado foi criado pela rotina de 
	// Programao de Entrega (MATA412) para realizar o estorno corretamente
	// dos itens do pedido e atualizar o campo D0_STATUS.
	//------------------------------------------------------------------------
	If !lRemito
		SD0->(DbSetOrder(3))//D0_FILIAL + D0_PEDIDO + D0_CLIENTE + D0_LOJA
		If ( SD0->( MsSeek( xFilial("SD0") + (cAliasSC6)->C6_NUM ) ) ) //Busca movimentacao na tabela de Programacao de Entrega (Cabecalho).
		
			If (cAliasSC6)->C6_QTDENT == 0 //Caso houver o estorno total dos itens do pedido de venda, realiza a tratativa abaixo.

				SDX->(DbSetOrder(1))//DX_FILIAL + DX_NUMENT + DX_ITEM + DX_PRODUTO
				If ( SDX->( MsSeek( xFilial("SDX") + SD0->D0_NUMENT + AllTrim((cAliasSC6)->C6_ITEM) + (cAliasSC6)->C6_PRODUTO) ) ) //Busca movimentacao na tabela de itens Programacao de Entrega.

					//Limpa o campo Nota Fiscal do item do pedido na Programacao de Entrega, pois ja foi realizado o estorno total dos itens do pedido de venda.
					RecLock( "SDX", .F. )
						SDX->DX_NOTA := ""
					SDX->(MsUnlock())

					If ( SDX->( MsSeek( xFilial("SDX") + SD0->D0_NUMENT ) ) ) //Busca todas as movimentacoes da tabela de itens da Programacao de Entrega atraves do numero do Pedido

						While SDX->( !Eof() ) .AND. SD0->D0_FILIAL + SD0->D0_NUMENT == xFilial() + SDX->DX_NUMENT 

							If !Empty(SDX->DX_NOTA)//Caso ainda houver pedido de venda com o campo Nota Fiscal preenchido, atualiza o status da Programacao de entrega atravs da funo Ma412Stat().
								lProgEnt := .T.
							EndIf

							SDX->( DBSkip() )

						EndDo
					EndIf
				EndIf

				If !lProgEnt //Atualiza o status da Programacao de Entrega para Pedido Gerado, caso nao houver mais pedido faturado.
					
					RecLock( "SD0", .F. )
						SD0->D0_STATUS := "01" 
					SD0->(MsUnlock())

				EndIf
			Else
				lProgEnt := .T.
			EndIf
		EndIf
	EndIf

EndCase

//--------------------------------------------------------------------------
// Se for Programao de entrega
//--------------------------------------------------------------------------
If ( lProgEnt )
	//Atualiza Status da Programao de entrega
	Ma412Stat( SC6->C6_NUM )
EndIf

//Ŀ
//Restaura a entrada da rotina                                            
//
RestArea(aAreaSF4)
RestArea(aAreaSA1)
RestArea(aAreaSB2)
RestArea(aArea)
					
Return(.T.)
/*/


Ŀ
Funcao    MaAvalSC9  Autor Eduardo Riera           Data 20.02.2000
Ĵ
Descrio Rotina de avaliacao dos eventos dos itens liberados do pedi-
          do de Venda ( SC9 )                                         
Ĵ
ParametrosExpC1: Alias da tabela dos itens liberados do Pedido de Ven-
                 da                                                   
          ExpN2: Codigo do Evento                                     
                 [1] Implantacao do SC9                               
                 [2] Estorno do SC9                                   
                 [3] Liberacao de Credito do SC9                      
                 [4] Estorno da Liberacao de Credito do SC9           
                 [5] Liberacao de Estoque do SC9                      
                 [6] Estorno da Liberacao de Estoque do SC9           
                 [7] Montagem de Carga do SC9                         
                 [8] Estorno da Montagem de Carga do SC9              
                 [9] Liberacao WMS do SC9                             
                 [10]Estorno WMS do SC9                               
                 [11]Geracao do Documento de Saida                    
                 [12]Estorno do Documento de Saida                    
          ExpL3: Array da SldPorLote somente da Localizacao Fisica    
          ExpL4: Array da SldPorLote (Somente para WMS)               
          ExpL5: Atualiza somente os acumulados (OPC)                 
                 DEFAULT .F.                                          
          ExpL6: Indica se o estorno sera precedido de uma exclusao   
                 DEFAULT .T. (OPC)                                    
			 ExpL7: Indica se Atualizar Empenhos				          
			 ExpL8: Array com os dados da roteirizacao (OPC)             
			        [1] Codigo da Rota             			          
			        [2] Codigo da Zona             			          
			        [3] Codigo do Setor             			          
			        [4] Motorista                  			          
			        [5] Caminhao                    			          
			        [6] Ajudante 1                 			          
			        [7] Ajudante 2                  			          
			        [8] Ajudante 3                  			          
			        [9] Hora chegada                			          
			        [10] Time Service                			          
			        [11] Data chegada                			          
			        [12] Data saida                			          
			        [13] Hora de inicio de entrega    			          
          ExpN9: Valor a ser adicionado ao limite de credito          
          ExpLA: Indica se esta o SC9 esta sendo baixado por un REMITO
Ĵ
Retorno   Nenhum                                                      
                                                                      
Ĵ
Descrio Esta rotina tem como objetivo atualizar os eventos vinculado
          ao item do pedido de venda.                                 
          A) Atualizacao das tabelas complementares.                  
          B) Atualizacao das informacoes complementares do PV         
                                                                      
Ĵ
ObservacaoBloqueios do SC9                                            
                                                                      
          C9_BLCRED: 01 - Bloqueio de Credito por Valor               
                     04 - Vencto do Limite de Credito                 
                     05 - Bloqueio de Credito por Estorno             
                     06 - Bloqueio de Credito por Risco               
                     09 - Rejeicao de Credito                         
                                                                      
          C9_BLEST:  02 - Bloqueio de Estoque                         
                     03 - Bloqueio Manual de Estoque                  
                                                                      
          C9_BLWMS:  01 - Bloqueio de Enderecamento do WMS/Somente SB2
                     02 - Bloqueio de Enderecamento do WMS            
                     03 - Bloqueio de WMS - Externo                   
                     05 - Liberacao para Bloqueio 01                  
                     06 - Liberacao para Bloqueio 02                  
                     07 - Liberacao para Bloqueio 03                  
                                                                      
Ĵ
Uso        Materiais                                                  
ٱ


/*/
Function MaAvalSC9(cAliasSC9,nEvento,aLocaliz,aSaldos,lAcumulado,lDeleta,lAtuEmp,aRotas,nVlrCred,lRemito,lDeletaDCF,cIdDCF,lGeraDCF,cFilCar)

Local aArea     := GetArea(cAliasSC9)
Local aAreaSF4  := SF4->(GetArea())
Local aAreaDAI  := {}
Local nSldPed   := 0
Local nSldPed2  := 0
Local nX        := 0
Local lContinua := .T.
Local lBlqCred  := !Empty((cAliasSC9)->C9_BLCRED)
Local lBlqEst   := !(Empty((cAliasSC9)->C9_BLCRED) .And. Empty((cAliasSC9)->C9_BLEST))
Local lFaturado := ((cAliasSC9)->C9_BLCRED=="10" .And. (cAliasSC9)->C9_BLEST=="10") .Or. ((cAliasSC9)->C9_BLCRED=="ZZ" .And. (cAliasSC9)->C9_BLEST=="ZZ")
Local lDelRes   := .F.
Local lFreteEmb := .F.
Local nMCusto   := 0
Local nValAv    := 0
//-- Variaveis utilizadas pela funcao wmsexedcf
Local lRetEmpPE := lAtuEmp
Local lWmsNew   := SuperGetMV("MV_WMSNEW",.F.,.F.)
Local lAtuSA1	:= Nil
Local cFilSC5	:= ""
Local cFilSC6	:= ""
Local cFilSA1	:= ""
Local cFilSF4	:= ""
Local lTrvSA1   := .T.

lAtuEmp:=If(lAtuEmp==NIL,.T.,lAtuEmp)

DEFAULT lAcumulado := .F.
DEFAULT lDeleta    := .T.
DEFAULT aRotas     := Array(15)
DEFAULT nVlrCred   := 0
DEFAULT lRemito    := .F.
DEFAULT lDeletaDCF := .T.
DEFAULT cIdDCF     := ''
DEFAULT lGeraDCF   := .T.
DEFAULT cFilCar    := xFilial("DAI")

If lMTValAvC == Nil 
	lMTValAvC := ExistBlock("MTVALAVC")
EndIf

If lMTVALEMP == Nil
	lMTVALEMP := ExistBlock("MTVALEMP")
EndIf

lAtuSA1	:= IIF(lMTValAvC .Or. !(IsInCallStack("MaPvlNfs2")), .T., .F.)

//Este ponto de entrada  utilizado pelo Nestl para no gerar empenho para os pedidos, mesmo liberando
//o estoque. Antes era utilizado o servio WMS para no gerar empenho, sem usar o WMS para fazer a separao,
//porm devido a evoluo do WMS este conceito foi alterado, pois quantdo  integrado ao WMS o empenho  gerado na separao WMS
If lMTVALEMP
   lRetEmpPE := ExecBlock("MTVALEMP",.F.,.F.,{nEvento,cAliasSC9,lAtuEmp})
   lAtuEmp   := Iif(ValType(lRetEmpPE)=="L",lRetEmpPE,lAtuEmp)
EndIf

Do Case
	//Ŀ
	//Implantacao de um item liberado do pedido de venda                      
	//
Case nEvento == 1
	//Ŀ
	//Posiciona registros                                                     
	//
	cFilSC5 := xFilial("SC5")
	If !(cFilSC5==SC5->C5_FILIAL .And. SC5->C5_NUM==(cAliasSC9)->C9_PEDIDO)
		SC5->(dbSetOrder(1))
		SC5->(MsSeek(cFilSC5+(cAliasSC9)->C9_PEDIDO))
	EndIf
	cFilSC6 := xFilial("SC6")
	If !(cFilSC6==SC6->C6_FILIAL .And.;
			SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
			SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
			SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO)
		SC6->(dbSetOrder(1))
		SC6->(MsSeek(cFilSC6+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO))
	EndIf
	SF4->(dbSetOrder(1))
	SF4->(MsSeek(xFilial("SF4")+SC6->C6_TES))
	If lContinua .And. SF4->F4_DUPLIC=="S" .And. !SC5->C5_TIPO$'DB'
		SA1->(dbSetOrder(1))
		SA1->(MsSeek(xFilial("SA1")+(cAliasSC9)->C9_CLIENTE+(cAliasSC9)->C9_LOJA))
		lTrvSA1 := IIf(cPaisLoc == "BRA" .And. lFATTRVSA1, ExecBlock("FATTRVSA1", .F., .F., {xFilial("SA1"), SA1->A1_COD, SA1->A1_LOJA}), .T.)
		If lTrvSA1
			lContinua := RecLock("SA1")
		EndIf
	EndIf
	If lContinua .And. SF4->F4_ESTOQUE=="S"
		SB2->(dbSetOrder(1))
		If SB2->(MsSeek(xFilial("SB2")+SC6->C6_PRODUTO+(cAliasSC9)->C9_LOCAL))
	   		lContinua := RecLock("SB2")
		Else
	   		HELP(" ",1,"NOFOUNDSB2")
	   		lContinua := .F.
	 	EndIf
	EndIf
	If lContinua .And. !lAcumulado
		lContinua := RecLock("SC5")
	EndIf
	If lAcumulado
		lContinua := RecLock("SC6")
	EndIf
	If lContinua .And. (SF4->F4_PODER3=='D' .Or. !Empty((cAliasSC9)->C9_IDENTB6)) .And. !lAcumulado
		SB6->(dbSetOrder(3))
		If SB6->(MsSeek(xFilial("SB6")+(cAliasSC9)->C9_IDENTB6+SC6->C6_PRODUTO+"R",.F.))
			lContinua := RecLock("SB6")
		Else
			lContinua := .F.
		EndIf
	EndIf
	If lContinua
		//Ŀ
		//Atualiza os dados do item do pedido de venda                            
		//
		RecLock("SC6")
		SC6->C6_QTDEMP  += (cAliasSC9)->C9_QTDLIB
		SC6->C6_QTDEMP2 += (cAliasSC9)->C9_QTDLIB2
		If !lAcumulado
			If IsInCallStack('WMSA332') 
				SC6->C6_QTDLIB := Max(SC6->C6_QTDLIB - (cAliasSC9)->C9_QTDLIB, 0)
			Else
				SC6->C6_QTDLIB -= (cAliasSC9)->C9_QTDLIB			
			EndIf
			SC6->C6_QTDLIB2 := Max( SC6->C6_QTDLIB2 - (cAliasSC9)->C9_QTDLIB2, 0 )
			//Ŀ
			// Libera o arquivo Poder de Terceiros                     
			//
			If ( SF4->F4_PODER3=="D" .Or. !Empty((cAliasSC9)->C9_IDENTB6) )
				SB6->B6_QULIB += (cAliasSC9)->C9_QTDLIB
			EndIf
		EndIf
		//Ŀ
		//Atualiza a Liberacao de Credito                                         
		//
		MaAvalSC9(cAliasSC9,3,,,lAcumulado,Nil,Nil,Nil,@nVlrCred,,,,lGeraDCF)
		//Ŀ
		//Atualiza a Liberacao de Estoque                                         
		//
		MaAvalSC9(cAliasSC9,5,aLocaliz,,lAcumulado,Nil,Nil,Nil,@nVlrCred,,,,lGeraDCF)
	EndIf
	//Ŀ
	//Estorno de um item liberado do pedido de venda                          
	//
Case nEvento == 2
	//Ŀ
	//Posiciona registros                                                     
	//
	cFilSC5 := xFilial("SC5")
	If !(cFilSC5==SC5->C5_FILIAL .And. SC5->C5_NUM==(cAliasSC9)->C9_PEDIDO)
		SC5->(dbSetOrder(1))
		SC5->(MsSeek(cFilSC5+(cAliasSC9)->C9_PEDIDO))
	EndIf
	cFilSC6 := xFilial("SC6")
	If !(xFilial("SC6")==SC6->C6_FILIAL .And.;
			SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
			SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
			SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO)
		SC6->(dbSetOrder(1))
		SC6->(MsSeek(cFilSC6+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO))
	EndIf
	SF4->(dbSetOrder(1))
	SF4->(MsSeek(xFilial("SF4")+SC6->C6_TES))
	If lContinua .And. SF4->F4_DUPLIC=="S" .And. !SC5->C5_TIPO$'DB'
		SA1->(dbSetOrder(1))
		SA1->(MsSeek(xFilial("SA1")+(cAliasSC9)->C9_CLIENTE+(cAliasSC9)->C9_LOJA))
		lTrvSA1 := IIf(cPaisLoc == "BRA" .And. lFATTRVSA1, ExecBlock("FATTRVSA1", .F., .F., {xFilial("SA1"), SA1->A1_COD, SA1->A1_LOJA}), .T.)
		If lTrvSA1
			lContinua := RecLock("SA1")
		EndIf
	EndIf
	If lContinua .And. SF4->F4_ESTOQUE=="S"
		SB2->(dbSetOrder(1))
		SB2->(MsSeek(xFilial("SB2")+SC6->C6_PRODUTO+(cAliasSC9)->C9_LOCAL))
		lContinua := RecLock("SB2")
	EndIf
	If lContinua .And. !lAcumulado
		lContinua := RecLock("SC5")
	EndIf
	If lContinua .And. !lAcumulado
		lContinua := RecLock("SC6")
	EndIf
	If lContinua .And. !lAcumulado
		lContinua := RecLock(cAliasSC9)
	EndIf
	If lContinua .And. ( SF4->F4_PODER3=='D' .Or. !Empty((cAliasSC9)->C9_IDENTB6)) .And. !lAcumulado
		SB6->(dbSetOrder(3))
		If SB6->(MsSeek(xFilial("SB6")+(cAliasSC9)->C9_IDENTB6+SC6->C6_PRODUTO+"R",.F.))
			lContinua := RecLock("SB6")
		Else
			lContinua := .F.
		EndIf
	EndIf
	If lContinua
		//Ŀ
		//Verifica se eh um item de liberacao ou um item faturado      
		//
		If !lFaturado
			//Ŀ
			// Apaga marca de Pedido totalmente liberado (SC5->C5_LIBEROK) 
			//
			If lDeleta .And. !lAcumulado
				MaAvalSC5("SC5",4)
			EndIf
			//Ŀ
			// Efetua o Estorno de Estoque                             
			//
			MaAvalSC9(cAliasSC9,6,,,lAcumulado,,lAtuEmp,Nil,@nVlrCred,,,,lGeraDCF)
			//Ŀ
			//Efetua o estorno de credito                                  
			//
			MaAvalSC9(cAliasSC9,4,,,lAcumulado,,lAtuEmp,Nil,@nVlrCred,,,,lGeraDCF)
			//Ŀ
			// Estorna valor no arquivo Poder de Terceiros             
			//
			If !lAcumulado
				If ( SF4->F4_PODER3=="D" .Or. !Empty((cAliasSC9)->C9_IDENTB6) )
					SB6->B6_QULIB -= (cAliasSC9)->C9_QTDLIB
				EndIf
			EndIf
			//Ŀ
			// Estorna qtde empenhada e nao faturada                   
			//
			SC6->C6_QTDEMP  -= (cAliasSC9)->C9_QTDLIB
			SC6->C6_QTDEMP2 := Max( SC6->C6_QTDEMP2 - (cAliasSC9)->C9_QTDLIB2, 0 )
			If lDeletaDCF .And. IntWms((cAliasSC9)->C9_PRODUTO) .And. !Empty((cAliasSC9)->C9_SERVIC) .And. SC6->C6_QTDVEN > 0
				lContinua := WmsUndoPed((cAliasSC9)->(Recno()))
			EndIf
		EndIf
	EndIf
	//Ŀ
	//Liberacao de Credito de um item liberado do pedido de venda             
	//
Case nEvento == 3
	//Ŀ
	//Posiciona registros                                                     
	//
	cFilSC5 := xFilial("SC5")
	If !(cFilSC5==SC5->C5_FILIAL .And. SC5->C5_NUM==(cAliasSC9)->C9_PEDIDO)
		SC5->(dbSetOrder(1))
		SC5->(MsSeek(cFilSC5+(cAliasSC9)->C9_PEDIDO))
	EndIf
	cFilSC6 := xFilial("SC6")
	If !(cFilSC6==SC6->C6_FILIAL .And.;
			SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
			SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
			SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO )
		SC6->(dbSetOrder(1))
		SC6->(MsSeek(cFilSC6+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO))
	EndIf
	SF4->(dbSetOrder(1))
	SF4->(MsSeek(xFilial("SF4")+SC6->C6_TES))
	If lContinua .And. SF4->F4_DUPLIC=="S" .And. !SC5->C5_TIPO$'DB'
		SA1->(dbSetOrder(1))
		SA1->(MsSeek(xFilial("SA1")+(cAliasSC9)->C9_CLIENTE+(cAliasSC9)->C9_LOJA))
		lTrvSA1 := IIf(cPaisLoc == "BRA" .And. lFATTRVSA1, ExecBlock("FATTRVSA1", .F., .F., {xFilial("SA1"), SA1->A1_COD, SA1->A1_LOJA}), .T.)
		If lTrvSA1
			lContinua := RecLock("SA1")
		EndIf
	EndIf
	If lAcumulado
		lContinua := RecLock("SC6")
	EndIf
	If lContinua .And. !lAcumulado
		lContinua := RecLock(cAliasSC9)
	EndIf
	If lContinua
		//Ŀ
		// Marca os pedidos liberados por credito para filtro na geracao da OP    
		//
		If !lBlqCred .And. !lAcumulado
			If ( Empty( SC6->C6_OP ) .Or. SC6->C6_OP == "02" .Or. SC6->C6_OP == "04") .And. SF4->F4_ESTOQUE=="S"
				SC6->C6_OP := "07"
			EndIf
			If SC6->C6_OP == "04"
				SC6->C6_OP := ""
			EndIf
		EndIf
		//Ŀ
		//Atualiza a Liberacao de Credito                                         
		//
		If SF4->F4_DUPLIC=="S" .And. !SC5->C5_TIPO$"DB" .And. !AllTrim(SC6->C6_BLQ)$"RS"
			nMCusto  :=  If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC, Val(SuperGetMv("MV_MCUSTO")))
			If lMTValAvC
				nValAv	:=	ExecBLock("MTValAvC",.F.,.F.,{'MAAVALSC9',(cAliasSC9)->C9_QTDLIB*(cAliasSC9)->C9_PRCVEN,nEvento})
			Else
				nValAv	:=	(cAliasSC9)->C9_QTDLIB*(cAliasSC9)->C9_PRCVEN
			Endif

			nSldLib  := xMoeda(nValAV,SC5->C5_MOEDA,nMCusto,(cAliasSC9)->C9_DATALIB)

			If !lBlqCred
				If lTrvSA1
					SA1->A1_SALPEDL += nSldLib
				EndIf
				nVlrCred -= nValAV
			Else
				If lTrvSA1
					SA1->A1_SALPEDB += nSldLib
				EndIf
			EndIf
			nSldPed := (cAliasSC9)->C9_QTDLIB
			nSldPed := If(nSldPed>(SC6->C6_QTDVEN-SC6->C6_QTDEMP+nSldPed-SC6->C6_QTDENT),SC6->C6_QTDVEN-SC6->C6_QTDEMP+nSldPed-SC6->C6_QTDENT,nSldPed)
			If lTrvSA1
				SA1->A1_SALPED -= xMoeda(nSldPed*(cAliasSC9)->C9_PRCVEN,SC5->C5_MOEDA,nMCusto,SC5->C5_EMISSAO)
			EndIf
		EndIf
	EndIf
	//Ŀ
	//Estorno da Liberacao de Credito de um item liberado do pedido de venda  
	//
Case nEvento == 4
	If !lFaturado
		//Ŀ
		//Posiciona registros                                                     
		//
		cFilSC5 := xFilial("SC5")
		If !(cFilSC5==SC5->C5_FILIAL .And. SC5->C5_NUM==(cAliasSC9)->C9_PEDIDO)
			SC5->(dbSetOrder(1))
			SC5->(MsSeek(cFilSC5+(cAliasSC9)->C9_PEDIDO))
		EndIf
		cFilSC6 := xFilial("SC6")
		If !(cFilSC6==SC6->C6_FILIAL .And.;
				SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
				SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
				SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO)
			SC6->(dbSetOrder(1))
			SC6->(MsSeek(cFilSC6+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO))
		EndIf
		SF4->(dbSetOrder(1))
		SF4->(MsSeek(xFilial("SF4")+SC6->C6_TES))
		If lContinua .And. SF4->F4_DUPLIC=="S" .And. !SC5->C5_TIPO$'DB' .And. (lBlqEst.Or.SF4->F4_ESTOQUE=='N')
			SA1->(dbSetOrder(1))
			SA1->(MsSeek(xFilial("SA1")+(cAliasSC9)->C9_CLIENTE+(cAliasSC9)->C9_LOJA))
			lTrvSA1 := IIf(cPaisLoc == "BRA" .And. lFATTRVSA1, ExecBlock("FATTRVSA1", .F., .F., {xFilial("SA1"), SA1->A1_COD, SA1->A1_LOJA}), .T.)
			If lTrvSA1
				lContinua := RecLock("SA1")
			EndIf
		EndIf
		If lContinua .And. !lAcumulado
			lContinua := RecLock("SC5")
		EndIf
		If lContinua .And. !lAcumulado
			lContinua := RecLock("SC6")
		EndIf
		If lContinua .And. !lAcumulado
			lContinua := RecLock(cAliasSC9)
		EndIf
		If lContinua

			//Ŀ
			// Desmarca os pedidos liberados por credito para filtro na geracao da OP 
			//
			If !lAcumulado
				If SC6->C6_OP == "07"
					SC6->C6_OP := ""
				EndIf
			EndIf
			If !SC5->C5_TIPO$"DB" .And. SF4->F4_DUPLIC == "S"  .And. !AllTrim(SC6->C6_BLQ)$"RS"
				nMCusto  :=  If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC, Val(SuperGetMv("MV_MCUSTO")))
				If lMTValAvC
					nValAv	:=	ExecBLock("MTValAvC",.F.,.F.,{'MAAVALSC9',(cAliasSC9)->C9_QTDLIB*(cAliasSC9)->C9_PRCVEN,nEvento})
				Else
					nValAv	:=	(cAliasSC9)->C9_QTDLIB*(cAliasSC9)->C9_PRCVEN
				Endif

				nSldLib  := xMoeda(nValAV,SC5->C5_MOEDA,nMCusto,(cAliasSC9)->C9_DATALIB)

				If !lBlqCred
					If lTrvSA1
						SA1->A1_SALPEDL -= nSldLib
					EndIf
					nVlrCred += nValAV
				Else
					If lTrvSA1
						SA1->A1_SALPEDB -= nSldLib
					EndIf
				EndIf
				nSldPed := (cAliasSC9)->C9_QTDLIB
				nSldPed := If(nSldPed>(SC6->C6_QTDVEN-SC6->C6_QTDEMP+nSldPed-SC6->C6_QTDENT),SC6->C6_QTDVEN-SC6->C6_QTDEMP+nSldPed-SC6->C6_QTDENT,nSldPed)
				If lTrvSA1
					SA1->A1_SALPED += xMoeda(nSldPed*(cAliasSC9)->C9_PRCVEN,SC5->C5_MOEDA,nMCusto,SC5->C5_EMISSAO)
				EndIf
				(cAliasSC9)->C9_BLCRED := "05" //Bloqueado Manualmente de Credito"
			EndIf
		EndIf
	EndIf
	//Ŀ
	//Liberacao de estoque de um item liberado do pedido de venda             
	//
Case nEvento == 5
	//Ŀ
	//Posiciona registros                                                     
	//
	cFilSC5 := xFilial("SC5")
	If !(cFilSC5==SC5->C5_FILIAL .And. SC5->C5_NUM==(cAliasSC9)->C9_PEDIDO)
		SC5->(dbSetOrder(1))
		SC5->(MsSeek(cFilSC5+(cAliasSC9)->C9_PEDIDO))
	EndIf
	cFilSC6 := xFilial("SC6")
	If !(cFilSC6==SC6->C6_FILIAL .And.;
			SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
			SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
			SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO)
		SC6->(dbSetOrder(1))
		SC6->(MsSeek(cFilSC6+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO))
	EndIf
	SF4->(dbSetOrder(1))
	SF4->(MsSeek(xFilial("SF4")+SC6->C6_TES))
	If lContinua .And. SF4->F4_ESTOQUE=="S"
		SB2->(dbSetOrder(1))
		SB2->(MsSeek(xFilial("SB2")+(cAliasSC9)->C9_PRODUTO+SC6->C6_LOCAL))
		lContinua := RecLock("SB2")
	EndIf
	If lContinua .And. !lAcumulado
		lContinua := RecLock("SC5")
	EndIf
	If lAcumulado
		lContinua := RecLock("SC6")
	EndIf
	If lContinua .And. !lAcumulado
		lContinua := RecLock(cAliasSC9)
	EndIf
	If lContinua
		//Ŀ
		//Atualiza a Liberacao de Estoque                                         
		//
		If ( SF4->F4_ESTOQUE == "S" )
			If ( !lBlqCred .And. !lBlqEst )
				//Ŀ
				//Gera o registro do WMS no DCF com base no pedido de Vendas              
				//
				If IntWms((cAliasSC9)->C9_PRODUTO) .And. !Empty((cAliasSC9)->C9_SERVIC)
					If !lAcumulado
						// Atualiza empenho sempre que for novo WMS ou quando no gerar DCF, que  o caso em que
						// se est estornando o faturamento para manter o pedido com status "Apto a faturar".
						// Nessa situao, o saldo dever retornar para doca empenhado. Assim, ao realizar um
						// novo faturamento, a baixa de estoque acontecer a partir do endereo correto.
						lAtuEmp := lWmsNew .Or. (cAliasSC9)->C9_BLWMS != "01" //!lGeraDCF
						If lGeraDCF
							//-- 1=no Pedido;2=na Montagem da Carga;3=na Unitizacao da Carga
							If SC5->C5_GERAWMS == '1' .And. !((cAliasSC9)->C9_BLWMS == '05') .And. SC6->C6_QTDVEN > 0
							   WmsIntPed((cAliasSC9)->(Recno()))
							EndIf
						EndIf
					Else
						lAtuEmp := lWmsNew .Or. (cAliasSC9)->C9_BLWMS == '05'
					EndIf
				EndIf
				//Ŀ
				//Atualiza as reservas para faturamento                                   
				//
				If !Empty((cAliasSC9)->C9_RESERVA)
					If !lAcumulado
						SC0->(dbSetOrder(1))
						If SC0->(MsSeek(xFilial("SC0")+(cAliasSC9)->C9_RESERVA+(cAliasSC9)->C9_PRODUTO+SC6->C6_LOCAL))
							//Ŀ
							//Tratamento dos Lotes da Reserva                                         
							//
							GravaEmp(SC0->C0_PRODUTO,;    //1
								SC6->C6_LOCAL,;      //2
								(cAliasSC9)->C9_QTDLIB,;   //3
								Nil,  ;        //4
								SC0->C0_LOTECTL,; //5
								SC0->C0_NUMLOTE,; //6
								SC0->C0_LOCALIZ,; //7
								SC0->C0_NUMSERI,; //8
								Nil,;          //9
								Nil,;          //10
								SC6->C6_RESERVA,; //11
								Nil,;          //12
								"SC0",;           //13
								Nil,;          //14
								Nil,;          //15
								Nil,;          //16
								.T.,;          //17
								.F.,;          //18
								.T.,;          //19
								.F.,;          //20
								Nil,;           //21
								IIf(!IntWms(SC0->C0_PRODUTO),!Empty(SC0->C0_LOTECTL+SC0->C0_NUMLOTE).Or.Localiza( SC0->C0_PRODUTO ,.T.),!Empty(SC0->C0_LOTECTL+SC0->C0_NUMLOTE+SC0->C0_LOCALIZ+SC0->C0_NUMSERI))) //22
							RecLock("SB2")
						EndIf
					Else
						RecLock("SB2")
						SB2->B2_QPEDVEN -= (cAliasSC9)->C9_QTDRESE
					EndIf
				EndIf
				//Ŀ
				//Reserva o saldo em Estoque                                              
				//
				For nX := 1 To Len(aLocaliz)
					GravaEmp((cAliasSC9)->C9_PRODUTO,;     //01
						(cAliasSC9)->C9_LOCAL,;       	//02
						aLocaliz[nX,5],;     			//03
						aLocaliz[nX,6],;     			//04
						(cAliasSC9)->C9_LOTECTL,;     	//05
						(cAliasSC9)->C9_NUMLOTE,;     	//06
						aLocaliz[nX,3],;     			//07
						aLocaliz[nX,4],;     			//08
						Nil,;             				//09
						(cAliasSC9)->C9_SEQUEN,;    	//10
						(cAliasSC9)->C9_PEDIDO,;       //11
						(cAliasSC9)->C9_ITEM,;         //12
						"SC6",;              			//13
						Nil,;             				//14
						Nil,;             				//15
						Nil,;             				//16
						.F.,;             				//17
						.F.,;             				//18
						.T.,;             				//19
						.F.,;             				//20
						!Empty((cAliasSC9)->C9_LOTECTL+(cAliasSC9)->C9_NUMLOTE),;//21
						lAtuEmp,; //22
						(lAtuEmp .And. !lAcumulado)) //23
					RecLock("SB2")
				Next nX
				nSldPed  := Max(Min(SC6->C6_QTDVEN-SC6->C6_QTDENT-SC6->C6_QTDEMP+(cAliasSC9)->C9_QTDLIB,(cAliasSC9)->C9_QTDLIB),0)
				nSldPed2 := SB1->(ConvUm(SB2->B2_COD,nSldPed,nSldPed2,2))

				If (Empty((cAliasSC9)->C9_RESERVA)) .And. !("S" $ SC6->C6_BLQ .Or. "R" $ SC6->C6_BLQ) //Se nao Bloqueado
						RecLock("SB2",.F.)
						SB2->B2_QPEDVEN -= nSldPed
						SB2->B2_QPEDVE2 -= nSldPed2
				Else
					//Ŀ
					// Atualiza o saldo da reserva                                  
					//
					If !lAcumulado
						SC0->(dbSetOrder(1))
						If SC0->(MsSeek(xFilial("SC0")+(cAliasSC9)->C9_RESERVA+(cAliasSC9)->C9_PRODUTO+SC6->C6_LOCAL))
							RecLock("SC0")
							SC6->C6_QTDRESE -= (cAliasSC9)->C9_QTDRESE
							SC0->C0_QTDPED -= (cAliasSC9)->C9_QTDRESE
							SC0->C0_TIPO   := If(SC0->C0_QTDPED==0,"LB","PD")
						EndIf
					EndIf
				EndIf
			Else
				If !lAcumulado
					If (cAliasSC9)->C9_RESERVA==SC6->C6_RESERVA .And. !Empty((cAliasSC9)->C9_RESERVA)
						//Ŀ
						//Atualiza os dados do SC6                                                
						//
						SC6->C6_QTDRESE -= (cAliasSC9)->C9_QTDRESE
					EndIf
				Else
					RecLock("SB2")
					SB2->B2_QPEDVEN -= (cAliasSC9)->C9_QTDRESE
					//Ŀ
					//Atualiza as reservas para faturamento                                   
					//
					If !Empty((cAliasSC9)->C9_RESERVA)
						SC0->(dbSetOrder(1))
						If SC0->(MsSeek(xFilial("SC0")+(cAliasSC9)->C9_RESERVA+(cAliasSC9)->C9_PRODUTO+SC6->C6_LOCAL))
							//Ŀ
							//Tratamento dos Lotes da Reserva                                         
							//
							GravaEmp(SC0->C0_PRODUTO,;    //1
								SC6->C6_LOCAL,;            //2
								(cAliasSC9)->C9_QTDRESE+SC6->C6_QTDRESE,;   //3
								NIL,;                //4
								SC0->C0_LOTECTL,;       //5
								SC0->C0_NUMLOTE,;       //6
								SC0->C0_LOCALIZ,;       //7
								SC0->C0_NUMSERI,;       //8
								Nil,;                //9
								Nil,;                //10
								(cAliasSC9)->C9_RESERVA,;        //11
								Nil,;                //12
								"SC0",;                 //13
								Nil,;                //14
								Nil,;                //15
								Nil,;                //16
								.F.,;                //17
								.F.,;                //18
								.T.,;                //19
								.F.,;                //20
								Nil,;                 //21
								IIf(!IntWms(SC0->C0_PRODUTO),!Empty(SC0->C0_LOTECTL+SC0->C0_NUMLOTE).Or.Localiza( SC0->C0_PRODUTO ,.T. ),!Empty(SC0->C0_LOTECTL+SC0->C0_NUMLOTE+SC0->C0_LOCALIZ+SC0->C0_NUMSERI))) //22
							RecLock("SB2")
						EndIf
					EndIf
				EndIf
			EndIf
			
			If !lBlqEst 
				PmsBxEmp(SC9->C9_PROJPMS, SC9->C9_TASKPMS, SC9->C9_PRODUTO, SC9->C9_LOCAL, SC9->C9_QTDLIB, "-", SC9->C9_QTDLIB2,SC9->C9_TRT)
			EndIf

			//Ŀ
			//                Notas sobre o campo C6_OP                               
			// 01 - OP Gerada pelo MATA650                                            
			// 02 - Liberacao de PV bloqueada ( Sem OP )                              
			// 03 - Liberacao de PV bloqueada ( Item 01 )                             
			// 04 - Bloqueio de credito pelo MATA650                                  
			// 05 - OP nao gerada pois ha qtde em Estoque                             
			// 06 - Liberacao de PV liberada  ( Item 05 )                             
			// 07 - Liberacao de credito efetuada / Estoque pendente/bloqueada        
			// 08 - Liberacao de estoque efetuada ( item 01 )                         
			//
			If !lAcumulado
				Do Case
				Case Empty(SC6->C6_OP)
					If !lBlqEst .Or. SF4->F4_ESTOQUE=="N"
						SC6->C6_OP     := ""
					Else
						SC6->C6_OP     := "02"
					EndIf
				Case SC6->C6_OP == "07"
					If !lBlqEst .Or. SF4->F4_ESTOQUE=="N"
						SC6->C6_OP     := ""
					EndIf
				Case SC6->C6_OP == "01"
					If !lBlqEst .Or. SF4->F4_ESTOQUE=="N"
						SC6->C6_OP     := "08"
					Else
						SC6->C6_OP     := "03"
					EndIf
				Case SC6->C6_OP == "05"
					If !lBlqEst .Or. SF4->F4_ESTOQUE=="N"
						SC6->C6_OP     := "06"
					EndIf
				EndCase
			EndIf
		EndIf
	EndIf
	//Ŀ
	//Estorno da Liberacao de estoque de um item liberado do pedido de venda  
	//
Case nEvento == 6
	//Ŀ
	//Posiciona registros                                                     
	//
	cFilSC6 := xFilial("SC6")
	If !(cFilSC6==SC6->C6_FILIAL .And.;
			SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
			SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
			SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO )
		SC6->(dbSetOrder(1))
		SC6->(MsSeek(cFilSC6+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO))
	EndIf
	SF4->(dbSetOrder(1))
	SF4->(MsSeek(xFilial("SF4")+SC6->C6_TES))
	If lContinua .And. SF4->F4_ESTOQUE=="S"
		SB2->(dbSetOrder(1))
		SB2->(MsSeek(xFilial("SB2")+(cAliasSC9)->C9_PRODUTO+(cAliasSC9)->C9_LOCAL))
		lContinua := RecLock("SB2")
		nRecnoB2 := SB2->(Recno())
	EndIf
	
	cFilSC5 := xFilial("SC5")
	If lContinua .And. !(cFilSC5==SC5->C5_FILIAL .And. SC5->C5_NUM==(cAliasSC9)->C9_PEDIDO)
		SC5->(dbSetOrder(1))
		SC5->(MsSeek(cFilSC5+(cAliasSC9)->C9_PEDIDO))
	EndIf

	If lContinua .And. !lAcumulado
		lContinua := RecLock("SC5")
	EndIf
	If lContinua
		lContinua := RecLock("SC6")
	EndIf
	If lContinua .And. !lAcumulado
		lContinua := RecLock(cAliasSC9)
	EndIf
	If lContinua
		If SF4->F4_ESTOQUE == "S" .And. !lFaturado
			//Ŀ
			//                Notas sobre o campo C6_OP                               
			// 01 - OP Gerada pelo MATA650                                            
			// 02 - Liberacao de PV bloqueada ( Sem OP )                              
			// 03 - Liberacao de PV bloqueada ( Item 01 )                             
			// 04 - Bloqueio de credito pelo MATA650                                  
			// 05 - OP nao gerada pois ha qtde em Estoque                             
			// 06 - Liberacao de PV liberada  ( Item 05 )                             
			// 07 - Liberacao de credito efetuada / Estoque pendente/bloqueada        
			// 08 - Liberacao de estoque efetuada ( item 01 )                         
			//
			If !lAcumulado
				Do Case
				Case SC6->C6_OP == "02"
					SC6->C6_OP := "07"
				Case SC6->C6_OP=="08"
					SC6->C6_OP  := "03"
				Case SC6->C6_OP == "06"
					SC6->C6_OP  := "05"
				Case SC6->C6_OP == "03"
					SC6->C6_OP  := "01"
				EndCase

			EndIf
			If !lBlqEst .And. !lBlqCred
				//Ŀ
				//Atualiza os dados da Reserva                                            
				//
				nSldPed  := Max(Min(SC6->C6_QTDVEN-SC6->C6_QTDENT-SC6->C6_QTDEMP+(cAliasSC9)->C9_QTDLIB,(cAliasSC9)->C9_QTDLIB),0)
				nSldPed2 := SB1->(ConvUm(SB2->B2_COD,nSldPed,nSldPed2,2))

				If ( !Empty((cAliasSC9)->C9_RESERVA) )
					SC0->(dbSetOrder(1))
					If SC0->(MsSeek(xFilial("SC0")+(cAliasSC9)->C9_RESERVA+SC6->C6_PRODUTO+SC6->C6_LOCAL))
						RecLock("SC0")
						If SC6->C6_QTDRESE==0
							SC6->C6_QTDRESE += (cAliasSC9)->C9_QTDRESE
							SC6->C6_RESERVA := (cAliasSC9)->C9_RESERVA
							SC0->C0_QTDPED  += (cAliasSC9)->C9_QTDRESE
							SC0->C0_TIPO    := "PD"
						Else
							lDelRes       := SuperGetMv("MV_DELRES")
							If SuperGetMv("MV_RESAUT") .AND. lDelRes
								SC0->C0_QUANT += (cAliasSC9)->C9_QTDRESE + SC0->C0_QTDPED
							Else
								SC0->C0_QUANT += (cAliasSC9)->C9_QTDRESE
							EndIf
							SC0->C0_TIPO  := If(SC0->C0_QTDPED==0.And.SC0->C0_TIPO=="PD","VD",SC0->C0_TIPO)
							If !("S" $ SC6->C6_BLQ .Or. "R" $ SC6->C6_BLQ) //Se nao Bloqueado
								SB2->B2_QPEDVEN += (cAliasSC9)->C9_QTDRESE
							EndIf
						EndIf
					EndIf
				ElseIf !("S" $ SC6->C6_BLQ .Or. "R" $ SC6->C6_BLQ) //Se nao Bloqueado
						RecLock("SB2",.F.)
						SB2->B2_QPEDVEN += nSldPed
						SB2->B2_QPEDVE2 += nSldPed2
					EndIf
				//Ŀ
				//Estorna o saldo Reservado                                               
				//
				GravaEmp((cAliasSC9)->C9_PRODUTO,;  //1
					(cAliasSC9)->C9_LOCAL,;       //2
					(cAliasSC9)->C9_QTDLIB,;      //3
					If( Empty( (cAliasSC9)->C9_QTDLIB2 ), NIL, (cAliasSC9)->C9_QTDLIB2 ),;  //4
					(cAliasSC9)->C9_LOTECTL,;     //5
					(cAliasSC9)->C9_NUMLOTE,;     //6
					Nil,;             //7
					Nil,;             //8
					Nil,;             //9
					(cAliasSC9)->C9_SEQUEN,;      //10
					(cAliasSC9)->C9_PEDIDO,;      //11
					(cAliasSC9)->C9_ITEM,;        //12
					"SC6",;              //13
					Nil,;             //14
					Nil,;             //15
					Nil,;             //16
					.T.,;             //17
					.F.,;             //18
					.T.,;             //19
					.F.,;             //20
					Nil,;             //21
					lAtuEmp) //22
				RecLock("SB2")
				//Ŀ
				//Atualiza a Reserva de Material                                          
				//
				If ( !Empty((cAliasSC9)->C9_RESERVA) )
					SC0->(dbSetOrder(1))
					If SC0->(MsSeek(xFilial("SC0")+(cAliasSC9)->C9_RESERVA+(cAliasSC9)->C9_PRODUTO+SC6->C6_LOCAL))
						//Ŀ
						//Tratamento dos Lotes da Reserva                                         
						//
						GravaEmp(SC0->C0_PRODUTO,;    //1
							SC6->C6_LOCAL,;            //2
							(cAliasSC9)->C9_QTDLIB,;   //3
							NIL,;                //4
							SC0->C0_LOTECTL,;       //5
							SC0->C0_NUMLOTE,;       //6
							SC0->C0_LOCALIZ,;       //7
							SC0->C0_NUMSERI,;       //8
							Nil,;                //9
							Nil,;                //10
							(cAliasSC9)->C9_RESERVA,;        //11
							Nil,;                //12
							"SC0",;                 //13
							Nil,;                //14
							Nil,;                //15
							Nil,;                //16
							.F.,;                //17
							.F.,;                //18
							.T.,;                //19
							.F.,;                //20
							Nil,;                 //21
							IIf(!IntWms(SC0->C0_PRODUTO),!Empty(SC0->C0_LOTECTL+SC0->C0_NUMLOTE).Or.Localiza( SC0->C0_PRODUTO ,.T.),!Empty(SC0->C0_LOTECTL+SC0->C0_NUMLOTE+SC0->C0_LOCALIZ+SC0->C0_NUMSERI))) //22

						If lDelRes
							a430Reserva({3,SC0->C0_TIPO,SC0->C0_DOCRES,SC0->C0_SOLICIT,SC0->C0_FILRES},;
								SC0->C0_NUM,;
								SC0->C0_PRODUTO,;
								SC0->C0_LOCAL,;
								SC0->C0_QUANT,;
								{SC0->C0_NUMLOTE,;
								SC0->C0_LOTECTL,;
								SC0->C0_LOCALIZ,;
								SC0->C0_NUMSERI})
						EndIf

						RecLock("SB2")
					Else
						If !("S" $ SC6->C6_BLQ .Or. "R" $ SC6->C6_BLQ) //Se nao Bloqueado
							SB2->B2_QPEDVEN += nSldPed
							SB2->B2_QPEDVE2 += nSldPed2
						EndIf
					EndIf
				EndIf
				//Ŀ
				//Atualiza o Bloqueio de Estoque                                          
				//
				(cAliasSC9)->C9_BLEST := "03" //"Bloqueio Manual de Estoque"
				//Ŀ
				//Cria o Log de movimento do estoque                                      
				//

				PmsBxEmp(SC9->C9_PROJPMS, SC9->C9_TASKPMS, SC9->C9_PRODUTO, SC9->C9_LOCAL,SC9->C9_QTDLIB, "+", SC9->C9_QTDLIB2,SC9->C9_TRT)

			Else
				//Ŀ
				//Atualiza dados do SC6                                                   
				//
				nSldPed  := Max(Min(SC6->C6_QTDVEN-SC6->C6_QTDENT-SC6->C6_QTDEMP+(cAliasSC9)->C9_QTDLIB,(cAliasSC9)->C9_QTDLIB),0)
				nSldPed2 := SB1->(ConvUm(SB2->B2_COD,nSldPed,nSldPed2,2))
				If ( !Empty((cAliasSC9)->C9_RESERVA) )
					If ( SC6->C6_RESERVA==(cAliasSC9)->C9_RESERVA .Or. SC6->C6_QTDRESE==0 )
						SC6->C6_QTDRESE += (cAliasSC9)->C9_QTDRESE
						SC6->C6_RESERVA := (cAliasSC9)->C9_RESERVA
					Else
						SC0->(dbSetOrder(1))
						If SC0->(MsSeek(xFilial("SC0")+(cAliasSC9)->C9_RESERVA+(cAliasSC9)->C9_PRODUTO+SC6->C6_LOCAL))
							RecLock("SC0")
							SC0->C0_QUANT += (cAliasSC9)->C9_QTDRESE
							SC0->C0_TIPO  := If (SC0->C0_QTDPED==0,"VD",SC0->C0_TIPO)
							If !("S" $ SC6->C6_BLQ .Or. "R" $ SC6->C6_BLQ) //Se nao Bloqueado
								SB2->B2_QPEDVEN += (cAliasSC9)->C9_QTDRESE
							EndIf
							If SuperGetMv("MV_DELRES")
								a430Reserva({3,SC0->C0_TIPO,SC0->C0_DOCRES,SC0->C0_SOLICIT,SC0->C0_FILRES},;
									SC0->C0_NUM,;
									SC0->C0_PRODUTO,;
									SC0->C0_LOCAL,;
									SC0->C0_QUANT,;
									{SC0->C0_NUMLOTE,;
									SC0->C0_LOTECTL,;
									SC0->C0_LOCALIZ,;
									SC0->C0_NUMSERI})
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
	//Ŀ
	//Montagem de Carga                                                       
	//
Case nEvento == 7
	If lContinua
		//Ŀ
		//Verifica-se a existencia do item da carga                               
		//
		DAI->(dbSetOrder(1)) //DAI_FILIAL+DAI_COD+DAI_SEQCAR+DAI_SEQUEN+DAI_PEDIDO
		If !DAI->(MsSeek(OsFilial("DAI",cFilCar)+(cAliasSC9)->C9_CARGA+(cAliasSC9)->C9_SEQCAR+(cAliasSC9)->C9_SEQENT+(cAliasSC9)->C9_PEDIDO))
			RecLock("DAI",.T.)
			DAI->DAI_FILIAL  := OsFilial("DAI",cFilCar)
			DAI->DAI_COD     := (cAliasSC9)->C9_CARGA
			DAI->DAI_SEQCAR  := (cAliasSC9)->C9_SEQCAR
			DAI->DAI_SEQUEN  := (cAliasSC9)->C9_SEQENT
			DAI->DAI_PEDIDO  := (cAliasSC9)->C9_PEDIDO
			If DAI->(FieldPos("DAI_FILPV")) > 0
				DAI->DAI_FILPV := (cAliasSC9)->C9_FILIAL
			EndIf
			DAI->DAI_CLIENT  := (cAliasSC9)->C9_CLIENTE
			DAI->DAI_LOJA    := (cAliasSC9)->C9_LOJA
			DAI->DAI_ROTEIR  := aRotas[1]
			DAI->DAI_PERCUR  := aRotas[2]
			DAI->DAI_ROTA    := aRotas[3]
			DAI->DAI_SEQROT  := Space(6)
			DAI->DAI_DATA    := dDataBase
			DAI->DAI_HORA    := Time()
			DAI->DAI_CARORI  := "CARGA"
			DAI->DAI_PESO   := 0
			DAI->DAI_CAPVOL := 0
			DAI->DAI_CHEGAD := aRotas[9]
			DAI->DAI_TMSERV := aRotas[10]
			DAI->DAI_DTCHEG := aRotas[11]
			DAI->DAI_DTSAID := aRotas[12]
			If lFreteEmb
				DAI->DAI_VALFRE := aRotas[14]
				DAI->DAI_FREAUT := aRotas[15]
			EndIf
		Else
			RecLock("DAI",.F.)
		EndIf
		Msunlock()
		//Ŀ
		//Atualiza os acumulados do DAI                                       
		//
		OsAvalDAI("DAI",1,aRotas,,,cFilCar)
	EndIf
	//Ŀ
	//Estorno da Montagem de Carga                                            
	//
Case nEvento == 8
	aAreaDAI := DAI->(GetArea())
	//Ŀ
	//Verifica-se a filial da liberacao do pedido de venda                    
	//
	cFilCar := (cAliasSC9)->(OsFilOpe(C9_CARGA,C9_SEQCAR,C9_SEQENT,C9_CLIENTE,C9_LOJA,C9_PEDIDO))
	
	//Ŀ
	//Atualiza os acumulados do DAI                                       
	//
	DAI->(dbSetOrder(1))
	If	DAI->(MsSeek(OsFilial("DAI",cFilCar)+(cAliasSC9)->C9_CARGA+(cAliasSC9)->C9_SEQCAR+(cAliasSC9)->C9_SEQENT+(cAliasSC9)->C9_PEDIDO))
		OsAvalDAI("DAI",2,aRotas,,,cFilCar)
	EndIf
	RestArea(aAreaDAI)
Case nEvento == 11
	//Ŀ
	//Posiciona registros                                                     
	//
	cFilSC5 := xFilial("SC5")
	If !(cFilSC5==SC5->C5_FILIAL .And.;
			SC5->C5_NUM==(cAliasSC9)->C9_PEDIDO)
		SC5->(dbSetOrder(1))
		SC5->(MsSeek(cFilSC5+(cAliasSC9)->C9_PEDIDO))
	EndIf
	If !SC5->C5_TIPO$'DB'
		cFilSA1 := xFilial("SA1")
		If !cFilSA1+(cAliasSC9)->C9_CLIENTE+(cAliasSC9)->C9_LOJA ==;
				SA1->A1_FILIAL+SA1->A1_COD+SA1->A1_LOJA
			SA1->(dbSetOrder(1))
			SA1->(MsSeek(cFilSA1+(cAliasSC9)->C9_CLIENTE+(cAliasSC9)->C9_LOJA))
		EndIf
		lTrvSA1 := IIf(cPaisLoc == "BRA" .And. lFATTRVSA1, ExecBlock("FATTRVSA1", .F., .F., {xFilial("SA1"), SA1->A1_COD, SA1->A1_LOJA}), .T.)
		lContinua := IIf(lAtuSA1 .And. lTrvSA1, RecLock("SA1"), .T.)
	EndIf
	cFilSC6 := xFilial("SC6")
	If !(cFilSC6==SC6->C6_FILIAL .And.;
			SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
			SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
			SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO)
		SC6->(dbSetOrder(1))
		SC6->(MsSeek(cFilSC6+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO))
	EndIf
	cFilSF4 := xFilial("SF4")
	If !cFilSF4+SC6->C6_TES == SF4->F4_FILIAL+SF4->F4_CODIGO
		SF4->(dbSetOrder(1))
		SF4->(MsSeek(cFilSF4+SC6->C6_TES))
	EndIf
	If lContinua
		If !lRemito
			(cAliasSC9)->C9_BLCRED  := "10"
			(cAliasSC9)->C9_BLEST   := "10"
			(cAliasSC9)->C9_NFISCAL := SD2->D2_DOC
			(cAliasSC9)->C9_SERIENF := SD2->D2_SERIE
			(cAliasSC9)->C9_NUMSEQ := SD2->D2_NUMSEQ
			If GetNewPar("MV_NFS_JOB",.F.)
				(cAliasSC9)->C9_BLCRED  := "ZZ"
				(cAliasSC9)->C9_BLEST   := "ZZ"
			EndIf
			If ( SF4->F4_DUPLIC == "S" .And. !SC5->C5_TIPO$"DB" .And. !AllTrim(SC6->C6_BLQ)$"RS" )
				nMCusto :=  Iif(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC,Val(SuperGetMv("MV_MCUSTO")))
				If lMTValAvC
					nValAv	:=	ExecBLock("MTValAvC",.F.,.F.,{'MAAVALSC9',(cAliasSC9)->C9_QTDLIB*(cAliasSC9)->C9_PRCVEN,nEvento})
				Else
					nValAv	:=	(cAliasSC9)->C9_QTDLIB*(cAliasSC9)->C9_PRCVEN
				EndIf
				nSldLib := xMoeda(nValAV,SC5->C5_MOEDA,nMCusto,(cAliasSC9)->C9_DATALIB)
				lTrvSA1 := IIf(cPaisLoc == "BRA" .And. lFATTRVSA1, ExecBlock("FATTRVSA1", .F., .F., {xFilial("SA1"), SA1->A1_COD, SA1->A1_LOJA}), .T.)
				If lAtuSA1 .And. lTrvSA1
					Reclock("SA1",.F.)
					SA1->A1_SALPEDL -= nSldLib
					MsUnLock()
				EndIf
			EndIf
		Else
			(cAliasSC9)->C9_REMITO  := SD2->D2_DOC
			(cAliasSC9)->C9_SERIREM := SD2->D2_SERIE
			(cAliasSC9)->C9_ITEMREM := SD2->D2_ITEM
			(cAliasSC9)->C9_DTREMIT := SD2->D2_EMISSAO
		EndIf
	EndIf
	//Ŀ
	//Estorno do Documento de Saida                                           
	//
Case nEvento == 12
	If lRemito
		//Ŀ
		//Atualiza a Liberacao de Credito                                         
		//
		If !SC5->C5_TIPO$"DB" .And. SF4->F4_DUPLIC == "S"  .And. !AllTrim(SC6->C6_BLQ)$"RS"
			nMCusto  :=  If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC, Val(SuperGetMv("MV_MCUSTO")))
			If lMTValAvC
				nValAv	:=	ExecBLock("MTValAvC",.F.,.F.,{'MAAVALSC9',(cAliasSC9)->C9_QTDLIB*(cAliasSC9)->C9_PRCVEN,nEvento})
			Else
				nValAv	:=	(cAliasSC9)->C9_QTDLIB*(cAliasSC9)->C9_PRCVEN
			Endif

			nSldLib  := xMoeda(nValAv,SC5->C5_MOEDA,nMCusto,(cAliasSC9)->C9_DATALIB)

			If !lBlqCred
				SA1->A1_SALPEDL -= nSldLib
				nVlrCred 		 += nValAV
			Else
				SA1->A1_SALPEDB -= nSldLib
			EndIf
		EndIf
	Endif

	If SF4->F4_MOVPRJ $ "25" .and. SF4->F4_ESTOQUE == "S"
		PmsBxEmp(SC9->C9_PROJPMS, SC9->C9_TASKPMS, SC9->C9_PRODUTO, SC9->C9_LOCAL,SC9->C9_QTDLIB, "+", SC9->C9_QTDLIB2,SC9->C9_TRT)
	EndIf
EndCase
RestArea(aAreaSF4)
RestArea(aArea)
Return(.T.)

/*


Ŀ
Funcao    MatGrdSoma Autor Eduardo Riera           Data  26.02.99 
Ĵ
Descrio Atualizar a Quantidade Vendida com as Quantidades da Grade  
Ĵ
Retorno   ExpN1: Quantidade digitada na Grade                         
Ĵ
ParametrosExpN1: Linha do aCols Principal                             
          ExpN2: Quantidade digitada na Acols Principal               
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
          Erike Yuri      Esta funcao esta fora de uso.              
ٱ


*/
Function MatGrdSoma(nLinAcols,nQtdInf,nColQtd)

Local nColunas	:= 0
Local nLinhas	:= 0
Local nSoma		:= 0

//Ŀ
//Soma a Quantidade digitada na grade                                     
//
For nColunas:=2 to Len(aHeadGrade[nLinAcols])
	For nLinhas:=1 to Len(aColsGrade[nLinAcols])
		nSoma+=aColsGrade[nLinAcols][nLinhas][nColunas][nColQtd]
	Next nLinhas
Next nColunas
//Ŀ
//Verifica se ha divergencias                                             
//
If ( nSoma <> nQtdInf .And. nQtdInf <> 0 )
	Help(" ",1,"A410QTDDIF")
EndIf
Return(nSoma)


/*/


Ŀ
Funcao    MatGrdMont Autor Eduardo Riera           Data  23.02.99 
Ĵ
Descrio Montagem do aHeadGrade e do aColsGrade                      
Ĵ
Retorno   ExpL1: Logico                                               
Ĵ
ParametrosExpN1: Numero da Linha da GetDados Principal                
          ExpC2: Produto da Grade                                     
          ExpL3: Indica se deve ser reinicializada a Grade            
          ExpL4: Indica se os registros bloqueado devem ser considera-
                 dos.                                                 
Ĵ
ObservacaoEstrutura dos Array's de Grade                              
          - aHeadGrade                                                
            [xx]             Referencia a Linha do Acols Principal    
            [xx][01]         Indica se eh uma (R)Referencia ou (N)Nao 
            [xx][yy]         Colunas da Grade                         
          - aColsGrade                                                
            [xx]             Referencia a Linha do Acols Principal    
            [xx][yy]         Referencia a Linha da Grade              
            [xx][yy][01]     Codigo da Linha da Grade                 
            [xx][yy][zz]     Referencia a Coluna da Grade             
            [xx][yy][zz][01] Quantidade Vendida                       
            [xx][yy][zz][02] Quantidade Liberada                      
            [xx][yy][zz][03] Quantidade ja Liberada                   
            [xx][yy][zz][04] Item do SC6                              
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
          Erike Yuri      Esta funcao esta fora de uso               
ٱ


/*/
Function MatGrdMont(nCnt,cProdGrd,lAlterou,lBloqueados)

Local aArea       := GetArea()
Local aAreaSB1    := SB1->(GetArea())
Local aTam        := {}
Local aColuna     := {}
Local aLinha      := {}

Local lRefer      := .F.

Local cProdRef    := ""
Local cMascara    := SuperGetMv("MV_MASCGRD")

Local nCntFor     := 0
Local nCntFor2    := 0
Local nTamRef     := Val(Substr(cMascara,1,2))
Local nTamLin     := Val(Substr(cMascara,4,2))
Local nTamCol     := Val(Substr(cMascara,7,2))
Local nLinhas     := 0

cProdGrd    := If(cProdGrd==Nil,"",cProdGrd)
cProdRef    := cProdGrd
//Ŀ
//Verifica se o Produto e uma referencia                                  
//
lReFer := MatGrdPrrf(@cProdRef)
//Ŀ
//Inicializa os Parametros com seus valores default                       
//
lAlterou := If(lAlterou==Nil,.F.,lAlterou)
DEFAULT lBloqueados := .F.

//Ŀ
//Tratamento da Grade de Produtos                                         
//
If ( !lRefer )
	//Ŀ
	//Produto que nao possuem controle de grade.                              
	//
	If ( Len(aHeadGrade) >= nCnt )
		aHeadGrade[nCnt]  := {}
		AAdd(aHeadGrade[nCnt],"N")
		aColsGrade[nCnt] := {}
	Else
		While Len(aHeadGrade) < nCnt
			AAdd(aHeadGrade,{})
			AAdd(aHeadGrade[Len(aHeadGrade)],"N")
			AAdd(aColsGrade,{})
		EndDo
	EndIf
Else
	//Ŀ
	//Produto que possue controle por grade                                   
	//
	dbSelectArea("SB4")
	dbSetOrder(1)
	MsSeek(xFilial("SB4")+cProdRef)
	If ( Len(aHeadGrade) >= nCnt )
		//Ŀ
		// Quando existe, verifica se o array era de um produto     
		// referencia, se ja era ok, se nao deve criar o array de   
		// novo                                                     
		//
		If ( aHeadGrade[nCnt][1] == "N" .Or. lAlterou )
			aHeadGrade[nCnt]  := {}
			AAdd(aHeadGrade[nCnt],{})
			aHeadGrade[nCnt][1] := "R"
			aTam:=TamSX3("C6_QTDVEN")
			//Ŀ
			//Verifica as Linhas e Colunas da Grade pelo produto                      
			//
			If ExistBlock("PVORDGRL") .And. ExistBlock("PVORDGRC")
				aLinha  := ExecBlock("PVORDGRL",.F.,.F.,{cProdRef})
				aColuna := ExecBlock("PVORDGRC",.F.,.F.,{cProdRef})
			Else
				dbSelectArea("SB1")
				dbSetOrder(1)
				MsSeek(xFilial("SB1")+cProdRef)
				While ( !Eof() .And. SB1->B1_FILIAL == xFilial("SB1") .And.;
						SubStr(SB1->B1_COD,1,nTamRef) == cProdRef )
					If SB1->B1_GRADE # "S" .And. ( !RegistroOk("SB1",.F.) .Or. lbloqueados )
						dbSkip()
						Loop
					EndIf
					If ( aScan(aColuna,SubStr(SB1->B1_COD,nTamRef+nTamLin+1,nTamCol))==0 )
						AAdd(aColuna,SubStr(SB1->B1_COD,nTamRef+nTamLin+1,nTamCol))
					EndIf
					If ( aScan(aLinha,SubStr(SB1->B1_COD,nTamRef+1,nTamLin))==0 )
						AAdd(aLinha,SubStr(SB1->B1_COD,nTamRef+1,nTamLin))
					EndIf
					dbSelectArea("SB1")
					dbSkip()
				EndDo
			EndIf
			If GetNewPar("MV_ORDGRDP",.T.)
				aColuna  := aSort(aColuna)
				aLinha   := aSort(aLinha)
			EndIf
			//Ŀ
			//Verifica a Coluna da Grade                                              
			//
			For nCntFor := 1 To Len(aColuna)
				AAdd(aHeadGrade[nCnt],{  aColuna[nCntFor],;
					"_"+A550RemoveSinal(aColuna[nCntFor]),;
					PesqPictQt("C6_QTDVEN",14),;
					aTam[1],;
					aTam[2],;
					"A410GValid()",;
					"",;
					"C",;
					" ",;
					" " })
			Next nCntFor
			//Ŀ
			//Verifica a Linha da Grade                                               
			//
			aColsGrade[nCnt]  := {}
			For nCntFor := 1 To Len(aLinha)
				nLinhas++
				For nCntFor2 := 1 To Len(aHeadGrade[nCnt])
					If ( nCntFor2 == 1 )
						AAdd(aColsGrade[nCnt],{})
						AAdd(aColsGrade[nCnt][nLinhas],aLinha[nCntFor])
					Else
						AAdd(aColsGrade[nCnt][nLinhas],{0,0,0,"",0})
					EndIf
				Next nCntFor2
				AAdd(aColsGrade[nCnt][nLinhas],.F.)
			Next nCntFor
		EndIf
	Else
		aTam:=TamSX3("C6_QTDVEN")
		AAdd(aHeadGrade,{})
		AAdd(aHeadGrade[nCnt],"R")
		//Ŀ
		//Verifica as Linhas e Colunas da Grade pelo produto                      
		//
		If ExistBlock("PVORDGRL") .And. ExistBlock("PVORDGRC")
			aLinha  := ExecBlock("PVORDGRL",.F.,.F.,{cProdRef})
			aColuna := ExecBlock("PVORDGRC",.F.,.F.,{cProdRef})
		Else
			dbSelectArea("SB1")
			dbSetOrder(1)
			MsSeek(xFilial("SB1")+cProdRef)
			While ( !Eof() .And. SB1->B1_FILIAL == xFilial("SB1") .And.;
					SubStr(SB1->B1_COD,1,nTamRef) == cProdRef )
				If RegistroOk("SB1",.F.) .Or. lBloqueados
					If ( aScan(aColuna,SubStr(SB1->B1_COD,nTamRef+nTamLin+1,nTamCol))==0 )
						AAdd(aColuna,SubStr(SB1->B1_COD,nTamRef+nTamLin+1,nTamCol))
					EndIf
					If ( aScan(aLinha,SubStr(SB1->B1_COD,nTamRef+1,nTamLin))==0 )
						AAdd(aLinha,SubStr(SB1->B1_COD,nTamRef+1,nTamLin))
					EndIf
				EndIf
				dbSelectArea("SB1")
				dbSkip()
			EndDo
		EndIf
		If GetNewPar("MV_ORDGRDP",.T.)
			aColuna  := aSort(aColuna)
			aLinha   := aSort(aLinha)
		EndIf
		//Ŀ
		//Verifica a Colunas                                                      
		//
		For nCntFor := 1 To Len(aColuna)
			AAdd(aHeadGrade[nCnt],{  aColuna[nCntFor],;
				"_"+A550RemoveSinal(aColuna[nCntFor]),;
				PesqPictQt("C6_QTDVEN",14),;
				aTam[1],;
				aTam[2],;
				"A410GValid()",;
				"",;
				"C",;
				" ",;
				" " })
		Next nCntFor
		//Ŀ
		//Verifica as Linhas                                                      
		//
		AAdd(aColsGrade,{})
		For nCntFor := 1 To Len(aLinha)
			nLinhas++
			For nCntFor2 := 1 To Len(aHeadGrade[nCnt])
				If ( nCntFor2 == 1 )
					AAdd(aColsGrade[nCnt],{})
					AAdd(aColsGrade[nCnt][nLinhas],aLinha[nCntFor])
				Else
					AAdd(aColsGrade[nCnt][nLinhas],{0,0,0,"",0})
				EndIf
			Next nCntFor2
		Next nCntFor
	EndIf
EndIf
RestArea(aAreaSB1)
RestArea(aArea)
Return(lRefer)

/*/


Ŀ
Funcao    FTReprEst  Autor  Sergio Silveira        Data 20/02/2001
Ĵ
Descrio  Retorna os grupos abaixo de um representante ( vendedor )  
Ĵ
Sintaxe    ExpA1 := FTReprEst( ExpC1 )                                
Ĵ
Retorno    ExpA1 -> Array com os grupos do representante.             
               1 - Grupo / 2 - String com acessos da workare          
Ĵ
Parametros ExpC1 -> Representante.                                    
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function FTReprEst( cRepres )

Local aArea		 := GetArea()
Local aGruposEst := {}

SA3->( dbSetOrder( 1 ) )
If SA3->( DbSeek( xFilial( "SA3" ) + cRepres ) )
	FTGrupRepr( SA3->A3_GRPREP, @aGruposEst )
EndIf

RestArea(aArea)

Return( aGruposEst )

/*/


Ŀ
Funcao    FTGrupRepr Autor  Sergio Silveira        Data 20/02/2001
Ĵ
Descrio  Faz a inclusao dos grupos ( funcao recursiva )             
Ĵ
Sintaxe    FTGrpRepr( ExpC1, @ExpA1 )                                 
Ĵ
Retorno    .T.                                                        
Ĵ
Parametros ExpC1 -> Grupo incluido / ExpA1 -> Array de grupos.        
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function FTGrupRepr( cGrupoInc, aGruposEst )

Local aRecnoACA  := {}
Local nLoop      := 0
Local lExistADK  := ChkFile("ADK")
Local cQuery     := ""
Local cAliasQry  := ""

ACA->( dbSetOrder( 1 ) )
If ACA->( DbSeek( xFilial( "ACA" ) + cGrupoInc ) )

	//Ŀ
	// Inclui os grupos que tem este grupo como superior            
	//
	aRecnoACA := {}

	cAliasQry := GetNextAlias()
	cQuery    := ""

	cQuery += "SELECT R_E_C_N_O_ ACARECNO FROM " + RetSqlName( "ACA" ) + " "
	cQuery += "WHERE "
	cQuery += "ACA_FILIAL='" + xFilial( "ACA" ) + "' AND "
	cQuery += "ACA_GRPSUP='" + cGrupoInc        + "' AND "
	cQuery += "ACA_TIPSUP = '2GR' AND "
	cQuery += "D_E_L_E_T_ = ' '"

	cQuery := ChangeQuery(cQuery)

	dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasQry, .F., .T. )
	dbGoTop()
	While !Eof()
		AAdd( aRecnoACA, ACARECNO )
		dbSkip()
	EndDo
	(cAliasQry)->(dbCloseArea())

	If lExistADK
		cAliasQry2 := GetNextAlias()
		cQuery    := ""

		cQuery += "SELECT ACA.R_E_C_N_O_ ACARECNO FROM " + RetSqlName( "ADK" ) + " ADK "
		cQuery += "INNER JOIN " + RetSqlName( "ACA" ) + " ACA ON ADK.ADK_COD = ACA.ACA_GRPSUP AND ACA.D_E_L_E_T_ = ' ' "
		cQuery += "WHERE "
		cQuery += "ADK_FILIAL='" + xFilial( "ADK" ) + "' AND "
		cQuery += "ADK_GRUNVE='" + cGrupoInc        + "' AND "
		cQuery += "ADK.D_E_L_E_T_ = ' ' "

		cQuery := ChangeQuery(cQuery)

		dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasQry2, .F., .T. )
		dbGoTop()
		While !Eof()
			AAdd( aRecnoACA, ACARECNO )
			dbSkip()
		EndDo
		(cAliasQry2)->(dbCloseArea())
	EndIf

	//Ŀ
	// Processa a lista de recnos                                   
	//
	For nLoop := 1 To Len( aRecnoACA )
		ACA->( MsGoto( aRecnoACA[ nLoop ] ) )
		//Ŀ
		// Inclui este grupo                                            
		//
		AAdd( aGruposEst, { ACA->ACA_GRPREP, ACA->ACA_ACCLIE + ACA->ACA_ACPROS + ;
			ACA->ACA_ACPIPE + ACA->ACA_ACAPON + ACA->ACA_ACOPOR + ACA->ACA_ACESTR + ACA->ACA_MODCLI + ;
			ACA->ACA_MODPRO + "11" + ACA->ACA_MODOPO + ACA->ACA_MODEST } )

			FTGrupRepr( ACA->ACA_GRPREP, @aGruposEst )

	Next nLoop
EndIf
Return(.T.)
/*/


Ŀ
Funcao    MaNeedP3   Autor  Eduardo Riera          Data 02/04/2002
Ĵ
Descrio Funcao de analise da Necessidade do Saldo do Poder de 3     
Ĵ
Sintaxe   ExpN1 := MaNeedP3()                                         
Ĵ
Retorno   ExpA1: [1] Saldo proprio necessario                         
                 [2] Saldo do Poder de Terceiro Necessario            
Ĵ
ParametrosExpN1: Quantidade Necessaria                                
          ExpN2: Quantidade ja reservada                         (OPC)
                                                                      
Ĵ
ObservacaoA Tes e o item do pedido de venda devem estar posicionados  
                                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function MaNeedP3(nQtdLib,nQtdReserva)

Local aArea      := GetArea()
Local aAreaSC9   := SC9->(GetArea())
Local aSaldos    := {0,0,0}
Local nSldFisico := 0
Local nSldPoder3 := 0
Local nSldNosso  := 0
Local nSldNPT    := 0
Local nQtdJaReser:= 0
Local nQtdJaLib  := 0
Local cQuery     := ""

DEFAULT nQtdReserva := 0
//Ŀ
// Verifica se eh necessario o saldo de poder de terceiro                 
//
If !Empty(SF4->F4_TESP3) .And. nQtdLib > 0 .And. SF4->F4_ESTOQUE=="S" .And.;
		SF4->F4_PODER3=="N" .And. Empty(SC6->C6_RESERVA)
	//Ŀ
	// Calcula o disponivel considerando o poder de teceiro                   
	//
	nSldFisico := SldAtuEst(SC6->C6_PRODUTO,SC6->C6_LOCAL,999999999999,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,SC6->C6_SERVIC)
	//Ŀ
	// Calcula o disponivel nao considerando o poder de teceiro               
	//
	nSldNosso  := Max(SldAtuEst(SC6->C6_PRODUTO,SC6->C6_LOCAL,999999999999,Nil,Nil,Nil,Nil,Nil,.F.,NIL,NIL,NIL,SC6->C6_SERVIC),0)
	//Ŀ
	// Verifica o saldo em poder de terceiro ja liberado                      
	//
	cQuery := "SELECT SUM(C9_QTDLIB) QTDLIB "
	cQuery += "FROM "+RetSqlName("SC9")+" SC9 "
	cQuery += "WHERE SC9.C9_FILIAL='"+xFilial("SC9")+"' AND "
	cQuery += "SC9.C9_PRODUTO='"+SC6->C6_PRODUTO+"' AND "
	cQuery += "SC9.C9_LOCAL='"+SC6->C6_LOCAL+"' AND "
	cQuery += "SC9.C9_BLEST='"+Space(Len(SC9->C9_BLEST))+"' AND "
	cQuery += "SC9.C9_BLCRED='"+Space(Len(SC9->C9_BLCRED))+"' AND "
	cQuery += "SC9.C9_IDENTB6<>'"+Space(Len(SC9->C9_IDENTB6))+"' AND "
	cQuery += "SC9.D_E_L_E_T_=' ' "

	cQuery := ChangeQuery(cQuery)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"MANEEDP3",.T.,.T.)
	nSldFisico += QTDLIB
	nQtdJaLib := QTDLIB
	dbCloseArea()
	dbSelectArea("SC9")
	nSldPoder3 := nSldFisico-nQtdJaLib
	If nQtdLib > nSldNosso
		aSaldos[1] := Min(nQtdLib,nSldNosso)
		aSaldos[2] := Min(nQtdLib-nSldNosso,nSldPoder3)
	Else
		aSaldos[1] := Min(nQtdLib,nSldNosso)
	EndIf
Else
	aSaldos[1] := nQtdLib
EndIf
//Ŀ
// Verifica se eh necessario o saldo de poder em terceiro                 
//
If aSaldos[2]==0 .And. nQtdLib > 0 .And. SF4->F4_ESTOQUE=="S" .And.;
		SF4->F4_PODER3=="N" .And. Empty(SC6->C6_RESERVA) .And.;
		SF4->F4_SLDNPT=="1"
	//Ŀ
	// Calcula o disponivel considerando o poder de teceiro                   
	//
	nSldFisico := SldAtuEst(SC6->C6_PRODUTO,SC6->C6_LOCAL,nQtdLib,Nil,Nil,Nil,Nil,Nil,Nil,.F.,NIL,NIL,SC6->C6_SERVIC)
	nSldFisico += nQtdReserva
	If nSldFisico < 0
		nQtdJaReser := Abs(nSldFisico)
		nSldFisico  := 0
	EndIf
	If nSldFisico < nQtdLib
		nSldNPT := SldAtuEst(SC6->C6_PRODUTO,SC6->C6_LOCAL,nQtdLib+nQtdJaReser,Nil,Nil,Nil,Nil,Nil,Nil,.T.,NIL,NIL,SC6->C6_SERVIC)-nSldFisico
		If nSldNPT > 0 .And. nSldNPT >= nQtdJaReser+nQtdLib
			aSaldos[1] := Min(nQtdLib,nSldFisico)
			aSaldos[3] := Min(nQtdLib-aSaldos[1],nSldNPT)
		EndIf
	EndIf
EndIf
RestArea(aAreaSC9)
RestArea(aArea)
Return(aSaldos)


/*


Ŀ
Funcao    FaAvRestri Autor  Sergio Silveira        Data 19/07/2002
Ĵ
Descrio Funcao de avaliacao das restricoes de visita                
Ĵ
Sintaxe   ExpA1 := FaAvRestri(ExpC1,ExpC2,ExpN1,[ExpC3],ExpD1,[ExpC4],
             [ExpC5],[ExpC6] )                                        
Ĵ
Retorno   ExpA1: Array contendo a seguintes elementos : { 1, 2, 3, 4 }
           1 - Tipo L - Indica se existe restricao                    
           2 - Tipo L - Indica se conseguiu sugerir um novo horario   
             apos a restricao ( apenas quando elem. 1 igual a .f. )   
           3 - Tipo C - Novo horario de inicio - Valido apenas quando 
                   elem. 2 = .T.                                      
           4 - Tipo C - Novo horario de fim    - Valido apenas quando 
                   elem. 2 = .T.                                      
Ĵ
ParametrosExpC1: Codigo do Cliente                                    
          ExpC2: Loja do cliente                                      
          ExpN1: Tipo de restricao: 1-Visita / 2-Entrega / 3-Ambos    
          ExpC3: Contato                                              
          ExpD1: Data de referencia                                   
          ExpC4: Hora inicial ou hora de referencia                   
          ExpC5: Hora final                                           
          ExpC6: Hora limite                                          
                                                                      
          O parametros de horario nao sao obrigatorios. E permitido   
          passar apenas o horario inicial e nesta situacao apenas     
          este sera verificado. O parametro hora limite e utilizado   
          para limitar o horario maximo permitido quando o sistema    
          sugerir um novo horario imediatamente apos uma restricao    
          existente.                                                  
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function FaAvRestri( cCodCli, cLoja, nAbrang, cContato, dDataAval, cHoraIni, cHoraFim, cHrLimite )

Local aGrupos   := {}
Local aArea     := GetArea()

Local bAbrang   := { || .T. }
Local bContato  := { || .T. }

Local cSeekACW  := ""
Local cQuery    := ""
Local cAliasQry := ""
Local cHrIniNew := ""
Local cHrFimNew := ""
Local cContNull := Space( Len( ACW->ACW_CODCON ) )

Local lRet      := .T.
Local lContinua := .T.
Local lHora     := ( ValType( cHoraIni ) == "C" )
Local lContato  := ( ValType( cContato ) == "C" )
Local lHoraNew  := .F.

Local nLoop     := 0
Local nRecnoACW := 0
Local nMinuto   := 1 / 60
Local nTempo    := 0

If lHora
	cHoraFim := If( ValType( cHoraFim ) == "C", cHoraFim, cHoraIni )
EndIf

bContato := If( lContato, { || ACW->ACW_CODCON == cContato .Or. ACW->ACW_CODCON == cContNull }, { || .T. } )

If nAbrang == 1
	bAbrang := { || ACW->ACW_ABRANG $ "13" }
ElseIf nAbrang == 2
	bAbrang := { || ACW->ACW_ABRANG $ "23" }
EndIf

SA1->( dbSetOrder( 1 ) )
If SA1->( MsSeek( xFilial( "SA1" ) + cCodCli + cLoja ) )

	//Ŀ
	// Pesquisa uma restricao para o cliente                                   
	//
	cSeekACW := xFilial( "ACW" ) + SA1->A1_COD + SA1->A1_LOJA + DTOS( dDataAval )
	ACW->( dbSetOrder( 3 ) )
	If ACW->( MsSeek( cSeekACW ) )
		If lHora

			//Ŀ
			// Pesquisa o horario da restricao                                         
			//
			cAliasQry := "FAAVRESTRI"

			cQuery := ""
			cQuery += "SELECT ACW.*, R_E_C_N_O_ ACWRECNO FROM " + RetSqlName( "ACW" ) + " ACW "
			cQuery += "WHERE "
			cQuery += "ACW_FILIAL='"   + xFilial( "ACW" ) + "' AND "
			cQuery += "ACW_CODCLI='"   + SA1->A1_COD      + "' AND "
			cQuery += "ACW_LOJA='"     + SA1->A1_LOJA     + "' AND "
			cQuery += "ACW_DATA='"     + DTOS( dDataAval )+ "' AND "

			If nAbrang == 1
				cQuery += "ACW_ABRANG IN ( '1', '3' ) AND "
			ElseIf nAbrang == 2
				cQuery += "ACW_ABRANG IN ( '2', '3' ) AND "
			EndIf

			If lContato
				cQuery += " ( ACW_CODCON='" + cContato + "' OR ACW_CODCON='" + cContNull + "' ) AND "
			EndIf

			cQuery += "( ( ACW_HORA1>='" + cHoraIni     + "' AND "
			cQuery += "ACW_HORA1<='"     + cHoraFim         + "' ) OR "

			cQuery += "( ACW_HORA2>='"   + cHoraIni     + "' AND "
			cQuery += "ACW_HORA2<='"     + cHoraFim     + "' ) OR "

			cQuery += "( '" + cHoraIni + "'>=ACW_HORA1 AND "
			cQuery += "'"   + cHoraIni + "'<=ACW_HORA2 ) OR "
			cQuery += "( '" + cHoraFim + "'>=ACW_HORA1 AND "
			cQuery += "'"   + cHoraFim + "'<=ACW_HORA2 ) ) AND "

			cQuery += "D_E_L_E_T_ = ' ' "
			cQuery += "ORDER BY " + SqlOrder( ACW->( IndexKey() ) )

			cQuery := ChangeQuery( cQuery )

			dbUseArea( .T., "TOPCONN", TcGenQry( ,, cQuery ), cAliasQry, .F., .T. )

			TcSetField( cAliasQry, "ACWRECNO", "N", 10, 0 )

			//Ŀ
			// Verifica o primeiro que atende a situacao                               
			//
			If !( cAliasQry )->( Eof() )
				lRet      := ( ( cAliasQry )->ACW_TIPO == "2" )
				lContinua := .F.
				nRecnoACW := ( cAliasQry )->ACWRECNO
			EndIf

			//Ŀ
			// Fecha a area de trabalho da query                                       
			//
			( cAliasQry )->( dbCloseArea() )
			dbSelectArea( "ACW" )
		Else
			lRet      := ( ACW->ACW_TIPO == "2" )
			lContinua := .F.
		EndIf
	EndIf

	//Ŀ
	// Se nao encontrou regra para o cliente, pesquisa uma regra para o grupo  
	//
	If lContinua

		If !Empty( SA1->A1_GRPVEN )

			//Ŀ
			// Obtem todos os grupos acima na estrutura                                
			//
			aGrupos := {}
			MaCliStrUp( SA1->A1_GRPVEN, @aGrupos )

			//Ŀ
			// ordena os grupos por nivel                                              
			//
			ASort( aGrupos, , , { |x,y| y[2] > x[2] } )

			//Ŀ
			// Percorre todos os grupos de baixo para cima                             
			//
			For nLoop := 1 To Len( aGrupos )

				//Ŀ
				// Persquisa uma restricao para o grupo atual                              
				//
				cSeekACW := xFilial( "ACY" ) + aGrupos[ nLoop, 1 ] + DTOS( dDataAval )

				ACW->( dbSetOrder( 2 ) )
				If ACW->( MsSeek( cSeekACW ) )
					If lHora
						//Ŀ
						// Verifica se a restricao encontra-se no horario                          
						//
						cAliasQry := "FAAVRESTR2"

						cQuery := ""
						cQuery += "SELECT ACW.*, R_E_C_N_O_ ACWRECNO FROM " + RetSqlName( "ACW" ) + " ACW "
						cQuery += "WHERE "
						cQuery += "ACW_FILIAL='"   + xFilial( "ACW" )    + "' AND "
						cQuery += "ACW_GRPVEN='"   + aGrupos[ nLoop, 1 ] + "' AND "
						cQuery += "ACW_DATA='"     + DTOS( dDataAval )   + "' AND "

						If nAbrang == 1
							cQuery += "ACW_ABRANG IN ( '1', '3' ) AND "
						ElseIf nAbrang == 2
							cQuery += "ACW_ABRANG IN ( '2', '3' ) AND "
						EndIf

						If lContato
							cQuery += " ( ACW_CODCON='" + cContato + "' OR ACW_CODCON='" + cContNull + "' ) AND "
						EndIf

						cQuery += "( ( ACW_HORA1>='" + cHoraIni     + "' AND "
						cQuery += "ACW_HORA1<='"     + cHoraFim     + "' ) OR "

						cQuery += "( ACW_HORA2>='"   + cHoraIni     + "' AND "
						cQuery += "ACW_HORA2<='"     + cHoraFim     + "' ) OR "

						cQuery += "( '" + cHoraIni + "'>=ACW_HORA1 AND "
						cQuery += "'"   + cHoraIni + "'<=ACW_HORA2 ) OR "
						cQuery += "( '" + cHoraFim + "'>=ACW_HORA1 AND "
						cQuery += "'"   + cHoraFim + "'<=ACW_HORA2 ) ) AND  "

						cQuery += "D_E_L_E_T_ = ' ' "
						cQuery += "ORDER BY " + SqlOrder( ACW->( IndexKey() ) )

						cQuery := ChangeQuery( cQuery )

						dbUseArea( .T., "TOPCONN", TcGenQry( ,, cQuery ), cAliasQry, .F., .T. )

						TcSetField( cAliasQry, "ACWRECNO", "N", 10, 0 )

						//Ŀ
						// Verifica o primeiro que atende a situacao                               
						//
						If !( cAliasQry )->( Eof() )
							lRet      := ( ( cAliasQry )->ACW_TIPO == "2" )
							lContinua := .F.
							nRecnoACW := ( cAliasQry )->ACWRECNO
						EndIf

						//Ŀ
						// Fecha a area de trabalho da query                                       
						//
						( cAliasQry )->( dbCloseArea() )

						dbSelectArea( "ACW" )

					Else
						lRet      := ( ACW->ACW_TIPO == "2" )
						lContinua := .F.
					EndIf

				EndIf

				//Ŀ
				// Se ja encontrou uma restricao, abandona                                 
				//
				If !lContinua
					Exit
				EndIf

			Next nLoop

		EndIf

	EndIf

EndIf

//Ŀ
// Se possui restricao e considera hora, tenta obter um novo horario sem restricao 
//
If !lRet .And. lHora

	If !Empty( nRecnoACW )

		ACW->( MsGoto( nRecnoACW ) )

		//Ŀ
		// Caso nao seja passado horario limite, o limite e' 23:59                         
		//
		cHrLimite := If( ValType( cHrLimite ) == "C", cHrLimite, "23:59" )
		lHoraNew  := .T.

		//Ŀ
		// Calcula o tempo de alocacao                                                     
		//
		nTempo := SubtHoras( dDataAval, cHoraIni, dDataAval, cHoraFim )

		//Ŀ
		// Soma um minuto ao horario final da restricao para encontrar o novo horario ini  
		//
		cHrIniNew := AtSomaHora( ACW->ACW_HORA2, nMinuto )
		cHrFimNew := AtSomaHora( cHrIniNew, nTempo )

		//Ŀ
		// Verifica se e possivel alocar para o dia                                        
		//
		If cHrIniNew > cHrLimite .Or. cHrFimNew > cHrLimite
			lHoraNew := .F.
		EndIf

		If !lHoraNew
			cHrIniNew := cHoraIni
			cHrFimNew := cHoraFim
		EndIf

	EndIf

EndIf

RestArea( aArea )

Return( { lRet, lHoraNew, cHrIniNew, cHrFimNew } )

/*


Ŀ
Funo    MaCliStru  Autor Sergio Silveira         Data 16/05/2002
Ĵ
Descrio  Traz todos os grupos abaixo de um grupo de clientes        
           ( recursiva )                                              
Ĵ
Sintaxe    MaCliStru( ExpC1, @ExpA1, [ ExpN1 ] )                      
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros ExpC1 -> Grupo a pesquisar                                 
           ExpA1 -> Array contendo os grupos. Deve ser passado por    
              referencia e alimentado pela funcao                     
                 Estrutura : 1 - Grupo ( C )                          
                             2 - Nivel do grupo ( N )                 
           ExpN1 -> Nivel atual. Este parametro nao deve ser passado  
           na chamada inicial, pois e passado quando a funcao chama   
           ela mesma ( recursividade )                                
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function MaCliStru( cGrpSup, aGrupos, nLevel )

Local cAliasQry := ""
Local cQuery    := ""

If ValType( nLevel ) <> "N"
	nLevel := 0
EndIf

//Ŀ
// Incrementa o contador de niveis                              
//

nLevel++

cAliasQry := GetNextAlias()

cQuery := ""
cQuery += "SELECT ACY_GRPVEN, ACY_GRPSUP FROM " + RetSqlName( "ACY" ) + " "
cQuery += "WHERE "
cQuery += "ACY_FILIAL='" + xFilial( "ACY" ) + "' AND "
cQuery += "ACY_GRPSUP='" + cGrpSup          + "' AND "
cQuery += "D_E_L_E_T_ = ' '"

cQuery := ChangeQuery( cQuery )

dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasQry, .F., .T. )

If Alias() == cAliasQry
	While !( cAliasQry )->( Eof() )
		AAdd( aGrupos, { ( cAliasQry )->ACY_GRPVEN, nLevel } )
		MaCliStru( ( cAliasQry )->ACY_GRPVEN, @aGrupos, @nLevel )
		( cAliasQry )->( dbSkip() )
	EndDo
	dbCloseArea()
	dbSelectArea( "ACY" )
EndIf

//Ŀ
// Decrementa o contador de niveis                              
//
nLevel--

Return()

/*


Ŀ
Funo    MaCliStrUp Autor Sergio Silveira         Data 19/07/2002
Ĵ
Descrio  Traz todos os grupos acima de um grupo de clientes         
           Funcao de chamada                                          
Ĵ
Sintaxe    MaCliStrUp( ExpC1, @ExpA1, [ ExpL1 ] )                     
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros ExpC1 -> Grupo a pesquisar                                 
           ExpA1 -> Array contendo os grupos. Deve ser passado por    
              referencia e alimentado pela funcao                     
                 Estrutura : 1 - Grupo ( C )                          
                             2 - Nivel do grupo ( N )                 
           ExpL1 -> Inverte a contagem de niveis no array. Quando     
           .T., a ordem passa a ser de cima para baixo                
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function MaCliStrUp( cGrpAtu, aGrupos, lInverte )

Local aArea    := GetArea()
Local aAreaACY := ACY->( GetArea() )

lInverte := If( ValType( lInverte ) == "L", lInverte, .F. )

//Ŀ
// Chama a funcao de processamento                              
//
MaPrcStrUp( cGrpAtu, @aGrupos )

//Ŀ
// Inverte a ordem de niveis                                    
//
If lInverte
	ASort( aGrupos, , , { |x,y| x[ 2 ] > y[ 2 ] } )
	AEval( aGrupos, { |x,y| x[ 2 ] := y } )
EndIf

RestArea( aAreaACY )
RestArea( aArea )

Return( .T. )

/*


Ŀ
Funo    MaPrcStrUp Autor Sergio Silveira         Data 19/07/2002
Ĵ
Descrio  Traz todos os grupos acima de um grupo de clientes         
           ( processamento )                                          
Ĵ
Sintaxe    MaPrcStrUp( ExpC1, @ExpA1, [ ExpN1 ] )                     
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros ExpC1 -> Grupo a pesquisar                                 
           ExpA1 -> Array contendo os grupos. Deve ser passado por    
              referencia e alimentado pela funcao                     
                 Estrutura : 1 - Grupo ( C )                          
                             2 - Nivel do grupo ( N )                 
           ExpN1 -> Nivel atual. Este parametro nao deve ser passado  
           na chamada inicial, pois e passado quando a funcao chama   
           ela mesma ( recursividade )                                
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function MaPrcStrUp( cGrpAtu, aGrupos, nLevel )

Local cSeekACY  := ""

If ValType( nLevel ) <> "N"
	nLevel := 0
EndIf

//Ŀ
// Incrementa o contador de niveis                              
//

nLevel++

ACY->( dbSetOrder( 1 ) )
cSeekACY := xFilial( "ACY" ) + cGrpAtu
If ACY->( MsSeek( cSeekACY ) )
	AAdd( aGrupos, { ACY->ACY_GRPVEN, nLevel } )
	MaPrcStrUp( ACY->ACY_GRPSUP, @aGrupos, @nLevel )
EndIf

//Ŀ
// Decrementa o contador de niveis                              
//
nLevel--

Return()

/*


Ŀ
Funo    FaIsOnStru Autor Sergio Silveira         Data 30/07/2002  
Ĵ
Descrio Verifica se um grupo de clientes esta contido na estrutura de 
          outro grupo de clientes                                       
Ĵ
Sintaxe   ExpL1 := FaIsOnStru( ExpC1, ExpC2 )                           
Ĵ
ParametrosExpC1: Grupo pai                                              
          ExpC2: Grupo filho                                            
Ĵ
Retorno   ExpL1: Validacao : .T. contido, .F. nao contido               
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ
 AtualizACQes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


*/

Function FaIsOnStru( cGrpPai, cGrpFilho )

Local aStruUp  := {}
Local lRetorno := .F.

//Ŀ
// Carrega a estrutura que esta acima do filho                  
//
MaCliStrUp( cGrpFilho, @aStruUp )

//Ŀ
// Verifica se o pai esta acima ou e igual ao filho             
//
lRetorno := !Empty( AScan( aStruUp, { |x| x[1] == cGrpPai } ) )

Return( lRetorno )

/*


Ŀ
Funo    FtVldQtVen Autor Henry Fila              Data 17/01/2003  
Ĵ
Descrio Verifica se uma quantidade de venda de um produto esta sendo  
          vendida com seu lote minimo                                   
Ĵ
Sintaxe   ExpL1 := FtVldQtVen( ExpC1, ExpC2,ExpL1 )                     
Ĵ
ParametrosExpC1: Produto                                                
          ExpC2: Quantidade                                             
          ExpL3: Mostra help ou nao                                     
Ĵ
Retorno   ExpL1: Validacao : .T. valido , .F. nao valido                
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ
 AtualizACQes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


*/
Function FtVldQtVen(cProduto,nQtde,lHelp,cTipo)

Local lRet     := .T.
Local aArea    := GetArea()
Local aAreaSB1 := SB1->(GetArea())

DEFAULT lHelp := .T.
DEFAULT cTipo := "N"

SB1->(dbSetOrder(1))
If SB1->(MsSeek(xFilial("SB1")+cProduto))
	If cTipo == "N" .And. SB1->B1_LOTVEN <> 0 .And. SB1->B1_LOTVEN > nQtde
		If lHelp
			Help(" ",1,"FTQTDMIN")
		Endif
		lRet := .F.
		If ExistBlock( "FTQTDMIN" )
			lRet := ExecBlock( "FTQTDMIN", .F., .F. )
		EndIf
	Endif
Endif

RestArea(aAreaSB1)
Restarea(aArea)

Return(lRet)

/*


Ŀ
Funo    MaVenStrUp Autor Sergio Silveira         Data 19/07/2002
Ĵ
Descrio  Traz todos os grupos acima de um grupo de vendedores       
           Funcao de chamada                                          
Ĵ
Sintaxe    MaVenStrUp( ExpC1, @ExpA1, [ ExpL1 ] )                     
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros ExpC1 -> Grupo a pesquisar                                 
           ExpA1 -> Array contendo os grupos. Deve ser passado por    
              referencia e alimentado pela funcao                     
                 Estrutura : 1 - Grupo ( C )                          
                             2 - Nivel do grupo ( N )                 
           ExpL1 -> Inverte a contagem de niveis no array. Quando     
           .T., a ordem passa a ser de cima para baixo                
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function MaVenStrUp( cGrpAtu, aGrupos, lInverte )

Local aArea    := GetArea()
Local aAreaACA := ACA->( GetArea() )

lInverte := If( ValType( lInverte ) == "L", lInverte, .F. )

//Ŀ
// Chama a funcao de processamento                              
//
MaPrcRepUp( cGrpAtu, @aGrupos )

//Ŀ
// Inverte a ordem de niveis                                    
//
If lInverte
	ASort( aGrupos, , , { |x,y| x[ 2 ] > y[ 2 ] } )
	AEval( aGrupos, { |x,y| x[ 2 ] := y } )
EndIf

RestArea( aAreaACA )
RestArea( aArea )

Return( .T. )

/*


Ŀ
Funo    MaPrcRepUp Autor Sergio Silveira         Data 19/07/2002
Ĵ
Descrio  Traz todos os grupos acima de um grupo de vendedores       
           ( processamento )                                          
Ĵ
Sintaxe    MaPrcRepUp( ExpC1, @ExpA1, [ ExpN1 ] )                     
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros ExpC1 -> Grupo a pesquisar                                 
           ExpA1 -> Array contendo os grupos. Deve ser passado por    
              referencia e alimentado pela funcao                     
                 Estrutura : 1 - Grupo ( C )                          
                             2 - Nivel do grupo ( N )                 
           ExpN1 -> Nivel atual. Este parametro nao deve ser passado  
           na chamada inicial, pois e passado quando a funcao chama   
           ela mesma ( recursividade )                                
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function MaPrcRepUp( cGrpAtu, aGrupos, nLevel )

Local cSeekACA  := ""

If ValType( nLevel ) <> "N"
	nLevel := 0
EndIf

//Ŀ
// Incrementa o contador de niveis                              
//

nLevel++

ACA->( dbSetOrder( 1 ) )
cSeekACA := xFilial( "ACA" ) + cGrpAtu
If ACA->( dbSeek( cSeekACA ) )
	AAdd( aGrupos, { ACA->ACA_GRPREP, nLevel } )
	MaPrcRepUp( ACA->ACA_GRPSUP, @aGrupos, @nLevel )
EndIf

//Ŀ
// Decrementa o contador de niveis                              
//
nLevel--

Return()

/*


Ŀ
Funo    Ma440Compl Autor Henry Fila              Data 24/11/2003
Ĵ
Descrio  Verifica se eh complemento de precos e possui item liberado
Ĵ
Sintaxe    Ma440Compl()                                               
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros Nenhum                                                     
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/
Function Ma440Compl()

Local lRet  := .T.
Local aArea := GetArea()
Local aAreaSC9 := SC9->(GetArea())
Local lCompl   := IIf(cPaisLoc == "BRA",;
					 (SC5->C5_TIPO $ "IP" .Or. (SC5->C5_TIPO $ "C" .And. SC5->C5_TPCOMPL == "1")),; //Compl. Preco
					  SC5->C5_TIPO $ "CIP")     

If lCompl
	SC9->(dbSetOrder(2))
	If SC9->(MsSeek(xFilial("SC9")+SC5->C5_CLIENTE+SC5->C5_LOJACLI+SC5->C5_NUM+SC6->C6_ITEM))
		lRet := .F.
	Endif

	If lRet
		If !Empty(SC6->C6_NOTA)
			lRet := .F.
		Endif
	Endif
Else
	lRet := .F.
Endif

RestArea(aAreaSC9)
RestArea(aArea)

Return(lRet)


/*


Ŀ
Funo    MaTesLZero Autor Henry Fila              Data 24/11/2003
Ĵ
Descrio  Verifica se eh quantidade zerada e possui item liberado    
Ĵ
Sintaxe    Ma440Compl()                                               
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros Nenhum                                                     
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/
Function MaTesLZero()

Local lRet  := .T.
Local aArea := GetArea()
Local aAreaSC9 := SC9->(GetArea())

SC9->(dbSetOrder(2))
If SC9->(MsSeek(xFilial("SC9")+SC5->C5_CLIENTE+SC5->C5_LOJACLI+SC5->C5_NUM+SC6->C6_ITEM))
	lRet := .F.
Endif

RestArea(aAreaSC9)
RestArea(aArea)

Return(lRet)

/*


Ŀ
Funo     FatLoad   Autor Marco Bianchi           Data 18/10/2007
Ĵ
Descrio  Funcoes a serem executadas na entrada do modulo Faturamento
Ĵ
Sintaxe    FatLoad()                                                  
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros Nenhum                                                     
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/
Function FatLoad()

//Ŀ
// Depuracao de reservas                                   
//
a430Auto()

//Ŀ
//Criacao de um template de proposta comercial 
//para integracao,com Microsoft Word.          
//
If FindFunction("R600TWrd")
	R600TWrd()
End

If cPaisLoc $ "COL"
	CIIUCOL()
EndIf

//--------------------------------------------------------------
// Cria o cadastro de integrao da Neogrid S&OP
//--------------------------------------------------------------
FT801Carga()


Return

/*


ͻ
Programa  A410LibBen Autor  Andre Anjos          Data   05/12/08   
͹
Descricao  Libera o saldo empenhado para o item de PV referente a      
			  remessa de beneficiamento quando ha lote e;ou localizacao.  
͹
Parametro  nEvento: Evento que esta sendo processado.				   
			  	1- Analise de saldo disponivel.							   
			  	2- Estorno de liberacao.								   
			  cAlias: Alias onde se encontra o empenho.				   
			  nRecno: Recno do registro de empenho.					   
			  nQtd1: Quantidade a ser restaurada 1UM.					   
			  nQtd2: Quantidade a ser restaurada 2UM.					   
͹
Retorno	  nRet: Quantidade do empenho baixado.						   
͹
Uso        FATXFUN                                   				   
ͼ


*/
Function A410LibBen(nEvento,cAlias,nRecno,nQtd1,nQtd2)
Local aArea 	:= GetArea()
Local nRet 		:= 0
Local cCpo1 	:= Substr(cAlias,2,2) + "_QUANT"
Local cCpo2 	:= Substr(cAlias,2,2) + "_QTSEGUM"
Local cCpoOrig := Substr(cAlias,2,2) + If(cAlias == "SDC","_QTDORIG","_QTDEORI")
Local cCpoProd := Substr(cAlias,2,2) + If(cAlias == "SDC","_PRODUTO","_COD")
Local nOperac	:= If(nEvento == 1,-1,1)
Local lProcess := .T.

dbSelectArea(cAlias)
dbGoTo(nRecno)

Default nQtd2 := If(&(cCpo2)>0,nQtd1/(&(cCpo1)/&(cCpo2)),0)
If cAlias == "SD4"
	nRet := &(cCpo1)
EndIf

//Prepara seek nas tabelas de saldos
SB2->(dbSetOrder(1))
SB8->(dbSetOrder(3))
SBF->(dbSetOrder(1))

If nEvento == 1 .And. nQtd1 > &(cCpo1)
	nQtd1 := &(cCpo1)
	nQtd2 := &(cCpo2)
ElseIf nEvento == 2
	If (nQtd1 > &(cCpoOrig)) .Or. ((nQtd1 + &(cCpo1)) > &(cCpoOrig))
		nQtd1 := &(cCpoOrig)
		nQtd2 := ConvUM(&(cCpoProd),nQtd1,0,2)
	ElseIf &(cCpo1) == &(cCpoOrig)
		lProcess := .F.
    EndIf
EndIf

If lProcess
	Begin Transaction
		If cAlias == "SDC"
			SBF->(dbSeek(xFilial("SB2")+(SDC->DC_LOCAL+SDC->DC_LOCALIZ+SDC->DC_PRODUTO+SDC->DC_NUMSERI+SDC->DC_LOTECTL+SDC->DC_NUMLOTE)))
			GravaBFEmp("+",(nQtd1*nOperac),"F",.F.,(nQtd2*nOperac))
		Else
			SB2->(dbSeek(xFilial("SB2")+SD4->(D4_COD+D4_LOCAL)))
			GravaB2Emp("+",(nQtd1*nOperac),"F",.F.,(nQtd2*nOperac))

			If !Empty(SD4->(D4_LOTECTL+D4_NUMLOTE))
				SB8->(dbSeek(xFilial("SB8")+SD4->(D4_COD+D4_LOCAL+D4_LOTECTL+If(Rastro(D4_COD,"S"),D4_NUMLOTE,""))))
				GravaB8Emp("+",(nQtd1*nOperac),"F",.F.,(nQtd2*nOperac))
			EndIf
		EndIf

		dbSelectArea(cAlias)
		RecLock(cAlias,.F.)
		Replace &(cCpo1) With &(cCpo1) + (nQtd1 * nOperac)
		Replace &(cCpo2) With &(cCpo2) + (nQtd2 * nOperac)
		MsUnLock()
	End Transaction
EndIf

RestArea(aArea)
Return nRet

/*


ͻ
Programa  FatAtuEmpNAutor  Andre Anjos          Data   28/05/09   
͹
Descricao  Funcao utilizada para fazer o controle de preenchimento do 
           campo B2_QEMPN nas atualizacoes de itens de pedido de venda
           (SC6 posicionado no item desejado).						  
͹
Parametros cSinal: sinal da operacao								  
͹
Uso        FATXFUN, MATA450 E MATA521								  
ͼ


*/
Function FatAtuEmpN(cSinal,lEstorn,cAliasSC9,lSeekSC6)
Local aArea       := GetArea()
Local aAreaSB2    := SB2->(GetArea())
Local lA650QLibPV := FindFunction("A650QLibPV")
Local lAtuSGJ     := .F.
Local nQtdAtEmpN  := 0
Local nQtdDif	  := 0
DEFAULT lEstorn   := .F.
DEFAULT cAliasSC9 := "SC9"
DEFAULT lSeekSC6  := .F.

//Posiciona SC6 caso necessario
If lSeekSC6 .And. !(xFilial("SC6")==SC6->C6_FILIAL .And.;
		SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
		SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
		SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO)
	dbSelectArea("SC6")
	dbSetOrder(1)
	MsSeek(xFilial("SC6")+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO)
EndIf

SB2->(dbSetOrder(1))

If !Empty(SC6->(C6_NUMOP+C6_ITEMOP))
	SC2->(dbSetOrder(1))
	SC2->(dbSeek(xFilial("SC2")+SC6->(C6_NUMOP+C6_ITEMOP)))
	If !SB2->(dbSeek(xFilial("SB2")+SC2->(C2_PRODUTO+C2_LOCAL)))
		CriaSB2(SC2->C2_PRODUTO,SC2->C2_LOCAL)
	EndIf
	If !lEstorn
		A650AtEmpN(SC6->(C6_QTDVEN-C6_QTDENT-C6_QTDRESE) - If(lA650QLibPV,A650QLibPV(),0),cSinal,SC2->C2_TPOP)
	Else
		A650AtEmpN(If(lA650QLibPV,A650QLibPV(lEstorn,cAliasSC9),0),cSinal,SC2->C2_TPOP)
	EndIf
ElseIf !Empty(SC6->(C6_NUMSC+C6_ITEMSC))
	SC1->(dbSetOrder(1))
	SC1->(dbSeek(xFilial("SC1")+SC6->(C6_NUMSC+C6_ITEMSC)))
	If !SB2->(dbSeek(xFilial("SB2")+SC1->(C1_PRODUTO+C1_LOCAL)))
		CriaSB2(SC1->C1_PRODUTO,SC1->C1_LOCAL)
	EndIf
	If !lEstorn
		A650AtEmpN(SC6->(C6_QTDVEN-C6_QTDENT-C6_QTDRESE) - If(lA650QLibPV,A650QLibPV(),0),cSinal,SC1->C1_TPOP)
	Else
		A650AtEmpN(If(lA650QLibPV,A650QLibPV(lEstorn),0),cSinal,SC1->C1_TPOP)
	EndIf
ElseIf SC6->C6_OP $ "03/05/06"
	SB2->(dbSeek(xFilial("SB2")+SC6->(C6_PRODUTO+C6_LOCAL)))
	If !lEstorn
		nQtdAtEmpN := A650QLibPV()
		lAtuSGJ	:= SuperGetMV("MV_PVCOMOP",.F.,.F.) .And. FindFunction("ALIASINDIC") .And. AliasIndic("SGJ")
		If !SuperGetMv("MV_LIBACIM") .And. !lAtuSGJ .And. Localiza(SC6->C6_PRODUTO, .T.) .And. cSinal=="+"
			nQtdDif := ( SC6->(C6_QTDVEN-C6_QTDENT) - nQtdAtEmpN )
			// Indica liberacao acima do saldo do pedido e nao grava o excesso liberado em B2_QEMPN
			If QtdComp(nQtdDif) < QtdComp(0)
				nQtdAtEmpN += nQtdDif
			EndIf
      	EndIf
		A650AtEmpN(SC6->(C6_QTDVEN-C6_QTDENT-C6_QTDRESE) - If(lA650QLibPV,nQtdAtEmpN,0),cSinal,SC6->C6_TPOP)
	Else
		If lA650QLibPV
			nQtdAtEmpN := A650QLibPV(lEstorn)
			lAtuSGJ	:= SuperGetMV("MV_PVCOMOP",.F.,.F.) .And. FindFunction("ALIASINDIC") .And. AliasIndic("SGJ")
			If !SuperGetMv("MV_LIBACIM") .And. !lAtuSGJ
				nQtdDif := ( SC6->(C6_QTDVEN-C6_QTDENT) - nQtdAtEmpN )
				// Indica liberacao acima do saldo do pedido e nao grava o excesso liberado em B2_QEMPN
				If QtdComp(nQtdDif) < QtdComp(0)
					nQtdAtEmpN += nQtdDif
				EndIf
			EndIf
		EndIf
		A650AtEmpN(If(lA650QLibPV,nQtdAtEmpN,0),cSinal,SC6->C6_TPOP)
	EndIf
EndIf
RestArea(aAreaSB2)
RestArea(aArea)
Return

/*


ͻ
Programa  FatCredToolsAutor  Faturamento          Data   28/05/09 
͹
Descricao  Funcao utilizada para fazer o analise de credito via 	  
           intellector da tools										  
͹
Parametros nValor: Valor acumulado de cada item do pedido de venda	  
͹
Uso        FATXFUN e MATA450										  
ͼ


*/
Function FatCredTools(cCodCli, cLojaCli, nVlItAcum, nVlTitAbe, nVlTitAtras)

Local cMvTolPoVe	:= ALLTRIM(SuperGetMv("MV_TOLPOVE", .F.,""))   //Politica de venda para integracao com Intellector
Local cMvTolTiVe	:= ALLTRIM(SuperGetMv("MV_TOLTIVE", .F.,""))   //Tipo de politica de venda para integracao com Intellector
Local cMvTolLayo	:= ALLTRIM(SuperGetMv("MV_TOLLAYO", .F.,""))   //Layout da politica para integracao com Intellector

Local nMvCrdTole	:= SuperGetMV("MV_CRDTOLE", .F., 1)			//Valor de tolerancia para liberacao de limite de credito
Local oRetYMF		:= NIL											//Objeto do tipo LJCDadosRetYMF
Local lRetorno		:= .F.											//Retorno da funcao

//Faz a analise de credito via Tools
oRetYMF	:= CrdXExecYMF(cMvTolPoVe  , cMvTolTiVe ,cMvTolLayo  ,cCodCli ,;
 						  cLojaCli, nVlTitAbe ,nMvCrdTole 	,nVlItAcum	  ,;
 						  nVlTitAtras)

//Limite de credito aprovado
lRetorno :=  (ValType(oRetYMF) == "O" .AND. oRetYMF:lAprovado)

Return lRetorno

/*


ͻ
Programa  BlPVLFat  Autor  Microsiga            Data   04/18/11   
͹
Desc.                                                                 
͹
Uso       FATXFUN - So para atender legislao de Alagoas             
ͼ


*/
Function BlPVLFat(cCli,cLoja,lPvBloq)
Local lBlqPv     := .F. // Pedido no bloqueado
Local lLibPv   := ( IsInCallStack("FT210PROC") .Or. IsInCallStack("MA215PROC") .Or. IsInCallStack("LJ7GERAENT") .Or. IsInCallStack("MADELNFS") )
Local lContrICM:= .F.
Local aSvAreaA1:= SA1->(GetArea())    
Local aSvAreaC6:= {}
Local cQueryD2 := ""
Local cQueryC9 := ""
Local cAliasD2 := GetNextAlias()
Local cAliasC9 := GetNextAlias()
Local nValLim := SuperGetMv("MV_LIMFTAL",,0)
Local cDtIni := StrZero(Year(dDataBase),4) + StrZero(Month(dDataBase),2) +  "01" // primeiro dia do mes database
Local cDtFim := DtoS(CtoD("01" + "/" + StrZero(IIF(Month(dDataBase)==12,1,Month(dDataBase) + 1),2) + "/" + StrZero(Year(dDataBase),4)) - 1) // ultimo dia do mes database
Local nTotFat := 0
Local nValPed := 0
Local InX     := 0
Local nPosVlr := IIf(!lLibPv,aScan(aHeader,{|x| Alltrim(Upper(x[2])) == "C6_VALOR"}),0)
Local nPosTES := IIf(!lLibPv,aScan(aHeader,{|x| Alltrim(Upper(x[2])) == "C6_TES"}),0)

Default lPvBloq := .F.

lPvBloq := IIf(lLibPv,.F.,lPvBloq) // Pela rotina(FATA210) de liberacao sempre considera como no bloqueado

//Ŀ
//Verifica se o cliente  contribuinte de ICMS. Mesmo tratamento feito no MATXFIS 
//
SA1->(dbSetOrder(1))
If SA1->(MsSeek(xFilial("SA1")+cCli+cLoja))
	If AllTrim(SuperGetMv("MV_ESTADO")) == AllTrim(SA1->A1_EST)
		lContrICM := IIf(Empty(SA1->A1_INSCR).Or."ISENT"$SA1->A1_INSCR.Or."RG"$SA1->A1_INSCR.Or. SA1->A1_CONTRIB == "2",.F.,.T.)
		//Tratamento para considerar como contribuinte do ICMS Produtor Rural com inscrio Rural
		If !Empty(SA1->A1_INSCRUR) .And. "L" $ SA1->A1_TIPO .And. SA1->A1_CONTRIB <> "1"
			lContrICM := .F.
		EndIf
		If !lContrICM .And. nValLim > 0 .And. !lPvBloq
			//Ŀ
			//Totaliza os pedidos liberados para faturameto dentro do mes corrente, conforme o cliente solicitado.
			//
			cQueryC9 := " SELECT SUM((C9_QTDLIB * C9_PRCVEN)) TOTAL "
			cQueryC9 += "   FROM " + RetSqlName("SC9")
			cQueryC9 += " WHERE D_E_L_E_T_ = ' ' "
			cQueryC9 += "   AND C9_FILIAL = '" + xFilial("SC9") + "' "
			cQueryC9 += "   AND C9_NFISCAL = '' "
			cQueryC9 += "   AND C9_DATALIB BETWEEN '" + cDtIni + "' AND '" + cDtFim + "' "
			cQueryC9 += "   AND C9_CLIENTE = '" + cCli + "' "
			cQueryC9 += "   AND C9_LOJA = '" + cLoja + "' "

			If Select(cAliasC9) > 0
				dbSelectArea(cAliasC9)
			   dbCloseArea()
			EndIf

			cQueryC9 := ChangeQuery( cQueryC9 )
			dbUseArea( .T., "TOPCONN", TcGenQry(,,cQueryC9), cAliasC9, .T., .T. )

			(cAliasC9)->TOTAL

			//Ŀ
			//Totaliza as notas fiscais emitida dentro do mes corrente, conforme o cliente solicitado.
			//
			cQueryD2 := " SELECT SUM(D2_TOTAL) TOTAL "
			cQueryD2 += "   FROM " + RetSqlName("SD2")
			cQueryD2 += "  WHERE D_E_L_E_T_ = ' ' "
			cQueryD2 += "     AND D2_FILIAL = '" + xFilial("SD2") + "' "
			cQueryD2 += "     AND D2_EMISSAO BETWEEN '" + cDtIni + "' AND '" + cDtFim + "' "
			cQueryD2 += "     AND D2_CLIENTE = '" + cCli + "' "
			cQueryD2 += "     AND D2_LOJA = '" + cLoja + "' "

			If Select(cAliasD2) > 0
				dbSelectArea(cAliasD2)
			   dbCloseArea()
			EndIf

			cQueryD2 := ChangeQuery( cQueryD2 )
			dbUseArea( .T., "TOPCONN", TcGenQry(,,cQueryD2), cAliasD2, .T., .T. )

			nTotFat := (cAliasC9)->TOTAL + (cAliasD2)->TOTAL

			//Ŀ
			//Fecha as duas tabelas
			//
			(cAliasC9)->(dbCloseArea())
			(cAliasD2)->(dbCloseArea())

			If nTotFat > nValLim
				lBlqPv := .T.
			Else
				If lLibPv // Liberao, verifica direto na tabela SC6
					aSvAreaC6:= SC6->(GetArea())
					SC6->(dbSetOrder(1))
					SC6->(dbSeek(xFilial("SC6")+SC5->C5_NUM))
					While SC6->(!Eof()) .And. SC5->C5_NUM == SC6->C6_NUM
						If Posicione("SF4",1,xFilial("SF4")+SC6->C6_TES,"F4_DUPLIC") == "S"
							nValPed += SC6->C6_VALOR
						EndIf
						SC6->(dbSkip())
					EndDo
					RestArea(aSvAreaC6)
				Else
					For InX := 1 To Len(aCols)
						If !(aCols[InX,Len(aHeader)+1]) .And. (Posicione("SF4",1,xFilial("SF4")+aCols[InX][nPosTES],"F4_DUPLIC") == "S")
							nValPed += aCols[InX][nPosVlr]
						EndIf
					Next InX
				EndIf
				If (nTotFat + nValPed) > nValLim
					lBlqPv := .T.
				EndIf
			EndIf

			If lBlqPv .And.  !(IsInCallStack("MA215PROC"))
				 VerBlqReg("BLQAL", 0, "", "", "")
			EndIf
		Else
			lBlqPv := lPvBloq
		EndIf
	EndIf
EndIf

RestArea(aSvAreaA1)

Return lBlqPv
/*


ͻ
Programa  RhInssPat Autor  Vendas CRM           Data   12/01/12   
͹
Desc.     Rotina para calculo do INSS Patronal chamada pelo mdulo de 
          RH                                                          
Ĵ
ObservacaocPeriodo -> Ms e Ano recebido do parmetro				  
          cFilProc-> Filial de processamento da rotina				  
			 l13Sal  -> Indica se  clculo de 13 salario               
          cPeriodo13-> Periodo inicial e final para calculo do 13sal  
          												  	 	      
͹
Uso        Vendas CRM                                                 
ͼ


*/ 
Function RhInssPat(cPeriodo,cFilProc,l13Sal,cPeriodo13,lAgrCtaCtb)

Local cQuery 			:= ""
Local cQueryD1 		:= ""
Local cQueryCG1		:= ""                                                               	
Local cAliasQry 		:= GetNextAlias()
Local cAliasSD1		:= GetNextAlias() 
Local cQryCG1			:= GetNextAlias()
Local cTmpCG1			:= GetNextAlias()
Local nPerIni13		:= IiF (ValType(cPeriodo13)=="C" .And. !Empty(cPeriodo13), AT("/",cPeriodo13),0)
Local cPerIni13		:= IiF (ValType(cPeriodo13)=="C" .And. nPerIni13 > 0, AllTrim(SubStr(cPeriodo13,1,nPerIni13-1)),"")
Local cPerFim13		:= IiF (ValType(cPeriodo13)=="C" .And. nPerIni13 > 0, AllTrim(SubStr(cPeriodo13,nPerIni13+1,(Len(cPeriodo13)))),"") 
Local dPerFim13		:= IiF (!Empty(cPerFim13),CTOD("01"+"/"+SUBSTR(cPerFim13,1,2)+"/"+SUBSTR(cPerFim13,5,6)),CTOD(""))
Local dPerIni			:= IiF (!l13Sal,CTOD("01"+"/"+SUBSTR(cPeriodo,1,2)+"/"+SUBSTR(cPeriodo,5,6)), CTOD("01"+"/"+SUBSTR(cPerIni13,1,2)+"/"+SUBSTR(cPerIni13,5,6)))
Local dPerFim			:= IiF (!l13Sal,CTOD(StrZero(F_ULTDIA(dPerIni),2)+"/"+SUBSTR(cPeriodo,1,2)+"/"+SUBSTR(cPeriodo,5,6)),CTOD(StrZero(F_ULTDIA(dPerFim13),2)+"/"+SUBSTR(cPerFim13,1,2)+"/"+SUBSTR(cPerFim13,5,6)))
Local aArea			:= GetArea()
Local aCFOPs			:= XFUNCFRec()  
Local cIniDes			:= SuperGetMv("MV_DESFOL",,"201208") //Periodo de inicio do cliente na desonerao Ms+Ano   se for fazer colocar o param no updfat23
Local cCFIND			:= SuperGetMv("MV_CFIND",,"") //CFOPs das vendas dos produtos industrializados pela empresa
Local cNFOrig 		:= ""
Local cSerOrig		:= ""
Local nFatBrut		:= 0 
Local nFatLiq			:= 0 
Local nFatExp			:= 0
Local nPosFis			:= 0
Local nPosDev			:= 0
Local nPosExp       	:= 0  
Local nTotLiqDev    	:= 0  
Local nFatLiqExp    	:= 0  
Local nX            	:= 0
Local nTotDev       	:= 0
Local nTot	        	:= 0
Local nImpostos     	:= 0
Local aTotFis			:= {}
Local aTotFisDev		:= {} 
Local aCampos			:= {}
Local aFatDes			:= {} 
Local lComplD1 		:= .F.
Local lDtIniCG1		:= .F. 
Local lCodAtiVld 		:= .F. 
Local lTmpCG1			:= .F.
Local lAgreg			:= .F. 
Local lDedICM			:= .F. 
Local nVlrLiqExp		:= 0
Local lDevolLj		:= .F.
Local lRet				:= .T.
Local lQryDeson		:= ExistBlock("QryDeson")
Local cEspecie		:= ""
Local nTotDevBrt		:= 0
Local nDescon			:= 0
Local cRealAlias		:= ""
Local cInsert			:= ""
Local nRetInsert		:= 0
Local oTmpCG1			:= Nil
Local aIdxCG1			:= {}
Local lD2CtaRec	  	:= SD2->(ColumnPos("D2_CTAREC")) > 0 //Valida se o campo D2_CTAREC existe para gravar a Conta de Receita - EFD Contribuies

Default cPeriodo 		:= ""
Default cPeriodo13	:= ""
Default cFilProc		:= cFilAnt
Default l13Sal		:= .F. 
Default lAgrCtaCtb	:= .F.

lDtIniCG1 := Iif(AliasInDic("CG1"),.T.,.F.) //Verifica se existe Data inicial do cdigo de atividade contido na tabela CG1

If cPaisLoc == "BRA"

	cQuery += " SELECT D2_ITEM, D2_DOC, D2_SERIE, D2_COD, D2_TIPO, D2_ESPECIE, D2_TOTAL, D2_VALIPI, D2_ICMSRET, D2_CF, D2_EMISSAO, D2_NFORI, D2_SERIORI, " 
	cQuery += " D2_VALFRE, D2_SEGURO, D2_DESPESA, D2_VALBRUT, D2_VALICM, D2_DESCON, D2_CONTA, F4_AGREG, B5_CODATIV, B5_INSPAT, B5_VERIND "
	If lD2CtaRec
		cQuery += ", D2_CTAREC "
	EndIf
	cQuery += " FROM " + RetSqlName( "SD2" ) + " SD2 "
	cQuery += " LEFT JOIN " + RetSQLName("SB5") +" SB5 ON "			
	cQuery += " SB5.B5_FILIAL = '" + xFilial("SB5") + "' AND "
	cQuery += " SB5.B5_COD = SD2.D2_COD AND " 
	cQuery += " SB5.D_E_L_E_T_ = ' ' "
	cQuery += " INNER JOIN " + RetSQLName("SF4") +" SF4 ON "			
	cQuery += " SF4.F4_FILIAL = '" + xFilial("SF4") + "' AND "
	cQuery += " SF4.F4_CODIGO = SD2.D2_TES AND "
	cQuery += " SF4.D_E_L_E_T_ = ' ' "
	cQuery += " WHERE "
	cQuery += " SD2.D2_FILIAL = '" + xFilial("SD2") + "' AND "
	cQuery += " SD2.D2_TIPO IN ('N','C','P')  AND "
	cQuery += " SD2.D2_EMISSAO BETWEEN '"+DTOS(dPerIni)+"' AND '"+DTOS(dPerFim)+"' AND " 
	cQuery += " SD2.D_E_L_E_T_ = ' ' "
	If lQryDeson
		cQuery += ExecBlock("QryDeson",.F.,.F.,{cQuery})
	EndIf
	cQuery += " ORDER BY SD2.D2_FILIAL, SD2.D2_COD "
			
	cQuery := ChangeQuery(cQuery)
	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)

	//Ŀ
	//Verifico os cdigos de atividade que possuem data de validade maior do que
	//o perodo de processamneto.                                               
	//
	If lDtIniCG1
		
		
		cQueryCG1 := " SELECT CG1_FILIAL, CG1_CODIGO, CG1_DTFIM, CG1_DTINI, CG1_ALIQ "
		cQueryCG1 += " FROM " + RetSqlName( "CG1" ) + " "
		cQueryCG1 += " WHERE "
   		cQueryCG1 += " ( CG1_FILIAL = '" + xFilial("CG1") + "' "
		cQueryCG1 += " AND (CG1_DTFIM >= '" + DTOS(dPerFim) +"' OR CG1_DTFIM='' ) AND CG1_DTINI <= '" + DTOS(dPerIni) + "' "
		cQueryCG1 += " AND CG1_DTINI <> ' ' OR CG1_CODIGO = '99999999' ) "
		cQueryCG1 += " AND D_E_L_E_T_ = ' ' "
		//cQueryCG1 += " ORDER BY CG1_FILIAL, CG1_CODIGO, CG1_DTFIM "
		cQueryCG1 += "ORDER BY "+SqlOrder(CG1->(IndexKey())) 
		
		cQueryCG1 := ChangeQuery(cQueryCG1)
		
   		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQueryCG1),cQryCG1,.T.,.T.)

		If !(cQryCG1)->(Eof())
			//Ŀ
			// Cria arquivo de dados temporrio 
			//
			aCampos := {}
			aAdd(aCampos,{"CG1_FILIAL"	,"C",TAMSX3("CG1_FILIAL")[1],2})
			aAdd(aCampos,{"CG1_CODIGO"	,"C",TAMSX3("CG1_CODIGO")[1],2})
			aAdd(aCampos,{"CG1_DTFIM"	,"D",TAMSX3("CG1_DTFIM")[1],2})
			aAdd(aCampos,{"CG1_DTINI"	,"D",TAMSX3("CG1_DTINI")[1],2})
			aAdd(aCampos,{"CG1_ALIQ "	,"N",TAMSX3("CG1_ALIQ")[1],2})

			oTmpCG1	:= FWTemporaryTable():New( cTmpCG1 )
			oTmpCG1:SetFields( aCampos )
			aIdxCG1 	:= {"CG1_FILIAL","CG1_CODIGO","CG1_DTFIM"}
			oTmpCG1:AddIndex("1",aIdxCG1)
			oTmpCG1:Create()
			
			cRealAlias := oTmpCG1:GetRealName()
			//Carrega a Estrutura da query(cQryCG1), para o arquivo Temporrio via Insert
			//e assim utilizar o indice que  criado na tabela temporria.
			cInsert := " INSERT INTO " + cRealAlias 
			cInsert += " ( CG1_FILIAL, CG1_CODIGO, CG1_DTFIM, CG1_DTINI, CG1_ALIQ ) "
			cInsert += cQueryCG1
			
			nRetInsert = TCSqlExec( cInsert )
			
			If nRetInsert < 0
				Conout( TCSQLError() )
			Else
				lTmpCG1 := .T.
			EndIf
			
		EndIf
		(cQryCG1)->(dbCloseArea())

	EndIf

	While !(cAliasQry)->( Eof() )
		lAgreg := .F.
		lDedICM := .F.
		cEspecie:= Posicione("SF2",1,xFilial("SF2") + (cAliasQry)->D2_DOC + (cAliasQry)->D2_SERIE, "F2_ESPECIE")
		If Alltrim((cAliasQry)->D2_CF)$ aCFOPs[1] .And. !Alltrim((cAliasQry)->D2_CF)$ aCFOPs[2]
			If ExistBlock("NFSDESON")
			   lRet := ExecBlock("NFSDESON",.F.,.F.,{(cAliasQry)->D2_DOC, (cAliasQry)->D2_SERIE, (cAliasQry)->D2_COD})
			   If ValType(lRet) <> "L"
				   lRet := .T.
			   EndIf
			EndIf
			If lRet
				nDescon += (cAliasQry)->D2_DESCON
				lAgreg := (cAliasQry)->F4_AGREG $"I|D" //Se for ICMS+Mer, subtrai o valor do ICMS do D2_VALBRUT
				//If !(Alltrim((cAliasQry)->D2_TIPO)== "I") .Or. (Alltrim((cAliasQry)->D2_TIPO)== "I" .And.(cAliasQry)->D2_ICMSRET > 0)
					If lAgreg  
						If (cAliasQry)->D2_ICMSRET > 0  // deduzir o valor do icms s quando for ST 
							lDedICM := .T.
							nFatBrut += (cAliasQry)->D2_VALBRUT + (cAliasQry)->D2_DESCON //Variavel que retornar o valor bruto das notas(considera frete seguro e despesa) 
							nFatLiq +=(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA + (cAliasQry)->D2_VALICM  //Variavel que retornar o valor liquido das notas 
							If SubStr((cAliasQry)->D2_CF,1,1) == "7" 
								nFatExp += (cAliasQry)->D2_VALBRUT
								nFatLiqExp += (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA -(cAliasQry)->D2_ICMSRET 
							EndIf	
							aAdd(aFatDes,{(cAliasQry)->D2_DOC,(cAliasQry)->D2_SERIE,(cAliasQry)->D2_TIPO,(cAliasQry)->D2_EMISSAO,(cAliasQry)->D2_TOTAL +; 
									(cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA , (cAliasQry)->D2_NFORI,(cAliasQry)->D2_SERIORI, (cAliasQry)->D2_CF,(cAliasQry)->D2_ITEM,cEspecie,(cAliasQry)->D2_VALBRUT,"","", iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
						Else
							//Quando for ICMS normal e agrega valor I|D o valor do ICMS  incorporado ao preo de venda.
							lDedICM := .F.
							nFatBrut += (cAliasQry)->D2_VALBRUT + (cAliasQry)->D2_DESCON
							nFatLiq +=(cAliasQry)->D2_VALBRUT - (cAliasQry)->D2_VALIPI //Variavel que retornar o valor liquido das notas 
							If SubStr((cAliasQry)->D2_CF,1,1) == "7" 
								nFatExp += (cAliasQry)->D2_VALBRUT
								nFatLiqExp += (cAliasQry)->D2_VALBRUT - (cAliasQry)->D2_VALIPI
							EndIf	
							aAdd(aFatDes,{(cAliasQry)->D2_DOC,(cAliasQry)->D2_SERIE,(cAliasQry)->D2_TIPO,(cAliasQry)->D2_EMISSAO,(cAliasQry)->D2_VALBRUT - (cAliasQry)->D2_VALIPI,; 
								 (cAliasQry)->D2_NFORI,(cAliasQry)->D2_SERIORI, (cAliasQry)->D2_CF,(cAliasQry)->D2_ITEM,cEspecie,(cAliasQry)->D2_VALBRUT,"","", iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
						EndIf			
					Else
						nFatBrut += (cAliasQry)->D2_VALBRUT + (cAliasQry)->D2_DESCON //Variavel que retornar o valor bruto das notas(considera frete seguro e despesa) 
						nFatLiq +=(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA    //Variavel que retornar o valor liquido das notas 
						If SubStr((cAliasQry)->D2_CF,1,1) == "7" 
							nFatExp += (cAliasQry)->D2_VALBRUT
							nFatLiqExp += (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
						EndIf	
						aAdd(aFatDes,{(cAliasQry)->D2_DOC,(cAliasQry)->D2_SERIE,(cAliasQry)->D2_TIPO,(cAliasQry)->D2_EMISSAO,(cAliasQry)->D2_TOTAL +; 
								(cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, (cAliasQry)->D2_NFORI,(cAliasQry)->D2_SERIORI, (cAliasQry)->D2_CF,(cAliasQry)->D2_ITEM,cEspecie,(cAliasQry)->D2_VALBRUT,"","", iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
					EndIf			
			   //	EndIf 
				//p
				//Verifico se a data da emisso do item, est entre algum cdigo de atividade valido,        |
				//|pois se no estiver, no ser validado com cod de atividade. 		  					  
				//Poder existir mais de um cdigo de atividade com datas de validade distintas              
				//p
			   	lCodAtiVld := .F. 
			   	If !Empty((cAliasQry)->B5_CODATIV) .And. lDtIniCG1 .And. lTmpCG1
			   		If (cTmpCG1)->(dbSeek(xFilial("CG1")+(cAliasQry)->B5_CODATIV))
						While !(cTmpCG1)->(Eof()) .And. (cTmpCG1)->CG1_CODIGO == (cAliasQry)->B5_CODATIV
							If (cTmpCG1)->CG1_DTINI <= Stod((cAliasQry)->D2_EMISSAO) .AND. ((cTmpCG1)->(CG1_DTFIM) >= Stod((cAliasQry)->D2_EMISSAO) .OR. EMPTY((cTmpCG1)->(CG1_DTFIM)) .OR. (cAliasQry)->B5_CODATIV == '99999999')
								 lCodAtiVld := .T. 
								 Exit 
					   		EndIf 
							(cTmpCG1)->(dbSkip())
						EndDo
					EndIf
				Else
					lDtIniCG1 := .F.
				EndIf
				//Ŀ
				//Tratamento para complemento de IPI                                                                                 		
				//Somo o valor do imposto no valor bruto pois  um complemento da NF Original, que na gerao n teve este imposto.	        
				//Somando esse valor no valbrut para calculo da deson, ele considera esse valor apenas como excluso e no como b. de calculo  
				//
	   			nVlrLiqExp := (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
	   			aFatDes[Len(aFatDes)][12]:= (cAliasQry)->B5_CODATIV
	   			If !Empty((cAliasQry)->B5_CODATIV) .And. lDtIniCG1
		   			If Alltrim((cAliasQry)->D2_TIPO)== "P" .And. lCodAtiVld  
					   	If (cAliasQry)->B5_INSPAT == "1"
					   		If lAgrCtaCtb 
					   			nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV) .And. x[9] == iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
					   		Else	
					   			nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
					   		EndIf	
					   		If STOD((cAliasQry)->D2_EMISSAO) >= CTOD("01"+"/"+SUBSTR(cIniDes,5,6)+"/"+SUBSTR(cIniDes,1,4))
						   		If nPosFis == 0
									aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_TOTAL,0,0,Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0),0,0,0,iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA) })
								Else
									aTotFis[nPosFis][2]+=(cAliasQry)->D2_TOTAL 
								EndIf
							EndIf	
					   	EndIf                                                                         			   	
					ElseIf lCodAtiVld  
						If SubStr((cAliasQry)->D2_CF,1,1) <> "7" .AND. ((cAliasQry)->B5_INSPAT == "1")
						    If (((cAliasQry)->B5_VERIND == "1" .And. AllTrim((cAliasQry)->D2_CF) $ cCFIND) .OR. (cAliasQry)->B5_VERIND <> "1")
						    
								//Ŀ
								//Soma os valores por codigo de atividade no array aTotFis
								//[1] Cdigo de atividade                                 
								//[2] Valor Bruto por cdigo atividade                    
								//[3] Valor Bruto Exportao por cdigo de atividade      
								//[4] Valor liq + frete + seguro + despesa                
								//[5] F4_AGREG =I/D o valor do ICMS  somado ao vlr bruto.
    							//[6] IPI das EXPORT deduz impost pois TCATVEXP ja tem IPI
    							//[7] Valor Liquido Exportao por cdigo de atividade    
    							//[8] Valor de Desconto										   
    							//[9] Conta Contbil de Receita							   
								//
								If lAgrCtaCtb 
									nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV) .And. x[9] == iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
								Else
									nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
								EndIf	
								If nPosFis == 0
									aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_VALBRUT + (cAliasQry)->D2_DESCON, 0,(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0),;
											(cAliasQry)->D2_VALIPI,0,(cAliasQry)->D2_DESCON, iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
								Else
									aTotFis[nPosFis][2]+= (cAliasQry)->D2_VALBRUT + (cAliasQry)->D2_DESCON
									aTotFis[nPosFis][4]+= (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
									aTotFis[nPosFis][5]+= Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0)
									aTotFis[nPosFis][6]+= (cAliasQry)->D2_VALIPI
									aTotFis[nPosFis][8]+= (cAliasQry)->D2_DESCON
								EndIf
							Else 
								If lAgrCtaCtb 
									nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV) .And. x[9] == iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
								Else
									nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
								EndIf
								If nPosFis == 0
									aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_VALBRUT + (cAliasQry)->D2_DESCON, 0,(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0),;
											(cAliasQry)->D2_VALIPI,0,(cAliasQry)->D2_DESCON, iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
								Else
									aTotFis[nPosFis][2]+= (cAliasQry)->D2_VALBRUT + (cAliasQry)->D2_DESCON
									aTotFis[nPosFis][4]+= (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
									aTotFis[nPosFis][5]+= Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0)
									aTotFis[nPosFis][6]+= (cAliasQry)->D2_VALIPI
									aTotFis[nPosFis][8]+= (cAliasQry)->D2_DESCON
								EndIf
							EndIf	 		
						//Ŀ
						//Verifico a exportaes que possuem codigo de atividade e
						//Atribuo a posio 3 do array                             
						//Atribui valor do IPI as EXPORT posio 6 do array        
						//
						ElseIf SubStr((cAliasQry)->D2_CF,1,1) == "7"
							If (cAliasQry)->B5_INSPAT == "1"
								If (((cAliasQry)->B5_VERIND == "1" .And. AllTrim((cAliasQry)->D2_CF) $cCFIND) .OR. (cAliasQry)->B5_VERIND <> "1")
														
									If lAgrCtaCtb 
										nPosExp := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV) .And. x[9] == iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
									Else
										nPosExp := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
									EndIf

									If nPosExp == 0
										aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_VALBRUT,(cAliasQry)->D2_VALBRUT,(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0),;
													(cAliasQry)->D2_VALIPI,nVlrLiqExp,(cAliasQry)->D2_DESCON, iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
									Else
										aTotFis[nPosExp][2]+= (cAliasQry)->D2_VALBRUT
										aTotFis[nPosExp][3]+= (cAliasQry)->D2_VALBRUT
										aTotFis[nPosExp][4]+= (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
										aTotFis[nPosExp][5]+= Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0)
										aTotFis[nPosExp][6]+= (cAliasQry)->D2_VALIPI
										aTotFis[nPosExp][7]+= nVlrLiqExp
										aTotFis[nPosExp][8]+= (cAliasQry)->D2_DESCON
									EndIf
								Else
									If lAgrCtaCtb 
										nPosExp := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV) .And. x[9] == iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
									Else
										nPosExp := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
									EndIf
									If nPosExp == 0
										aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_VALBRUT,(cAliasQry)->D2_VALBRUT,(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0),;
													(cAliasQry)->D2_VALIPI,nVlrLiqExp,(cAliasQry)->D2_DESCON, iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
									Else
										aTotFis[nPosExp][2]+= (cAliasQry)->D2_VALBRUT
										aTotFis[nPosExp][3]+= (cAliasQry)->D2_VALBRUT
										aTotFis[nPosExp][4]+= (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
										aTotFis[nPosExp][5]+= Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0)
										aTotFis[nPosExp][6]+= (cAliasQry)->D2_VALIPI
										aTotFis[nPosExp][7]+= nVlrLiqExp
										aTotFis[nPosExp][8]+= (cAliasQry)->D2_DESCON
									EndIf
								EndIf	
							EndIf	
						EndIf
					EndIf
				Else
					If !Empty((cAliasQry)->B5_CODATIV) .And. Alltrim((cAliasQry)->D2_TIPO)== "P"   
					   	If (cAliasQry)->B5_INSPAT == "1"
					   		If lAgrCtaCtb 
								nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV) .And. x[9] == iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
							Else
								nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
							EndIf
					   		If STOD((cAliasQry)->D2_EMISSAO) >= CTOD("01"+"/"+SUBSTR(cIniDes,5,6)+"/"+SUBSTR(cIniDes,1,4))
						   		If nPosFis == 0
									aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_TOTAL,0,0,Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0),(cAliasQry)->D2_VALIPI, 0, 0 ,iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
								Else
									aTotFis[nPosFis][2]+=(cAliasQry)->D2_TOTAL 
								EndIf
							EndIf	
					   	EndIf                                                                         			   	
					ElseIf !Empty((cAliasQry)->B5_CODATIV)
						If SubStr((cAliasQry)->D2_CF,1,1) <> "7" .AND. (cAliasQry)->B5_INSPAT == "1"
						    If (((cAliasQry)->B5_VERIND == "1" .And. AllTrim((cAliasQry)->D2_CF) $cCFIND) .OR. (cAliasQry)->B5_VERIND <> "1")
								//Ŀ
								//Soma os valores por codigo de atividade no array aTotFis
								//[1] Cdigo de atividade                                 
								//[2] Valor Bruto por cdigo atividade                    
								//[3] Valor Bruto Exportao por cdigo de atividade      
								//[4] Valor liq + frete + seguro + despesa                
								//[5] F4_AGREG =I/D o valor do ICMS  somado ao vlr bruto.
    							//[6] IPI das EXPORT deduz impost pois TCATVEXP ja tem IPI
    							//[7] Valor Liquido Exportao por cdigo de atividade    
    							//[8] Valor de Desconto										   
    							//[9] Conta Contbil de Receita							   
								//
								If lAgrCtaCtb 
									nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV) .And. x[9] == iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
								Else
									nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
								EndIf
								If nPosFis == 0
									aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_VALBRUT + (cAliasQry)->D2_DESCON, 0,(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0),;
												(cAliasQry)->D2_VALIPI,0,(cAliasQry)->D2_DESCON, iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
								Else
									aTotFis[nPosFis][2]+=(cAliasQry)->D2_VALBRUT + (cAliasQry)->D2_DESCON
									aTotFis[nPosFis][4]+=(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
									aTotFis[nPosFis][5]+= Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0)
									aTotFis[nPosFis][6]+= (cAliasQry)->D2_VALIPI
									aTotFis[nPosFis][8]+= (cAliasQry)->D2_DESCON
								EndIf
							Else 
								If lAgrCtaCtb 
									nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV) .And. x[9] == iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
								Else
									nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
								EndIf
								If nPosFis == 0
									aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_VALBRUT, 0,(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0),;
												(cAliasQry)->D2_VALIPI,0,(cAliasQry)->D2_DESCON, iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
								Else
									aTotFis[nPosFis][2]+= (cAliasQry)->D2_VALBRUT + (cAliasQry)->D2_DESCON
									aTotFis[nPosFis][4]+= (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
									aTotFis[nPosFis][5]+= Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0)
									aTotFis[nPosFis][6]+= (cAliasQry)->D2_VALIPI
									aTotFis[nPosFis][8]+= (cAliasQry)->D2_DESCON
								EndIf
							EndIf	 		
						//Ŀ
						//Verifico a exportaes que possuem codigo de atividade e
						//atribuo a posio 3 do array                            
						//
						ElseIf SubStr((cAliasQry)->D2_CF,1,1) == "7"
							If (cAliasQry)->B5_INSPAT == "1"
								If (((cAliasQry)->B5_VERIND == "1" .And. AllTrim((cAliasQry)->D2_CF) $cCFIND) .OR. (cAliasQry)->B5_VERIND <> "1")
									If lAgrCtaCtb 
										nPosExp := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV) .And. x[9] == iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
									Else
										nPosExp := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
									EndIf
									If nPosExp == 0
										aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_VALBRUT,(cAliasQry)->D2_VALBRUT,(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0),;
												(cAliasQry)->D2_VALIPI,nVlrLiqExp,(cAliasQry)->D2_DESCON, iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
									Else
										aTotFis[nPosExp][2]+= (cAliasQry)->D2_VALBRUT
										aTotFis[nPosExp][3]+= (cAliasQry)->D2_VALBRUT
										aTotFis[nPosExp][4]+= (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
										aTotFis[nPosExp][5]+= Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0)
										aTotFis[nPosExp][6]+= (cAliasQry)->D2_VALIPI
										aTotFis[nPosExp][7]+= nVlrLiqExp
										aTotFis[nPosExp][8]+= (cAliasQry)->D2_DESCON
									EndIf
								Else
									If lAgrCtaCtb 
										nPosExp := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV) .And. x[9] == iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
									Else
										nPosExp := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
									EndIf
									If nPosExp == 0
										aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_VALBRUT,(cAliasQry)->D2_VALBRUT,(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0),;
												(cAliasQry)->D2_VALIPI,nVlrLiqExp,(cAliasQry)->D2_DESCON, iIF(lD2CtaRec .And. !Empty((cAliasQry)->D2_CTAREC),(cAliasQry)->D2_CTAREC,(cAliasQry)->D2_CONTA)})
									Else
										aTotFis[nPosExp][2]+= (cAliasQry)->D2_VALBRUT
										aTotFis[nPosExp][3]+= (cAliasQry)->D2_VALBRUT
										aTotFis[nPosExp][4]+= (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
										aTotFis[nPosExp][5]+= Iif(lAgreg .And. lDedICM,(cAliasQry)->D2_ICMSRET,0)
										aTotFis[nPosExp][6]+= (cAliasQry)->D2_VALIPI
										aTotFis[nPosExp][7]+= nVlrLiqExp
										aTotFis[nPosExp][8]+= (cAliasQry)->D2_DESCON
									EndIf
								EndIf	
							EndIf	
						EndIf
					EndIf	 
				EndIf							 	 
			EndIf
		EndIf	
		(cAliasQry)->(dbSkip())	
	EndDo 
	(cAliasQry)->(dbCloseArea())
   
//Ŀ
//Processamento das notas de devoluo
//
   	
	cQueryD1 := " SELECT D1_ITEM, D1_DOC, D1_SERIE, D1_COD, D1_TIPO, D1_TOTAL, D1_VALDESC, D1_CF, D1_EMISSAO,D1_DTDIGIT, D1_NFORI, D1_SERIORI, D1_FORNECE, D1_LOJA, D1_ITEMORI, "
	cQueryD1 += " D1_VALDESC, D1_VALFRE, D1_SEGURO, D1_DESPESA, D1_VALIPI, D1_ICMSRET, D1_ORIGLAN, B5_CODATIV, B5_INSPAT, B5_VERIND " 
	cQueryD1 += " FROM " + RetSqlName( "SD1" ) + " SD1 "
	cQueryD1 += " LEFT JOIN " + RetSQLName("SB5") +" SB5 ON "			
	cQueryD1 += " SB5.B5_FILIAL = '" + xFilial("SB5") + "' AND "
	cQueryD1 += " SB5.B5_COD = SD1.D1_COD AND "
	cQueryD1 += " SB5.D_E_L_E_T_ = ' ' "
	cQueryD1 += " WHERE "
	cQueryD1 += " SD1.D1_FILIAL = '"  + xFilial("SD1") + "' AND "
	cQueryD1 += " SD1.D1_TIPO IN ('D','C','P') AND "
    cQueryD1 += " SD1.D1_DTDIGIT BETWEEN '"+DTOS(dPerIni)+"' AND '"+DTOS(dPerFim)+"' AND " 
	cQueryD1 += " SD1.D1_TES <> ' ' AND "  		    
	cQueryD1 += " SD1.D_E_L_E_T_ = ' ' "
	cQueryD1 += " ORDER BY SD1.D1_FILIAL, SD1.D1_COD, SD1.D1_DOC, SD1.D1_SERIE "	
	
	cQueryD1 := ChangeQuery( cQueryD1 )
	dbUseArea( .T., "TOPCONN", TcGenQry( ,,cQueryD1 ), cAliasSD1, .F., .T. )		

	While !(cAliasSD1)->(Eof())
		lComplD1 := .F.
		lDevolLj := .F.
		cEspecie:= Posicione("SF1",1,xFilial("SF1") + (cAliasSD1)->D1_DOC + (cAliasSD1)->D1_SERIE, "F1_ESPECIE")
		If !(cAliasSD1)->D1_TIPO $ "D|N"
			cNFOrig  := Posicione("SD1",1,xFilial("SD1")+ (cAliasSD1)->D1_NFORI + (cAliasSD1)->D1_SERIORI,"D1_NFORI")
			cSerOrig := Posicione("SD1",1,xFilial("SD1")+ (cAliasSD1)->D1_NFORI + (cAliasSD1)->D1_SERIORI,"D1_SERIORI")
			lComplD1 := .T.
		EndIf	
		//Se a devoluo for feita pelo SIGALOJA no utiliza D1_FORNECE/D1_LOJA, pois a devoluo pode ser feita com cdigos diferentes.
		If !lComplD1 .And. (cAliasSD1)->D1_ORIGLAN == "LO"
			lComplD1 := .T.
			lDevolLj := .T.
		EndIf
		SD2->(dbSetOrder(3))
		If Iif(!lComplD1, SD2->(dbSeek(xFilial("SD2")+(cAliasSD1)->D1_NFORI + (cAliasSD1)->D1_SERIORI+ (cAliasSD1)->D1_FORNECE + (cAliasSD1)->D1_LOJA + (cAliasSD1)->D1_COD + (cAliasSD1)->D1_ITEMORI)),;
			IIf(!lDevolLj, SD2->(dbSeek(xFilial("SD2")+cNFOrig+cSerOrig)), SD2->(dbSeek(xFilial("SD2")+(cAliasSD1)->D1_NFORI+(cAliasSD1)->D1_SERIORI))))
			If (Alltrim(SD2->D2_CF)$ aCFOPs[1] .And. !Alltrim(SD2->D2_CF)$ aCFOPs[2]) .And. SD2->D2_EMISSAO >= CTOD("01"+"/"+SUBSTR(cIniDes,5,6)+"/"+SUBSTR(cIniDes,1,4))
				nTotDevBrt	:= (cAliasSD1)->D1_TOTAL + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET //variavel que ira acumular o valo total de Notas de devoluo (considera frete seguro e despesa)
			   	If SubStr(SD2->D2_CF,1,1) <> "7"
			    	nTotDev	+= ((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC) + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA +; 
			    				(cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET //variavel que ira acumular o valo total de Notas de devoluo (considera frete seguro e despesa)
				    nTotLiqDev += ((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC) + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA
				EndIf    
		    	aAdd(aFatDes,{(cAliasSD1)->D1_DOC,(cAliasSD1)->D1_SERIE,(cAliasSD1)->D1_TIPO,(cAliasSD1)->D1_DTDIGIT,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC) + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA,;
		  					(cAliasSD1)->D1_NFORI,(cAliasSD1)->D1_SERIORI, (cAliasSD1)->D1_CF,(cAliasSD1)->D1_ITEM,cEspecie,nTotDevBrt,"",(cAliasSD1)->D1_ITEMORI, iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})			  			
				//p
				//Verifico se a data da emisso do item, est entre algum cdigo de atividade valido,        |
				//|pois se no estiver, no ser validado com cod de atividade. 		  					  
				//Poder existir mais de um cdigo de atividade com datas de validade distintas              
				//p
			  	lCodAtiVld := .F.
			   	If !Empty((cAliasSD1)->B5_CODATIV) .And. lDtIniCG1
			   		If (cTmpCG1)->(dbSeek(xFilial("CG1")+(cAliasSD1)->B5_CODATIV))
						While !(cTmpCG1)->(Eof()) .And. (cTmpCG1)->CG1_CODIGO == (cAliasSD1)->B5_CODATIV
							If ((cTmpCG1)->CG1_DTINI <= Stod((cAliasSD1)->D1_DTDIGIT) .AND. ((cTmpCG1)->CG1_DTFIM >= Stod((cAliasSD1)->D1_DTDIGIT) .OR. EMPTY((cTmpCG1)->CG1_DTFIM)))
								 lCodAtiVld := .T. 
								 Exit 
					   		EndIf 
							(cTmpCG1)->(dbSkip())
						EndDo
					EndIf
                Else
                	lDtIniCG1 := .F.
				EndIf
			 	//d
				//Se for complemento de ICMS ST ou complemento de IPI na devoluo, adiciono o valor somente no valor bruto do ATOTFIS, 
				// pois como impostos nao vo para desonerao, subtraio apenas no valor bruto do cod de atividade.			       	 
				//d
				aFatDes[Len(aFatDes)][12]:= (cAliasSD1)->B5_CODATIV
				If !Empty((cAliasSD1)->B5_CODATIV) .And. lDtIniCG1
					If Alltrim((cAliasSD1)->D1_TIPO)== "P" .And. lCodAtiVld
					   If (cAliasSD1)->B5_INSPAT == "1"
					   		If lAgrCtaCtb 
								nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV) .And. x[9] == iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
							Else
								nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
							EndIf
					   		If STOD((cAliasSD1)->D1_DTDIGIT) >= CTOD("01"+"/"+SUBSTR(cIniDes,5,6)+"/"+SUBSTR(cIniDes,1,4))
						   		If nPosFis == 0
									aAdd(aTotFis,{(cAliasSD1)->B5_CODATIV,-(cAliasSD1)->D1_TOTAL,0,0, nVlrLiqExp,,,,iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
								Else
									aTotFis[nPosFis][2]-=(cAliasSD1)->D1_TOTAL
								EndIf
							EndIf	
					  	EndIf
					ElseIf lCodAtiVld
						
						If SubStr(SD2->D2_CF,1,1) <> "7" .AND. (cAliasSD1)->B5_INSPAT == "1"					
					 	//Ŀ
						//Soma os valores por codigo de atividade no array aTotFisDev 
						//[1] Cdigo de atividade                                 	   
						//[2] Valor Bruto devoluo por cdigo atividade              
						//[3] Valor Bruto devoluo de Exportao por cd de atividade
						//[4] Valor devoluo liq + frete + seguro + despesa     	   
						//[5] Valor Liqdo devoluo de Exportao por cd de atividade
						//[6] Conta Contbil de receita									
						// 
							If (((cAliasSD1)->B5_VERIND == "1" .And. AllTrim(SD2->D2_CF) $cCFIND) .OR. (cAliasSD1)->B5_VERIND <> "1")						 	
								If lAgrCtaCtb 
									nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV) .And. x[6] == iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
								Else
									nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
								EndIf
								If nPosFis == 0
									aAdd(aTotFisDev,{(cAliasSD1)->B5_CODATIV,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA+ (cAliasSD1)->D1_VALIPI +; 
																(cAliasSD1)->D1_ICMSRET),0,(cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC +; 
																(cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA , 0,iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
								Else
									aTotFisDev[nPosFis][2]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
									aTotFisDev[nPosFis][4]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA)						 
								EndIf
							Else 
								If lAgrCtaCtb 
									nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV) .And. x[6] == iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
								Else
									nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
								EndIf

								If nPosFis == 0
									aAdd(aTotFisDev,{(cAliasSD1)->B5_CODATIV,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA+ (cAliasSD1)->D1_VALIPI +; 
																(cAliasSD1)->D1_ICMSRET),0,(cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC +; 
																(cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA , 0, iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
								Else
									aTotFisDev[nPosFis][2]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
									aTotFisDev[nPosFis][4]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA)						 
								EndIf
							EndIf
						//Ŀ
						//Verifico as devolues de exportaes que possuem codigo de atividade e 	  
						//atribuo a posio 3 do array aTotFisDev. Tambm ser tratado itens de      |
						//| export por cod de ativ na posio 2 do aTotFisDev(Soma tot por cod ativ)  
						//
						ElseIf SubStr(SD2->D2_CF,1,1) == "7" 
							If (cAliasSD1)->B5_INSPAT == "1" 
								If (((cAliasSD1)->B5_VERIND == "1" .And. AllTrim(SD2->D2_CF) $cCFIND) .OR. (cAliasSD1)->B5_VERIND <> "1")						 	
									If lAgrCtaCtb 
										nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV) .And. x[6] == iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
									Else
										nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
									EndIf

									If nPosFis == 0
										aAdd(aTotFisDev,{(cAliasSD1)->B5_CODATIV,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +;
										 				(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET),;
										 				((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO +; 
										 				(cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET),;
										 				0, (cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA,iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA) })									
									Else
										aTotFisDev[nPosFis][2]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
										aTotFisDev[nPosFis][3]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
										aTotFisDev[nPosFis][5]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA )
															
									EndIf
								Else
									If lAgrCtaCtb 
										nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV) .And. x[6] == iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
									Else
										nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
									EndIf
									
									If nPosFis == 0
										aAdd(aTotFisDev,{(cAliasSD1)->B5_CODATIV,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +;
										 				(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET),;
										 				((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO +; 
										 				(cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET),;
										 				0,(cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA, iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})	
										 			   
									Else
										aTotFisDev[nPosFis][2]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
										aTotFisDev[nPosFis][3]+=(cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET
										aTotFisDev[nPosFis][5]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																	(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA )
															
									EndIf
								EndIf			
							EndIf
						EndIf  
					EndIf
				Else
					If !Empty((cAliasSD1)->B5_CODATIV) .And. Alltrim((cAliasSD1)->D1_TIPO)== "P" 
					   If (cAliasSD1)->B5_INSPAT == "1"
					   		If lAgrCtaCtb 
								nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV) .And. x[9] == iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
							Else
								nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
							EndIf
							
					   		If STOD((cAliasSD1)->D1_DTDIGIT) >= CTOD("01"+"/"+SUBSTR(cIniDes,5,6)+"/"+SUBSTR(cIniDes,1,4))
						   		If nPosFis == 0
									aAdd(aTotFis,{(cAliasSD1)->B5_CODATIV,-(cAliasSD1)->D1_TOTAL,0,0})
								Else
									aTotFis[nPosFis][2]-=(cAliasSD1)->D1_TOTAL 
								EndIf
							EndIf	
					  	EndIf
					ElseIf !Empty((cAliasSD1)->B5_CODATIV)
						If SubStr(SD2->D2_CF,1,1) <> "7" .AND. (cAliasSD1)->B5_INSPAT == "1"					
					 	//Ŀ
						//Soma os valores por codigo de atividade no array aTotFisDev 
						//[1] Cdigo de atividade                                 	   
						//[2] Valor Bruto devoluo por cdigo atividade              
						//[3] Valor Bruto devoluo de Exportao por cd de atividade
						//[4] Valor devoluo liq + frete + seguro + despesa     	   
						//[5] Valor Liqdo devoluo de Exportao por cd de atividade
						//[6] Conta Contbil de receita									
						// 
						// 
							If (((cAliasSD1)->B5_VERIND == "1" .And. AllTrim(SD2->D2_CF) $cCFIND) .OR. (cAliasSD1)->B5_VERIND <> "1")						 	
								If lAgrCtaCtb 
									nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV) .And. x[6] == iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
								Else
									nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
								EndIf

								If nPosFis == 0
									aAdd(aTotFisDev,{(cAliasSD1)->B5_CODATIV,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA+ (cAliasSD1)->D1_VALIPI +; 
																(cAliasSD1)->D1_ICMSRET),0,(cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC +; 
																(cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA , 0,iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
								Else
									aTotFisDev[nPosFis][2]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
									aTotFisDev[nPosFis][4]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA)						 
								EndIf
							Else 
								If lAgrCtaCtb 
									nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV) .And. x[6] == iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
								Else
									nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
								EndIf
								If nPosFis == 0
									aAdd(aTotFisDev,{(cAliasSD1)->B5_CODATIV,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA+ (cAliasSD1)->D1_VALIPI +; 
																(cAliasSD1)->D1_ICMSRET),0,(cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC +; 
																(cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA , 0,iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
								Else
									aTotFisDev[nPosFis][2]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
									aTotFisDev[nPosFis][4]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA)						 
								EndIf
							EndIf
						//Ŀ
						//Verifico as devolues de exportaes que possuem codigo de atividade e 	  
						//atribuo a posio 3 do array aTotFisDev. Tambm ser tratado itens de      |
						//| export por cod de ativ na posio 2 do aTotFisDev(Soma tot por cod ativ)  
						//
						ElseIf SubStr(SD2->D2_CF,1,1) == "7" 
							If (cAliasSD1)->B5_INSPAT == "1" 
								If (((cAliasSD1)->B5_VERIND == "1" .And. AllTrim(SD2->D2_CF) $cCFIND) .OR. (cAliasSD1)->B5_VERIND <> "1")						 	
									If lAgrCtaCtb 
										nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV) .And. x[6] == iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
									Else
										nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
									EndIf
									
									If nPosFis == 0
										
										aAdd(aTotFisDev,{(cAliasSD1)->B5_CODATIV,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +;
										 				(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET),;
										 				((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO +; 
										 				(cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET),;
										 				0,(cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
														(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA, iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
									Else
										aTotFisDev[nPosFis][2]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
										aTotFisDev[nPosFis][3]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)						
										aTotFisDev[nPosFis][5]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA )					
									EndIf
								Else
									If lAgrCtaCtb 
										nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV) .And. x[6] == iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
									Else
										nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
									EndIf
									
									If nPosFis == 0
										aAdd(aTotFisDev,{(cAliasSD1)->B5_CODATIV,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +;
											 				(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET),;
											 				((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO +; 
											 				(cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET),;
											 				0,(cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
															(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA, iIF(lD2CtaRec .And. !Empty(SD2->D2_CTAREC),SD2->D2_CTAREC,SD2->D2_CONTA)})
									Else
										aTotFisDev[nPosFis][2]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
										aTotFisDev[nPosFis][3]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)						
									  	aTotFisDev[nPosFis][5]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																	(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA )				
									EndIf
								EndIf
							EndIf
						EndIf  
					EndIf	
				EndIf		
			EndIf		
		EndIf					
        (cAliasSD1)->(dbSkip())
	EndDo
	(cAliasSD1)->(dbCloseArea())

	If Select(cTmpCG1) > 0
		oTmpCG1:Delete() 
	EndIf  

	RhInssLog(aFatDes, cPeriodo, cFilProc, l13Sal)
			   
	//Ŀ
	//A estrutura da tabela temporria foi criada de acordo com Registro P100 (Contribuio Previdenciria sobre a Receita Bruta) 
	//-
	//Ŀ
	//Cria a estrutura do arquivo de trabalho 
	//
	aCampos := {}
	aAdd(aCampos,{"TOTALLIQ"		,"N",TAMSX3("D2_TOTAL")[1],2})		// TOTAL LIQUIDO
	aAdd(aCampos,{"TOTAL"		,"N",TAMSX3("D2_TOTAL")[1],2})		// TOTAL BRUTO
	aAdd(aCampos,{"TOTLIQDEV"	,"N",TAMSX3("D2_TOTAL")[1],2})	    // TOTAL DEVOLUO
	aAdd(aCampos,{"TOTALDEV"		,"N",TAMSX3("D2_TOTAL")[1],2})	    // TOTAL DEVOLUO
	aAdd(aCampos,{"TOTLIQEXP"	,"N",TAMSX3("D2_TOTAL")[1],2})	    // TOTAL EXPORTAO
	aAdd(aCampos,{"TOTALEXP"		,"N",TAMSX3("D2_TOTAL")[1],2})	    // TOTAL EXPORTAO
	aAdd(aCampos,{"TOTADESC"		,"N",TAMSX3("D2_TOTAL")[1],2})	    // TOTAL DESCONTOS GERAL
	//CODIGO ATIVIDADE
	aAdd(aCampos,{"CODATV"		,"C",TAMSX3("B5_CODATIV")[1],2}) 	// CODIGO ATIVIDADE
	aAdd(aCampos,{"TOTCODAT"		,"N",TAMSX3("D2_TOTAL")[1],2})     // TOTAL CODIGO ATIVIDADE BRUTO
   	aAdd(aCampos,{"TCODATLQ"		,"N",TAMSX3("D2_TOTAL")[1],2})     // TOTAL CODIGO ATIVIDADE LIQUIDO
	aAdd(aCampos,{"TCATVDEV"		,"N",TAMSX3("D2_TOTAL")[1],2})     // TOTAL DEV CODIGO ATIVIDADE
	aAdd(aCampos,{"TCATVEXP" 	,"N",TAMSX3("D2_TOTAL")[1],2})     // TOTAL EXPORTAES POR CODIGO DE ATIVIDADE
	aAdd(aCampos,{"TLQCATVEXP" 	,"N",TAMSX3("D2_TOTAL")[1],2}) 		// TOTAL LIQUIDO EXPORTAES POR CODIGO DE ATIVIDADE
	aAdd(aCampos,{"TCATVDVEX" 	,"N",TAMSX3("D2_TOTAL")[1],2})     // TOTAL DE DEVOLUES DE EXPORTAES POR CODIGO DE ATIVIDADE
	aAdd(aCampos,{"TLQCATDVEX" 	,"N",TAMSX3("D2_TOTAL")[1],2})     // TOTAL LIQUIDO DE DEVOLUES DE EXPORTAES POR CODIGO DE ATIVIDADE
	aAdd(aCampos,{"TCDESCON"		,"N",TAMSX3("D2_TOTAL")[1],2})     // TOTAL COD ATIV - DESCONTOS
	aAdd(aCampos,{"TCDEVEXP"		,"N",TAMSX3("D2_TOTAL")[1],2})     // TOTAL COD ATIV - DEVOLUO - EXPRTAO
	aAdd(aCampos,{"CONTARECE"	,"C",TAMSX3("D2_CONTA")[1],2})     // CONTA DE RECEITA - PEGA DO CAMPO D2_CTAREC OU DO D2_CONTA
	
	
	//Ŀ
	//Cria o arquivo de trabalho
	//	
	
	oTmpTrbFat	:= FWTemporaryTable():New( "TRBFAT" )
	oTmpTrbFat:SetFields( aCampos )
	aIdxTrbFat := {"CODATV"}
	oTmpTrbFat:AddIndex("1",aIdxTrbFat)
	oTmpTrbFat:Create()

	If Len(aTotFis)== 0	.And. Len(aTotFisDev)== 0	 
		If (nFatBrut + nTotDev + nFatExp) > 0
			RecLock("TRBFAT", .T.)	
			TRBFAT->TOTALLIQ		:= nFatLiq    			// valor total Liquido geral das notas
			TRBFAT->TOTAL			:= nFatBrut    			// valor total BRUTO geral das notas
			
		    TRBFAT->TOTLIQDEV 	:= nTotLiqDev 			// Valor total Liquido de devolues
		    TRBFAT->TOTALDEV 	:= nTotDev 				// Valor total de devolues

		    TRBFAT->TOTLIQEXP 	:= nFatLiqExp 			// Valor total Liquido de exportaes 
		    TRBFAT->TOTALEXP 	:= nFatExp 				// Valor total de exportaes
		    TRBFAT->TOTADESC 	:= nDescon					// Valor total de descontos  
		    TRBFAT->(MsUnlock())
		EndIf    
    ElseIf Len(aTotFis)> 0	
		For nx:= 1 to Len(aTotFis)
			nImpostos := 0
			RecLock("TRBFAT", .T.)
			TRBFAT->TOTALLIQ		:= nFatLiq    			// valor total Liquido geral das notas
			TRBFAT->TOTAL			:= nFatBrut    			// valor total BRUTO geral das notas
			
		    TRBFAT->TOTLIQDEV 	:= nTotLiqDev 			// Valor total Liquido de devolues
		    TRBFAT->TOTALDEV 	:= nTotDev 				// Valor total de devolues

		    TRBFAT->TOTLIQEXP 	:= nFatLiqExp 			// Valor total Liquido de exportaes 
		    TRBFAT->TOTALEXP 	:= nFatExp 				// Valor total de exportaes
		    TRBFAT->TOTADESC 	:= nDescon					// Valor total de descontos   
			// Totais por cdigo de atividade
			TRBFAT->CODATV		:= aTotFis[nx][1] 		// Cdigo de atividade
			TRBFAT->TOTCODAT		:= aTotFis[nx][2] 		// Valor total BRUTO do cdigo de atividade
		   	If lAgreg
				TRBFAT->TCODATLQ	:= aTotFis[nx][2] - aTotFis[nX][5] - aTotFis[nX][6]	// Valor total LIQ do cdigo de atividade - ICMS que ja esta imbutido no valor.
			Else
				TRBFAT->TCODATLQ	:= aTotFis[nx][4] //Valor total LIQ do cdigo de atividade
			EndIf		
			// Verifica se existe alguma nota de devoluo para o cdigo de atividade posicionado.
			If lAgrCtaCtb 
				nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(aTotFis[nX][1]) .And. x[6] == aTotFis[nX][9]})
			Else
				nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(aTotFis[nX][1])})
			EndIf

			If nPosFis > 0
				TRBFAT->TCATVDEV	:= aTotFisDev[nPosFis][4]// Nota de devoluo (tem que ser o valor liq, pois para desoner no inclui impostos quando tem cod atividade)
		    Else
		       TRBFAT->TCATVDEV	:= 0
		    EndIf
		    TRBFAT->TCATVEXP		:= aTotFis[nx][3] // Total Bruto Exportao por Cdigo de atividade(Saida) 
		    TRBFAT->TLQCATVEXP	:= aTotFis[nx][7] // Total Liquido Exportao        por Cdigo de atividade(Saida) 
		   
		    // Verifica se existe alguma nota de devoluo de exportao para o cdigo de atividade posicionado.
			If lAgrCtaCtb 		   
		    	nPosDev := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(aTotFis[nx][1]) .And. x[6]== aTotFis[nx][9]})
		    Else
		    	nPosDev := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(aTotFis[nx][1])})
		    EndIf
			If nPosDev > 0
		    	TRBFAT->TCATVDVEX		:= aTotFisDev[nPosDev][3]// Nota de devoluo de exportao 
		    	TRBFAT->TLQCATDVEX 	:= aTotFisDev[nPosDev][5]// Nota de devoluo de exportao 
		    Else 
			   	TRBFAT->TCATVDVEX	:= 0
		    EndIf
		    TRBFAT->TCDESCON 	:= aTotFis[nx][8]// DESCONTOS INCONDICIONAIS
		    
		    //aTotFis[nX][5] - ICMS - Soma os valores do ICMS ao valor lquido, pois se a TES estiver configurada F4_AGREG=I/D o valor do ICMS  asomado ao valor bruto.
			nTot := (TRBFAT->TCODATLQ - (TRBFAT->TCATVDEV + TRBFAT->TLQCATVEXP))	// Total por Cdigo de atividade - devoluo - exportao
			TRBFAT->TCDEVEXP := nTot
			If lAgrCtaCtb
				TRBFAT->CONTARECE := aTotFis[nx][9]
			Else
				TRBFAT->CONTARECE := Space(TAMSX3("D2_CONTA")[1])
			EndIf	
						
			TRBFAT->(MsUnlock())
		Next(nX)
		//Ŀ
		//Verifico se houve alguma devoluo que no foi processada no array atotfis(sada)
		//Este caso acontee se existe apenas devoluo com cod de atividade para o perodo
		//pois a NF original j foi processada em ms anterior.                            
		//
		If Len(aTotFisDev)> 0	
			For nX:= 1 to Len(aTotFisDev)

				If lAgrCtaCtb 
					nPosFisDev := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim(aTotFisDev[nx][1]) .And. x[9] == aTotFisDev[nx][6]})
				Else
					nPosFisDev := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim(aTotFisDev[nx][1])})
				EndIf				
				 
				// Se o codigo de atividade no foi encontrado no atotfis e possui no atotfisdev
				// Inclui uma linha com a devoluo com cod atividade
				If nPosFisDev == 0
					nImpostos := 0
					RecLock("TRBFAT", .T.)
					TRBFAT->TOTALLIQ		:= nFatLiq    			// valor total Liquido geral das notas
					TRBFAT->TOTAL			:= nFatBrut    			// valor total BRUTO geral das notas
					
				    TRBFAT->TOTLIQDEV 	:= nTotLiqDev 			// Valor total Liquido de devolues
				    TRBFAT->TOTALDEV 	:= nTotDev 				// Valor total de devolues
		
				    TRBFAT->TOTLIQEXP 	:= nFatLiqExp 			// Valor total Liquido de exportaes 
				    TRBFAT->TOTALEXP 	:= nFatExp 				// Valor total de exportaes 
				    TRBFAT->TOTADESC 	:= nDescon					// Valor total de descontos  
					// Totais por cdigo de atividade
					TRBFAT->CODATV		:= aTotFisDev[nx][1] 	// Cdigo de atividade
					TRBFAT->TOTCODAT		:= 0						// Valor total do cdigo de atividade
					TRBFAT->TCODATLQ		:= 0				 		// Valor total LIQ do cdigo de atividade
					// Verifica se existe alguma nota de devoluo para o cdigo de atividade posicionado.
					nPosDev := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(aTotFisDev[nx][1])})
					If nPosDev > 0
						TRBFAT->TCATVDEV	:= aTotFisDev[nPosDev][4]// Nota de devoluo (tem que ser o valor liq, pois para desoner no inclui impostos quando tem cod atividade)
				    Else
				        TRBFAT->TCATVDEV	:= 0
				    EndIf
				    TRBFAT->TCATVEXP		:= aTotFisDev[nx][3] // Total Exportao por Cdigo de atividade(Saida) 
				    // Verifica se existe alguma nota de devoluo de exportao para o cdigo de atividade posicionado.
				    nPosDev := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(aTotFisDev[nx][1])})
					If nPosDev > 0
				    	TRBFAT->TCATVDVEX	:= aTotFisDev[nPosDev][3]// Nota de devoluo de exportao 
				    Else 
					   TRBFAT->TCATVDVEX	:= 0
				    EndIf
				    nImpostos := TRBFAT->TOTCODAT - TRBFAT->TCODATLQ
				    
					nTot := TRBFAT->TOTCODAT - TRBFAT->TCATVDEV - TRBFAT->TCATVEXP - nImpostos  // Total por Cdigo de atividade - devoluo - exportao 
			 
				    If nTot > 0
				    	TRBFAT->TCDEVEXP := nTot
				    Else 
				    	TRBFAT->TCDEVEXP := 0
				    EndIf		   		
					 
					If lAgrCtaCtb
						TRBFAT->CONTARECE := aTotFisDev[nx][6]
					Else
						TRBFAT->CONTARECE := Space(TAMSX3("D2_CONTA")[1])
					EndIf	
					TRBFAT->(MsUnlock())
					
		    	EndIf
			Next nX
		EndIf	
	ElseIf Len(aTotFisDev)> 0 
	//Ŀ
	//Tratamento para caso haja apenas devoluo no periodo.
	//
		For nx:= 1 to Len(aTotFisDev) 
			nImpostos := 0
			RecLock("TRBFAT", .T.)
			TRBFAT->TOTALLIQ		:= nFatLiq    			// valor total Liquido geral das notas
			TRBFAT->TOTAL			:= nFatBrut    			// valor total BRUTO geral das notas
			
		   	TRBFAT->TOTLIQDEV 	:= nTotLiqDev 			// Valor total Liquido de devolues
		   	TRBFAT->TOTALDEV 	:= nTotDev 					// Valor total de devolues

		   	TRBFAT->TOTLIQEXP 	:= nFatLiqExp 			// Valor total Liquido de exportaes 
		   	TRBFAT->TOTALEXP 	:= nFatExp 					// Valor total de exportaes 
			// Totais por cdigo de atividade
			TRBFAT->CODATV		:= aTotFisDev[nx][1] 	// Cdigo de atividade
			TRBFAT->TOTCODAT		:= 0	   					// Valor total do cdigo de atividade
			TRBFAT->TCODATLQ		:= 0 	   					// Valor total LIQ DEVOLUCAO do cdigo de atividade
			// Verifica se existe alguma nota de devoluo para o cdigo de atividade posicionado.
			
			nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(aTotFisDev[nx][1])})
			If nPosFis > 0
				TRBFAT->TCATVDEV	:= aTotFisDev[nPosFis][4]// Nota de devoluo (tem que ser o valor liq, pois para desoner no inclui impostos quando tem cod atividade)
		    Else
		        TRBFAT->TCATVDEV	:= 0
		    EndIf
		    TRBFAT->TCATVEXP		:= aTotFisDev[nx][3] // Total Exportao por Cdigo de atividade(Saida) 
		    // Verifica se existe alguma nota de devoluo de exportao para o cdigo de atividade posicionado.
		    nPosDev := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(aTotFisDev[nx][1])})
			If nPosDev > 0
		    	TRBFAT->TCATVDVEX	:= aTotFisDev[nPosDev][3]// Nota de devoluo de exportao 
		   	Else 
			   TRBFAT->TCATVDVEX	:= 0
		  	EndIf
		   	nImpostos := TRBFAT->TOTCODAT - TRBFAT->TCODATLQ	
			nTot := TRBFAT->TOTCODAT - TRBFAT->TCATVDEV - TRBFAT->TCATVEXP - nImpostos  // Total por Cdigo de atividade - devoluo - exportao - impostos
					
		   	If nTot > 0
		   		TRBFAT->TCDEVEXP := nTot
		    Else 
		    	TRBFAT->TCDEVEXP := 0
		    EndIf		   		
			If lAgrCtaCtb
				TRBFAT->CONTARECE := aTotFisDev[nx][6]
			Else
				TRBFAT->CONTARECE := Space(TAMSX3("D2_CONTA")[1])
			EndIf	
			TRBFAT->(MsUnlock())
		Next(nX)
	EndIf	
EndIf
aSize(aTotFis,0)
aSize(aTotFisDev,0)
aSize(aFatDes,0)
aSize(aCampos,0)
RestArea(aArea)
Return("TRBFAT")//Retorna o arquivo de trabalho  
                                               
/*


ͻ
Programa  RhInssLog Autor  Microsiga            Data   09/05/12   
͹
Desc.      Gera o arquivo de Log do periodo informado com o total das 
           de saida e devoluo                                       
͹
Uso       aFatDes - Array contendo os itens para alimentar o arq de   
          			 trabalho									      
          cPeriodo - Periodo de apurao das Notas					  
          cFilProc - Filial de Processamento						  
          l13Sal   - Gerao de arquivo de 13 salario      	          
ͼ


*/

Static Function RhInssLog(aFatDes, cPeriodo, cFilProc, l13Sal)

Local nx			:= 0
Local cRotina		:= ""
Local cQuery		:= ""
Local lV5CtaRec  	:= SV5->(ColumnPos("V5_CTAREC")) > 0 //Valida se o campo V5_CTAREC existe

If IsInCallStack("GPEM013")
	cRotina := "GPEM013"
ElseIf IsInCallStack("GPEM070")
	cRotina := "GPEM070"
Else
	cRotina := "P100"
EndIf

If ChkFile("SV5")
	dbSelectArea("SV5")
	dbSetOrder(1)
	If SV5->(dbSeek(cFilProc+cPeriodo+cRotina))
		cQuery := "DELETE FROM "+RetSqlName("SV5")+" WHERE V5_FILIAL='"+cFilProc+"' AND V5_ROTINA='"+cRotina+"' AND V5_PERIODO='"+cPeriodo+"' "
		TcSqlExec(cQuery)
	EndIf

	For nx:= 1 to Len(aFatDes)
		Reclock("SV5", .T.)
		Replace V5_FILIAL		WITH cFilProc
		Replace V5_NUMNF		WITH aFatDes[nX][1]
		Replace V5_SERIE 		WITH aFatDes[nX][2]
		Replace V5_TIPO  		WITH aFatDes[nX][3]
		Replace V5_ITEMNF		WITH aFatDes[nX][9]
		Replace V5_ESPECNF	WITH aFatDes[nX][10]
		Replace V5_DATANF		WITH Stod(aFatDes[nX][4])
		Replace V5_CFOP		WITH aFatDes[nX][8]
		Replace V5_TOTAL		WITH aFatDes[nX][5]
		Replace V5_TOTBRUT	WITH aFatDes[nX][11]
		Replace V5_NFORI		WITH aFatDes[nX][6]
		Replace V5_SERIORI 	WITH aFatDes[nX][7]
		Replace V5_ITEMORI 	WITH aFatDes[nX][13]
		Replace V5_CODATIV	WITH aFatDes[nX][12]
		Replace V5_PERIODO	WITH cPeriodo
		Replace V5_ROTINA		WITH cRotina
		//Grava a Conta de Receita retornado pelo LP610(CT5_CTAREC)- EFD Contribuies
		//contido no campo D2_CTAREC, seno pega do D2_CONTA.
		If lV5CtaRec
			Replace V5_CTAREC	WITH aFatDes[nX][14]
		EndIf
		SV5->(MsUnLock())
	Next nX
EndIf

Return

//------------------------------------------------------------------------------
/*/{Protheus.doc} NewDesFol
Esta funo  chamada pelo Fiscal e RH via findfunction, pois se este fonte 
estiver desatualizado, essa funo no ir existir e j interpretaro que esto
utilizando o modelo antigo de desonerao via LOG em DBF

@sample 	NewDesFol()
@return		Nil
@author		Servios - Vendas/CRM
@since		01/12/17
@version	P12.1.17
/*/
//------------------------------------------------------------------------------
Function NewDesFol()

Return Nil

//------------------------------------------------------------------------------
/*/{Protheus.doc} CloseTRBDF
Esta funo  chamada pelo Fiscal e RH para fechar o arquivo Temporrio
oTmpTrbFat

@sample 	CloseTRBDF()
@return		Nil
@author		Servios - Vendas/CRM
@since		01/12/17
@version	P12.1.17
/*/
//------------------------------------------------------------------------------
Function CloseTRBDF()

If Select("TRBFAT") > 0
	oTmpTrbFat:Delete() 
EndIf  

Return Nil
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
/*/{Protheus.doc} MaSerEspNF
Retorna a srie/espcie da nota fiscal de sada.

@sample 	MaSerEspNF()

@return		ExpC 	Retorna uma string com a srie/espcie da nota fiscal de
					sada que esto configurados na tabela "SN" (SX5) ou no
					parmetro MV_ESPECIE.

@author		Servios - Vendas/CRM
@since		04/04/2016
@version	P12.1.11
/*/
//------------------------------------------------------------------------------
Function MaSerEspNF()

Local aArea		:= GetArea()
Local aAreaSX5	:= SX5->(GetArea())
Local cTpDocPar	:= AllTrim(SuperGetMv('MV_ESPECIE'))
Local lEspNfX5 	:= SuperGetMV("MV_ESPNFX5",.F.,.F.)
Local cTiposDoc 	:= ""

If lEspNfX5
	dbSelectArea("SX5")
	SX5->(dbSetOrder(1))
	If SX5->(dbSeek(xFilial("SX5")+"SN"))
		While SX5->(!Eof()) .And. SX5->X5_FILIAL == xFilial("SX5") .And. SX5->X5_TABELA == "SN"
			If !Empty(SX5->X5_DESCRI)
				cTiposDoc += AllTrim(SX5->X5_DESCRI) + ";"
			EndIf
		SX5->(dbSkip())
		EndDo
		cTiposDoc += cTpDocPar
	Else
		cTiposDoc := cTpDocPar
	EndIf
Else
	cTiposDoc := cTpDocPar
EndIf

RestArea(aAreaSX5)
RestArea(aArea)

Return (cTiposDoc)
//-----------------------------------------------------------
/*/{Protheus.doc}FatVldStr

@authorServios
@since22/04/2016
@version1.0
@returnPossui(T)ouno(F)caracterespecial
/*/
//-----------------------------------------------------------
Function FatVldStr()
Local lRet				:= .T.
Local cConteudo		:=Alltrim(&(ReadVar()))
Local cCaracPip		:="|'"
Local nX				:= 0

For nX:= 1 To Len(cConteudo)
	If SubStr(cConteudo,nX,1) $ cCaracPip
		lRet:= .F.
		Exit
	EndIf

Next(nX)

If !lRet
	Help("",1,"Help",,STR0020,1,0)
EndIf
Return lRet


//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} MaSetFaLog
Preenchimento do array com log de processamento  
@author Servicos - CRM/Faturamento 
@version P12.1.17  
@since 26/12/2018
@return .T.  
/*/
//-----------------------------------------------------------------------------------------------------
Function MaSetFaLog(aLinha)
	If (ValType(aLogMsg) == "U")
		aLogMsg := {}
	EndIf
	AAdd(aLogMsg, aLinha)
Return .T.

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} MaGetFaLog
Retornar o array com log de processamento  
@author Servicos - CRM/Faturamento 
@version P12.1.17  
@since 26/12/2018
@return aLogMsg - Array - Log do processamento  
/*/
//-----------------------------------------------------------------------------------------------------
Function MaGetFaLog()
Return aLogMsg

//-----------------------------------------------------------------------------------------------------
/*/{Protheus.doc} MaCleFaLog
Esvaziar o array com log de processamento  
@author Servicos - CRM/Faturamento 
@version P12.1.17  
@since 26/12/2018
@return .T.  
/*/
//-----------------------------------------------------------------------------------------------------
Function MaCleFaLog()
	FreeObj(aLogMsg)
Return .T.
/*/


Ŀ
Funo     FatGetPicN  Autor  Crm/Faturamento     Data  30.01.19  
Ĵ
Descrio  Retornar picture adicionando casas decimais                
Ĵ
 Uso       					                                          
ٱ


/*/
Function FatGetPicN(cCampo,nTampict,lMilhar)
	Local 	nDec 		:= TamSX3(cCampo)[2]
	Local 	nX			:= 1
	Local 	nY			:= 1
	Local 	cMaskI		:= ""
	Local 	cMaskF		:= ""
	Local 	cRet 		:= ""
	Default nTamPict	:= 16
	Default lMilhar		:= .T.
	
	If !Empty(cCampo)
		nTamPict := Iif(nTamPict > 16, 16, nTamPict)
		cMaskI := Iif(nDec > 0, Replicate("9",nTamPict - nDec - 1),Replicate("9",nTamPict))
		cMaskF := cMaskI
		nTamPict := Len(cMaskF)
		If lMilhar
			For nY := 0 to nTamPict
  				If nX >= 3 .And. (nTamPict - nY > 1)
					cMaskF := Stuff(cMaskF, nTamPict - nY, 0, ",")
					nX := 0
				EndIf
 				nX ++
			Next
		EndIF
		cRet := "@E " + cMaskF + Iif(nDec == 0, "", "." + Replicate("9",nDec))
	EndIf
Return(cRet)

/*/{Protheus.doc} FatGetHelp
Retorna a mensagem de texto do ltimo Help/soluo executado e limpa o buffer.
@type       Function
@author     CRM/Faturamento
@since      Nov/2020
@version    12.1.27
@return     array, 1 Elemento: Mensagem do ltimo help executado
                   2 Elemento: Soluo do ltimo help executado
****************************************************************************************************************************************************
***  Observaes:                                                                                                                                ***
***  1) NO APAGAR essa funo. Ela  utilizada em Casos de Testes Automatizados, e pode tambm ser utilizada por programas do mdulo.           ***
***  2) ESSA FUNO NO DEVE SER REPASSADA PARA QUE CLIENTES A UTILIZEM EM SUAS CUSTOMIZAES. ESTA FUNO SE LIMITA APENAS A USO INTERNO TOTVS. ***
****************************************************************************************************************************************************
/*/
Function FatGetHelp()

Local cMsgHlp		:= ''
Local cSolHlp		:= ''
Local nQtdElem		:= 0
Local nX			:= 1
Local lPadrao		:= !( FWIsInCallStack("EXECBLOCK") .OR. FWIsInCallStack("EXECTEMPLATE") )	//Verifica se a funo est sendo chamada por funes do Padro ou por Customizaes e/ou Templates
Local aRet			:= {'',''}
Local aHelp

If	lPadrao
	//S executa a funo se for chamada por funes do padro, e no possuir funes CUSTOMIZADAS ou de TEMPLATE na pilha de chamadas...
	aHelp	:= FwGetUltHlp()
	If ValType(aHelp) == 'A' .AND. Len(aHelp) == 3
		//Mensagem
		nQtdElem := Len(aHelp[2])
		For nX := 1 to nQtdElem
			cMsgHlp += If(Empty(cMsgHlp), '', ' ') + AllTrim(aHelp[2][nX])
		Next nX

		//Soluo
		nQtdElem := Len(aHelp[3])
		For nX := 1 to nQtdElem
			cSolHlp += If(Empty(cSolHlp), '', ' ') + AllTrim(aHelp[3][nX])
		Next nX
		aRet	:= {cMsgHlp, cSolHlp}
	EndIf

	FwClearHlp()	//Limpa ltimo help executado
	FreeObj(aHelp)
EndIf
Return aRet


/*/{Protheus.doc} FtGtSldOS
Retorna o saldo das liberaes dos pedidos de venda com ordem de separao vinculada e no faturada.
@type       Function
@author     CRM/Faturamento
@since      Fev/2021
@version    12.1.27
@return     nSldOrdSep, numrico, saldo das liberaes dos pedidos de venda com ordem de separao vinculada e no faturada
/*/
Function FtGtSldOS()

Local lIntACD  	    := SuperGetMV("MV_INTACD",.F.,"0") == "1"
Local cAliasOSep    := ""
Local nSldOrdSep	:= 0
Local cRemito		:= ""

If lIntACD .And. IsInCallStack("MATA455")
	cAliasOSep := GetNextAlias()
	
	If cPaisLoc <> "BRA"
		cRemito := "% C9_REMITO = '" + Space(Len(SC9->C9_REMITO)) + "' AND %"
	Else
		cRemito := "% %"
	EndIf

	BeginSQL Alias cAliasOSep
		SELECT 
			SUM(C9_QTDLIB) SALDO_LIBERADO,
			C9_FILIAL,
			C9_PEDIDO,
			C9_ITEM
		FROM
			%table:SC9%
		WHERE
			C9_FILIAL  =  %xFilial:SC9%                     AND
			C9_PEDIDO  =  %Exp:SC6->C6_NUM%              AND
			C9_ITEM    =  %Exp:SC6->C6_ITEM%                AND
			C9_ORDSEP  <> %Exp:Space(Len(SC9->C9_ORDSEP))%  AND
			C9_NFISCAL =  %Exp:Space(Len(SC9->C9_NFISCAL))% AND
			%exp:cRemito%
			%notDel%
		GROUP BY
			C9_FILIAL,
			C9_PEDIDO,
			C9_ITEM
	EndSQL
	
	If (!(cAliasOSep)->(EOF()))
		nSldOrdSep := (cAliasOSep)->SALDO_LIBERADO
	EndIf
	
	(cAliasOSep)->(DbCloseArea())
EndIf

Return nSldOrdSep

/*/{Protheus.doc} FatLibMetric
Funo utilizada para validar a data da LIB para ser utilizada na Telemetria
@type       Function
@author     CRM/Faturamento
@since      Maio/2021
@version    12.1.27
@return     __lMetric, lgico, se a LIB pode ser utilizada para Telemetria
/*/
Static Function FatLibMetric()

If __lMetric == Nil 
	__lMetric := FWLibVersion() >= "20210517"
EndIf

Return __lMetric

/*/{Protheus.doc} FatxVerLib
Funo utilizada para validar a data da LIB para utilizao da classe FWExecStatement

@type       Function
@author     CRM/Faturamento
@since      Mar/2022
@version    12.1.33
@return     __lFatxlib retorna lgico quando a data da lib for superior a 16/11/2021
/*/
Static Function FatxVerLib()

Static __lFatxlib := Nil

If __lFatxlib == Nil 
	__lFatxlib := FWLibVersion() >= "20211116"
EndIf

Return __lFatxlib
